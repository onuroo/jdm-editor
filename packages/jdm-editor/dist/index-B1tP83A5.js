import * as O from "react";
import U, { isValidElement as jA, useContext as Yt, createContext as Yo, useRef as he, useLayoutEffect as Eg, useEffect as Pe, useState as ht, forwardRef as li, useMemo as mt, Children as oF, createRef as Uh, useCallback as Kt, useImperativeHandle as fl, cloneElement as M0, memo as Sn, Suspense as sF } from "react";
import * as aF from "react-dom";
import lF, { createPortal as gw, unstable_batchedUpdates as cF, flushSync as Cp } from "react-dom";
var Bn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function hl(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var I0 = { exports: {} }, gu = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lS;
function uF() {
  if (lS)
    return gu;
  lS = 1;
  var e = U, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, d = {}, f = null, h = null;
    u !== void 0 && (f = "" + u), l.key !== void 0 && (f = "" + l.key), l.ref !== void 0 && (h = l.ref);
    for (c in l)
      r.call(l, c) && !o.hasOwnProperty(c) && (d[c] = l[c]);
    if (a && a.defaultProps)
      for (c in l = a.defaultProps, l)
        d[c] === void 0 && (d[c] = l[c]);
    return { $$typeof: t, type: a, key: f, ref: h, props: d, _owner: i.current };
  }
  return gu.Fragment = n, gu.jsx = s, gu.jsxs = s, gu;
}
var mu = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cS;
function dF() {
  return cS || (cS = 1, process.env.NODE_ENV !== "production" && function() {
    var e = U, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), p = Symbol.iterator, g = "@@iterator";
    function m(ee) {
      if (ee === null || typeof ee != "object")
        return null;
      var be = p && ee[p] || ee[g];
      return typeof be == "function" ? be : null;
    }
    var v = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function b(ee) {
      {
        for (var be = arguments.length, Ee = new Array(be > 1 ? be - 1 : 0), ye = 1; ye < be; ye++)
          Ee[ye - 1] = arguments[ye];
        x("error", ee, Ee);
      }
    }
    function x(ee, be, Ee) {
      {
        var ye = v.ReactDebugCurrentFrame, Ke = ye.getStackAddendum();
        Ke !== "" && (be += "%s", Ee = Ee.concat([Ke]));
        var et = Ee.map(function(Ie) {
          return String(Ie);
        });
        et.unshift("Warning: " + be), Function.prototype.apply.call(console[ee], console, et);
      }
    }
    var w = !1, C = !1, y = !1, S = !1, A = !1, $;
    $ = Symbol.for("react.module.reference");
    function M(ee) {
      return !!(typeof ee == "string" || typeof ee == "function" || ee === r || ee === o || A || ee === i || ee === u || ee === c || S || ee === h || w || C || y || typeof ee == "object" && ee !== null && (ee.$$typeof === f || ee.$$typeof === d || ee.$$typeof === s || ee.$$typeof === a || ee.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      ee.$$typeof === $ || ee.getModuleId !== void 0));
    }
    function _(ee, be, Ee) {
      var ye = ee.displayName;
      if (ye)
        return ye;
      var Ke = be.displayName || be.name || "";
      return Ke !== "" ? Ee + "(" + Ke + ")" : Ee;
    }
    function T(ee) {
      return ee.displayName || "Context";
    }
    function D(ee) {
      if (ee == null)
        return null;
      if (typeof ee.tag == "number" && b("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof ee == "function")
        return ee.displayName || ee.name || null;
      if (typeof ee == "string")
        return ee;
      switch (ee) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof ee == "object")
        switch (ee.$$typeof) {
          case a:
            var be = ee;
            return T(be) + ".Consumer";
          case s:
            var Ee = ee;
            return T(Ee._context) + ".Provider";
          case l:
            return _(ee, ee.render, "ForwardRef");
          case d:
            var ye = ee.displayName || null;
            return ye !== null ? ye : D(ee.type) || "Memo";
          case f: {
            var Ke = ee, et = Ke._payload, Ie = Ke._init;
            try {
              return D(Ie(et));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var E = Object.assign, R = 0, I, k, P, L, N, F, B;
    function j() {
    }
    j.__reactDisabledLog = !0;
    function z() {
      {
        if (R === 0) {
          I = console.log, k = console.info, P = console.warn, L = console.error, N = console.group, F = console.groupCollapsed, B = console.groupEnd;
          var ee = {
            configurable: !0,
            enumerable: !0,
            value: j,
            writable: !0
          };
          Object.defineProperties(console, {
            info: ee,
            log: ee,
            warn: ee,
            error: ee,
            group: ee,
            groupCollapsed: ee,
            groupEnd: ee
          });
        }
        R++;
      }
    }
    function H() {
      {
        if (R--, R === 0) {
          var ee = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: E({}, ee, {
              value: I
            }),
            info: E({}, ee, {
              value: k
            }),
            warn: E({}, ee, {
              value: P
            }),
            error: E({}, ee, {
              value: L
            }),
            group: E({}, ee, {
              value: N
            }),
            groupCollapsed: E({}, ee, {
              value: F
            }),
            groupEnd: E({}, ee, {
              value: B
            })
          });
        }
        R < 0 && b("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var W = v.ReactCurrentDispatcher, G;
    function K(ee, be, Ee) {
      {
        if (G === void 0)
          try {
            throw Error();
          } catch (Ke) {
            var ye = Ke.stack.trim().match(/\n( *(at )?)/);
            G = ye && ye[1] || "";
          }
        return `
` + G + ee;
      }
    }
    var Y = !1, X;
    {
      var Z = typeof WeakMap == "function" ? WeakMap : Map;
      X = new Z();
    }
    function Q(ee, be) {
      if (!ee || Y)
        return "";
      {
        var Ee = X.get(ee);
        if (Ee !== void 0)
          return Ee;
      }
      var ye;
      Y = !0;
      var Ke = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var et;
      et = W.current, W.current = null, z();
      try {
        if (be) {
          var Ie = function() {
            throw Error();
          };
          if (Object.defineProperty(Ie.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ie, []);
            } catch (pn) {
              ye = pn;
            }
            Reflect.construct(ee, [], Ie);
          } else {
            try {
              Ie.call();
            } catch (pn) {
              ye = pn;
            }
            ee.call(Ie.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (pn) {
            ye = pn;
          }
          ee();
        }
      } catch (pn) {
        if (pn && ye && typeof pn.stack == "string") {
          for (var Ae = pn.stack.split(`
`), tt = ye.stack.split(`
`), dt = Ae.length - 1, Tt = tt.length - 1; dt >= 1 && Tt >= 0 && Ae[dt] !== tt[Tt]; )
            Tt--;
          for (; dt >= 1 && Tt >= 0; dt--, Tt--)
            if (Ae[dt] !== tt[Tt]) {
              if (dt !== 1 || Tt !== 1)
                do
                  if (dt--, Tt--, Tt < 0 || Ae[dt] !== tt[Tt]) {
                    var Ct = `
` + Ae[dt].replace(" at new ", " at ");
                    return ee.displayName && Ct.includes("<anonymous>") && (Ct = Ct.replace("<anonymous>", ee.displayName)), typeof ee == "function" && X.set(ee, Ct), Ct;
                  }
                while (dt >= 1 && Tt >= 0);
              break;
            }
        }
      } finally {
        Y = !1, W.current = et, H(), Error.prepareStackTrace = Ke;
      }
      var vn = ee ? ee.displayName || ee.name : "", Hn = vn ? K(vn) : "";
      return typeof ee == "function" && X.set(ee, Hn), Hn;
    }
    function ne(ee, be, Ee) {
      return Q(ee, !1);
    }
    function q(ee) {
      var be = ee.prototype;
      return !!(be && be.isReactComponent);
    }
    function te(ee, be, Ee) {
      if (ee == null)
        return "";
      if (typeof ee == "function")
        return Q(ee, q(ee));
      if (typeof ee == "string")
        return K(ee);
      switch (ee) {
        case u:
          return K("Suspense");
        case c:
          return K("SuspenseList");
      }
      if (typeof ee == "object")
        switch (ee.$$typeof) {
          case l:
            return ne(ee.render);
          case d:
            return te(ee.type, be, Ee);
          case f: {
            var ye = ee, Ke = ye._payload, et = ye._init;
            try {
              return te(et(Ke), be, Ee);
            } catch {
            }
          }
        }
      return "";
    }
    var fe = Object.prototype.hasOwnProperty, Se = {}, de = v.ReactDebugCurrentFrame;
    function ce(ee) {
      if (ee) {
        var be = ee._owner, Ee = te(ee.type, ee._source, be ? be.type : null);
        de.setExtraStackFrame(Ee);
      } else
        de.setExtraStackFrame(null);
    }
    function pe(ee, be, Ee, ye, Ke) {
      {
        var et = Function.call.bind(fe);
        for (var Ie in ee)
          if (et(ee, Ie)) {
            var Ae = void 0;
            try {
              if (typeof ee[Ie] != "function") {
                var tt = Error((ye || "React class") + ": " + Ee + " type `" + Ie + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof ee[Ie] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw tt.name = "Invariant Violation", tt;
              }
              Ae = ee[Ie](be, Ie, ye, Ee, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (dt) {
              Ae = dt;
            }
            Ae && !(Ae instanceof Error) && (ce(Ke), b("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ye || "React class", Ee, Ie, typeof Ae), ce(null)), Ae instanceof Error && !(Ae.message in Se) && (Se[Ae.message] = !0, ce(Ke), b("Failed %s type: %s", Ee, Ae.message), ce(null));
          }
      }
    }
    var Oe = Array.isArray;
    function Re(ee) {
      return Oe(ee);
    }
    function De(ee) {
      {
        var be = typeof Symbol == "function" && Symbol.toStringTag, Ee = be && ee[Symbol.toStringTag] || ee.constructor.name || "Object";
        return Ee;
      }
    }
    function Me(ee) {
      try {
        return Ue(ee), !1;
      } catch {
        return !0;
      }
    }
    function Ue(ee) {
      return "" + ee;
    }
    function oe(ee) {
      if (Me(ee))
        return b("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", De(ee)), Ue(ee);
    }
    var Ce = v.ReactCurrentOwner, ge = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ve, me, Fe;
    Fe = {};
    function Be(ee) {
      if (fe.call(ee, "ref")) {
        var be = Object.getOwnPropertyDescriptor(ee, "ref").get;
        if (be && be.isReactWarning)
          return !1;
      }
      return ee.ref !== void 0;
    }
    function qe(ee) {
      if (fe.call(ee, "key")) {
        var be = Object.getOwnPropertyDescriptor(ee, "key").get;
        if (be && be.isReactWarning)
          return !1;
      }
      return ee.key !== void 0;
    }
    function Ve(ee, be) {
      if (typeof ee.ref == "string" && Ce.current && be && Ce.current.stateNode !== be) {
        var Ee = D(Ce.current.type);
        Fe[Ee] || (b('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', D(Ce.current.type), ee.ref), Fe[Ee] = !0);
      }
    }
    function We(ee, be) {
      {
        var Ee = function() {
          ve || (ve = !0, b("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", be));
        };
        Ee.isReactWarning = !0, Object.defineProperty(ee, "key", {
          get: Ee,
          configurable: !0
        });
      }
    }
    function Ge(ee, be) {
      {
        var Ee = function() {
          me || (me = !0, b("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", be));
        };
        Ee.isReactWarning = !0, Object.defineProperty(ee, "ref", {
          get: Ee,
          configurable: !0
        });
      }
    }
    var $e = function(ee, be, Ee, ye, Ke, et, Ie) {
      var Ae = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: ee,
        key: be,
        ref: Ee,
        props: Ie,
        // Record the component responsible for creating this element.
        _owner: et
      };
      return Ae._store = {}, Object.defineProperty(Ae._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Ae, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ye
      }), Object.defineProperty(Ae, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ke
      }), Object.freeze && (Object.freeze(Ae.props), Object.freeze(Ae)), Ae;
    };
    function ze(ee, be, Ee, ye, Ke) {
      {
        var et, Ie = {}, Ae = null, tt = null;
        Ee !== void 0 && (oe(Ee), Ae = "" + Ee), qe(be) && (oe(be.key), Ae = "" + be.key), Be(be) && (tt = be.ref, Ve(be, Ke));
        for (et in be)
          fe.call(be, et) && !ge.hasOwnProperty(et) && (Ie[et] = be[et]);
        if (ee && ee.defaultProps) {
          var dt = ee.defaultProps;
          for (et in dt)
            Ie[et] === void 0 && (Ie[et] = dt[et]);
        }
        if (Ae || tt) {
          var Tt = typeof ee == "function" ? ee.displayName || ee.name || "Unknown" : ee;
          Ae && We(Ie, Tt), tt && Ge(Ie, Tt);
        }
        return $e(ee, Ae, tt, Ke, ye, Ce.current, Ie);
      }
    }
    var at = v.ReactCurrentOwner, xt = v.ReactDebugCurrentFrame;
    function jt(ee) {
      if (ee) {
        var be = ee._owner, Ee = te(ee.type, ee._source, be ? be.type : null);
        xt.setExtraStackFrame(Ee);
      } else
        xt.setExtraStackFrame(null);
    }
    var Lt;
    Lt = !1;
    function At(ee) {
      return typeof ee == "object" && ee !== null && ee.$$typeof === t;
    }
    function Et() {
      {
        if (at.current) {
          var ee = D(at.current.type);
          if (ee)
            return `

Check the render method of \`` + ee + "`.";
        }
        return "";
      }
    }
    function nt(ee) {
      return "";
    }
    var it = {};
    function je(ee) {
      {
        var be = Et();
        if (!be) {
          var Ee = typeof ee == "string" ? ee : ee.displayName || ee.name;
          Ee && (be = `

Check the top-level render call using <` + Ee + ">.");
        }
        return be;
      }
    }
    function Le(ee, be) {
      {
        if (!ee._store || ee._store.validated || ee.key != null)
          return;
        ee._store.validated = !0;
        var Ee = je(be);
        if (it[Ee])
          return;
        it[Ee] = !0;
        var ye = "";
        ee && ee._owner && ee._owner !== at.current && (ye = " It was passed a child from " + D(ee._owner.type) + "."), jt(ee), b('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ee, ye), jt(null);
      }
    }
    function ot(ee, be) {
      {
        if (typeof ee != "object")
          return;
        if (Re(ee))
          for (var Ee = 0; Ee < ee.length; Ee++) {
            var ye = ee[Ee];
            At(ye) && Le(ye, be);
          }
        else if (At(ee))
          ee._store && (ee._store.validated = !0);
        else if (ee) {
          var Ke = m(ee);
          if (typeof Ke == "function" && Ke !== ee.entries)
            for (var et = Ke.call(ee), Ie; !(Ie = et.next()).done; )
              At(Ie.value) && Le(Ie.value, be);
        }
      }
    }
    function yt(ee) {
      {
        var be = ee.type;
        if (be == null || typeof be == "string")
          return;
        var Ee;
        if (typeof be == "function")
          Ee = be.propTypes;
        else if (typeof be == "object" && (be.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        be.$$typeof === d))
          Ee = be.propTypes;
        else
          return;
        if (Ee) {
          var ye = D(be);
          pe(Ee, ee.props, "prop", ye, ee);
        } else if (be.PropTypes !== void 0 && !Lt) {
          Lt = !0;
          var Ke = D(be);
          b("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ke || "Unknown");
        }
        typeof be.getDefaultProps == "function" && !be.getDefaultProps.isReactClassApproved && b("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function He(ee) {
      {
        for (var be = Object.keys(ee.props), Ee = 0; Ee < be.length; Ee++) {
          var ye = be[Ee];
          if (ye !== "children" && ye !== "key") {
            jt(ee), b("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ye), jt(null);
            break;
          }
        }
        ee.ref !== null && (jt(ee), b("Invalid attribute `ref` supplied to `React.Fragment`."), jt(null));
      }
    }
    function Je(ee, be, Ee, ye, Ke, et) {
      {
        var Ie = M(ee);
        if (!Ie) {
          var Ae = "";
          (ee === void 0 || typeof ee == "object" && ee !== null && Object.keys(ee).length === 0) && (Ae += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var tt = nt();
          tt ? Ae += tt : Ae += Et();
          var dt;
          ee === null ? dt = "null" : Re(ee) ? dt = "array" : ee !== void 0 && ee.$$typeof === t ? (dt = "<" + (D(ee.type) || "Unknown") + " />", Ae = " Did you accidentally export a JSX literal instead of a component?") : dt = typeof ee, b("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", dt, Ae);
        }
        var Tt = ze(ee, be, Ee, Ke, et);
        if (Tt == null)
          return Tt;
        if (Ie) {
          var Ct = be.children;
          if (Ct !== void 0)
            if (ye)
              if (Re(Ct)) {
                for (var vn = 0; vn < Ct.length; vn++)
                  ot(Ct[vn], ee);
                Object.freeze && Object.freeze(Ct);
              } else
                b("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              ot(Ct, ee);
        }
        return ee === r ? He(Tt) : yt(Tt), Tt;
      }
    }
    function Qe(ee, be, Ee) {
      return Je(ee, be, Ee, !0);
    }
    function lt(ee, be, Ee) {
      return Je(ee, be, Ee, !1);
    }
    var pt = lt, vt = Qe;
    mu.Fragment = r, mu.jsx = pt, mu.jsxs = vt;
  }()), mu;
}
process.env.NODE_ENV === "production" ? I0.exports = uF() : I0.exports = dF();
var V = I0.exports, zA = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function n() {
      for (var o = "", s = 0; s < arguments.length; s++) {
        var a = arguments[s];
        a && (o = i(o, r(a)));
      }
      return o;
    }
    function r(o) {
      if (typeof o == "string" || typeof o == "number")
        return o;
      if (typeof o != "object")
        return "";
      if (Array.isArray(o))
        return n.apply(null, o);
      if (o.toString !== Object.prototype.toString && !o.toString.toString().includes("[native code]"))
        return o.toString();
      var s = "";
      for (var a in o)
        t.call(o, a) && o[a] && (s = i(s, a));
      return s;
    }
    function i(o, s) {
      return s ? o ? o + " " + s : o + s : o;
    }
    e.exports ? (n.default = n, e.exports = n) : window.classNames = n;
  })();
})(zA);
var fF = zA.exports;
const se = /* @__PURE__ */ hl(fF);
function we() {
  return we = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, we.apply(this, arguments);
}
var k0 = { exports: {} }, an = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uS;
function hF() {
  if (uS)
    return an;
  uS = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), a = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), p;
  p = Symbol.for("react.module.reference");
  function g(m) {
    if (typeof m == "object" && m !== null) {
      var v = m.$$typeof;
      switch (v) {
        case e:
          switch (m = m.type, m) {
            case n:
            case i:
            case r:
            case u:
            case c:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case a:
                case s:
                case l:
                case f:
                case d:
                case o:
                  return m;
                default:
                  return v;
              }
          }
        case t:
          return v;
      }
    }
  }
  return an.ContextConsumer = s, an.ContextProvider = o, an.Element = e, an.ForwardRef = l, an.Fragment = n, an.Lazy = f, an.Memo = d, an.Portal = t, an.Profiler = i, an.StrictMode = r, an.Suspense = u, an.SuspenseList = c, an.isAsyncMode = function() {
    return !1;
  }, an.isConcurrentMode = function() {
    return !1;
  }, an.isContextConsumer = function(m) {
    return g(m) === s;
  }, an.isContextProvider = function(m) {
    return g(m) === o;
  }, an.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === e;
  }, an.isForwardRef = function(m) {
    return g(m) === l;
  }, an.isFragment = function(m) {
    return g(m) === n;
  }, an.isLazy = function(m) {
    return g(m) === f;
  }, an.isMemo = function(m) {
    return g(m) === d;
  }, an.isPortal = function(m) {
    return g(m) === t;
  }, an.isProfiler = function(m) {
    return g(m) === i;
  }, an.isStrictMode = function(m) {
    return g(m) === r;
  }, an.isSuspense = function(m) {
    return g(m) === u;
  }, an.isSuspenseList = function(m) {
    return g(m) === c;
  }, an.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === n || m === i || m === r || m === u || m === c || m === h || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === d || m.$$typeof === o || m.$$typeof === s || m.$$typeof === l || m.$$typeof === p || m.getModuleId !== void 0);
  }, an.typeOf = g, an;
}
var ln = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var dS;
function pF() {
  return dS || (dS = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), s = Symbol.for("react.context"), a = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), h = Symbol.for("react.offscreen"), p = !1, g = !1, m = !1, v = !1, b = !1, x;
    x = Symbol.for("react.module.reference");
    function w(q) {
      return !!(typeof q == "string" || typeof q == "function" || q === n || q === i || b || q === r || q === u || q === c || v || q === h || p || g || m || typeof q == "object" && q !== null && (q.$$typeof === f || q.$$typeof === d || q.$$typeof === o || q.$$typeof === s || q.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      q.$$typeof === x || q.getModuleId !== void 0));
    }
    function C(q) {
      if (typeof q == "object" && q !== null) {
        var te = q.$$typeof;
        switch (te) {
          case e:
            var fe = q.type;
            switch (fe) {
              case n:
              case i:
              case r:
              case u:
              case c:
                return fe;
              default:
                var Se = fe && fe.$$typeof;
                switch (Se) {
                  case a:
                  case s:
                  case l:
                  case f:
                  case d:
                  case o:
                    return Se;
                  default:
                    return te;
                }
            }
          case t:
            return te;
        }
      }
    }
    var y = s, S = o, A = e, $ = l, M = n, _ = f, T = d, D = t, E = i, R = r, I = u, k = c, P = !1, L = !1;
    function N(q) {
      return P || (P = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function F(q) {
      return L || (L = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function B(q) {
      return C(q) === s;
    }
    function j(q) {
      return C(q) === o;
    }
    function z(q) {
      return typeof q == "object" && q !== null && q.$$typeof === e;
    }
    function H(q) {
      return C(q) === l;
    }
    function W(q) {
      return C(q) === n;
    }
    function G(q) {
      return C(q) === f;
    }
    function K(q) {
      return C(q) === d;
    }
    function Y(q) {
      return C(q) === t;
    }
    function X(q) {
      return C(q) === i;
    }
    function Z(q) {
      return C(q) === r;
    }
    function Q(q) {
      return C(q) === u;
    }
    function ne(q) {
      return C(q) === c;
    }
    ln.ContextConsumer = y, ln.ContextProvider = S, ln.Element = A, ln.ForwardRef = $, ln.Fragment = M, ln.Lazy = _, ln.Memo = T, ln.Portal = D, ln.Profiler = E, ln.StrictMode = R, ln.Suspense = I, ln.SuspenseList = k, ln.isAsyncMode = N, ln.isConcurrentMode = F, ln.isContextConsumer = B, ln.isContextProvider = j, ln.isElement = z, ln.isForwardRef = H, ln.isFragment = W, ln.isLazy = G, ln.isMemo = K, ln.isPortal = Y, ln.isProfiler = X, ln.isStrictMode = Z, ln.isSuspense = Q, ln.isSuspenseList = ne, ln.isValidElementType = w, ln.typeOf = C;
  }()), ln;
}
process.env.NODE_ENV === "production" ? k0.exports = hF() : k0.exports = pF();
var Xu = k0.exports;
function Xr(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = [];
  return U.Children.forEach(e, function(r) {
    r == null && !t.keepEmpty || (Array.isArray(r) ? n = n.concat(Xr(r)) : Xu.isFragment(r) && r.props ? n = n.concat(Xr(r.props.children, t)) : n.push(r));
  }), n;
}
var P0 = {}, mw = [], gF = function(t) {
  mw.push(t);
};
function Ss(e, t) {
  if (process.env.NODE_ENV !== "production" && !e && console !== void 0) {
    var n = mw.reduce(function(r, i) {
      return i(r ?? "", "warning");
    }, t);
    n && console.error("Warning: ".concat(n));
  }
}
function mF(e, t) {
  if (process.env.NODE_ENV !== "production" && !e && console !== void 0) {
    var n = mw.reduce(function(r, i) {
      return i(r ?? "", "note");
    }, t);
    n && console.warn("Note: ".concat(n));
  }
}
function HA() {
  P0 = {};
}
function VA(e, t, n) {
  !t && !P0[n] && (e(!1, n), P0[n] = !0);
}
function $t(e, t) {
  VA(Ss, e, t);
}
function N0(e, t) {
  VA(mF, e, t);
}
$t.preMessage = gF;
$t.resetWarned = HA;
$t.noteOnce = N0;
function wt(e) {
  "@babel/helpers - typeof";
  return wt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, wt(e);
}
function vF(e, t) {
  if (wt(e) != "object" || !e)
    return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (wt(r) != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function WA(e) {
  var t = vF(e, "string");
  return wt(t) == "symbol" ? t : t + "";
}
function re(e, t, n) {
  return t = WA(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function fS(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ie(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fS(Object(n), !0).forEach(function(r) {
      re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fS(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Sp(e) {
  return e instanceof HTMLElement || e instanceof SVGElement;
}
function Yu(e) {
  return Sp(e) ? e : e instanceof U.Component ? lF.findDOMNode(e) : null;
}
function lf(e, t, n) {
  var r = O.useRef({});
  return (!("value" in r.current) || n(r.current.condition, t)) && (r.current.value = e(), r.current.condition = t), r.current.value;
}
function vw(e, t) {
  typeof e == "function" ? e(t) : wt(e) === "object" && e && "current" in e && (e.current = t);
}
function xi() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  var r = t.filter(function(i) {
    return i;
  });
  return r.length <= 1 ? r[0] : function(i) {
    t.forEach(function(o) {
      vw(o, i);
    });
  };
}
function ba() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return lf(function() {
    return xi.apply(void 0, t);
  }, t, function(r, i) {
    return r.length !== i.length || r.every(function(o, s) {
      return o !== i[s];
    });
  });
}
function Ms(e) {
  var t, n, r = Xu.isMemo(e) ? e.type.type : e.type;
  return !(typeof r == "function" && !((t = r.prototype) !== null && t !== void 0 && t.render) && r.$$typeof !== Xu.ForwardRef || typeof e == "function" && !((n = e.prototype) !== null && n !== void 0 && n.render) && e.$$typeof !== Xu.ForwardRef);
}
function bF(e) {
  return !/* @__PURE__ */ jA(e) || Xu.isFragment(e) ? !1 : Ms(e);
}
var L0 = /* @__PURE__ */ O.createContext(null);
function yF(e) {
  var t = e.children, n = e.onBatchResize, r = O.useRef(0), i = O.useRef([]), o = O.useContext(L0), s = O.useCallback(function(a, l, u) {
    r.current += 1;
    var c = r.current;
    i.current.push({
      size: a,
      element: l,
      data: u
    }), Promise.resolve().then(function() {
      c === r.current && (n == null || n(i.current), i.current = []);
    }), o == null || o(a, l, u);
  }, [n, o]);
  return /* @__PURE__ */ O.createElement(L0.Provider, {
    value: s
  }, t);
}
var UA = function() {
  if (typeof Map < "u")
    return Map;
  function e(t, n) {
    var r = -1;
    return t.some(function(i, o) {
      return i[0] === n ? (r = o, !0) : !1;
    }), r;
  }
  return (
    /** @class */
    function() {
      function t() {
        this.__entries__ = [];
      }
      return Object.defineProperty(t.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.get = function(n) {
        var r = e(this.__entries__, n), i = this.__entries__[r];
        return i && i[1];
      }, t.prototype.set = function(n, r) {
        var i = e(this.__entries__, n);
        ~i ? this.__entries__[i][1] = r : this.__entries__.push([n, r]);
      }, t.prototype.delete = function(n) {
        var r = this.__entries__, i = e(r, n);
        ~i && r.splice(i, 1);
      }, t.prototype.has = function(n) {
        return !!~e(this.__entries__, n);
      }, t.prototype.clear = function() {
        this.__entries__.splice(0);
      }, t.prototype.forEach = function(n, r) {
        r === void 0 && (r = null);
        for (var i = 0, o = this.__entries__; i < o.length; i++) {
          var s = o[i];
          n.call(r, s[1], s[0]);
        }
      }, t;
    }()
  );
}(), F0 = typeof window < "u" && typeof document < "u" && window.document === document, xp = function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}(), wF = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(xp) : function(e) {
    return setTimeout(function() {
      return e(Date.now());
    }, 1e3 / 60);
  };
}(), CF = 2;
function SF(e, t) {
  var n = !1, r = !1, i = 0;
  function o() {
    n && (n = !1, e()), r && a();
  }
  function s() {
    wF(o);
  }
  function a() {
    var l = Date.now();
    if (n) {
      if (l - i < CF)
        return;
      r = !0;
    } else
      n = !0, r = !1, setTimeout(s, t);
    i = l;
  }
  return a;
}
var xF = 20, EF = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], $F = typeof MutationObserver < "u", OF = (
  /** @class */
  function() {
    function e() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = SF(this.refresh.bind(this), xF);
    }
    return e.prototype.addObserver = function(t) {
      ~this.observers_.indexOf(t) || this.observers_.push(t), this.connected_ || this.connect_();
    }, e.prototype.removeObserver = function(t) {
      var n = this.observers_, r = n.indexOf(t);
      ~r && n.splice(r, 1), !n.length && this.connected_ && this.disconnect_();
    }, e.prototype.refresh = function() {
      var t = this.updateObservers_();
      t && this.refresh();
    }, e.prototype.updateObservers_ = function() {
      var t = this.observers_.filter(function(n) {
        return n.gatherActive(), n.hasActive();
      });
      return t.forEach(function(n) {
        return n.broadcastActive();
      }), t.length > 0;
    }, e.prototype.connect_ = function() {
      !F0 || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), $F ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, e.prototype.disconnect_ = function() {
      !F0 || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, e.prototype.onTransitionEnd_ = function(t) {
      var n = t.propertyName, r = n === void 0 ? "" : n, i = EF.some(function(o) {
        return !!~r.indexOf(o);
      });
      i && this.refresh();
    }, e.getInstance = function() {
      return this.instance_ || (this.instance_ = new e()), this.instance_;
    }, e.instance_ = null, e;
  }()
), GA = function(e, t) {
  for (var n = 0, r = Object.keys(t); n < r.length; n++) {
    var i = r[n];
    Object.defineProperty(e, i, {
      value: t[i],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return e;
}, Oc = function(e) {
  var t = e && e.ownerDocument && e.ownerDocument.defaultView;
  return t || xp;
}, KA = $g(0, 0, 0, 0);
function Ep(e) {
  return parseFloat(e) || 0;
}
function hS(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  return t.reduce(function(r, i) {
    var o = e["border-" + i + "-width"];
    return r + Ep(o);
  }, 0);
}
function AF(e) {
  for (var t = ["top", "right", "bottom", "left"], n = {}, r = 0, i = t; r < i.length; r++) {
    var o = i[r], s = e["padding-" + o];
    n[o] = Ep(s);
  }
  return n;
}
function DF(e) {
  var t = e.getBBox();
  return $g(0, 0, t.width, t.height);
}
function _F(e) {
  var t = e.clientWidth, n = e.clientHeight;
  if (!t && !n)
    return KA;
  var r = Oc(e).getComputedStyle(e), i = AF(r), o = i.left + i.right, s = i.top + i.bottom, a = Ep(r.width), l = Ep(r.height);
  if (r.boxSizing === "border-box" && (Math.round(a + o) !== t && (a -= hS(r, "left", "right") + o), Math.round(l + s) !== n && (l -= hS(r, "top", "bottom") + s)), !RF(e)) {
    var u = Math.round(a + o) - t, c = Math.round(l + s) - n;
    Math.abs(u) !== 1 && (a -= u), Math.abs(c) !== 1 && (l -= c);
  }
  return $g(i.left, i.top, a, l);
}
var TF = /* @__PURE__ */ function() {
  return typeof SVGGraphicsElement < "u" ? function(e) {
    return e instanceof Oc(e).SVGGraphicsElement;
  } : function(e) {
    return e instanceof Oc(e).SVGElement && typeof e.getBBox == "function";
  };
}();
function RF(e) {
  return e === Oc(e).document.documentElement;
}
function MF(e) {
  return F0 ? TF(e) ? DF(e) : _F(e) : KA;
}
function IF(e) {
  var t = e.x, n = e.y, r = e.width, i = e.height, o = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, s = Object.create(o.prototype);
  return GA(s, {
    x: t,
    y: n,
    width: r,
    height: i,
    top: n,
    right: t + r,
    bottom: i + n,
    left: t
  }), s;
}
function $g(e, t, n, r) {
  return { x: e, y: t, width: n, height: r };
}
var kF = (
  /** @class */
  function() {
    function e(t) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = $g(0, 0, 0, 0), this.target = t;
    }
    return e.prototype.isActive = function() {
      var t = MF(this.target);
      return this.contentRect_ = t, t.width !== this.broadcastWidth || t.height !== this.broadcastHeight;
    }, e.prototype.broadcastRect = function() {
      var t = this.contentRect_;
      return this.broadcastWidth = t.width, this.broadcastHeight = t.height, t;
    }, e;
  }()
), PF = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t, n) {
      var r = IF(n);
      GA(this, { target: t, contentRect: r });
    }
    return e;
  }()
), NF = (
  /** @class */
  function() {
    function e(t, n, r) {
      if (this.activeObservations_ = [], this.observations_ = new UA(), typeof t != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = t, this.controller_ = n, this.callbackCtx_ = r;
    }
    return e.prototype.observe = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(t instanceof Oc(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var n = this.observations_;
        n.has(t) || (n.set(t, new kF(t)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, e.prototype.unobserve = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(t instanceof Oc(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var n = this.observations_;
        n.has(t) && (n.delete(t), n.size || this.controller_.removeObserver(this));
      }
    }, e.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, e.prototype.gatherActive = function() {
      var t = this;
      this.clearActive(), this.observations_.forEach(function(n) {
        n.isActive() && t.activeObservations_.push(n);
      });
    }, e.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var t = this.callbackCtx_, n = this.activeObservations_.map(function(r) {
          return new PF(r.target, r.broadcastRect());
        });
        this.callback_.call(t, n, t), this.clearActive();
      }
    }, e.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, e.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, e;
  }()
), XA = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new UA(), YA = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      if (!(this instanceof e))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var n = OF.getInstance(), r = new NF(t, n, this);
      XA.set(this, r);
    }
    return e;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(e) {
  YA.prototype[e] = function() {
    var t;
    return (t = XA.get(this))[e].apply(t, arguments);
  };
});
var LF = function() {
  return typeof xp.ResizeObserver < "u" ? xp.ResizeObserver : YA;
}(), ps = /* @__PURE__ */ new Map();
function qA(e) {
  e.forEach(function(t) {
    var n, r = t.target;
    (n = ps.get(r)) === null || n === void 0 || n.forEach(function(i) {
      return i(r);
    });
  });
}
var QA = new LF(qA);
process.env.NODE_ENV;
process.env.NODE_ENV;
function FF(e, t) {
  ps.has(e) || (ps.set(e, /* @__PURE__ */ new Set()), QA.observe(e)), ps.get(e).add(t);
}
function BF(e, t) {
  ps.has(e) && (ps.get(e).delete(t), ps.get(e).size || (QA.unobserve(e), ps.delete(e)));
}
function ci(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function pS(e, t) {
  for (var n = 0; n < t.length; n++) {
    var r = t[n];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, WA(r.key), r);
  }
}
function ui(e, t, n) {
  return t && pS(e.prototype, t), n && pS(e, n), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function B0(e, t) {
  return B0 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, B0(e, t);
}
function pl(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && B0(e, t);
}
function Ac(e) {
  return Ac = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, Ac(e);
}
function bw() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (bw = function() {
    return !!e;
  })();
}
function tn(e) {
  if (e === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function ZA(e, t) {
  if (t && (wt(t) === "object" || typeof t == "function"))
    return t;
  if (t !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return tn(e);
}
function cf(e) {
  var t = bw();
  return function() {
    var r = Ac(e), i;
    if (t) {
      var o = Ac(this).constructor;
      i = Reflect.construct(r, arguments, o);
    } else
      i = r.apply(this, arguments);
    return ZA(this, i);
  };
}
var jF = /* @__PURE__ */ function(e) {
  pl(n, e);
  var t = cf(n);
  function n() {
    return ci(this, n), t.apply(this, arguments);
  }
  return ui(n, [{
    key: "render",
    value: function() {
      return this.props.children;
    }
  }]), n;
}(O.Component);
function zF(e, t) {
  var n = e.children, r = e.disabled, i = O.useRef(null), o = O.useRef(null), s = O.useContext(L0), a = typeof n == "function", l = a ? n(i) : n, u = O.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  }), c = !a && /* @__PURE__ */ O.isValidElement(l) && Ms(l), d = c ? l.ref : null, f = ba(d, i), h = function() {
    var v;
    return Yu(i.current) || // Support `nativeElement` format
    (i.current && wt(i.current) === "object" ? Yu((v = i.current) === null || v === void 0 ? void 0 : v.nativeElement) : null) || Yu(o.current);
  };
  O.useImperativeHandle(t, function() {
    return h();
  });
  var p = O.useRef(e);
  p.current = e;
  var g = O.useCallback(function(m) {
    var v = p.current, b = v.onResize, x = v.data, w = m.getBoundingClientRect(), C = w.width, y = w.height, S = m.offsetWidth, A = m.offsetHeight, $ = Math.floor(C), M = Math.floor(y);
    if (u.current.width !== $ || u.current.height !== M || u.current.offsetWidth !== S || u.current.offsetHeight !== A) {
      var _ = {
        width: $,
        height: M,
        offsetWidth: S,
        offsetHeight: A
      };
      u.current = _;
      var T = S === Math.round(C) ? C : S, D = A === Math.round(y) ? y : A, E = ie(ie({}, _), {}, {
        offsetWidth: T,
        offsetHeight: D
      });
      s == null || s(E, m, x), b && Promise.resolve().then(function() {
        b(E, m);
      });
    }
  }, []);
  return O.useEffect(function() {
    var m = h();
    return m && !r && FF(m, g), function() {
      return BF(m, g);
    };
  }, [i.current, r]), /* @__PURE__ */ O.createElement(jF, {
    ref: o
  }, c ? /* @__PURE__ */ O.cloneElement(l, {
    ref: f
  }) : l);
}
var JA = /* @__PURE__ */ O.forwardRef(zF);
process.env.NODE_ENV !== "production" && (JA.displayName = "SingleObserver");
var HF = "rc-observer-key";
function VF(e, t) {
  var n = e.children, r = typeof n == "function" ? [n] : Xr(n);
  return process.env.NODE_ENV !== "production" && (r.length > 1 ? Ss(!1, "Find more than one child node with `children` in ResizeObserver. Please use ResizeObserver.Collection instead.") : r.length === 0 && Ss(!1, "`children` of ResizeObserver is empty. Nothing is in observe.")), r.map(function(i, o) {
    var s = (i == null ? void 0 : i.key) || "".concat(HF, "-").concat(o);
    return /* @__PURE__ */ O.createElement(JA, we({}, e, {
      key: s,
      ref: o === 0 ? t : void 0
    }), i);
  });
}
var Ci = /* @__PURE__ */ O.forwardRef(VF);
process.env.NODE_ENV !== "production" && (Ci.displayName = "ResizeObserver");
Ci.Collection = yF;
function zn(e, t) {
  var n = ie({}, e);
  return Array.isArray(t) && t.forEach(function(r) {
    delete n[r];
  }), n;
}
function j0(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function WF(e) {
  if (Array.isArray(e))
    return j0(e);
}
function eD(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null)
    return Array.from(e);
}
function yw(e, t) {
  if (e) {
    if (typeof e == "string")
      return j0(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return j0(e, t);
  }
}
function UF() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function _e(e) {
  return WF(e) || eD(e) || yw(e) || UF();
}
var tD = function(t) {
  return +setTimeout(t, 16);
}, nD = function(t) {
  return clearTimeout(t);
};
typeof window < "u" && "requestAnimationFrame" in window && (tD = function(t) {
  return window.requestAnimationFrame(t);
}, nD = function(t) {
  return window.cancelAnimationFrame(t);
});
var gS = 0, Og = /* @__PURE__ */ new Map();
function rD(e) {
  Og.delete(e);
}
var rn = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  gS += 1;
  var r = gS;
  function i(o) {
    if (o === 0)
      rD(r), t();
    else {
      var s = tD(function() {
        i(o - 1);
      });
      Og.set(r, s);
    }
  }
  return i(n), r;
};
rn.cancel = function(e) {
  var t = Og.get(e);
  return rD(e), nD(t);
};
process.env.NODE_ENV !== "production" && (rn.ids = function() {
  return Og;
});
function iD(e) {
  if (Array.isArray(e))
    return e;
}
function GF(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var r, i, o, s, a = [], l = !0, u = !1;
    try {
      if (o = (n = n.call(e)).next, t === 0) {
        if (Object(n) !== n)
          return;
        l = !1;
      } else
        for (; !(l = (r = o.call(n)).done) && (a.push(r.value), a.length !== t); l = !0)
          ;
    } catch (c) {
      u = !0, i = c;
    } finally {
      try {
        if (!l && n.return != null && (s = n.return(), Object(s) !== s))
          return;
      } finally {
        if (u)
          throw i;
      }
    }
    return a;
  }
}
function oD() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ae(e, t) {
  return iD(e) || GF(e, t) || yw(e, t) || oD();
}
function fd(e) {
  for (var t = 0, n, r = 0, i = e.length; i >= 4; ++r, i -= 4)
    n = e.charCodeAt(r) & 255 | (e.charCodeAt(++r) & 255) << 8 | (e.charCodeAt(++r) & 255) << 16 | (e.charCodeAt(++r) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      t ^= (e.charCodeAt(r + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(r + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(r) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
function Ir() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function z0(e, t) {
  if (!e)
    return !1;
  if (e.contains)
    return e.contains(t);
  for (var n = t; n; ) {
    if (n === e)
      return !0;
    n = n.parentNode;
  }
  return !1;
}
var mS = "data-rc-order", vS = "data-rc-priority", KF = "rc-util-key", H0 = /* @__PURE__ */ new Map();
function sD() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.mark;
  return t ? t.startsWith("data-") ? t : "data-".concat(t) : KF;
}
function Ag(e) {
  if (e.attachTo)
    return e.attachTo;
  var t = document.querySelector("head");
  return t || document.body;
}
function XF(e) {
  return e === "queue" ? "prependQueue" : e ? "prepend" : "append";
}
function ww(e) {
  return Array.from((H0.get(e) || e).children).filter(function(t) {
    return t.tagName === "STYLE";
  });
}
function aD(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!Ir())
    return null;
  var n = t.csp, r = t.prepend, i = t.priority, o = i === void 0 ? 0 : i, s = XF(r), a = s === "prependQueue", l = document.createElement("style");
  l.setAttribute(mS, s), a && o && l.setAttribute(vS, "".concat(o)), n != null && n.nonce && (l.nonce = n == null ? void 0 : n.nonce), l.innerHTML = e;
  var u = Ag(t), c = u.firstChild;
  if (r) {
    if (a) {
      var d = (t.styles || ww(u)).filter(function(f) {
        if (!["prepend", "prependQueue"].includes(f.getAttribute(mS)))
          return !1;
        var h = Number(f.getAttribute(vS) || 0);
        return o >= h;
      });
      if (d.length)
        return u.insertBefore(l, d[d.length - 1].nextSibling), l;
    }
    u.insertBefore(l, c);
  } else
    u.appendChild(l);
  return l;
}
function lD(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = Ag(t);
  return (t.styles || ww(n)).find(function(r) {
    return r.getAttribute(sD(t)) === e;
  });
}
function hd(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = lD(e, t);
  if (n) {
    var r = Ag(t);
    r.removeChild(n);
  }
}
function YF(e, t) {
  var n = H0.get(e);
  if (!n || !z0(document, n)) {
    var r = aD("", t), i = r.parentNode;
    H0.set(e, i), e.removeChild(r);
  }
}
function vs(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = Ag(n), i = ww(r), o = ie(ie({}, n), {}, {
    styles: i
  });
  YF(r, o);
  var s = lD(t, o);
  if (s) {
    var a, l;
    if ((a = o.csp) !== null && a !== void 0 && a.nonce && s.nonce !== ((l = o.csp) === null || l === void 0 ? void 0 : l.nonce)) {
      var u;
      s.nonce = (u = o.csp) === null || u === void 0 ? void 0 : u.nonce;
    }
    return s.innerHTML !== e && (s.innerHTML = e), s;
  }
  var c = aD(e, o);
  return c.setAttribute(sD(o), t), c;
}
function qF(e, t) {
  if (e == null)
    return {};
  var n = {};
  for (var r in e)
    if (Object.prototype.hasOwnProperty.call(e, r)) {
      if (t.indexOf(r) >= 0)
        continue;
      n[r] = e[r];
    }
  return n;
}
function Rt(e, t) {
  if (e == null)
    return {};
  var n = qF(e, t), r, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function pd(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, r = /* @__PURE__ */ new Set();
  function i(o, s) {
    var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, l = r.has(o);
    if ($t(!l, "Warning: There may be circular references"), l)
      return !1;
    if (o === s)
      return !0;
    if (n && a > 1)
      return !1;
    r.add(o);
    var u = a + 1;
    if (Array.isArray(o)) {
      if (!Array.isArray(s) || o.length !== s.length)
        return !1;
      for (var c = 0; c < o.length; c++)
        if (!i(o[c], s[c], u))
          return !1;
      return !0;
    }
    if (o && s && wt(o) === "object" && wt(s) === "object") {
      var d = Object.keys(o);
      return d.length !== Object.keys(s).length ? !1 : d.every(function(f) {
        return i(o[f], s[f], u);
      });
    }
    return !1;
  }
  return i(e, t);
}
var QF = "%";
function V0(e) {
  return e.join(QF);
}
var ZF = /* @__PURE__ */ function() {
  function e(t) {
    ci(this, e), re(this, "instanceId", void 0), re(this, "cache", /* @__PURE__ */ new Map()), this.instanceId = t;
  }
  return ui(e, [{
    key: "get",
    value: function(n) {
      return this.opGet(V0(n));
    }
    /** A fast get cache with `get` concat. */
  }, {
    key: "opGet",
    value: function(n) {
      return this.cache.get(n) || null;
    }
  }, {
    key: "update",
    value: function(n, r) {
      return this.opUpdate(V0(n), r);
    }
    /** A fast get cache with `get` concat. */
  }, {
    key: "opUpdate",
    value: function(n, r) {
      var i = this.cache.get(n), o = r(i);
      o === null ? this.cache.delete(n) : this.cache.set(n, o);
    }
  }]), e;
}(), Dc = "data-token-hash", bo = "data-css-hash", JF = "data-cache-path", Xs = "__cssinjs_instance__";
function e5() {
  var e = Math.random().toString(12).slice(2);
  if (typeof document < "u" && document.head && document.body) {
    var t = document.body.querySelectorAll("style[".concat(bo, "]")) || [], n = document.head.firstChild;
    Array.from(t).forEach(function(i) {
      i[Xs] = i[Xs] || e, i[Xs] === e && document.head.insertBefore(i, n);
    });
    var r = {};
    Array.from(document.querySelectorAll("style[".concat(bo, "]"))).forEach(function(i) {
      var o = i.getAttribute(bo);
      if (r[o]) {
        if (i[Xs] === e) {
          var s;
          (s = i.parentNode) === null || s === void 0 || s.removeChild(i);
        }
      } else
        r[o] = !0;
    });
  }
  return new ZF(e);
}
var Dg = /* @__PURE__ */ O.createContext({
  hashPriority: "low",
  cache: e5(),
  defaultCache: !0
});
function t5(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
var Cw = /* @__PURE__ */ function() {
  function e() {
    ci(this, e), re(this, "cache", void 0), re(this, "keys", void 0), re(this, "cacheCallTimes", void 0), this.cache = /* @__PURE__ */ new Map(), this.keys = [], this.cacheCallTimes = 0;
  }
  return ui(e, [{
    key: "size",
    value: function() {
      return this.keys.length;
    }
  }, {
    key: "internalGet",
    value: function(n) {
      var r, i, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, s = {
        map: this.cache
      };
      return n.forEach(function(a) {
        if (!s)
          s = void 0;
        else {
          var l;
          s = (l = s) === null || l === void 0 || (l = l.map) === null || l === void 0 ? void 0 : l.get(a);
        }
      }), (r = s) !== null && r !== void 0 && r.value && o && (s.value[1] = this.cacheCallTimes++), (i = s) === null || i === void 0 ? void 0 : i.value;
    }
  }, {
    key: "get",
    value: function(n) {
      var r;
      return (r = this.internalGet(n, !0)) === null || r === void 0 ? void 0 : r[0];
    }
  }, {
    key: "has",
    value: function(n) {
      return !!this.internalGet(n);
    }
  }, {
    key: "set",
    value: function(n, r) {
      var i = this;
      if (!this.has(n)) {
        if (this.size() + 1 > e.MAX_CACHE_SIZE + e.MAX_CACHE_OFFSET) {
          var o = this.keys.reduce(function(u, c) {
            var d = ae(u, 2), f = d[1];
            return i.internalGet(c)[1] < f ? [c, i.internalGet(c)[1]] : u;
          }, [this.keys[0], this.cacheCallTimes]), s = ae(o, 1), a = s[0];
          this.delete(a);
        }
        this.keys.push(n);
      }
      var l = this.cache;
      n.forEach(function(u, c) {
        if (c === n.length - 1)
          l.set(u, {
            value: [r, i.cacheCallTimes++]
          });
        else {
          var d = l.get(u);
          d ? d.map || (d.map = /* @__PURE__ */ new Map()) : l.set(u, {
            map: /* @__PURE__ */ new Map()
          }), l = l.get(u).map;
        }
      });
    }
  }, {
    key: "deleteByPath",
    value: function(n, r) {
      var i = n.get(r[0]);
      if (r.length === 1) {
        var o;
        return i.map ? n.set(r[0], {
          map: i.map
        }) : n.delete(r[0]), (o = i.value) === null || o === void 0 ? void 0 : o[0];
      }
      var s = this.deleteByPath(i.map, r.slice(1));
      return (!i.map || i.map.size === 0) && !i.value && n.delete(r[0]), s;
    }
  }, {
    key: "delete",
    value: function(n) {
      if (this.has(n))
        return this.keys = this.keys.filter(function(r) {
          return !t5(r, n);
        }), this.deleteByPath(this.cache, n);
    }
  }]), e;
}();
re(Cw, "MAX_CACHE_SIZE", 20);
re(Cw, "MAX_CACHE_OFFSET", 5);
var bS = 0, cD = /* @__PURE__ */ function() {
  function e(t) {
    ci(this, e), re(this, "derivatives", void 0), re(this, "id", void 0), this.derivatives = Array.isArray(t) ? t : [t], this.id = bS, t.length === 0 && Ss(t.length > 0, "[Ant Design CSS-in-JS] Theme should have at least one derivative function."), bS += 1;
  }
  return ui(e, [{
    key: "getDerivativeToken",
    value: function(n) {
      return this.derivatives.reduce(function(r, i) {
        return i(n, r);
      }, void 0);
    }
  }]), e;
}(), Nm = new Cw();
function gd(e) {
  var t = Array.isArray(e) ? e : [e];
  return Nm.has(t) || Nm.set(t, new cD(t)), Nm.get(t);
}
var n5 = /* @__PURE__ */ new WeakMap(), Lm = {};
function r5(e, t) {
  for (var n = n5, r = 0; r < t.length; r += 1) {
    var i = t[r];
    n.has(i) || n.set(i, /* @__PURE__ */ new WeakMap()), n = n.get(i);
  }
  return n.has(Lm) || n.set(Lm, e()), n.get(Lm);
}
var yS = /* @__PURE__ */ new WeakMap();
function qu(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = yS.get(e) || "";
  return n || (Object.keys(e).forEach(function(r) {
    var i = e[r];
    n += r, i instanceof cD ? n += i.id : i && wt(i) === "object" ? n += qu(i, t) : n += i;
  }), t && (n = fd(n)), yS.set(e, n)), n;
}
function wS(e, t) {
  return fd("".concat(t, "_").concat(qu(e, !0)));
}
var W0 = Ir();
function le(e) {
  return typeof e == "number" ? "".concat(e, "px") : e;
}
function $p(e, t, n) {
  var r, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
  if (o)
    return e;
  var s = ie(ie({}, i), {}, (r = {}, re(r, Dc, t), re(r, bo, n), r)), a = Object.keys(s).map(function(l) {
    var u = s[l];
    return u ? "".concat(l, '="').concat(u, '"') : null;
  }).filter(function(l) {
    return l;
  }).join(" ");
  return "<style ".concat(a, ">").concat(e, "</style>");
}
var uD = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return "--".concat(n ? "".concat(n, "-") : "").concat(t).replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
}, i5 = function(t, n, r) {
  return Object.keys(t).length ? ".".concat(n).concat(r != null && r.scope ? ".".concat(r.scope) : "", "{").concat(Object.entries(t).map(function(i) {
    var o = ae(i, 2), s = o[0], a = o[1];
    return "".concat(s, ":").concat(a, ";");
  }).join(""), "}") : "";
}, dD = function(t, n, r) {
  var i = {}, o = {};
  return Object.entries(t).forEach(function(s) {
    var a, l, u = ae(s, 2), c = u[0], d = u[1];
    if (r != null && (a = r.preserve) !== null && a !== void 0 && a[c])
      o[c] = d;
    else if ((typeof d == "string" || typeof d == "number") && !(r != null && (l = r.ignore) !== null && l !== void 0 && l[c])) {
      var f, h = uD(c, r == null ? void 0 : r.prefix);
      i[h] = typeof d == "number" && !(r != null && (f = r.unitless) !== null && f !== void 0 && f[c]) ? "".concat(d, "px") : String(d), o[c] = "var(".concat(h, ")");
    }
  }), [o, i5(i, n, {
    scope: r == null ? void 0 : r.scope
  })];
}, CS = process.env.NODE_ENV !== "test" && Ir() ? O.useLayoutEffect : O.useEffect, sn = function(t, n) {
  var r = O.useRef(!0);
  CS(function() {
    return t(r.current);
  }, n), CS(function() {
    return r.current = !1, function() {
      r.current = !0;
    };
  }, []);
}, U0 = function(t, n) {
  sn(function(r) {
    if (!r)
      return t();
  }, n);
}, o5 = ie({}, O), SS = o5.useInsertionEffect, s5 = function(t, n, r) {
  O.useMemo(t, r), sn(function() {
    return n(!0);
  }, r);
}, a5 = SS ? function(e, t, n) {
  return SS(function() {
    return e(), t();
  }, n);
} : s5, l5 = ie({}, O), c5 = l5.useInsertionEffect, u5 = function(t) {
  var n = [], r = !1;
  function i(o) {
    if (r) {
      process.env.NODE_ENV !== "production" && Ss(!1, "[Ant Design CSS-in-JS] You are registering a cleanup function after unmount, which will not have any effect.");
      return;
    }
    n.push(o);
  }
  return O.useEffect(function() {
    return r = !1, function() {
      r = !0, n.length && n.forEach(function(o) {
        return o();
      });
    };
  }, t), i;
}, d5 = function() {
  return function(t) {
    t();
  };
}, f5 = typeof c5 < "u" ? u5 : d5;
function h5() {
  return !1;
}
var G0 = !1;
function p5() {
  return G0;
}
const g5 = process.env.NODE_ENV === "production" ? h5 : p5;
if (process.env.NODE_ENV !== "production" && typeof module < "u" && module && module.hot && typeof window < "u") {
  var Fm = window;
  if (typeof Fm.webpackHotUpdate == "function") {
    var m5 = Fm.webpackHotUpdate;
    Fm.webpackHotUpdate = function() {
      return G0 = !0, setTimeout(function() {
        G0 = !1;
      }, 0), m5.apply(void 0, arguments);
    };
  }
}
function Sw(e, t, n, r, i) {
  var o = O.useContext(Dg), s = o.cache, a = [e].concat(_e(t)), l = V0(a), u = f5([l]), c = g5(), d = function(g) {
    s.opUpdate(l, function(m) {
      var v = m || [void 0, void 0], b = ae(v, 2), x = b[0], w = x === void 0 ? 0 : x, C = b[1], y = C;
      process.env.NODE_ENV !== "production" && C && c && (r == null || r(y, c), y = null);
      var S = y || n(), A = [w, S];
      return g ? g(A) : A;
    });
  };
  O.useMemo(
    function() {
      d();
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [l]
    /* eslint-enable */
  );
  var f = s.opGet(l);
  process.env.NODE_ENV !== "production" && !f && (d(), f = s.opGet(l));
  var h = f[1];
  return a5(function() {
    i == null || i(h);
  }, function(p) {
    return d(function(g) {
      var m = ae(g, 2), v = m[0], b = m[1];
      return p && v === 0 && (i == null || i(h)), [v + 1, b];
    }), function() {
      s.opUpdate(l, function(g) {
        var m = g || [], v = ae(m, 2), b = v[0], x = b === void 0 ? 0 : b, w = v[1], C = x - 1;
        return C === 0 ? (u(function() {
          (p || !s.opGet(l)) && (r == null || r(w, !1));
        }), null) : [x - 1, w];
      });
    };
  }, [l]), h;
}
var v5 = {}, b5 = process.env.NODE_ENV !== "production" ? "css-dev-only-do-not-override" : "css", Ia = /* @__PURE__ */ new Map();
function y5(e) {
  Ia.set(e, (Ia.get(e) || 0) + 1);
}
function w5(e, t) {
  if (typeof document < "u") {
    var n = document.querySelectorAll("style[".concat(Dc, '="').concat(e, '"]'));
    n.forEach(function(r) {
      if (r[Xs] === t) {
        var i;
        (i = r.parentNode) === null || i === void 0 || i.removeChild(r);
      }
    });
  }
}
var C5 = 0;
function S5(e, t) {
  Ia.set(e, (Ia.get(e) || 0) - 1);
  var n = Array.from(Ia.keys()), r = n.filter(function(i) {
    var o = Ia.get(i) || 0;
    return o <= 0;
  });
  n.length - r.length > C5 && r.forEach(function(i) {
    w5(i, t), Ia.delete(i);
  });
}
var fD = function(t, n, r, i) {
  var o = r.getDerivativeToken(t), s = ie(ie({}, o), n);
  return i && (s = i(s)), s;
}, hD = "token";
function x5(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = Yt(Dg), i = r.cache.instanceId, o = r.container, s = n.salt, a = s === void 0 ? "" : s, l = n.override, u = l === void 0 ? v5 : l, c = n.formatToken, d = n.getComputedToken, f = n.cssVar, h = r5(function() {
    return Object.assign.apply(Object, [{}].concat(_e(t)));
  }, t), p = qu(h), g = qu(u), m = f ? qu(f) : "", v = Sw(hD, [a, e.id, p, g, m], function() {
    var b, x = d ? d(h, u, e) : fD(h, u, e, c), w = ie({}, x), C = "";
    if (f) {
      var y = dD(x, f.key, {
        prefix: f.prefix,
        ignore: f.ignore,
        unitless: f.unitless,
        preserve: f.preserve
      }), S = ae(y, 2);
      x = S[0], C = S[1];
    }
    var A = wS(x, a);
    x._tokenKey = A, w._tokenKey = wS(w, a);
    var $ = (b = f == null ? void 0 : f.key) !== null && b !== void 0 ? b : A;
    x._themeKey = $, y5($);
    var M = "".concat(b5, "-").concat(fd(A));
    return x._hashId = M, [x, M, w, C, (f == null ? void 0 : f.key) || ""];
  }, function(b) {
    S5(b[0]._themeKey, i);
  }, function(b) {
    var x = ae(b, 4), w = x[0], C = x[3];
    if (f && C) {
      var y = vs(C, fd("css-variables-".concat(w._themeKey)), {
        mark: bo,
        prepend: "queue",
        attachTo: o,
        priority: -999
      });
      y[Xs] = i, y.setAttribute(Dc, w._themeKey);
    }
  });
  return v;
}
var E5 = function(t, n, r) {
  var i = ae(t, 5), o = i[2], s = i[3], a = i[4], l = r || {}, u = l.plain;
  if (!s)
    return null;
  var c = o._tokenKey, d = -999, f = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(d)
  }, h = $p(s, a, c, f, u);
  return [d, c, h];
}, $5 = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, pD = "comm", gD = "rule", mD = "decl", O5 = "@import", A5 = "@keyframes", D5 = "@layer", vD = Math.abs, xw = String.fromCharCode;
function bD(e) {
  return e.trim();
}
function Gh(e, t, n) {
  return e.replace(t, n);
}
function _5(e, t, n) {
  return e.indexOf(t, n);
}
function md(e, t) {
  return e.charCodeAt(t) | 0;
}
function vd(e, t, n) {
  return e.slice(t, n);
}
function us(e) {
  return e.length;
}
function T5(e) {
  return e.length;
}
function jf(e, t) {
  return t.push(e), e;
}
var _g = 1, _c = 1, yD = 0, to = 0, sr = 0, Yc = "";
function Ew(e, t, n, r, i, o, s, a) {
  return { value: e, root: t, parent: n, type: r, props: i, children: o, line: _g, column: _c, length: s, return: "", siblings: a };
}
function R5() {
  return sr;
}
function M5() {
  return sr = to > 0 ? md(Yc, --to) : 0, _c--, sr === 10 && (_c = 1, _g--), sr;
}
function yo() {
  return sr = to < yD ? md(Yc, to++) : 0, _c++, sr === 10 && (_c = 1, _g++), sr;
}
function Wa() {
  return md(Yc, to);
}
function Kh() {
  return to;
}
function Tg(e, t) {
  return vd(Yc, e, t);
}
function K0(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function I5(e) {
  return _g = _c = 1, yD = us(Yc = e), to = 0, [];
}
function k5(e) {
  return Yc = "", e;
}
function Bm(e) {
  return bD(Tg(to - 1, X0(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function P5(e) {
  for (; (sr = Wa()) && sr < 33; )
    yo();
  return K0(e) > 2 || K0(sr) > 3 ? "" : " ";
}
function N5(e, t) {
  for (; --t && yo() && !(sr < 48 || sr > 102 || sr > 57 && sr < 65 || sr > 70 && sr < 97); )
    ;
  return Tg(e, Kh() + (t < 6 && Wa() == 32 && yo() == 32));
}
function X0(e) {
  for (; yo(); )
    switch (sr) {
      case e:
        return to;
      case 34:
      case 39:
        e !== 34 && e !== 39 && X0(sr);
        break;
      case 40:
        e === 41 && X0(e);
        break;
      case 92:
        yo();
        break;
    }
  return to;
}
function L5(e, t) {
  for (; yo() && e + sr !== 57; )
    if (e + sr === 84 && Wa() === 47)
      break;
  return "/*" + Tg(t, to - 1) + "*" + xw(e === 47 ? e : yo());
}
function F5(e) {
  for (; !K0(Wa()); )
    yo();
  return Tg(e, to);
}
function B5(e) {
  return k5(Xh("", null, null, null, [""], e = I5(e), 0, [0], e));
}
function Xh(e, t, n, r, i, o, s, a, l) {
  for (var u = 0, c = 0, d = s, f = 0, h = 0, p = 0, g = 1, m = 1, v = 1, b = 0, x = "", w = i, C = o, y = r, S = x; m; )
    switch (p = b, b = yo()) {
      case 40:
        if (p != 108 && md(S, d - 1) == 58) {
          _5(S += Gh(Bm(b), "&", "&\f"), "&\f", vD(u ? a[u - 1] : 0)) != -1 && (v = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        S += Bm(b);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        S += P5(p);
        break;
      case 92:
        S += N5(Kh() - 1, 7);
        continue;
      case 47:
        switch (Wa()) {
          case 42:
          case 47:
            jf(j5(L5(yo(), Kh()), t, n, l), l);
            break;
          default:
            S += "/";
        }
        break;
      case 123 * g:
        a[u++] = us(S) * v;
      case 125 * g:
      case 59:
      case 0:
        switch (b) {
          case 0:
          case 125:
            m = 0;
          case 59 + c:
            v == -1 && (S = Gh(S, /\f/g, "")), h > 0 && us(S) - d && jf(h > 32 ? ES(S + ";", r, n, d - 1, l) : ES(Gh(S, " ", "") + ";", r, n, d - 2, l), l);
            break;
          case 59:
            S += ";";
          default:
            if (jf(y = xS(S, t, n, u, c, i, a, x, w = [], C = [], d, o), o), b === 123)
              if (c === 0)
                Xh(S, t, y, y, w, o, d, a, C);
              else
                switch (f === 99 && md(S, 3) === 110 ? 100 : f) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Xh(e, y, y, r && jf(xS(e, y, y, 0, 0, i, a, x, i, w = [], d, C), C), i, C, d, a, r ? w : C);
                    break;
                  default:
                    Xh(S, y, y, y, [""], C, 0, a, C);
                }
        }
        u = c = h = 0, g = v = 1, x = S = "", d = s;
        break;
      case 58:
        d = 1 + us(S), h = p;
      default:
        if (g < 1) {
          if (b == 123)
            --g;
          else if (b == 125 && g++ == 0 && M5() == 125)
            continue;
        }
        switch (S += xw(b), b * g) {
          case 38:
            v = c > 0 ? 1 : (S += "\f", -1);
            break;
          case 44:
            a[u++] = (us(S) - 1) * v, v = 1;
            break;
          case 64:
            Wa() === 45 && (S += Bm(yo())), f = Wa(), c = d = us(x = S += F5(Kh())), b++;
            break;
          case 45:
            p === 45 && us(S) == 2 && (g = 0);
        }
    }
  return o;
}
function xS(e, t, n, r, i, o, s, a, l, u, c, d) {
  for (var f = i - 1, h = i === 0 ? o : [""], p = T5(h), g = 0, m = 0, v = 0; g < r; ++g)
    for (var b = 0, x = vd(e, f + 1, f = vD(m = s[g])), w = e; b < p; ++b)
      (w = bD(m > 0 ? h[b] + " " + x : Gh(x, /&\f/g, h[b]))) && (l[v++] = w);
  return Ew(e, t, n, i === 0 ? gD : a, l, u, c, d);
}
function j5(e, t, n, r) {
  return Ew(e, t, n, pD, xw(R5()), vd(e, 2, -2), 0, r);
}
function ES(e, t, n, r, i) {
  return Ew(e, t, n, mD, vd(e, 0, r), vd(e, r + 1, -1), r, i);
}
function Y0(e, t) {
  for (var n = "", r = 0; r < e.length; r++)
    n += t(e[r], r, e, t) || "";
  return n;
}
function z5(e, t, n, r) {
  switch (e.type) {
    case D5:
      if (e.children.length)
        break;
    case O5:
    case mD:
      return e.return = e.return || e.value;
    case pD:
      return "";
    case A5:
      return e.return = e.value + "{" + Y0(e.children, r) + "}";
    case gD:
      if (!us(e.value = e.props.join(",")))
        return "";
  }
  return us(n = Y0(e.children, r)) ? e.return = e.value + "{" + n + "}" : "";
}
function wD(e, t) {
  var n = t.path, r = t.parentSelectors;
  $t(!1, "[Ant Design CSS-in-JS] ".concat(n ? "Error in ".concat(n, ": ") : "").concat(e).concat(r.length ? " Selector: ".concat(r.join(" | ")) : ""));
}
var H5 = function(t, n, r) {
  if (t === "content") {
    var i = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, o = ["normal", "none", "initial", "inherit", "unset"];
    (typeof n != "string" || o.indexOf(n) === -1 && !i.test(n) && (n.charAt(0) !== n.charAt(n.length - 1) || n.charAt(0) !== '"' && n.charAt(0) !== "'")) && wD("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"".concat(n, "\"'`."), r);
  }
}, V5 = function(t, n, r) {
  t === "animation" && r.hashId && n !== "none" && wD("You seem to be using hashed animation '".concat(n, "', in which case 'animationName' with Keyframe as value is recommended."), r);
}, $S = "data-ant-cssinjs-cache-path", CD = "_FILE_STYLE__", Ua, SD = !0;
function W5() {
  if (!Ua && (Ua = {}, Ir())) {
    var e = document.createElement("div");
    e.className = $S, e.style.position = "fixed", e.style.visibility = "hidden", e.style.top = "-9999px", document.body.appendChild(e);
    var t = getComputedStyle(e).content || "";
    t = t.replace(/^"/, "").replace(/"$/, ""), t.split(";").forEach(function(i) {
      var o = i.split(":"), s = ae(o, 2), a = s[0], l = s[1];
      Ua[a] = l;
    });
    var n = document.querySelector("style[".concat($S, "]"));
    if (n) {
      var r;
      SD = !1, (r = n.parentNode) === null || r === void 0 || r.removeChild(n);
    }
    document.body.removeChild(e);
  }
}
function U5(e) {
  return W5(), !!Ua[e];
}
function G5(e) {
  var t = Ua[e], n = null;
  if (t && Ir())
    if (SD)
      n = CD;
    else {
      var r = document.querySelector("style[".concat(bo, '="').concat(Ua[e], '"]'));
      r ? n = r.innerHTML : delete Ua[e];
    }
  return [n, t];
}
var xD = "_skip_check_", ED = "_multi_value_";
function Yh(e) {
  var t = Y0(B5(e), z5);
  return t.replace(/\{%%%\:[^;];}/g, ";");
}
function K5(e) {
  return wt(e) === "object" && e && (xD in e || ED in e);
}
function X5(e, t, n) {
  if (!t)
    return e;
  var r = ".".concat(t), i = n === "low" ? ":where(".concat(r, ")") : r, o = e.split(",").map(function(s) {
    var a, l = s.trim().split(/\s+/), u = l[0] || "", c = ((a = u.match(/^\w+/)) === null || a === void 0 ? void 0 : a[0]) || "";
    return u = "".concat(c).concat(i).concat(u.slice(c.length)), [u].concat(_e(l.slice(1))).join(" ");
  });
  return o.join(",");
}
var Y5 = function e(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    root: !0,
    parentSelectors: []
  }, i = r.root, o = r.injectHash, s = r.parentSelectors, a = n.hashId, l = n.layer, u = n.path, c = n.hashPriority, d = n.transformers, f = d === void 0 ? [] : d, h = n.linters, p = h === void 0 ? [] : h, g = "", m = {};
  function v(w) {
    var C = w.getName(a);
    if (!m[C]) {
      var y = e(w.style, n, {
        root: !1,
        parentSelectors: s
      }), S = ae(y, 1), A = S[0];
      m[C] = "@keyframes ".concat(w.getName(a)).concat(A);
    }
  }
  function b(w) {
    var C = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return w.forEach(function(y) {
      Array.isArray(y) ? b(y, C) : y && C.push(y);
    }), C;
  }
  var x = b(Array.isArray(t) ? t : [t]);
  return x.forEach(function(w) {
    var C = typeof w == "string" && !i ? {} : w;
    if (typeof C == "string")
      g += "".concat(C, `
`);
    else if (C._keyframe)
      v(C);
    else {
      var y = f.reduce(function(S, A) {
        var $;
        return (A == null || ($ = A.visit) === null || $ === void 0 ? void 0 : $.call(A, S)) || S;
      }, C);
      Object.keys(y).forEach(function(S) {
        var A = y[S];
        if (wt(A) === "object" && A && (S !== "animationName" || !A._keyframe) && !K5(A)) {
          var $ = !1, M = S.trim(), _ = !1;
          (i || o) && a ? M.startsWith("@") ? $ = !0 : M = X5(S, a, c) : i && !a && (M === "&" || M === "") && (M = "", _ = !0);
          var T = e(A, n, {
            root: _,
            injectHash: $,
            parentSelectors: [].concat(_e(s), [M])
          }), D = ae(T, 2), E = D[0], R = D[1];
          m = ie(ie({}, m), R), g += "".concat(M).concat(E);
        } else {
          let P = function(L, N) {
            process.env.NODE_ENV !== "production" && (wt(A) !== "object" || !(A != null && A[xD])) && [H5, V5].concat(_e(p)).forEach(function(j) {
              return j(L, N, {
                path: u,
                hashId: a,
                parentSelectors: s
              });
            });
            var F = L.replace(/[A-Z]/g, function(j) {
              return "-".concat(j.toLowerCase());
            }), B = N;
            !$5[L] && typeof B == "number" && B !== 0 && (B = "".concat(B, "px")), L === "animationName" && N !== null && N !== void 0 && N._keyframe && (v(N), B = N.getName(a)), g += "".concat(F, ":").concat(B, ";");
          };
          var I, k = (I = A == null ? void 0 : A.value) !== null && I !== void 0 ? I : A;
          wt(A) === "object" && A !== null && A !== void 0 && A[ED] && Array.isArray(k) ? k.forEach(function(L) {
            P(S, L);
          }) : P(S, k);
        }
      });
    }
  }), i ? l && (g = "@layer ".concat(l.name, " {").concat(g, "}"), l.dependencies && (m["@layer ".concat(l.name)] = l.dependencies.map(function(w) {
    return "@layer ".concat(w, ", ").concat(l.name, ";");
  }).join(`
`))) : g = "{".concat(g, "}"), [g, m];
};
function $D(e, t) {
  return fd("".concat(e.join("%")).concat(t));
}
function q5() {
  return null;
}
var OD = "style";
function q0(e, t) {
  var n = e.token, r = e.path, i = e.hashId, o = e.layer, s = e.nonce, a = e.clientOnly, l = e.order, u = l === void 0 ? 0 : l, c = O.useContext(Dg), d = c.autoClear, f = c.mock, h = c.defaultCache, p = c.hashPriority, g = c.container, m = c.ssrInline, v = c.transformers, b = c.linters, x = c.cache, w = c.layer, C = n._tokenKey, y = [C];
  w && y.push("layer"), y.push.apply(y, _e(r));
  var S = W0;
  process.env.NODE_ENV !== "production" && f !== void 0 && (S = f === "client");
  var A = Sw(
    OD,
    y,
    // Create cache if needed
    function() {
      var D = y.join("|");
      if (U5(D)) {
        var E = G5(D), R = ae(E, 2), I = R[0], k = R[1];
        if (I)
          return [I, C, k, {}, a, u];
      }
      var P = t(), L = Y5(P, {
        hashId: i,
        hashPriority: p,
        layer: w ? o : void 0,
        path: r.join("-"),
        transformers: v,
        linters: b
      }), N = ae(L, 2), F = N[0], B = N[1], j = Yh(F), z = $D(y, j);
      return [j, C, z, B, a, u];
    },
    // Remove cache if no need
    function(D, E) {
      var R = ae(D, 3), I = R[2];
      (E || d) && W0 && hd(I, {
        mark: bo
      });
    },
    // Effect: Inject style here
    function(D) {
      var E = ae(D, 4), R = E[0];
      E[1];
      var I = E[2], k = E[3];
      if (S && R !== CD) {
        var P = {
          mark: bo,
          prepend: w ? !1 : "queue",
          attachTo: g,
          priority: u
        }, L = typeof s == "function" ? s() : s;
        L && (P.csp = {
          nonce: L
        });
        var N = [], F = [];
        Object.keys(k).forEach(function(j) {
          j.startsWith("@layer") ? N.push(j) : F.push(j);
        }), N.forEach(function(j) {
          vs(Yh(k[j]), "_layer-".concat(j), ie(ie({}, P), {}, {
            prepend: !0
          }));
        });
        var B = vs(R, I, P);
        B[Xs] = x.instanceId, B.setAttribute(Dc, C), process.env.NODE_ENV !== "production" && B.setAttribute(JF, y.join("|")), F.forEach(function(j) {
          vs(Yh(k[j]), "_effect-".concat(j), P);
        });
      }
    }
  ), $ = ae(A, 3), M = $[0], _ = $[1], T = $[2];
  return function(D) {
    var E;
    if (!m || S || !h)
      E = /* @__PURE__ */ O.createElement(q5, null);
    else {
      var R;
      E = /* @__PURE__ */ O.createElement("style", we({}, (R = {}, re(R, Dc, _), re(R, bo, T), R), {
        dangerouslySetInnerHTML: {
          __html: M
        }
      }));
    }
    return /* @__PURE__ */ O.createElement(O.Fragment, null, E, D);
  };
}
var Q5 = function(t, n, r) {
  var i = ae(t, 6), o = i[0], s = i[1], a = i[2], l = i[3], u = i[4], c = i[5], d = r || {}, f = d.plain;
  if (u)
    return null;
  var h = o, p = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(c)
  };
  return h = $p(o, s, a, p, f), l && Object.keys(l).forEach(function(g) {
    if (!n[g]) {
      n[g] = !0;
      var m = Yh(l[g]), v = $p(m, s, "_effect-".concat(g), p, f);
      g.startsWith("@layer") ? h = v + h : h += v;
    }
  }), [c, a, h];
}, AD = "cssVar", Z5 = function(t, n) {
  var r = t.key, i = t.prefix, o = t.unitless, s = t.ignore, a = t.token, l = t.scope, u = l === void 0 ? "" : l, c = Yt(Dg), d = c.cache.instanceId, f = c.container, h = a._tokenKey, p = [].concat(_e(t.path), [r, u, h]), g = Sw(AD, p, function() {
    var m = n(), v = dD(m, r, {
      prefix: i,
      unitless: o,
      ignore: s,
      scope: u
    }), b = ae(v, 2), x = b[0], w = b[1], C = $D(p, w);
    return [x, w, C, r];
  }, function(m) {
    var v = ae(m, 3), b = v[2];
    W0 && hd(b, {
      mark: bo
    });
  }, function(m) {
    var v = ae(m, 3), b = v[1], x = v[2];
    if (b) {
      var w = vs(b, x, {
        mark: bo,
        prepend: "queue",
        attachTo: f,
        priority: -999
      });
      w[Xs] = d, w.setAttribute(Dc, r);
    }
  });
  return g;
}, J5 = function(t, n, r) {
  var i = ae(t, 4), o = i[1], s = i[2], a = i[3], l = r || {}, u = l.plain;
  if (!o)
    return null;
  var c = -999, d = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(c)
  }, f = $p(o, a, s, d, u);
  return [c, s, f];
}, vu;
vu = {}, re(vu, OD, Q5), re(vu, hD, E5), re(vu, AD, J5);
var Gt = /* @__PURE__ */ function() {
  function e(t, n) {
    ci(this, e), re(this, "name", void 0), re(this, "style", void 0), re(this, "_keyframe", !0), this.name = t, this.style = n;
  }
  return ui(e, [{
    key: "getName",
    value: function() {
      var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return n ? "".concat(n, "-").concat(this.name) : this.name;
    }
  }]), e;
}();
function Il(e) {
  return e.notSplit = !0, e;
}
Il(["borderTop", "borderBottom"]), Il(["borderTop"]), Il(["borderBottom"]), Il(["borderLeft", "borderRight"]), Il(["borderLeft"]), Il(["borderRight"]);
var $w = /* @__PURE__ */ Yo({});
function DD(e) {
  return iD(e) || eD(e) || yw(e) || oD();
}
function Wo(e, t) {
  for (var n = e, r = 0; r < t.length; r += 1) {
    if (n == null)
      return;
    n = n[t[r]];
  }
  return n;
}
function _D(e, t, n, r) {
  if (!t.length)
    return n;
  var i = DD(t), o = i[0], s = i.slice(1), a;
  return !e && typeof o == "number" ? a = [] : Array.isArray(e) ? a = _e(e) : a = ie({}, e), r && n === void 0 && s.length === 1 ? delete a[o][s[0]] : a[o] = _D(a[o], s, n, r), a;
}
function co(e, t, n) {
  var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return t.length && r && n === void 0 && !Wo(e, t.slice(0, -1)) ? e : _D(e, t, n, r);
}
function e3(e) {
  return wt(e) === "object" && e !== null && Object.getPrototypeOf(e) === Object.prototype;
}
function OS(e) {
  return Array.isArray(e) ? [] : {};
}
var t3 = typeof Reflect > "u" ? Object.keys : Reflect.ownKeys;
function rc() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  var r = OS(t[0]);
  return t.forEach(function(i) {
    function o(s, a) {
      var l = new Set(a), u = Wo(i, s), c = Array.isArray(u);
      if (c || e3(u)) {
        if (!l.has(u)) {
          l.add(u);
          var d = Wo(r, s);
          c ? r = co(r, s, []) : (!d || wt(d) !== "object") && (r = co(r, s, OS(u))), t3(u).forEach(function(f) {
            o([].concat(_e(s), [f]), l);
          });
        }
      } else
        r = co(r, s, u);
    }
    o([]);
  }), r;
}
function TD() {
}
let as = null;
function n3() {
  as = null, HA();
}
let Ow = TD;
process.env.NODE_ENV !== "production" && (Ow = (e, t, n) => {
  $t(e, `[antd: ${t}] ${n}`), process.env.NODE_ENV === "test" && n3();
});
const RD = /* @__PURE__ */ O.createContext({}), Zt = process.env.NODE_ENV !== "production" ? (e) => {
  const {
    strict: t
  } = O.useContext(RD), n = (r, i, o) => {
    if (!r)
      if (t === !1 && i === "deprecated") {
        const s = as;
        as || (as = {}), as[e] = as[e] || [], as[e].includes(o || "") || as[e].push(o || ""), s || console.warn("[antd] There exists deprecated usage in your code:", as);
      } else
        process.env.NODE_ENV !== "production" && Ow(r, e, o);
  };
  return n.deprecated = (r, i, o, s) => {
    n(r, "deprecated", `\`${i}\` is deprecated. Please use \`${o}\` instead.${s ? ` ${s}` : ""}`);
  }, n;
} : () => {
  const e = () => {
  };
  return e.deprecated = TD, e;
}, gl = Ow, MD = /* @__PURE__ */ Yo(void 0);
var r3 = {
  // Options
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  // Pagination
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
}, i3 = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: !0,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
};
const ID = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
}, AS = {
  lang: Object.assign({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, i3),
  timePickerLocale: Object.assign({}, ID)
}, Oi = "${label} is not a valid ${type}", xs = {
  locale: "en",
  Pagination: r3,
  DatePicker: AS,
  TimePicker: ID,
  Calendar: AS,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand",
    collapse: "Collapse"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: Oi,
        method: Oi,
        array: Oi,
        object: Oi,
        number: Oi,
        date: Oi,
        boolean: Oi,
        integer: Oi,
        float: Oi,
        regexp: Oi,
        email: Oi,
        url: Oi,
        hex: Oi
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  },
  ColorPicker: {
    presetEmpty: "Empty"
  }
};
let qh = Object.assign({}, xs.Modal), Qh = [];
const DS = () => Qh.reduce((e, t) => Object.assign(Object.assign({}, e), t), xs.Modal);
function o3(e) {
  if (e) {
    const t = Object.assign({}, e);
    return Qh.push(t), qh = DS(), () => {
      Qh = Qh.filter((n) => n !== t), qh = DS();
    };
  }
  qh = Object.assign({}, xs.Modal);
}
function kD() {
  return qh;
}
const Aw = /* @__PURE__ */ Yo(void 0), ml = (e, t) => {
  const n = O.useContext(Aw), r = O.useMemo(() => {
    var o;
    const s = t || xs[e], a = (o = n == null ? void 0 : n[e]) !== null && o !== void 0 ? o : {};
    return Object.assign(Object.assign({}, typeof s == "function" ? s() : s), a || {});
  }, [e, t, n]), i = O.useMemo(() => {
    const o = n == null ? void 0 : n.locale;
    return n != null && n.exist && !o ? xs.locale : o;
  }, [n]);
  return [r, i];
}, PD = "internalMark", ND = (e) => {
  const {
    locale: t = {},
    children: n,
    _ANT_MARK__: r
  } = e;
  if (process.env.NODE_ENV !== "production") {
    const o = Zt("LocaleProvider");
    process.env.NODE_ENV !== "production" && o(r === PD, "deprecated", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead: http://u.ant.design/locale");
  }
  O.useEffect(() => o3(t && t.Modal), [t]);
  const i = O.useMemo(() => Object.assign(Object.assign({}, t), {
    exist: !0
  }), [t]);
  return /* @__PURE__ */ O.createElement(Aw.Provider, {
    value: i
  }, n);
};
process.env.NODE_ENV !== "production" && (ND.displayName = "LocaleProvider");
function kr(e, t) {
  s3(e) && (e = "100%");
  var n = a3(e);
  return e = t === 360 ? e : Math.min(t, Math.max(0, parseFloat(e))), n && (e = parseInt(String(e * t), 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : (t === 360 ? e = (e < 0 ? e % t + t : e % t) / parseFloat(String(t)) : e = e % t / parseFloat(String(t)), e);
}
function zf(e) {
  return Math.min(1, Math.max(0, e));
}
function s3(e) {
  return typeof e == "string" && e.indexOf(".") !== -1 && parseFloat(e) === 1;
}
function a3(e) {
  return typeof e == "string" && e.indexOf("%") !== -1;
}
function LD(e) {
  return e = parseFloat(e), (isNaN(e) || e < 0 || e > 1) && (e = 1), e;
}
function Hf(e) {
  return e <= 1 ? "".concat(Number(e) * 100, "%") : e;
}
function Pa(e) {
  return e.length === 1 ? "0" + e : String(e);
}
function l3(e, t, n) {
  return {
    r: kr(e, 255) * 255,
    g: kr(t, 255) * 255,
    b: kr(n, 255) * 255
  };
}
function _S(e, t, n) {
  e = kr(e, 255), t = kr(t, 255), n = kr(n, 255);
  var r = Math.max(e, t, n), i = Math.min(e, t, n), o = 0, s = 0, a = (r + i) / 2;
  if (r === i)
    s = 0, o = 0;
  else {
    var l = r - i;
    switch (s = a > 0.5 ? l / (2 - r - i) : l / (r + i), r) {
      case e:
        o = (t - n) / l + (t < n ? 6 : 0);
        break;
      case t:
        o = (n - e) / l + 2;
        break;
      case n:
        o = (e - t) / l + 4;
        break;
    }
    o /= 6;
  }
  return { h: o, s, l: a };
}
function jm(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * (6 * n) : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function c3(e, t, n) {
  var r, i, o;
  if (e = kr(e, 360), t = kr(t, 100), n = kr(n, 100), t === 0)
    i = n, o = n, r = n;
  else {
    var s = n < 0.5 ? n * (1 + t) : n + t - n * t, a = 2 * n - s;
    r = jm(a, s, e + 1 / 3), i = jm(a, s, e), o = jm(a, s, e - 1 / 3);
  }
  return { r: r * 255, g: i * 255, b: o * 255 };
}
function Q0(e, t, n) {
  e = kr(e, 255), t = kr(t, 255), n = kr(n, 255);
  var r = Math.max(e, t, n), i = Math.min(e, t, n), o = 0, s = r, a = r - i, l = r === 0 ? 0 : a / r;
  if (r === i)
    o = 0;
  else {
    switch (r) {
      case e:
        o = (t - n) / a + (t < n ? 6 : 0);
        break;
      case t:
        o = (n - e) / a + 2;
        break;
      case n:
        o = (e - t) / a + 4;
        break;
    }
    o /= 6;
  }
  return { h: o, s: l, v: s };
}
function u3(e, t, n) {
  e = kr(e, 360) * 6, t = kr(t, 100), n = kr(n, 100);
  var r = Math.floor(e), i = e - r, o = n * (1 - t), s = n * (1 - i * t), a = n * (1 - (1 - i) * t), l = r % 6, u = [n, s, o, o, a, n][l], c = [a, n, n, s, o, o][l], d = [o, o, a, n, n, s][l];
  return { r: u * 255, g: c * 255, b: d * 255 };
}
function Z0(e, t, n, r) {
  var i = [
    Pa(Math.round(e).toString(16)),
    Pa(Math.round(t).toString(16)),
    Pa(Math.round(n).toString(16))
  ];
  return r && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("");
}
function d3(e, t, n, r, i) {
  var o = [
    Pa(Math.round(e).toString(16)),
    Pa(Math.round(t).toString(16)),
    Pa(Math.round(n).toString(16)),
    Pa(f3(r))
  ];
  return i && o[0].startsWith(o[0].charAt(1)) && o[1].startsWith(o[1].charAt(1)) && o[2].startsWith(o[2].charAt(1)) && o[3].startsWith(o[3].charAt(1)) ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0) + o[3].charAt(0) : o.join("");
}
function f3(e) {
  return Math.round(parseFloat(e) * 255).toString(16);
}
function TS(e) {
  return _i(e) / 255;
}
function _i(e) {
  return parseInt(e, 16);
}
function h3(e) {
  return {
    r: e >> 16,
    g: (e & 65280) >> 8,
    b: e & 255
  };
}
var J0 = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function Jl(e) {
  var t = { r: 0, g: 0, b: 0 }, n = 1, r = null, i = null, o = null, s = !1, a = !1;
  return typeof e == "string" && (e = m3(e)), typeof e == "object" && (ts(e.r) && ts(e.g) && ts(e.b) ? (t = l3(e.r, e.g, e.b), s = !0, a = String(e.r).substr(-1) === "%" ? "prgb" : "rgb") : ts(e.h) && ts(e.s) && ts(e.v) ? (r = Hf(e.s), i = Hf(e.v), t = u3(e.h, r, i), s = !0, a = "hsv") : ts(e.h) && ts(e.s) && ts(e.l) && (r = Hf(e.s), o = Hf(e.l), t = c3(e.h, r, o), s = !0, a = "hsl"), Object.prototype.hasOwnProperty.call(e, "a") && (n = e.a)), n = LD(n), {
    ok: s,
    format: e.format || a,
    r: Math.min(255, Math.max(t.r, 0)),
    g: Math.min(255, Math.max(t.g, 0)),
    b: Math.min(255, Math.max(t.b, 0)),
    a: n
  };
}
var p3 = "[-\\+]?\\d+%?", g3 = "[-\\+]?\\d*\\.\\d+%?", Ys = "(?:".concat(g3, ")|(?:").concat(p3, ")"), zm = "[\\s|\\(]+(".concat(Ys, ")[,|\\s]+(").concat(Ys, ")[,|\\s]+(").concat(Ys, ")\\s*\\)?"), Hm = "[\\s|\\(]+(".concat(Ys, ")[,|\\s]+(").concat(Ys, ")[,|\\s]+(").concat(Ys, ")[,|\\s]+(").concat(Ys, ")\\s*\\)?"), lo = {
  CSS_UNIT: new RegExp(Ys),
  rgb: new RegExp("rgb" + zm),
  rgba: new RegExp("rgba" + Hm),
  hsl: new RegExp("hsl" + zm),
  hsla: new RegExp("hsla" + Hm),
  hsv: new RegExp("hsv" + zm),
  hsva: new RegExp("hsva" + Hm),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function m3(e) {
  if (e = e.trim().toLowerCase(), e.length === 0)
    return !1;
  var t = !1;
  if (J0[e])
    e = J0[e], t = !0;
  else if (e === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var n = lo.rgb.exec(e);
  return n ? { r: n[1], g: n[2], b: n[3] } : (n = lo.rgba.exec(e), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = lo.hsl.exec(e), n ? { h: n[1], s: n[2], l: n[3] } : (n = lo.hsla.exec(e), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = lo.hsv.exec(e), n ? { h: n[1], s: n[2], v: n[3] } : (n = lo.hsva.exec(e), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = lo.hex8.exec(e), n ? {
    r: _i(n[1]),
    g: _i(n[2]),
    b: _i(n[3]),
    a: TS(n[4]),
    format: t ? "name" : "hex8"
  } : (n = lo.hex6.exec(e), n ? {
    r: _i(n[1]),
    g: _i(n[2]),
    b: _i(n[3]),
    format: t ? "name" : "hex"
  } : (n = lo.hex4.exec(e), n ? {
    r: _i(n[1] + n[1]),
    g: _i(n[2] + n[2]),
    b: _i(n[3] + n[3]),
    a: TS(n[4] + n[4]),
    format: t ? "name" : "hex8"
  } : (n = lo.hex3.exec(e), n ? {
    r: _i(n[1] + n[1]),
    g: _i(n[2] + n[2]),
    b: _i(n[3] + n[3]),
    format: t ? "name" : "hex"
  } : !1)))))))));
}
function ts(e) {
  return !!lo.CSS_UNIT.exec(String(e));
}
var ir = (
  /** @class */
  function() {
    function e(t, n) {
      t === void 0 && (t = ""), n === void 0 && (n = {});
      var r;
      if (t instanceof e)
        return t;
      typeof t == "number" && (t = h3(t)), this.originalInput = t;
      var i = Jl(t);
      this.originalInput = t, this.r = i.r, this.g = i.g, this.b = i.b, this.a = i.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (r = n.format) !== null && r !== void 0 ? r : i.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = i.ok;
    }
    return e.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, e.prototype.isLight = function() {
      return !this.isDark();
    }, e.prototype.getBrightness = function() {
      var t = this.toRgb();
      return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3;
    }, e.prototype.getLuminance = function() {
      var t = this.toRgb(), n, r, i, o = t.r / 255, s = t.g / 255, a = t.b / 255;
      return o <= 0.03928 ? n = o / 12.92 : n = Math.pow((o + 0.055) / 1.055, 2.4), s <= 0.03928 ? r = s / 12.92 : r = Math.pow((s + 0.055) / 1.055, 2.4), a <= 0.03928 ? i = a / 12.92 : i = Math.pow((a + 0.055) / 1.055, 2.4), 0.2126 * n + 0.7152 * r + 0.0722 * i;
    }, e.prototype.getAlpha = function() {
      return this.a;
    }, e.prototype.setAlpha = function(t) {
      return this.a = LD(t), this.roundA = Math.round(100 * this.a) / 100, this;
    }, e.prototype.isMonochrome = function() {
      var t = this.toHsl().s;
      return t === 0;
    }, e.prototype.toHsv = function() {
      var t = Q0(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, v: t.v, a: this.a };
    }, e.prototype.toHsvString = function() {
      var t = Q0(this.r, this.g, this.b), n = Math.round(t.h * 360), r = Math.round(t.s * 100), i = Math.round(t.v * 100);
      return this.a === 1 ? "hsv(".concat(n, ", ").concat(r, "%, ").concat(i, "%)") : "hsva(".concat(n, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHsl = function() {
      var t = _S(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, l: t.l, a: this.a };
    }, e.prototype.toHslString = function() {
      var t = _S(this.r, this.g, this.b), n = Math.round(t.h * 360), r = Math.round(t.s * 100), i = Math.round(t.l * 100);
      return this.a === 1 ? "hsl(".concat(n, ", ").concat(r, "%, ").concat(i, "%)") : "hsla(".concat(n, ", ").concat(r, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHex = function(t) {
      return t === void 0 && (t = !1), Z0(this.r, this.g, this.b, t);
    }, e.prototype.toHexString = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex(t);
    }, e.prototype.toHex8 = function(t) {
      return t === void 0 && (t = !1), d3(this.r, this.g, this.b, this.a, t);
    }, e.prototype.toHex8String = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex8(t);
    }, e.prototype.toHexShortString = function(t) {
      return t === void 0 && (t = !1), this.a === 1 ? this.toHexString(t) : this.toHex8String(t);
    }, e.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, e.prototype.toRgbString = function() {
      var t = Math.round(this.r), n = Math.round(this.g), r = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(t, ", ").concat(n, ", ").concat(r, ")") : "rgba(".concat(t, ", ").concat(n, ", ").concat(r, ", ").concat(this.roundA, ")");
    }, e.prototype.toPercentageRgb = function() {
      var t = function(n) {
        return "".concat(Math.round(kr(n, 255) * 100), "%");
      };
      return {
        r: t(this.r),
        g: t(this.g),
        b: t(this.b),
        a: this.a
      };
    }, e.prototype.toPercentageRgbString = function() {
      var t = function(n) {
        return Math.round(kr(n, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")");
    }, e.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var t = "#" + Z0(this.r, this.g, this.b, !1), n = 0, r = Object.entries(J0); n < r.length; n++) {
        var i = r[n], o = i[0], s = i[1];
        if (t === s)
          return o;
      }
      return !1;
    }, e.prototype.toString = function(t) {
      var n = !!t;
      t = t ?? this.format;
      var r = !1, i = this.a < 1 && this.a >= 0, o = !n && i && (t.startsWith("hex") || t === "name");
      return o ? t === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (r = this.toRgbString()), t === "prgb" && (r = this.toPercentageRgbString()), (t === "hex" || t === "hex6") && (r = this.toHexString()), t === "hex3" && (r = this.toHexString(!0)), t === "hex4" && (r = this.toHex8String(!0)), t === "hex8" && (r = this.toHex8String()), t === "name" && (r = this.toName()), t === "hsl" && (r = this.toHslString()), t === "hsv" && (r = this.toHsvString()), r || this.toHexString());
    }, e.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, e.prototype.clone = function() {
      return new e(this.toString());
    }, e.prototype.lighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l += t / 100, n.l = zf(n.l), new e(n);
    }, e.prototype.brighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toRgb();
      return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(t / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(t / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(t / 100)))), new e(n);
    }, e.prototype.darken = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l -= t / 100, n.l = zf(n.l), new e(n);
    }, e.prototype.tint = function(t) {
      return t === void 0 && (t = 10), this.mix("white", t);
    }, e.prototype.shade = function(t) {
      return t === void 0 && (t = 10), this.mix("black", t);
    }, e.prototype.desaturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s -= t / 100, n.s = zf(n.s), new e(n);
    }, e.prototype.saturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s += t / 100, n.s = zf(n.s), new e(n);
    }, e.prototype.greyscale = function() {
      return this.desaturate(100);
    }, e.prototype.spin = function(t) {
      var n = this.toHsl(), r = (n.h + t) % 360;
      return n.h = r < 0 ? 360 + r : r, new e(n);
    }, e.prototype.mix = function(t, n) {
      n === void 0 && (n = 50);
      var r = this.toRgb(), i = new e(t).toRgb(), o = n / 100, s = {
        r: (i.r - r.r) * o + r.r,
        g: (i.g - r.g) * o + r.g,
        b: (i.b - r.b) * o + r.b,
        a: (i.a - r.a) * o + r.a
      };
      return new e(s);
    }, e.prototype.analogous = function(t, n) {
      t === void 0 && (t = 6), n === void 0 && (n = 30);
      var r = this.toHsl(), i = 360 / n, o = [this];
      for (r.h = (r.h - (i * t >> 1) + 720) % 360; --t; )
        r.h = (r.h + i) % 360, o.push(new e(r));
      return o;
    }, e.prototype.complement = function() {
      var t = this.toHsl();
      return t.h = (t.h + 180) % 360, new e(t);
    }, e.prototype.monochromatic = function(t) {
      t === void 0 && (t = 6);
      for (var n = this.toHsv(), r = n.h, i = n.s, o = n.v, s = [], a = 1 / t; t--; )
        s.push(new e({ h: r, s: i, v: o })), o = (o + a) % 1;
      return s;
    }, e.prototype.splitcomplement = function() {
      var t = this.toHsl(), n = t.h;
      return [
        this,
        new e({ h: (n + 72) % 360, s: t.s, l: t.l }),
        new e({ h: (n + 216) % 360, s: t.s, l: t.l })
      ];
    }, e.prototype.onBackground = function(t) {
      var n = this.toRgb(), r = new e(t).toRgb(), i = n.a + r.a * (1 - n.a);
      return new e({
        r: (n.r * n.a + r.r * r.a * (1 - n.a)) / i,
        g: (n.g * n.a + r.g * r.a * (1 - n.a)) / i,
        b: (n.b * n.a + r.b * r.a * (1 - n.a)) / i,
        a: i
      });
    }, e.prototype.triad = function() {
      return this.polyad(3);
    }, e.prototype.tetrad = function() {
      return this.polyad(4);
    }, e.prototype.polyad = function(t) {
      for (var n = this.toHsl(), r = n.h, i = [this], o = 360 / t, s = 1; s < t; s++)
        i.push(new e({ h: (r + s * o) % 360, s: n.s, l: n.l }));
      return i;
    }, e.prototype.equals = function(t) {
      return this.toRgbString() === new e(t).toRgbString();
    }, e;
  }()
), Vf = 2, RS = 0.16, v3 = 0.05, b3 = 0.05, y3 = 0.15, FD = 5, BD = 4, w3 = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function MS(e) {
  var t = e.r, n = e.g, r = e.b, i = Q0(t, n, r);
  return {
    h: i.h * 360,
    s: i.s,
    v: i.v
  };
}
function Wf(e) {
  var t = e.r, n = e.g, r = e.b;
  return "#".concat(Z0(t, n, r, !1));
}
function C3(e, t, n) {
  var r = n / 100, i = {
    r: (t.r - e.r) * r + e.r,
    g: (t.g - e.g) * r + e.g,
    b: (t.b - e.b) * r + e.b
  };
  return i;
}
function IS(e, t, n) {
  var r;
  return Math.round(e.h) >= 60 && Math.round(e.h) <= 240 ? r = n ? Math.round(e.h) - Vf * t : Math.round(e.h) + Vf * t : r = n ? Math.round(e.h) + Vf * t : Math.round(e.h) - Vf * t, r < 0 ? r += 360 : r >= 360 && (r -= 360), r;
}
function kS(e, t, n) {
  if (e.h === 0 && e.s === 0)
    return e.s;
  var r;
  return n ? r = e.s - RS * t : t === BD ? r = e.s + RS : r = e.s + v3 * t, r > 1 && (r = 1), n && t === FD && r > 0.1 && (r = 0.1), r < 0.06 && (r = 0.06), Number(r.toFixed(2));
}
function PS(e, t, n) {
  var r;
  return n ? r = e.v + b3 * t : r = e.v - y3 * t, r > 1 && (r = 1), Number(r.toFixed(2));
}
function Es(e) {
  for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = [], r = Jl(e), i = FD; i > 0; i -= 1) {
    var o = MS(r), s = Wf(Jl({
      h: IS(o, i, !0),
      s: kS(o, i, !0),
      v: PS(o, i, !0)
    }));
    n.push(s);
  }
  n.push(Wf(r));
  for (var a = 1; a <= BD; a += 1) {
    var l = MS(r), u = Wf(Jl({
      h: IS(l, a),
      s: kS(l, a),
      v: PS(l, a)
    }));
    n.push(u);
  }
  return t.theme === "dark" ? w3.map(function(c) {
    var d = c.index, f = c.opacity, h = Wf(C3(Jl(t.backgroundColor || "#141414"), Jl(n[d]), f * 100));
    return h;
  }) : n;
}
var Vm = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1677FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
}, Qu = {}, Wm = {};
Object.keys(Vm).forEach(function(e) {
  Qu[e] = Es(Vm[e]), Qu[e].primary = Qu[e][5], Wm[e] = Es(Vm[e], {
    theme: "dark",
    backgroundColor: "#141414"
  }), Wm[e].primary = Wm[e][5];
});
var S3 = Qu.gold, x3 = Qu.blue;
const Dw = {
  blue: "#1677ff",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  pink: "#eb2f96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
}, Tc = Object.assign(Object.assign({}, Dw), {
  // Color
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorLink: "",
  colorTextBase: "",
  colorBgBase: "",
  // Font
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontFamilyCode: "'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace",
  fontSize: 14,
  // Line
  lineWidth: 1,
  lineType: "solid",
  // Motion
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  // Radius
  borderRadius: 6,
  // Size
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  // Control Base
  controlHeight: 32,
  // zIndex
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  // Image
  opacityImage: 1,
  // Wireframe
  wireframe: !1,
  // Motion
  motion: !0
});
function jD(e, t) {
  let {
    generateColorPalettes: n,
    generateNeutralColorPalettes: r
  } = t;
  const {
    colorSuccess: i,
    colorWarning: o,
    colorError: s,
    colorInfo: a,
    colorPrimary: l,
    colorBgBase: u,
    colorTextBase: c
  } = e, d = n(l), f = n(i), h = n(o), p = n(s), g = n(a), m = r(u, c), v = e.colorLink || e.colorInfo, b = n(v);
  return Object.assign(Object.assign({}, m), {
    colorPrimaryBg: d[1],
    colorPrimaryBgHover: d[2],
    colorPrimaryBorder: d[3],
    colorPrimaryBorderHover: d[4],
    colorPrimaryHover: d[5],
    colorPrimary: d[6],
    colorPrimaryActive: d[7],
    colorPrimaryTextHover: d[8],
    colorPrimaryText: d[9],
    colorPrimaryTextActive: d[10],
    colorSuccessBg: f[1],
    colorSuccessBgHover: f[2],
    colorSuccessBorder: f[3],
    colorSuccessBorderHover: f[4],
    colorSuccessHover: f[4],
    colorSuccess: f[6],
    colorSuccessActive: f[7],
    colorSuccessTextHover: f[8],
    colorSuccessText: f[9],
    colorSuccessTextActive: f[10],
    colorErrorBg: p[1],
    colorErrorBgHover: p[2],
    colorErrorBorder: p[3],
    colorErrorBorderHover: p[4],
    colorErrorHover: p[5],
    colorError: p[6],
    colorErrorActive: p[7],
    colorErrorTextHover: p[8],
    colorErrorText: p[9],
    colorErrorTextActive: p[10],
    colorWarningBg: h[1],
    colorWarningBgHover: h[2],
    colorWarningBorder: h[3],
    colorWarningBorderHover: h[4],
    colorWarningHover: h[4],
    colorWarning: h[6],
    colorWarningActive: h[7],
    colorWarningTextHover: h[8],
    colorWarningText: h[9],
    colorWarningTextActive: h[10],
    colorInfoBg: g[1],
    colorInfoBgHover: g[2],
    colorInfoBorder: g[3],
    colorInfoBorderHover: g[4],
    colorInfoHover: g[4],
    colorInfo: g[6],
    colorInfoActive: g[7],
    colorInfoTextHover: g[8],
    colorInfoText: g[9],
    colorInfoTextActive: g[10],
    colorLinkHover: b[4],
    colorLink: b[6],
    colorLinkActive: b[7],
    colorBgMask: new ir("#000").setAlpha(0.45).toRgbString(),
    colorWhite: "#fff"
  });
}
const E3 = (e) => {
  let t = e, n = e, r = e, i = e;
  return e < 6 && e >= 5 ? t = e + 1 : e < 16 && e >= 6 ? t = e + 2 : e >= 16 && (t = 16), e < 7 && e >= 5 ? n = 4 : e < 8 && e >= 7 ? n = 5 : e < 14 && e >= 8 ? n = 6 : e < 16 && e >= 14 ? n = 7 : e >= 16 && (n = 8), e < 6 && e >= 2 ? r = 1 : e >= 6 && (r = 2), e > 4 && e < 8 ? i = 4 : e >= 8 && (i = 6), {
    borderRadius: e,
    borderRadiusXS: r,
    borderRadiusSM: n,
    borderRadiusLG: t,
    borderRadiusOuter: i
  };
};
function $3(e) {
  const {
    motionUnit: t,
    motionBase: n,
    borderRadius: r,
    lineWidth: i
  } = e;
  return Object.assign({
    // motion
    motionDurationFast: `${(n + t).toFixed(1)}s`,
    motionDurationMid: `${(n + t * 2).toFixed(1)}s`,
    motionDurationSlow: `${(n + t * 3).toFixed(1)}s`,
    // line
    lineWidthBold: i + 1
  }, E3(r));
}
const zD = (e) => {
  const {
    controlHeight: t
  } = e;
  return {
    controlHeightSM: t * 0.75,
    controlHeightXS: t * 0.5,
    controlHeightLG: t * 1.25
  };
};
function Zh(e) {
  return (e + 8) / e;
}
function O3(e) {
  const t = new Array(10).fill(null).map((n, r) => {
    const i = r - 1, o = e * Math.pow(2.71828, i / 5), s = r > 1 ? Math.floor(o) : Math.ceil(o);
    return Math.floor(s / 2) * 2;
  });
  return t[1] = e, t.map((n) => ({
    size: n,
    lineHeight: Zh(n)
  }));
}
const HD = (e) => {
  const t = O3(e), n = t.map((c) => c.size), r = t.map((c) => c.lineHeight), i = n[1], o = n[0], s = n[2], a = r[1], l = r[0], u = r[2];
  return {
    fontSizeSM: o,
    fontSize: i,
    fontSizeLG: s,
    fontSizeXL: n[3],
    fontSizeHeading1: n[6],
    fontSizeHeading2: n[5],
    fontSizeHeading3: n[4],
    fontSizeHeading4: n[3],
    fontSizeHeading5: n[2],
    lineHeight: a,
    lineHeightLG: u,
    lineHeightSM: l,
    fontHeight: Math.round(a * i),
    fontHeightLG: Math.round(u * s),
    fontHeightSM: Math.round(l * o),
    lineHeightHeading1: r[6],
    lineHeightHeading2: r[5],
    lineHeightHeading3: r[4],
    lineHeightHeading4: r[3],
    lineHeightHeading5: r[2]
  };
};
function A3(e) {
  const {
    sizeUnit: t,
    sizeStep: n
  } = e;
  return {
    sizeXXL: t * (n + 8),
    // 48
    sizeXL: t * (n + 4),
    // 32
    sizeLG: t * (n + 2),
    // 24
    sizeMD: t * (n + 1),
    // 20
    sizeMS: t * n,
    // 16
    size: t * n,
    // 16
    sizeSM: t * (n - 1),
    // 12
    sizeXS: t * (n - 2),
    // 8
    sizeXXS: t * (n - 3)
    // 4
  };
}
const ns = (e, t) => new ir(e).setAlpha(t).toRgbString(), bu = (e, t) => new ir(e).darken(t).toHexString(), D3 = (e) => {
  const t = Es(e);
  return {
    1: t[0],
    2: t[1],
    3: t[2],
    4: t[3],
    5: t[4],
    6: t[5],
    7: t[6],
    8: t[4],
    9: t[5],
    10: t[6]
    // 8: colors[7],
    // 9: colors[8],
    // 10: colors[9],
  };
}, _3 = (e, t) => {
  const n = e || "#fff", r = t || "#000";
  return {
    colorBgBase: n,
    colorTextBase: r,
    colorText: ns(r, 0.88),
    colorTextSecondary: ns(r, 0.65),
    colorTextTertiary: ns(r, 0.45),
    colorTextQuaternary: ns(r, 0.25),
    colorFill: ns(r, 0.15),
    colorFillSecondary: ns(r, 0.06),
    colorFillTertiary: ns(r, 0.04),
    colorFillQuaternary: ns(r, 0.02),
    colorBgLayout: bu(n, 4),
    colorBgContainer: bu(n, 0),
    colorBgElevated: bu(n, 0),
    colorBgSpotlight: ns(r, 0.85),
    colorBgBlur: "transparent",
    colorBorder: bu(n, 15),
    colorBorderSecondary: bu(n, 6)
  };
};
function uf(e) {
  const t = Object.keys(Dw).map((n) => {
    const r = Es(e[n]);
    return new Array(10).fill(1).reduce((i, o, s) => (i[`${n}-${s + 1}`] = r[s], i[`${n}${s + 1}`] = r[s], i), {});
  }).reduce((n, r) => (n = Object.assign(Object.assign({}, n), r), n), {});
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, e), t), jD(e, {
    generateColorPalettes: D3,
    generateNeutralColorPalettes: _3
  })), HD(e.fontSize)), A3(e)), zD(e)), $3(e));
}
const VD = gd(uf), bd = {
  token: Tc,
  override: {
    override: Tc
  },
  hashed: !0
}, WD = /* @__PURE__ */ U.createContext(bd), _w = "anticon", T3 = (e, t) => t || (e ? `ant-${e}` : "ant"), rt = /* @__PURE__ */ O.createContext({
  // We provide a default function for Context without provider
  getPrefixCls: T3,
  iconPrefixCls: _w
}), R3 = `-ant-${Date.now()}-${Math.random()}`;
function M3(e, t) {
  const n = {}, r = (s, a) => {
    let l = s.clone();
    return l = (a == null ? void 0 : a(l)) || l, l.toRgbString();
  }, i = (s, a) => {
    const l = new ir(s), u = Es(l.toRgbString());
    n[`${a}-color`] = r(l), n[`${a}-color-disabled`] = u[1], n[`${a}-color-hover`] = u[4], n[`${a}-color-active`] = u[6], n[`${a}-color-outline`] = l.clone().setAlpha(0.2).toRgbString(), n[`${a}-color-deprecated-bg`] = u[0], n[`${a}-color-deprecated-border`] = u[2];
  };
  if (t.primaryColor) {
    i(t.primaryColor, "primary");
    const s = new ir(t.primaryColor), a = Es(s.toRgbString());
    a.forEach((u, c) => {
      n[`primary-${c + 1}`] = u;
    }), n["primary-color-deprecated-l-35"] = r(s, (u) => u.lighten(35)), n["primary-color-deprecated-l-20"] = r(s, (u) => u.lighten(20)), n["primary-color-deprecated-t-20"] = r(s, (u) => u.tint(20)), n["primary-color-deprecated-t-50"] = r(s, (u) => u.tint(50)), n["primary-color-deprecated-f-12"] = r(s, (u) => u.setAlpha(u.getAlpha() * 0.12));
    const l = new ir(a[0]);
    n["primary-color-active-deprecated-f-30"] = r(l, (u) => u.setAlpha(u.getAlpha() * 0.3)), n["primary-color-active-deprecated-d-02"] = r(l, (u) => u.darken(2));
  }
  return t.successColor && i(t.successColor, "success"), t.warningColor && i(t.warningColor, "warning"), t.errorColor && i(t.errorColor, "error"), t.infoColor && i(t.infoColor, "info"), `
  :root {
    ${Object.keys(n).map((s) => `--${e}-${s}: ${n[s]};`).join(`
`)}
  }
  `.trim();
}
function I3(e, t) {
  const n = M3(e, t);
  Ir() ? vs(n, `${R3}-dynamic-theme`) : process.env.NODE_ENV !== "production" && gl(!1, "ConfigProvider", "SSR do not support dynamic theme with css variables.");
}
const Ko = /* @__PURE__ */ O.createContext(!1), Tw = (e) => {
  let {
    children: t,
    disabled: n
  } = e;
  const r = O.useContext(Ko);
  return /* @__PURE__ */ O.createElement(Ko.Provider, {
    value: n ?? r
  }, t);
}, Qa = /* @__PURE__ */ O.createContext(void 0), k3 = (e) => {
  let {
    children: t,
    size: n
  } = e;
  const r = O.useContext(Qa);
  return /* @__PURE__ */ O.createElement(Qa.Provider, {
    value: n || r
  }, t);
};
function P3() {
  const e = Yt(Ko), t = Yt(Qa);
  return {
    componentDisabled: e,
    componentSize: t
  };
}
const yd = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"], N3 = "5.16.2";
function Um(e) {
  return e >= 0 && e <= 255;
}
function Uf(e, t) {
  const {
    r: n,
    g: r,
    b: i,
    a: o
  } = new ir(e).toRgb();
  if (o < 1)
    return e;
  const {
    r: s,
    g: a,
    b: l
  } = new ir(t).toRgb();
  for (let u = 0.01; u <= 1; u += 0.01) {
    const c = Math.round((n - s * (1 - u)) / u), d = Math.round((r - a * (1 - u)) / u), f = Math.round((i - l * (1 - u)) / u);
    if (Um(c) && Um(d) && Um(f))
      return new ir({
        r: c,
        g: d,
        b: f,
        a: Math.round(u * 100) / 100
      }).toRgbString();
  }
  return new ir({
    r: n,
    g: r,
    b: i,
    a: 1
  }).toRgbString();
}
var L3 = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
function Rw(e) {
  const {
    override: t
  } = e, n = L3(e, ["override"]), r = Object.assign({}, t);
  Object.keys(Tc).forEach((f) => {
    delete r[f];
  });
  const i = Object.assign(Object.assign({}, n), r), o = 480, s = 576, a = 768, l = 992, u = 1200, c = 1600;
  if (i.motion === !1) {
    const f = "0s";
    i.motionDurationFast = f, i.motionDurationMid = f, i.motionDurationSlow = f;
  }
  return Object.assign(Object.assign(Object.assign({}, i), {
    // ============== Background ============== //
    colorFillContent: i.colorFillSecondary,
    colorFillContentHover: i.colorFill,
    colorFillAlter: i.colorFillQuaternary,
    colorBgContainerDisabled: i.colorFillTertiary,
    // ============== Split ============== //
    colorBorderBg: i.colorBgContainer,
    colorSplit: Uf(i.colorBorderSecondary, i.colorBgContainer),
    // ============== Text ============== //
    colorTextPlaceholder: i.colorTextQuaternary,
    colorTextDisabled: i.colorTextQuaternary,
    colorTextHeading: i.colorText,
    colorTextLabel: i.colorTextSecondary,
    colorTextDescription: i.colorTextTertiary,
    colorTextLightSolid: i.colorWhite,
    colorHighlight: i.colorError,
    colorBgTextHover: i.colorFillSecondary,
    colorBgTextActive: i.colorFill,
    colorIcon: i.colorTextTertiary,
    colorIconHover: i.colorText,
    colorErrorOutline: Uf(i.colorErrorBg, i.colorBgContainer),
    colorWarningOutline: Uf(i.colorWarningBg, i.colorBgContainer),
    // Font
    fontSizeIcon: i.fontSizeSM,
    // Line
    lineWidthFocus: i.lineWidth * 4,
    // Control
    lineWidth: i.lineWidth,
    controlOutlineWidth: i.lineWidth * 2,
    // Checkbox size and expand icon size
    controlInteractiveSize: i.controlHeight / 2,
    controlItemBgHover: i.colorFillTertiary,
    controlItemBgActive: i.colorPrimaryBg,
    controlItemBgActiveHover: i.colorPrimaryBgHover,
    controlItemBgActiveDisabled: i.colorFill,
    controlTmpOutline: i.colorFillQuaternary,
    controlOutline: Uf(i.colorPrimaryBg, i.colorBgContainer),
    lineType: i.lineType,
    borderRadius: i.borderRadius,
    borderRadiusXS: i.borderRadiusXS,
    borderRadiusSM: i.borderRadiusSM,
    borderRadiusLG: i.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: i.sizeXXS,
    paddingXS: i.sizeXS,
    paddingSM: i.sizeSM,
    padding: i.size,
    paddingMD: i.sizeMD,
    paddingLG: i.sizeLG,
    paddingXL: i.sizeXL,
    paddingContentHorizontalLG: i.sizeLG,
    paddingContentVerticalLG: i.sizeMS,
    paddingContentHorizontal: i.sizeMS,
    paddingContentVertical: i.sizeSM,
    paddingContentHorizontalSM: i.size,
    paddingContentVerticalSM: i.sizeXS,
    marginXXS: i.sizeXXS,
    marginXS: i.sizeXS,
    marginSM: i.sizeSM,
    margin: i.size,
    marginMD: i.sizeMD,
    marginLG: i.sizeLG,
    marginXL: i.sizeXL,
    marginXXL: i.sizeXXL,
    boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS: o,
    screenXSMin: o,
    screenXSMax: s - 1,
    screenSM: s,
    screenSMMin: s,
    screenSMMax: a - 1,
    screenMD: a,
    screenMDMin: a,
    screenMDMax: l - 1,
    screenLG: l,
    screenLGMin: l,
    screenLGMax: u - 1,
    screenXL: u,
    screenXLMin: u,
    screenXLMax: c - 1,
    screenXXL: c,
    screenXXLMin: c,
    boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
    boxShadowCard: `
      0 1px 2px -2px ${new ir("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new ir("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new ir("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
  }), r);
}
var NS = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const UD = {
  lineHeight: !0,
  lineHeightSM: !0,
  lineHeightLG: !0,
  lineHeightHeading1: !0,
  lineHeightHeading2: !0,
  lineHeightHeading3: !0,
  lineHeightHeading4: !0,
  lineHeightHeading5: !0,
  opacityLoading: !0,
  fontWeightStrong: !0,
  zIndexPopupBase: !0,
  zIndexBase: !0
}, GD = {
  size: !0,
  sizeSM: !0,
  sizeLG: !0,
  sizeMD: !0,
  sizeXS: !0,
  sizeXXS: !0,
  sizeMS: !0,
  sizeXL: !0,
  sizeXXL: !0,
  sizeUnit: !0,
  sizeStep: !0,
  motionBase: !0,
  motionUnit: !0
}, F3 = {
  screenXS: !0,
  screenXSMin: !0,
  screenXSMax: !0,
  screenSM: !0,
  screenSMMin: !0,
  screenSMMax: !0,
  screenMD: !0,
  screenMDMin: !0,
  screenMDMax: !0,
  screenLG: !0,
  screenLGMin: !0,
  screenLGMax: !0,
  screenXL: !0,
  screenXLMin: !0,
  screenXLMax: !0,
  screenXXL: !0,
  screenXXLMin: !0
}, KD = (e, t, n) => {
  const r = n.getDerivativeToken(e), {
    override: i
  } = t, o = NS(t, ["override"]);
  let s = Object.assign(Object.assign({}, r), {
    override: i
  });
  return s = Rw(s), o && Object.entries(o).forEach((a) => {
    let [l, u] = a;
    const {
      theme: c
    } = u, d = NS(u, ["theme"]);
    let f = d;
    c && (f = KD(Object.assign(Object.assign({}, s), d), {
      override: d
    }, c)), s[l] = f;
  }), s;
};
function Sr() {
  const {
    token: e,
    hashed: t,
    theme: n,
    override: r,
    cssVar: i
  } = U.useContext(WD), o = `${N3}-${t || ""}`, s = n || VD, [a, l, u] = x5(s, [Tc, e], {
    salt: o,
    override: r,
    getComputedToken: KD,
    // formatToken will not be consumed after 1.15.0 with getComputedToken.
    // But token will break if @ant-design/cssinjs is under 1.15.0 without it
    formatToken: Rw,
    cssVar: i && {
      prefix: i.prefix,
      key: i.key,
      unitless: UD,
      ignore: GD,
      preserve: F3
    }
  });
  return [s, u, t ? l : "", a, i];
}
function XD(e, t, n) {
  return t = Ac(t), ZA(e, bw() ? Reflect.construct(t, [], Ac(e).constructor) : t.apply(e, n));
}
let YD = /* @__PURE__ */ ui(function e() {
  ci(this, e);
});
const qD = "CALC_UNIT";
function Gm(e) {
  return typeof e == "number" ? `${e}${qD}` : e;
}
let B3 = /* @__PURE__ */ function(e) {
  function t(n) {
    var r;
    return ci(this, t), r = XD(this, t), r.result = "", n instanceof t ? r.result = `(${n.result})` : typeof n == "number" ? r.result = Gm(n) : typeof n == "string" && (r.result = n), r;
  }
  return pl(t, e), ui(t, [{
    key: "add",
    value: function(r) {
      return r instanceof t ? this.result = `${this.result} + ${r.getResult()}` : (typeof r == "number" || typeof r == "string") && (this.result = `${this.result} + ${Gm(r)}`), this.lowPriority = !0, this;
    }
  }, {
    key: "sub",
    value: function(r) {
      return r instanceof t ? this.result = `${this.result} - ${r.getResult()}` : (typeof r == "number" || typeof r == "string") && (this.result = `${this.result} - ${Gm(r)}`), this.lowPriority = !0, this;
    }
  }, {
    key: "mul",
    value: function(r) {
      return this.lowPriority && (this.result = `(${this.result})`), r instanceof t ? this.result = `${this.result} * ${r.getResult(!0)}` : (typeof r == "number" || typeof r == "string") && (this.result = `${this.result} * ${r}`), this.lowPriority = !1, this;
    }
  }, {
    key: "div",
    value: function(r) {
      return this.lowPriority && (this.result = `(${this.result})`), r instanceof t ? this.result = `${this.result} / ${r.getResult(!0)}` : (typeof r == "number" || typeof r == "string") && (this.result = `${this.result} / ${r}`), this.lowPriority = !1, this;
    }
  }, {
    key: "getResult",
    value: function(r) {
      return this.lowPriority || r ? `(${this.result})` : this.result;
    }
  }, {
    key: "equal",
    value: function(r) {
      const {
        unit: i = !0
      } = r || {}, o = new RegExp(`${qD}`, "g");
      return this.result = this.result.replace(o, i ? "px" : ""), typeof this.lowPriority < "u" ? `calc(${this.result})` : this.result;
    }
  }]);
}(YD), j3 = /* @__PURE__ */ function(e) {
  function t(n) {
    var r;
    return ci(this, t), r = XD(this, t), r.result = 0, n instanceof t ? r.result = n.result : typeof n == "number" && (r.result = n), r;
  }
  return pl(t, e), ui(t, [{
    key: "add",
    value: function(r) {
      return r instanceof t ? this.result += r.result : typeof r == "number" && (this.result += r), this;
    }
  }, {
    key: "sub",
    value: function(r) {
      return r instanceof t ? this.result -= r.result : typeof r == "number" && (this.result -= r), this;
    }
  }, {
    key: "mul",
    value: function(r) {
      return r instanceof t ? this.result *= r.result : typeof r == "number" && (this.result *= r), this;
    }
  }, {
    key: "div",
    value: function(r) {
      return r instanceof t ? this.result /= r.result : typeof r == "number" && (this.result /= r), this;
    }
  }, {
    key: "equal",
    value: function() {
      return this.result;
    }
  }]);
}(YD);
const z3 = (e) => {
  const t = e === "css" ? B3 : j3;
  return (n) => new t(n);
};
function Nn(e) {
  var t = O.useRef();
  t.current = e;
  var n = O.useCallback(function() {
    for (var r, i = arguments.length, o = new Array(i), s = 0; s < i; s++)
      o[s] = arguments[s];
    return (r = t.current) === null || r === void 0 ? void 0 : r.call.apply(r, [t].concat(o));
  }, []);
  return n;
}
function ta(e) {
  var t = O.useRef(!1), n = O.useState(e), r = ae(n, 2), i = r[0], o = r[1];
  O.useEffect(function() {
    return t.current = !1, function() {
      t.current = !0;
    };
  }, []);
  function s(a, l) {
    l && t.current || o(a);
  }
  return [i, s];
}
function Km(e) {
  return e !== void 0;
}
function Un(e, t) {
  var n = t || {}, r = n.defaultValue, i = n.value, o = n.onChange, s = n.postState, a = ta(function() {
    return Km(i) ? i : Km(r) ? typeof r == "function" ? r() : r : typeof e == "function" ? e() : e;
  }), l = ae(a, 2), u = l[0], c = l[1], d = i !== void 0 ? i : u, f = s ? s(d) : d, h = Nn(o), p = ta([d]), g = ae(p, 2), m = g[0], v = g[1];
  U0(function() {
    var x = m[0];
    u !== x && h(u, x);
  }, [m]), U0(function() {
    Km(i) || c(i);
  }, [i]);
  var b = Nn(function(x, w) {
    c(x, w), v([d], w);
  });
  return [f, b];
}
const QD = (e) => ({
  // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
  // And Typography use this to generate link style which should not do this.
  color: e.colorLink,
  textDecoration: "none",
  outline: "none",
  cursor: "pointer",
  transition: `color ${e.motionDurationSlow}`,
  "&:focus, &:hover": {
    color: e.colorLinkHover
  },
  "&:active": {
    color: e.colorLinkActive
  }
}), la = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
}, Gn = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  return {
    boxSizing: "border-box",
    margin: 0,
    padding: 0,
    color: e.colorText,
    fontSize: e.fontSize,
    // font-variant: @font-variant-base;
    lineHeight: e.lineHeight,
    listStyle: "none",
    // font-feature-settings: @font-feature-settings-base;
    fontFamily: t ? "inherit" : e.fontFamily
  };
}, Rg = () => ({
  display: "inline-flex",
  alignItems: "center",
  color: "inherit",
  fontStyle: "normal",
  lineHeight: 0,
  textAlign: "center",
  textTransform: "none",
  // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
  verticalAlign: "-0.125em",
  textRendering: "optimizeLegibility",
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  "> *": {
    lineHeight: 1
  },
  svg: {
    display: "inline-block"
  }
}), ca = () => ({
  // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
  "&::before": {
    display: "table",
    content: '""'
  },
  "&::after": {
    // https://github.com/ant-design/ant-design/issues/21864
    display: "table",
    clear: "both",
    content: '""'
  }
}), H3 = (e) => ({
  a: {
    color: e.colorLink,
    textDecoration: e.linkDecoration,
    backgroundColor: "transparent",
    // remove the gray background on active links in IE 10.
    outline: "none",
    cursor: "pointer",
    transition: `color ${e.motionDurationSlow}`,
    "-webkit-text-decoration-skip": "objects",
    // remove gaps in links underline in iOS 8+ and Safari 8+.
    "&:hover": {
      color: e.colorLinkHover
    },
    "&:active": {
      color: e.colorLinkActive
    },
    "&:active,\n  &:hover": {
      textDecoration: e.linkHoverDecoration,
      outline: 0
    },
    // https://github.com/ant-design/ant-design/issues/22503
    "&:focus": {
      textDecoration: e.linkFocusDecoration,
      outline: 0
    },
    "&[disabled]": {
      color: e.colorTextDisabled,
      cursor: "not-allowed"
    }
  }
}), V3 = (e, t, n) => {
  const {
    fontFamily: r,
    fontSize: i
  } = e, o = `[class^="${t}"], [class*=" ${t}"]`;
  return {
    [n ? `.${n}` : o]: {
      fontFamily: r,
      fontSize: i,
      boxSizing: "border-box",
      "&::before, &::after": {
        boxSizing: "border-box"
      },
      [o]: {
        boxSizing: "border-box",
        "&::before, &::after": {
          boxSizing: "border-box"
        }
      }
    }
  };
}, Mw = (e) => ({
  outline: `${le(e.lineWidthFocus)} solid ${e.colorPrimaryBorder}`,
  outlineOffset: 1,
  transition: "outline-offset 0s, outline 0s"
}), Za = (e) => ({
  "&:focus-visible": Object.assign({}, Mw(e))
});
function W3(e) {
  return e === "js" ? {
    max: Math.max,
    min: Math.min
  } : {
    max: function() {
      for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
        n[r] = arguments[r];
      return `max(${n.map((i) => le(i)).join(",")})`;
    },
    min: function() {
      for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
        n[r] = arguments[r];
      return `min(${n.map((i) => le(i)).join(",")})`;
    }
  };
}
const ZD = process.env.NODE_ENV !== "production" || typeof CSSINJS_STATISTIC < "u";
let eb = !0;
function Jt() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  if (!ZD)
    return Object.assign.apply(Object, [{}].concat(t));
  eb = !1;
  const r = {};
  return t.forEach((i) => {
    Object.keys(i).forEach((s) => {
      Object.defineProperty(r, s, {
        configurable: !0,
        enumerable: !0,
        get: () => i[s]
      });
    });
  }), eb = !0, r;
}
const LS = {};
function U3() {
}
const G3 = (e) => {
  let t, n = e, r = U3;
  return ZD && typeof Proxy < "u" && (t = /* @__PURE__ */ new Set(), n = new Proxy(e, {
    get(i, o) {
      return eb && t.add(o), i[o];
    }
  }), r = (i, o) => {
    var s;
    LS[i] = {
      global: Array.from(t),
      component: Object.assign(Object.assign({}, (s = LS[i]) === null || s === void 0 ? void 0 : s.component), o)
    };
  }), {
    token: n,
    keys: t,
    flush: r
  };
}, JD = (e, t) => {
  const [n, r] = Sr();
  return q0({
    theme: n,
    token: r,
    hashId: "",
    path: ["ant-design-icons", e],
    nonce: () => t == null ? void 0 : t.nonce
  }, () => [{
    [`.${e}`]: Object.assign(Object.assign({}, Rg()), {
      [`.${e} .${e}-icon`]: {
        display: "block"
      }
    })
  }]);
}, e_ = (e, t, n) => {
  var r;
  return typeof n == "function" ? n(Jt(t, (r = t[e]) !== null && r !== void 0 ? r : {})) : n ?? {};
}, t_ = (e, t, n, r) => {
  const i = Object.assign({}, t[e]);
  if (r != null && r.deprecatedTokens) {
    const {
      deprecatedTokens: s
    } = r;
    s.forEach((a) => {
      let [l, u] = a;
      var c;
      process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && $t(!(i != null && i[l]), `Component Token \`${String(l)}\` of ${e} is deprecated. Please use \`${String(u)}\` instead.`), (i != null && i[l] || i != null && i[u]) && ((c = i[u]) !== null && c !== void 0 || (i[u] = i == null ? void 0 : i[l]));
    });
  }
  const o = Object.assign(Object.assign({}, n), i);
  return Object.keys(o).forEach((s) => {
    o[s] === t[s] && delete o[s];
  }), o;
}, K3 = (e, t) => `${[t, e.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-")}`;
function Mg(e, t, n) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const i = Array.isArray(e) ? e : [e, e], [o] = i, s = i.join("-");
  return function(a) {
    let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : a;
    const [u, c, d, f, h] = Sr(), {
      getPrefixCls: p,
      iconPrefixCls: g,
      csp: m
    } = Yt(rt), v = p(), b = h ? "css" : "js", x = z3(b), {
      max: w,
      min: C
    } = W3(b), y = {
      theme: u,
      token: f,
      hashId: d,
      nonce: () => m == null ? void 0 : m.nonce,
      clientOnly: r.clientOnly,
      // antd is always at top of styles
      order: r.order || -999
    };
    return q0(Object.assign(Object.assign({}, y), {
      clientOnly: !1,
      path: ["Shared", v]
    }), () => [{
      // Link
      "&": H3(f)
    }]), JD(g, m), [q0(Object.assign(Object.assign({}, y), {
      path: [s, a, g]
    }), () => {
      if (r.injectStyle === !1)
        return [];
      const {
        token: A,
        flush: $
      } = G3(f), M = e_(o, c, n), _ = `.${a}`, T = t_(o, c, M, {
        deprecatedTokens: r.deprecatedTokens
      });
      h && Object.keys(M).forEach((R) => {
        M[R] = `var(${uD(R, K3(o, h.prefix))})`;
      });
      const D = Jt(A, {
        componentCls: _,
        prefixCls: a,
        iconCls: `.${g}`,
        antCls: `.${v}`,
        calc: x,
        // @ts-ignore
        max: w,
        // @ts-ignore
        min: C
      }, h ? M : T), E = t(D, {
        hashId: d,
        prefixCls: a,
        rootPrefixCls: v,
        iconPrefixCls: g
      });
      return $(o, T), [r.resetStyle === !1 ? null : V3(D, a, l), E];
    }), d];
  };
}
const Ig = (e, t, n, r) => {
  const i = Mg(e, t, n, Object.assign({
    resetStyle: !1,
    // Sub Style should default after root one
    order: -998
  }, r)), o = (s) => {
    let {
      prefixCls: a,
      rootCls: l = a
    } = s;
    return i(a, l), null;
  };
  return process.env.NODE_ENV !== "production" && (o.displayName = `SubStyle_${Array.isArray(e) ? e.join(".") : e}`), o;
}, X3 = (e, t, n) => {
  function r(u) {
    return `${e}${u.slice(0, 1).toUpperCase()}${u.slice(1)}`;
  }
  const {
    unitless: i = {},
    injectStyle: o = !0
  } = n ?? {}, s = {
    [r("zIndexPopup")]: !0
  };
  Object.keys(i).forEach((u) => {
    s[r(u)] = i[u];
  });
  const a = (u) => {
    let {
      rootCls: c,
      cssVar: d
    } = u;
    const [, f] = Sr();
    return Z5({
      path: [e],
      prefix: d.prefix,
      key: d == null ? void 0 : d.key,
      unitless: Object.assign(Object.assign({}, UD), s),
      ignore: GD,
      token: f,
      scope: c
    }, () => {
      const h = e_(e, f, t), p = t_(e, f, h, {
        deprecatedTokens: n == null ? void 0 : n.deprecatedTokens
      });
      return Object.keys(h).forEach((g) => {
        p[r(g)] = p[g], delete p[g];
      }), p;
    }), null;
  };
  return (u) => {
    const [, , , , c] = Sr();
    return [(d) => o && c ? /* @__PURE__ */ U.createElement(U.Fragment, null, /* @__PURE__ */ U.createElement(a, {
      rootCls: u,
      cssVar: c,
      component: e
    }), d) : d, c == null ? void 0 : c.key];
  };
}, $n = (e, t, n, r) => {
  const i = Mg(e, t, n, r), o = X3(Array.isArray(e) ? e[0] : e, n, r);
  return function(s) {
    let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
    const [, l] = i(s, a), [u, c] = o(a);
    return [u, l, c];
  };
};
function Y3(e, t) {
  return yd.reduce((n, r) => {
    const i = e[`${r}1`], o = e[`${r}3`], s = e[`${r}6`], a = e[`${r}7`];
    return Object.assign(Object.assign({}, n), t(r, {
      lightColor: i,
      lightBorderColor: o,
      darkColor: s,
      textColor: a
    }));
  }, {});
}
const q3 = Object.assign({}, O), {
  useId: FS
} = q3, Q3 = () => "", Z3 = typeof FS > "u" ? Q3 : FS;
function J3(e, t, n) {
  var r, i;
  const o = Zt("ConfigProvider"), s = e || {}, a = s.inherit === !1 || !t ? Object.assign(Object.assign({}, bd), {
    hashed: (r = t == null ? void 0 : t.hashed) !== null && r !== void 0 ? r : bd.hashed,
    cssVar: t == null ? void 0 : t.cssVar
  }) : t, l = Z3();
  if (process.env.NODE_ENV !== "production") {
    const u = s.cssVar || a.cssVar, c = !!(typeof s.cssVar == "object" && (!((i = s.cssVar) === null || i === void 0) && i.key) || l);
    process.env.NODE_ENV !== "production" && o(!u || c, "breaking", "Missing key in `cssVar` config. Please upgrade to React 18 or set `cssVar.key` manually in each ConfigProvider inside `cssVar` enabled ConfigProvider.");
  }
  return lf(() => {
    var u, c;
    if (!e)
      return t;
    const d = Object.assign({}, a.components);
    Object.keys(e.components || {}).forEach((p) => {
      d[p] = Object.assign(Object.assign({}, d[p]), e.components[p]);
    });
    const f = `css-var-${l.replace(/:/g, "")}`, h = ((u = s.cssVar) !== null && u !== void 0 ? u : a.cssVar) && Object.assign(Object.assign(Object.assign({
      prefix: n == null ? void 0 : n.prefixCls
    }, typeof a.cssVar == "object" ? a.cssVar : {}), typeof s.cssVar == "object" ? s.cssVar : {}), {
      key: typeof s.cssVar == "object" && ((c = s.cssVar) === null || c === void 0 ? void 0 : c.key) || f
    });
    return Object.assign(Object.assign(Object.assign({}, a), s), {
      token: Object.assign(Object.assign({}, a.token), s.token),
      components: d,
      cssVar: h
    });
  }, [s, a], (u, c) => u.some((d, f) => {
    const h = c[f];
    return !pd(d, h, !0);
  }));
}
var e4 = ["children"], n_ = /* @__PURE__ */ O.createContext({});
function t4(e) {
  var t = e.children, n = Rt(e, e4);
  return /* @__PURE__ */ O.createElement(n_.Provider, {
    value: n
  }, t);
}
var n4 = /* @__PURE__ */ function(e) {
  pl(n, e);
  var t = cf(n);
  function n() {
    return ci(this, n), t.apply(this, arguments);
  }
  return ui(n, [{
    key: "render",
    value: function() {
      return this.props.children;
    }
  }]), n;
}(O.Component), Oa = "none", Gf = "appear", Kf = "enter", Xf = "leave", BS = "none", uo = "prepare", ic = "start", oc = "active", Iw = "end", r_ = "prepared";
function jS(e, t) {
  var n = {};
  return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit".concat(e)] = "webkit".concat(t), n["Moz".concat(e)] = "moz".concat(t), n["ms".concat(e)] = "MS".concat(t), n["O".concat(e)] = "o".concat(t.toLowerCase()), n;
}
function r4(e, t) {
  var n = {
    animationend: jS("Animation", "AnimationEnd"),
    transitionend: jS("Transition", "TransitionEnd")
  };
  return e && ("AnimationEvent" in t || delete n.animationend.animation, "TransitionEvent" in t || delete n.transitionend.transition), n;
}
var i4 = r4(Ir(), typeof window < "u" ? window : {}), i_ = {};
if (Ir()) {
  var o4 = document.createElement("div");
  i_ = o4.style;
}
var Yf = {};
function o_(e) {
  if (Yf[e])
    return Yf[e];
  var t = i4[e];
  if (t)
    for (var n = Object.keys(t), r = n.length, i = 0; i < r; i += 1) {
      var o = n[i];
      if (Object.prototype.hasOwnProperty.call(t, o) && o in i_)
        return Yf[e] = t[o], Yf[e];
    }
  return "";
}
var s_ = o_("animationend"), a_ = o_("transitionend"), l_ = !!(s_ && a_), zS = s_ || "animationend", HS = a_ || "transitionend";
function VS(e, t) {
  if (!e)
    return null;
  if (wt(e) === "object") {
    var n = t.replace(/-\w/g, function(r) {
      return r[1].toUpperCase();
    });
    return e[n];
  }
  return "".concat(e, "-").concat(t);
}
const s4 = function(e) {
  var t = he(), n = he(e);
  n.current = e;
  var r = O.useCallback(function(s) {
    n.current(s);
  }, []);
  function i(s) {
    s && (s.removeEventListener(HS, r), s.removeEventListener(zS, r));
  }
  function o(s) {
    t.current && t.current !== s && i(t.current), s && s !== t.current && (s.addEventListener(HS, r), s.addEventListener(zS, r), t.current = s);
  }
  return O.useEffect(function() {
    return function() {
      i(t.current);
    };
  }, []), [o, i];
};
var c_ = Ir() ? Eg : Pe;
const a4 = function() {
  var e = O.useRef(null);
  function t() {
    rn.cancel(e.current);
  }
  function n(r) {
    var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    t();
    var o = rn(function() {
      i <= 1 ? r({
        isCanceled: function() {
          return o !== e.current;
        }
      }) : n(r, i - 1);
    });
    e.current = o;
  }
  return O.useEffect(function() {
    return function() {
      t();
    };
  }, []), [n, t];
};
var l4 = [uo, ic, oc, Iw], c4 = [uo, r_], u_ = !1, u4 = !0;
function d_(e) {
  return e === oc || e === Iw;
}
const d4 = function(e, t, n) {
  var r = ta(BS), i = ae(r, 2), o = i[0], s = i[1], a = a4(), l = ae(a, 2), u = l[0], c = l[1];
  function d() {
    s(uo, !0);
  }
  var f = t ? c4 : l4;
  return c_(function() {
    if (o !== BS && o !== Iw) {
      var h = f.indexOf(o), p = f[h + 1], g = n(o);
      g === u_ ? s(p, !0) : p && u(function(m) {
        function v() {
          m.isCanceled() || s(p, !0);
        }
        g === !0 ? v() : Promise.resolve(g).then(v);
      });
    }
  }, [e, o]), O.useEffect(function() {
    return function() {
      c();
    };
  }, []), [d, o];
};
function f4(e, t, n, r) {
  var i = r.motionEnter, o = i === void 0 ? !0 : i, s = r.motionAppear, a = s === void 0 ? !0 : s, l = r.motionLeave, u = l === void 0 ? !0 : l, c = r.motionDeadline, d = r.motionLeaveImmediately, f = r.onAppearPrepare, h = r.onEnterPrepare, p = r.onLeavePrepare, g = r.onAppearStart, m = r.onEnterStart, v = r.onLeaveStart, b = r.onAppearActive, x = r.onEnterActive, w = r.onLeaveActive, C = r.onAppearEnd, y = r.onEnterEnd, S = r.onLeaveEnd, A = r.onVisibleChanged, $ = ta(), M = ae($, 2), _ = M[0], T = M[1], D = ta(Oa), E = ae(D, 2), R = E[0], I = E[1], k = ta(null), P = ae(k, 2), L = P[0], N = P[1], F = he(!1), B = he(null);
  function j() {
    return n();
  }
  var z = he(!1);
  function H() {
    I(Oa, !0), N(null, !0);
  }
  function W(ce) {
    var pe = j();
    if (!(ce && !ce.deadline && ce.target !== pe)) {
      var Oe = z.current, Re;
      R === Gf && Oe ? Re = C == null ? void 0 : C(pe, ce) : R === Kf && Oe ? Re = y == null ? void 0 : y(pe, ce) : R === Xf && Oe && (Re = S == null ? void 0 : S(pe, ce)), R !== Oa && Oe && Re !== !1 && H();
    }
  }
  var G = s4(W), K = ae(G, 1), Y = K[0], X = function(pe) {
    var Oe, Re, De;
    switch (pe) {
      case Gf:
        return Oe = {}, re(Oe, uo, f), re(Oe, ic, g), re(Oe, oc, b), Oe;
      case Kf:
        return Re = {}, re(Re, uo, h), re(Re, ic, m), re(Re, oc, x), Re;
      case Xf:
        return De = {}, re(De, uo, p), re(De, ic, v), re(De, oc, w), De;
      default:
        return {};
    }
  }, Z = O.useMemo(function() {
    return X(R);
  }, [R]), Q = d4(R, !e, function(ce) {
    if (ce === uo) {
      var pe = Z[uo];
      return pe ? pe(j()) : u_;
    }
    if (te in Z) {
      var Oe;
      N(((Oe = Z[te]) === null || Oe === void 0 ? void 0 : Oe.call(Z, j(), null)) || null);
    }
    return te === oc && (Y(j()), c > 0 && (clearTimeout(B.current), B.current = setTimeout(function() {
      W({
        deadline: !0
      });
    }, c))), te === r_ && H(), u4;
  }), ne = ae(Q, 2), q = ne[0], te = ne[1], fe = d_(te);
  z.current = fe, c_(function() {
    T(t);
    var ce = F.current;
    F.current = !0;
    var pe;
    !ce && t && a && (pe = Gf), ce && t && o && (pe = Kf), (ce && !t && u || !ce && d && !t && u) && (pe = Xf);
    var Oe = X(pe);
    pe && (e || Oe[uo]) ? (I(pe), q()) : I(Oa);
  }, [t]), Pe(function() {
    // Cancel appear
    (R === Gf && !a || // Cancel enter
    R === Kf && !o || // Cancel leave
    R === Xf && !u) && I(Oa);
  }, [a, o, u]), Pe(function() {
    return function() {
      F.current = !1, clearTimeout(B.current);
    };
  }, []);
  var Se = O.useRef(!1);
  Pe(function() {
    _ && (Se.current = !0), _ !== void 0 && R === Oa && ((Se.current || _) && (A == null || A(_)), Se.current = !0);
  }, [_, R]);
  var de = L;
  return Z[uo] && te === ic && (de = ie({
    transition: "none"
  }, de)), [R, te, de, _ ?? t];
}
function h4(e) {
  var t = e;
  wt(e) === "object" && (t = e.transitionSupport);
  function n(i, o) {
    return !!(i.motionName && t && o !== !1);
  }
  var r = /* @__PURE__ */ O.forwardRef(function(i, o) {
    var s = i.visible, a = s === void 0 ? !0 : s, l = i.removeOnLeave, u = l === void 0 ? !0 : l, c = i.forceRender, d = i.children, f = i.motionName, h = i.leavedClassName, p = i.eventProps, g = O.useContext(n_), m = g.motion, v = n(i, m), b = he(), x = he();
    function w() {
      try {
        return b.current instanceof HTMLElement ? b.current : Yu(x.current);
      } catch {
        return null;
      }
    }
    var C = f4(v, a, w, i), y = ae(C, 4), S = y[0], A = y[1], $ = y[2], M = y[3], _ = O.useRef(M);
    M && (_.current = !0);
    var T = O.useCallback(function(N) {
      b.current = N, vw(o, N);
    }, [o]), D, E = ie(ie({}, p), {}, {
      visible: a
    });
    if (!d)
      D = null;
    else if (S === Oa)
      M ? D = d(ie({}, E), T) : !u && _.current && h ? D = d(ie(ie({}, E), {}, {
        className: h
      }), T) : c || !u && !h ? D = d(ie(ie({}, E), {}, {
        style: {
          display: "none"
        }
      }), T) : D = null;
    else {
      var R, I;
      A === uo ? I = "prepare" : d_(A) ? I = "active" : A === ic && (I = "start");
      var k = VS(f, "".concat(S, "-").concat(I));
      D = d(ie(ie({}, E), {}, {
        className: se(VS(f, S), (R = {}, re(R, k, k && I), re(R, f, typeof f == "string"), R)),
        style: $
      }), T);
    }
    if (/* @__PURE__ */ O.isValidElement(D) && Ms(D)) {
      var P = D, L = P.ref;
      L || (D = /* @__PURE__ */ O.cloneElement(D, {
        ref: T
      }));
    }
    return /* @__PURE__ */ O.createElement(n4, {
      ref: x
    }, D);
  });
  return r.displayName = "CSSMotion", r;
}
const qo = h4(l_);
var tb = "add", nb = "keep", rb = "remove", Xm = "removed";
function p4(e) {
  var t;
  return e && wt(e) === "object" && "key" in e ? t = e : t = {
    key: e
  }, ie(ie({}, t), {}, {
    key: String(t.key)
  });
}
function ib() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return e.map(p4);
}
function g4() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], n = [], r = 0, i = t.length, o = ib(e), s = ib(t);
  o.forEach(function(u) {
    for (var c = !1, d = r; d < i; d += 1) {
      var f = s[d];
      if (f.key === u.key) {
        r < d && (n = n.concat(s.slice(r, d).map(function(h) {
          return ie(ie({}, h), {}, {
            status: tb
          });
        })), r = d), n.push(ie(ie({}, f), {}, {
          status: nb
        })), r += 1, c = !0;
        break;
      }
    }
    c || n.push(ie(ie({}, u), {}, {
      status: rb
    }));
  }), r < i && (n = n.concat(s.slice(r).map(function(u) {
    return ie(ie({}, u), {}, {
      status: tb
    });
  })));
  var a = {};
  n.forEach(function(u) {
    var c = u.key;
    a[c] = (a[c] || 0) + 1;
  });
  var l = Object.keys(a).filter(function(u) {
    return a[u] > 1;
  });
  return l.forEach(function(u) {
    n = n.filter(function(c) {
      var d = c.key, f = c.status;
      return d !== u || f !== rb;
    }), n.forEach(function(c) {
      c.key === u && (c.status = nb);
    });
  }), n;
}
var m4 = ["component", "children", "onVisibleChanged", "onAllRemoved"], v4 = ["status"], b4 = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function y4(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : qo, n = /* @__PURE__ */ function(r) {
    pl(o, r);
    var i = cf(o);
    function o() {
      var s;
      ci(this, o);
      for (var a = arguments.length, l = new Array(a), u = 0; u < a; u++)
        l[u] = arguments[u];
      return s = i.call.apply(i, [this].concat(l)), re(tn(s), "state", {
        keyEntities: []
      }), re(tn(s), "removeKey", function(c) {
        var d = s.state.keyEntities, f = d.map(function(h) {
          return h.key !== c ? h : ie(ie({}, h), {}, {
            status: Xm
          });
        });
        return s.setState({
          keyEntities: f
        }), f.filter(function(h) {
          var p = h.status;
          return p !== Xm;
        }).length;
      }), s;
    }
    return ui(o, [{
      key: "render",
      value: function() {
        var a = this, l = this.state.keyEntities, u = this.props, c = u.component, d = u.children, f = u.onVisibleChanged, h = u.onAllRemoved, p = Rt(u, m4), g = c || O.Fragment, m = {};
        return b4.forEach(function(v) {
          m[v] = p[v], delete p[v];
        }), delete p.keys, /* @__PURE__ */ O.createElement(g, p, l.map(function(v, b) {
          var x = v.status, w = Rt(v, v4), C = x === tb || x === nb;
          return /* @__PURE__ */ O.createElement(t, we({}, m, {
            key: w.key,
            visible: C,
            eventProps: w,
            onVisibleChanged: function(S) {
              if (f == null || f(S, {
                key: w.key
              }), !S) {
                var A = a.removeKey(w.key);
                A === 0 && h && h();
              }
            }
          }), function(y, S) {
            return d(ie(ie({}, y), {}, {
              index: b
            }), S);
          });
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function(a, l) {
        var u = a.keys, c = l.keyEntities, d = ib(u), f = g4(c, d);
        return {
          keyEntities: f.filter(function(h) {
            var p = c.find(function(g) {
              var m = g.key;
              return h.key === m;
            });
            return !(p && p.status === Xm && h.status === rb);
          })
        };
      }
    }]), o;
  }(O.Component);
  return re(n, "defaultProps", {
    component: "div"
  }), n;
}
const f_ = y4(l_);
function w4(e) {
  const {
    children: t
  } = e, [, n] = Sr(), {
    motion: r
  } = n, i = O.useRef(!1);
  return i.current = i.current || r === !1, i.current ? /* @__PURE__ */ O.createElement(t4, {
    motion: r
  }, t) : t;
}
const h_ = /* @__PURE__ */ O.memo((e) => {
  let {
    dropdownMatchSelectWidth: t
  } = e;
  return Zt("ConfigProvider").deprecated(t === void 0, "dropdownMatchSelectWidth", "popupMatchSelectWidth"), null;
});
process.env.NODE_ENV !== "production" && (h_.displayName = "PropWarning");
const C4 = process.env.NODE_ENV !== "production" ? h_ : () => null;
var S4 = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
let ob = !1;
const kw = process.env.NODE_ENV !== "production" ? (e) => {
  process.env.NODE_ENV !== "production" && gl(!ob, e, "Static function can not consume context like dynamic theme. Please use 'App' component instead.");
} : (
  /* istanbul ignore next */
  null
), x4 = ["getTargetContainer", "getPopupContainer", "renderEmpty", "input", "pagination", "form", "select", "button"], E4 = "ant";
let Op, p_, g_, m_;
function Jh() {
  return Op || E4;
}
function $4() {
  return p_ || _w;
}
function O4(e) {
  return Object.keys(e).some((t) => t.endsWith("Color"));
}
const A4 = (e) => {
  const {
    prefixCls: t,
    iconPrefixCls: n,
    theme: r,
    holderRender: i
  } = e;
  t !== void 0 && (Op = t), n !== void 0 && (p_ = n), "holderRender" in e && (m_ = i), r && (O4(r) ? (process.env.NODE_ENV !== "production" && gl(!1, "ConfigProvider", "`config` of css variable theme is not work in v5. Please use new `theme` config instead."), I3(Jh(), r)) : g_ = r);
}, df = () => ({
  getPrefixCls: (e, t) => t || (e ? `${Jh()}-${e}` : Jh()),
  getIconPrefixCls: $4,
  getRootPrefixCls: () => Op || Jh(),
  getTheme: () => g_,
  holderRender: m_
}), D4 = (e) => {
  const {
    children: t,
    csp: n,
    autoInsertSpaceInButton: r,
    alert: i,
    anchor: o,
    form: s,
    locale: a,
    componentSize: l,
    direction: u,
    space: c,
    virtual: d,
    dropdownMatchSelectWidth: f,
    popupMatchSelectWidth: h,
    popupOverflow: p,
    legacyLocale: g,
    parentContext: m,
    iconPrefixCls: v,
    theme: b,
    componentDisabled: x,
    segmented: w,
    statistic: C,
    spin: y,
    calendar: S,
    carousel: A,
    cascader: $,
    collapse: M,
    typography: _,
    checkbox: T,
    descriptions: D,
    divider: E,
    drawer: R,
    skeleton: I,
    steps: k,
    image: P,
    layout: L,
    list: N,
    mentions: F,
    modal: B,
    progress: j,
    result: z,
    slider: H,
    breadcrumb: W,
    menu: G,
    pagination: K,
    input: Y,
    textArea: X,
    empty: Z,
    badge: Q,
    radio: ne,
    rate: q,
    switch: te,
    transfer: fe,
    avatar: Se,
    message: de,
    tag: ce,
    table: pe,
    card: Oe,
    tabs: Re,
    timeline: De,
    timePicker: Me,
    upload: Ue,
    notification: oe,
    tree: Ce,
    colorPicker: ge,
    datePicker: ve,
    rangePicker: me,
    flex: Fe,
    wave: Be,
    dropdown: qe,
    warning: Ve,
    tour: We,
    floatButtonGroup: Ge
  } = e, $e = O.useCallback((Le, ot) => {
    const {
      prefixCls: yt
    } = e;
    if (ot)
      return ot;
    const He = yt || m.getPrefixCls("");
    return Le ? `${He}-${Le}` : He;
  }, [m.getPrefixCls, e.prefixCls]), ze = v || m.iconPrefixCls || _w, at = n || m.csp;
  JD(ze, at);
  const xt = J3(b, m.theme, {
    prefixCls: $e("")
  });
  process.env.NODE_ENV !== "production" && (ob = ob || !!xt);
  const jt = {
    csp: at,
    autoInsertSpaceInButton: r,
    alert: i,
    anchor: o,
    locale: a || g,
    direction: u,
    space: c,
    virtual: d,
    popupMatchSelectWidth: h ?? f,
    popupOverflow: p,
    getPrefixCls: $e,
    iconPrefixCls: ze,
    theme: xt,
    segmented: w,
    statistic: C,
    spin: y,
    calendar: S,
    carousel: A,
    cascader: $,
    collapse: M,
    typography: _,
    checkbox: T,
    descriptions: D,
    divider: E,
    drawer: R,
    skeleton: I,
    steps: k,
    image: P,
    input: Y,
    textArea: X,
    layout: L,
    list: N,
    mentions: F,
    modal: B,
    progress: j,
    result: z,
    slider: H,
    breadcrumb: W,
    menu: G,
    pagination: K,
    empty: Z,
    badge: Q,
    radio: ne,
    rate: q,
    switch: te,
    transfer: fe,
    avatar: Se,
    message: de,
    tag: ce,
    table: pe,
    card: Oe,
    tabs: Re,
    timeline: De,
    timePicker: Me,
    upload: Ue,
    notification: oe,
    tree: Ce,
    colorPicker: ge,
    datePicker: ve,
    rangePicker: me,
    flex: Fe,
    wave: Be,
    dropdown: qe,
    warning: Ve,
    tour: We,
    floatButtonGroup: Ge
  }, Lt = Object.assign({}, m);
  Object.keys(jt).forEach((Le) => {
    jt[Le] !== void 0 && (Lt[Le] = jt[Le]);
  }), x4.forEach((Le) => {
    const ot = e[Le];
    ot && (Lt[Le] = ot);
  });
  const At = lf(() => Lt, Lt, (Le, ot) => {
    const yt = Object.keys(Le), He = Object.keys(ot);
    return yt.length !== He.length || yt.some((Je) => Le[Je] !== ot[Je]);
  }), Et = O.useMemo(() => ({
    prefixCls: ze,
    csp: at
  }), [ze, at]);
  let nt = /* @__PURE__ */ O.createElement(O.Fragment, null, /* @__PURE__ */ O.createElement(C4, {
    dropdownMatchSelectWidth: f
  }), t);
  const it = O.useMemo(() => {
    var Le, ot, yt, He;
    return rc(((Le = xs.Form) === null || Le === void 0 ? void 0 : Le.defaultValidateMessages) || {}, ((yt = (ot = At.locale) === null || ot === void 0 ? void 0 : ot.Form) === null || yt === void 0 ? void 0 : yt.defaultValidateMessages) || {}, ((He = At.form) === null || He === void 0 ? void 0 : He.validateMessages) || {}, (s == null ? void 0 : s.validateMessages) || {});
  }, [At, s == null ? void 0 : s.validateMessages]);
  Object.keys(it).length > 0 && (nt = /* @__PURE__ */ O.createElement(MD.Provider, {
    value: it
  }, nt)), a && (nt = /* @__PURE__ */ O.createElement(ND, {
    locale: a,
    _ANT_MARK__: PD
  }, nt)), (ze || at) && (nt = /* @__PURE__ */ O.createElement($w.Provider, {
    value: Et
  }, nt)), l && (nt = /* @__PURE__ */ O.createElement(k3, {
    size: l
  }, nt)), nt = /* @__PURE__ */ O.createElement(w4, null, nt);
  const je = O.useMemo(() => {
    const Le = xt || {}, {
      algorithm: ot,
      token: yt,
      components: He,
      cssVar: Je
    } = Le, Qe = S4(Le, ["algorithm", "token", "components", "cssVar"]), lt = ot && (!Array.isArray(ot) || ot.length > 0) ? gd(ot) : VD, pt = {};
    Object.entries(He || {}).forEach((ee) => {
      let [be, Ee] = ee;
      const ye = Object.assign({}, Ee);
      "algorithm" in ye && (ye.algorithm === !0 ? ye.theme = lt : (Array.isArray(ye.algorithm) || typeof ye.algorithm == "function") && (ye.theme = gd(ye.algorithm)), delete ye.algorithm), pt[be] = ye;
    });
    const vt = Object.assign(Object.assign({}, Tc), yt);
    return Object.assign(Object.assign({}, Qe), {
      theme: lt,
      token: vt,
      components: pt,
      override: Object.assign({
        override: vt
      }, pt),
      cssVar: Je
    });
  }, [xt]);
  return b && (nt = /* @__PURE__ */ O.createElement(WD.Provider, {
    value: je
  }, nt)), At.warning && (nt = /* @__PURE__ */ O.createElement(RD.Provider, {
    value: At.warning
  }, nt)), x !== void 0 && (nt = /* @__PURE__ */ O.createElement(Tw, {
    disabled: x
  }, nt)), /* @__PURE__ */ O.createElement(rt.Provider, {
    value: At
  }, nt);
}, vl = (e) => {
  const t = O.useContext(rt), n = O.useContext(Aw);
  return /* @__PURE__ */ O.createElement(D4, Object.assign({
    parentContext: t,
    legacyLocale: n
  }, e));
};
vl.ConfigContext = rt;
vl.SizeContext = Qa;
vl.config = A4;
vl.useConfig = P3;
Object.defineProperty(vl, "SizeContext", {
  get: () => (process.env.NODE_ENV !== "production" && gl(!1, "ConfigProvider", "ConfigProvider.SizeContext is deprecated. Please use `ConfigProvider.useConfig().componentSize` instead."), Qa)
});
process.env.NODE_ENV !== "production" && (vl.displayName = "ConfigProvider");
const qc = vl;
var _4 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, name: "check-circle", theme: "filled" };
function v_(e) {
  var t;
  return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e);
}
function T4(e) {
  return v_(e) instanceof ShadowRoot;
}
function Ap(e) {
  return T4(e) ? v_(e) : null;
}
function R4(e) {
  return e.replace(/-(.)/g, function(t, n) {
    return n.toUpperCase();
  });
}
function M4(e, t) {
  $t(e, "[@ant-design/icons] ".concat(t));
}
function WS(e) {
  return wt(e) === "object" && typeof e.name == "string" && typeof e.theme == "string" && (wt(e.icon) === "object" || typeof e.icon == "function");
}
function US() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(e).reduce(function(t, n) {
    var r = e[n];
    switch (n) {
      case "class":
        t.className = r, delete t.class;
        break;
      default:
        delete t[n], t[R4(n)] = r;
    }
    return t;
  }, {});
}
function sb(e, t, n) {
  return n ? /* @__PURE__ */ U.createElement(e.tag, ie(ie({
    key: t
  }, US(e.attrs)), n), (e.children || []).map(function(r, i) {
    return sb(r, "".concat(t, "-").concat(e.tag, "-").concat(i));
  })) : /* @__PURE__ */ U.createElement(e.tag, ie({
    key: t
  }, US(e.attrs)), (e.children || []).map(function(r, i) {
    return sb(r, "".concat(t, "-").concat(e.tag, "-").concat(i));
  }));
}
function b_(e) {
  return Es(e)[0];
}
function y_(e) {
  return e ? Array.isArray(e) ? e : [e] : [];
}
var I4 = `
.anticon {
  display: inline-flex;
  alignItems: center;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`, k4 = function(t) {
  var n = Yt($w), r = n.csp, i = n.prefixCls, o = I4;
  i && (o = o.replace(/anticon/g, i)), Pe(function() {
    var s = t.current, a = Ap(s);
    vs(o, "@ant-design-icons", {
      prepend: !0,
      csp: r,
      attachTo: a
    });
  }, []);
}, P4 = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"], Zu = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: !1
};
function N4(e) {
  var t = e.primaryColor, n = e.secondaryColor;
  Zu.primaryColor = t, Zu.secondaryColor = n || b_(t), Zu.calculated = !!n;
}
function L4() {
  return ie({}, Zu);
}
var Qc = function(t) {
  var n = t.icon, r = t.className, i = t.onClick, o = t.style, s = t.primaryColor, a = t.secondaryColor, l = Rt(t, P4), u = O.useRef(), c = Zu;
  if (s && (c = {
    primaryColor: s,
    secondaryColor: a || b_(s)
  }), k4(u), M4(WS(n), "icon should be icon definiton, but got ".concat(n)), !WS(n))
    return null;
  var d = n;
  return d && typeof d.icon == "function" && (d = ie(ie({}, d), {}, {
    icon: d.icon(c.primaryColor, c.secondaryColor)
  })), sb(d.icon, "svg-".concat(d.name), ie(ie({
    className: r,
    onClick: i,
    style: o,
    "data-icon": d.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }, l), {}, {
    ref: u
  }));
};
Qc.displayName = "IconReact";
Qc.getTwoToneColors = L4;
Qc.setTwoToneColors = N4;
function w_(e) {
  var t = y_(e), n = ae(t, 2), r = n[0], i = n[1];
  return Qc.setTwoToneColors({
    primaryColor: r,
    secondaryColor: i
  });
}
function F4() {
  var e = Qc.getTwoToneColors();
  return e.calculated ? [e.primaryColor, e.secondaryColor] : e.primaryColor;
}
var B4 = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
w_(x3.primary);
var kt = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.className, r = e.icon, i = e.spin, o = e.rotate, s = e.tabIndex, a = e.onClick, l = e.twoToneColor, u = Rt(e, B4), c = O.useContext($w), d = c.prefixCls, f = d === void 0 ? "anticon" : d, h = c.rootClassName, p = se(h, f, re(re({}, "".concat(f, "-").concat(r.name), !!r.name), "".concat(f, "-spin"), !!i || r.name === "loading"), n), g = s;
  g === void 0 && a && (g = -1);
  var m = o ? {
    msTransform: "rotate(".concat(o, "deg)"),
    transform: "rotate(".concat(o, "deg)")
  } : void 0, v = y_(l), b = ae(v, 2), x = b[0], w = b[1];
  return /* @__PURE__ */ O.createElement("span", we({
    role: "img",
    "aria-label": r.name
  }, u, {
    ref: t,
    tabIndex: g,
    onClick: a,
    className: p
  }), /* @__PURE__ */ O.createElement(Qc, {
    icon: r,
    primaryColor: x,
    secondaryColor: w,
    style: m
  }));
});
kt.displayName = "AntdIcon";
kt.getTwoToneColor = F4;
kt.setTwoToneColor = w_;
var j4 = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: _4
  }));
}, ff = /* @__PURE__ */ O.forwardRef(j4);
process.env.NODE_ENV !== "production" && (ff.displayName = "CheckCircleFilled");
var z4 = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, name: "close-circle", theme: "filled" }, H4 = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: z4
  }));
}, bl = /* @__PURE__ */ O.forwardRef(H4);
process.env.NODE_ENV !== "production" && (bl.displayName = "CloseCircleFilled");
var V4 = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, name: "close", theme: "outlined" }, W4 = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: V4
  }));
}, To = /* @__PURE__ */ O.forwardRef(W4);
process.env.NODE_ENV !== "production" && (To.displayName = "CloseOutlined");
var U4 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "exclamation-circle", theme: "filled" }, G4 = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: U4
  }));
}, yl = /* @__PURE__ */ O.forwardRef(G4);
process.env.NODE_ENV !== "production" && (yl.displayName = "ExclamationCircleFilled");
var K4 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "info-circle", theme: "filled" }, X4 = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: K4
  }));
}, kg = /* @__PURE__ */ O.forwardRef(X4);
process.env.NODE_ENV !== "production" && (kg.displayName = "InfoCircleFilled");
var Y4 = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`, q4 = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`, Q4 = "".concat(Y4, " ").concat(q4).split(/[\s\n]+/), Z4 = "aria-", J4 = "data-";
function GS(e, t) {
  return e.indexOf(t) === 0;
}
function $s(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n;
  t === !1 ? n = {
    aria: !0,
    data: !0,
    attr: !0
  } : t === !0 ? n = {
    aria: !0
  } : n = ie({}, t);
  var r = {};
  return Object.keys(e).forEach(function(i) {
    // Aria
    (n.aria && (i === "role" || GS(i, Z4)) || // Data
    n.data && GS(i, J4) || // Attr
    n.attr && Q4.includes(i)) && (r[i] = e[i]);
  }), r;
}
function C_(e) {
  return e && /* @__PURE__ */ U.isValidElement(e) && e.type === U.Fragment;
}
const eB = (e, t, n) => /* @__PURE__ */ U.isValidElement(e) ? /* @__PURE__ */ U.cloneElement(e, typeof n == "function" ? n(e.props || {}) : n) : t;
function oi(e, t) {
  return eB(e, e, t);
}
const KS = (e) => typeof e == "object" && e != null && e.nodeType === 1, XS = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", Ym = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    const n = getComputedStyle(e, null);
    return XS(n.overflowY, t) || XS(n.overflowX, t) || ((r) => {
      const i = ((o) => {
        if (!o.ownerDocument || !o.ownerDocument.defaultView)
          return null;
        try {
          return o.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!i && (i.clientHeight < r.scrollHeight || i.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, qf = (e, t, n, r, i, o, s, a) => o < e && s > t || o > e && s < t ? 0 : o <= e && a <= n || s >= t && a >= n ? o - e - r : s > t && a < n || o < e && a > n ? s - t + i : 0, tB = (e) => {
  const t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
}, YS = (e, t) => {
  var n, r, i, o;
  if (typeof document > "u")
    return [];
  const { scrollMode: s, block: a, inline: l, boundary: u, skipOverflowHiddenElements: c } = t, d = typeof u == "function" ? u : (I) => I !== u;
  if (!KS(e))
    throw new TypeError("Invalid target");
  const f = document.scrollingElement || document.documentElement, h = [];
  let p = e;
  for (; KS(p) && d(p); ) {
    if (p = tB(p), p === f) {
      h.push(p);
      break;
    }
    p != null && p === document.body && Ym(p) && !Ym(document.documentElement) || p != null && Ym(p, c) && h.push(p);
  }
  const g = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, m = (o = (i = window.visualViewport) == null ? void 0 : i.height) != null ? o : innerHeight, { scrollX: v, scrollY: b } = window, { height: x, width: w, top: C, right: y, bottom: S, left: A } = e.getBoundingClientRect(), { top: $, right: M, bottom: _, left: T } = ((I) => {
    const k = window.getComputedStyle(I);
    return { top: parseFloat(k.scrollMarginTop) || 0, right: parseFloat(k.scrollMarginRight) || 0, bottom: parseFloat(k.scrollMarginBottom) || 0, left: parseFloat(k.scrollMarginLeft) || 0 };
  })(e);
  let D = a === "start" || a === "nearest" ? C - $ : a === "end" ? S + _ : C + x / 2 - $ + _, E = l === "center" ? A + w / 2 - T + M : l === "end" ? y + M : A - T;
  const R = [];
  for (let I = 0; I < h.length; I++) {
    const k = h[I], { height: P, width: L, top: N, right: F, bottom: B, left: j } = k.getBoundingClientRect();
    if (s === "if-needed" && C >= 0 && A >= 0 && S <= m && y <= g && C >= N && S <= B && A >= j && y <= F)
      return R;
    const z = getComputedStyle(k), H = parseInt(z.borderLeftWidth, 10), W = parseInt(z.borderTopWidth, 10), G = parseInt(z.borderRightWidth, 10), K = parseInt(z.borderBottomWidth, 10);
    let Y = 0, X = 0;
    const Z = "offsetWidth" in k ? k.offsetWidth - k.clientWidth - H - G : 0, Q = "offsetHeight" in k ? k.offsetHeight - k.clientHeight - W - K : 0, ne = "offsetWidth" in k ? k.offsetWidth === 0 ? 0 : L / k.offsetWidth : 0, q = "offsetHeight" in k ? k.offsetHeight === 0 ? 0 : P / k.offsetHeight : 0;
    if (f === k)
      Y = a === "start" ? D : a === "end" ? D - m : a === "nearest" ? qf(b, b + m, m, W, K, b + D, b + D + x, x) : D - m / 2, X = l === "start" ? E : l === "center" ? E - g / 2 : l === "end" ? E - g : qf(v, v + g, g, H, G, v + E, v + E + w, w), Y = Math.max(0, Y + b), X = Math.max(0, X + v);
    else {
      Y = a === "start" ? D - N - W : a === "end" ? D - B + K + Q : a === "nearest" ? qf(N, B, P, W, K + Q, D, D + x, x) : D - (N + P / 2) + Q / 2, X = l === "start" ? E - j - H : l === "center" ? E - (j + L / 2) + Z / 2 : l === "end" ? E - F + G + Z : qf(j, F, L, H, G + Z, E, E + w, w);
      const { scrollLeft: te, scrollTop: fe } = k;
      Y = q === 0 ? 0 : Math.max(0, Math.min(fe + Y / q, k.scrollHeight - P / q + Q)), X = ne === 0 ? 0 : Math.max(0, Math.min(te + X / ne, k.scrollWidth - L / ne + Z)), D += fe - Y, E += te - X;
    }
    R.push({ el: k, top: Y, left: X });
  }
  return R;
}, nB = (e) => e === !1 ? { block: "end", inline: "nearest" } : ((t) => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" };
function rB(e, t) {
  if (!e.isConnected || !((i) => {
    let o = i;
    for (; o && o.parentNode; ) {
      if (o.parentNode === document)
        return !0;
      o = o.parentNode instanceof ShadowRoot ? o.parentNode.host : o.parentNode;
    }
    return !1;
  })(e))
    return;
  const n = ((i) => {
    const o = window.getComputedStyle(i);
    return { top: parseFloat(o.scrollMarginTop) || 0, right: parseFloat(o.scrollMarginRight) || 0, bottom: parseFloat(o.scrollMarginBottom) || 0, left: parseFloat(o.scrollMarginLeft) || 0 };
  })(e);
  if (((i) => typeof i == "object" && typeof i.behavior == "function")(t))
    return t.behavior(YS(e, t));
  const r = typeof t == "boolean" || t == null ? void 0 : t.behavior;
  for (const { el: i, top: o, left: s } of YS(e, nB(t))) {
    const a = o - n.top + n.bottom, l = s - n.left + n.right;
    i.scroll({ top: a, left: l, behavior: r });
  }
}
const Kn = (e) => {
  const [, , , , t] = Sr();
  return t ? `${e}-css-var` : "";
};
var xe = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  // NUMLOCK on FF/Safari Mac
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  // also NUM_NORTH_EAST
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  // also NUM_SOUTH_EAST
  /**
   * END
   */
  END: 35,
  // also NUM_SOUTH_WEST
  /**
   * HOME
   */
  HOME: 36,
  // also NUM_NORTH_WEST
  /**
   * LEFT
   */
  LEFT: 37,
  // also NUM_WEST
  /**
   * UP
   */
  UP: 38,
  // also NUM_NORTH
  /**
   * RIGHT
   */
  RIGHT: 39,
  // also NUM_EAST
  /**
   * DOWN
   */
  DOWN: 40,
  // also NUM_SOUTH
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  // also NUM_INSERT
  /**
   * DELETE
   */
  DELETE: 46,
  // also NUM_DELETE
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  // needs localization
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  // WIN_KEY_LEFT
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  // needs localization
  /**
   * DASH
   */
  DASH: 189,
  // needs localization
  /**
   * EQUALS
   */
  EQUALS: 187,
  // needs localization
  /**
   * COMMA
   */
  COMMA: 188,
  // needs localization
  /**
   * PERIOD
   */
  PERIOD: 190,
  // needs localization
  /**
   * SLASH
   */
  SLASH: 191,
  // needs localization
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  // needs localization
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  // needs localization
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  // needs localization
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  // needs localization
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  // needs localization
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  // Firefox (Gecko) fires this for the meta key instead of 91
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function(t) {
    var n = t.keyCode;
    if (t.altKey && !t.ctrlKey || t.metaKey || // Function keys don't generate text
    n >= xe.F1 && n <= xe.F12)
      return !1;
    switch (n) {
      case xe.ALT:
      case xe.CAPS_LOCK:
      case xe.CONTEXT_MENU:
      case xe.CTRL:
      case xe.DOWN:
      case xe.END:
      case xe.ESC:
      case xe.HOME:
      case xe.INSERT:
      case xe.LEFT:
      case xe.MAC_FF_META:
      case xe.META:
      case xe.NUMLOCK:
      case xe.NUM_CENTER:
      case xe.PAGE_DOWN:
      case xe.PAGE_UP:
      case xe.PAUSE:
      case xe.PRINT_SCREEN:
      case xe.RIGHT:
      case xe.SHIFT:
      case xe.UP:
      case xe.WIN_KEY:
      case xe.WIN_KEY_RIGHT:
        return !1;
      default:
        return !0;
    }
  },
  /**
   * whether character is entered.
   */
  isCharacterKey: function(t) {
    if (t >= xe.ZERO && t <= xe.NINE || t >= xe.NUM_ZERO && t <= xe.NUM_MULTIPLY || t >= xe.A && t <= xe.Z || window.navigator.userAgent.indexOf("WebKit") !== -1 && t === 0)
      return !0;
    switch (t) {
      case xe.SPACE:
      case xe.QUESTION_MARK:
      case xe.NUM_PLUS:
      case xe.NUM_MINUS:
      case xe.NUM_PERIOD:
      case xe.NUM_DIVISION:
      case xe.SEMICOLON:
      case xe.DASH:
      case xe.EQUALS:
      case xe.COMMA:
      case xe.PERIOD:
      case xe.SLASH:
      case xe.APOSTROPHE:
      case xe.SINGLE_QUOTE:
      case xe.OPEN_SQUARE_BRACKET:
      case xe.BACKSLASH:
      case xe.CLOSE_SQUARE_BRACKET:
        return !0;
      default:
        return !1;
    }
  }
}, Pw = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.prefixCls, r = e.style, i = e.className, o = e.duration, s = o === void 0 ? 4.5 : o, a = e.eventKey, l = e.content, u = e.closable, c = e.closeIcon, d = c === void 0 ? "x" : c, f = e.props, h = e.onClick, p = e.onNoticeClose, g = e.times, m = e.hovering, v = O.useState(!1), b = ae(v, 2), x = b[0], w = b[1], C = m || x, y = function() {
    p(a);
  }, S = function(T) {
    (T.key === "Enter" || T.code === "Enter" || T.keyCode === xe.ENTER) && y();
  };
  O.useEffect(function() {
    if (!C && s > 0) {
      var _ = setTimeout(function() {
        y();
      }, s * 1e3);
      return function() {
        clearTimeout(_);
      };
    }
  }, [s, C, g]);
  var A = O.useMemo(function() {
    return wt(u) === "object" && u !== null ? u : u ? {
      closeIcon: d
    } : {};
  }, [u, d]), $ = $s(A, !0), M = "".concat(n, "-notice");
  return /* @__PURE__ */ O.createElement("div", we({}, f, {
    ref: t,
    className: se(M, i, re({}, "".concat(M, "-closable"), u)),
    style: r,
    onMouseEnter: function(T) {
      var D;
      w(!0), f == null || (D = f.onMouseEnter) === null || D === void 0 || D.call(f, T);
    },
    onMouseLeave: function(T) {
      var D;
      w(!1), f == null || (D = f.onMouseLeave) === null || D === void 0 || D.call(f, T);
    },
    onClick: h
  }), /* @__PURE__ */ O.createElement("div", {
    className: "".concat(M, "-content")
  }, l), u && /* @__PURE__ */ O.createElement("a", we({
    tabIndex: 0,
    className: "".concat(M, "-close"),
    onKeyDown: S,
    "aria-label": "Close"
  }, $, {
    onClick: function(T) {
      T.preventDefault(), T.stopPropagation(), y();
    }
  }), A.closeIcon));
}), S_ = /* @__PURE__ */ U.createContext({}), x_ = function(t) {
  var n = t.children, r = t.classNames;
  return /* @__PURE__ */ U.createElement(S_.Provider, {
    value: {
      classNames: r
    }
  }, n);
}, qS = 8, QS = 3, ZS = 16, iB = function(t) {
  var n = {
    offset: qS,
    threshold: QS,
    gap: ZS
  };
  if (t && wt(t) === "object") {
    var r, i, o;
    n.offset = (r = t.offset) !== null && r !== void 0 ? r : qS, n.threshold = (i = t.threshold) !== null && i !== void 0 ? i : QS, n.gap = (o = t.gap) !== null && o !== void 0 ? o : ZS;
  }
  return [!!t, n];
}, oB = ["className", "style", "classNames", "styles"], E_ = function(t) {
  var n = t.configList, r = t.placement, i = t.prefixCls, o = t.className, s = t.style, a = t.motion, l = t.onAllNoticeRemoved, u = t.onNoticeClose, c = t.stack, d = Yt(S_), f = d.classNames, h = he({}), p = ht(null), g = ae(p, 2), m = g[0], v = g[1], b = ht([]), x = ae(b, 2), w = x[0], C = x[1], y = n.map(function(I) {
    return {
      config: I,
      key: String(I.key)
    };
  }), S = iB(c), A = ae(S, 2), $ = A[0], M = A[1], _ = M.offset, T = M.threshold, D = M.gap, E = $ && (w.length > 0 || y.length <= T), R = typeof a == "function" ? a(r) : a;
  return Pe(function() {
    $ && w.length > 1 && C(function(I) {
      return I.filter(function(k) {
        return y.some(function(P) {
          var L = P.key;
          return k === L;
        });
      });
    });
  }, [w, y, $]), Pe(function() {
    var I;
    if ($ && h.current[(I = y[y.length - 1]) === null || I === void 0 ? void 0 : I.key]) {
      var k;
      v(h.current[(k = y[y.length - 1]) === null || k === void 0 ? void 0 : k.key]);
    }
  }, [y, $]), /* @__PURE__ */ U.createElement(f_, we({
    key: r,
    className: se(i, "".concat(i, "-").concat(r), f == null ? void 0 : f.list, o, re(re({}, "".concat(i, "-stack"), !!$), "".concat(i, "-stack-expanded"), E)),
    style: s,
    keys: y,
    motionAppear: !0
  }, R, {
    onAllRemoved: function() {
      l(r);
    }
  }), function(I, k) {
    var P = I.config, L = I.className, N = I.style, F = I.index, B = P, j = B.key, z = B.times, H = String(j), W = P, G = W.className, K = W.style, Y = W.classNames, X = W.styles, Z = Rt(W, oB), Q = y.findIndex(function(Me) {
      return Me.key === H;
    }), ne = {};
    if ($) {
      var q = y.length - 1 - (Q > -1 ? Q : F - 1), te = r === "top" || r === "bottom" ? "-50%" : "0";
      if (q > 0) {
        var fe, Se, de;
        ne.height = E ? (fe = h.current[H]) === null || fe === void 0 ? void 0 : fe.offsetHeight : m == null ? void 0 : m.offsetHeight;
        for (var ce = 0, pe = 0; pe < q; pe++) {
          var Oe;
          ce += ((Oe = h.current[y[y.length - 1 - pe].key]) === null || Oe === void 0 ? void 0 : Oe.offsetHeight) + D;
        }
        var Re = (E ? ce : q * _) * (r.startsWith("top") ? 1 : -1), De = !E && m !== null && m !== void 0 && m.offsetWidth && (Se = h.current[H]) !== null && Se !== void 0 && Se.offsetWidth ? ((m == null ? void 0 : m.offsetWidth) - _ * 2 * (q < 3 ? q : 3)) / ((de = h.current[H]) === null || de === void 0 ? void 0 : de.offsetWidth) : 1;
        ne.transform = "translate3d(".concat(te, ", ").concat(Re, "px, 0) scaleX(").concat(De, ")");
      } else
        ne.transform = "translate3d(".concat(te, ", 0, 0)");
    }
    return /* @__PURE__ */ U.createElement("div", {
      ref: k,
      className: se("".concat(i, "-notice-wrapper"), L, Y == null ? void 0 : Y.wrapper),
      style: ie(ie(ie({}, N), ne), X == null ? void 0 : X.wrapper),
      onMouseEnter: function() {
        return C(function(Ue) {
          return Ue.includes(H) ? Ue : [].concat(_e(Ue), [H]);
        });
      },
      onMouseLeave: function() {
        return C(function(Ue) {
          return Ue.filter(function(oe) {
            return oe !== H;
          });
        });
      }
    }, /* @__PURE__ */ U.createElement(Pw, we({}, Z, {
      ref: function(Ue) {
        Q > -1 ? h.current[H] = Ue : delete h.current[H];
      },
      prefixCls: i,
      classNames: Y,
      styles: X,
      className: se(G, f == null ? void 0 : f.notice),
      style: K,
      times: z,
      key: j,
      eventKey: j,
      onNoticeClose: u,
      hovering: $ && w.length > 0
    })));
  });
};
process.env.NODE_ENV !== "production" && (E_.displayName = "NoticeList");
var $_ = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.prefixCls, r = n === void 0 ? "rc-notification" : n, i = e.container, o = e.motion, s = e.maxCount, a = e.className, l = e.style, u = e.onAllRemoved, c = e.stack, d = e.renderNotifications, f = O.useState([]), h = ae(f, 2), p = h[0], g = h[1], m = function($) {
    var M, _ = p.find(function(T) {
      return T.key === $;
    });
    _ == null || (M = _.onClose) === null || M === void 0 || M.call(_), g(function(T) {
      return T.filter(function(D) {
        return D.key !== $;
      });
    });
  };
  O.useImperativeHandle(t, function() {
    return {
      open: function($) {
        g(function(M) {
          var _ = _e(M), T = _.findIndex(function(R) {
            return R.key === $.key;
          }), D = ie({}, $);
          if (T >= 0) {
            var E;
            D.times = (((E = M[T]) === null || E === void 0 ? void 0 : E.times) || 0) + 1, _[T] = D;
          } else
            D.times = 0, _.push(D);
          return s > 0 && _.length > s && (_ = _.slice(-s)), _;
        });
      },
      close: function($) {
        m($);
      },
      destroy: function() {
        g([]);
      }
    };
  });
  var v = O.useState({}), b = ae(v, 2), x = b[0], w = b[1];
  O.useEffect(function() {
    var A = {};
    p.forEach(function($) {
      var M = $.placement, _ = M === void 0 ? "topRight" : M;
      _ && (A[_] = A[_] || [], A[_].push($));
    }), Object.keys(x).forEach(function($) {
      A[$] = A[$] || [];
    }), w(A);
  }, [p]);
  var C = function($) {
    w(function(M) {
      var _ = ie({}, M), T = _[$] || [];
      return T.length || delete _[$], _;
    });
  }, y = O.useRef(!1);
  if (O.useEffect(function() {
    Object.keys(x).length > 0 ? y.current = !0 : y.current && (u == null || u(), y.current = !1);
  }, [x]), !i)
    return null;
  var S = Object.keys(x);
  return /* @__PURE__ */ gw(/* @__PURE__ */ O.createElement(O.Fragment, null, S.map(function(A) {
    var $ = x[A], M = /* @__PURE__ */ O.createElement(E_, {
      key: A,
      configList: $,
      placement: A,
      prefixCls: r,
      className: a == null ? void 0 : a(A),
      style: l == null ? void 0 : l(A),
      motion: o,
      onNoticeClose: m,
      onAllNoticeRemoved: C,
      stack: c
    });
    return d ? d(M, {
      prefixCls: r,
      key: A
    }) : M;
  })), i);
});
process.env.NODE_ENV !== "production" && ($_.displayName = "Notifications");
var sB = ["getContainer", "motion", "prefixCls", "maxCount", "className", "style", "onAllRemoved", "stack", "renderNotifications"], aB = function() {
  return document.body;
}, JS = 0;
function lB() {
  for (var e = {}, t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  return n.forEach(function(i) {
    i && Object.keys(i).forEach(function(o) {
      var s = i[o];
      s !== void 0 && (e[o] = s);
    });
  }), e;
}
function O_() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.getContainer, n = t === void 0 ? aB : t, r = e.motion, i = e.prefixCls, o = e.maxCount, s = e.className, a = e.style, l = e.onAllRemoved, u = e.stack, c = e.renderNotifications, d = Rt(e, sB), f = O.useState(), h = ae(f, 2), p = h[0], g = h[1], m = O.useRef(), v = /* @__PURE__ */ O.createElement($_, {
    container: p,
    ref: m,
    prefixCls: i,
    motion: r,
    maxCount: o,
    className: s,
    style: a,
    onAllRemoved: l,
    stack: u,
    renderNotifications: c
  }), b = O.useState([]), x = ae(b, 2), w = x[0], C = x[1], y = O.useMemo(function() {
    return {
      open: function(A) {
        var $ = lB(d, A);
        ($.key === null || $.key === void 0) && ($.key = "rc-notification-".concat(JS), JS += 1), C(function(M) {
          return [].concat(_e(M), [{
            type: "open",
            config: $
          }]);
        });
      },
      close: function(A) {
        C(function($) {
          return [].concat(_e($), [{
            type: "close",
            key: A
          }]);
        });
      },
      destroy: function() {
        C(function(A) {
          return [].concat(_e(A), [{
            type: "destroy"
          }]);
        });
      }
    };
  }, []);
  return O.useEffect(function() {
    g(n());
  }), O.useEffect(function() {
    m.current && w.length && (w.forEach(function(S) {
      switch (S.type) {
        case "open":
          m.current.open(S.config);
          break;
        case "close":
          m.current.close(S.key);
          break;
        case "destroy":
          m.current.destroy();
          break;
      }
    }), C(function(S) {
      return S.filter(function(A) {
        return !w.includes(A);
      });
    }));
  }, [w]), [y, v];
}
var cB = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, name: "loading", theme: "outlined" }, uB = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: cB
  }));
}, wl = /* @__PURE__ */ O.forwardRef(uB);
process.env.NODE_ENV !== "production" && (wl.displayName = "LoadingOutlined");
const hf = /* @__PURE__ */ U.createContext(void 0);
process.env.NODE_ENV !== "production" && (hf.displayName = "zIndexContext");
const Aa = 100, dB = 10, Pg = Aa * dB, A_ = {
  Modal: Aa,
  Drawer: Aa,
  Popover: Aa,
  Popconfirm: Aa,
  Tooltip: Aa,
  Tour: Aa
}, fB = {
  SelectLike: 50,
  Dropdown: 50,
  DatePicker: 50,
  Menu: 50,
  ImagePreview: 1
};
function hB(e) {
  return e in A_;
}
function Zc(e, t) {
  const [, n] = Sr(), r = U.useContext(hf), i = hB(e);
  if (t !== void 0)
    return [t, t];
  let o = r ?? 0;
  return i ? (o += // Use preset token zIndex by default but not stack when has parent container
  (r ? 0 : n.zIndexPopupBase) + // Container offset
  A_[e], o = Math.min(o, n.zIndexPopupBase + Pg)) : o += fB[e], [r === void 0 ? t : o, o];
}
const pB = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    boxShadow: r,
    colorText: i,
    colorSuccess: o,
    colorError: s,
    colorWarning: a,
    colorInfo: l,
    fontSizeLG: u,
    motionEaseInOutCirc: c,
    motionDurationSlow: d,
    marginXS: f,
    paddingXS: h,
    borderRadiusLG: p,
    zIndexPopup: g,
    // Custom token
    contentPadding: m,
    contentBg: v
  } = e, b = `${t}-notice`, x = new Gt("MessageMoveIn", {
    "0%": {
      padding: 0,
      transform: "translateY(-100%)",
      opacity: 0
    },
    "100%": {
      padding: h,
      transform: "translateY(0)",
      opacity: 1
    }
  }), w = new Gt("MessageMoveOut", {
    "0%": {
      maxHeight: e.height,
      padding: h,
      opacity: 1
    },
    "100%": {
      maxHeight: 0,
      padding: 0,
      opacity: 0
    }
  }), C = {
    padding: h,
    textAlign: "center",
    [`${t}-custom-content > ${n}`]: {
      verticalAlign: "text-bottom",
      marginInlineEnd: f,
      // affected by ltr or rtl
      fontSize: u
    },
    [`${b}-content`]: {
      display: "inline-block",
      padding: m,
      background: v,
      borderRadius: p,
      boxShadow: r,
      pointerEvents: "all"
    },
    [`${t}-success > ${n}`]: {
      color: o
    },
    [`${t}-error > ${n}`]: {
      color: s
    },
    [`${t}-warning > ${n}`]: {
      color: a
    },
    [`${t}-info > ${n},
      ${t}-loading > ${n}`]: {
      color: l
    }
  };
  return [
    // ============================ Holder ============================
    {
      [t]: Object.assign(Object.assign({}, Gn(e)), {
        color: i,
        position: "fixed",
        top: f,
        width: "100%",
        pointerEvents: "none",
        zIndex: g,
        [`${t}-move-up`]: {
          animationFillMode: "forwards"
        },
        [`
        ${t}-move-up-appear,
        ${t}-move-up-enter
      `]: {
          animationName: x,
          animationDuration: d,
          animationPlayState: "paused",
          animationTimingFunction: c
        },
        [`
        ${t}-move-up-appear${t}-move-up-appear-active,
        ${t}-move-up-enter${t}-move-up-enter-active
      `]: {
          animationPlayState: "running"
        },
        [`${t}-move-up-leave`]: {
          animationName: w,
          animationDuration: d,
          animationPlayState: "paused",
          animationTimingFunction: c
        },
        [`${t}-move-up-leave${t}-move-up-leave-active`]: {
          animationPlayState: "running"
        },
        "&-rtl": {
          direction: "rtl",
          span: {
            direction: "rtl"
          }
        }
      })
    },
    // ============================ Notice ============================
    {
      [t]: {
        [`${b}-wrapper`]: Object.assign({}, C)
      }
    },
    // ============================= Pure =============================
    {
      [`${t}-notice-pure-panel`]: Object.assign(Object.assign({}, C), {
        padding: 0,
        textAlign: "start"
      })
    }
  ];
}, gB = (e) => ({
  zIndexPopup: e.zIndexPopupBase + Pg + 10,
  contentBg: e.colorBgElevated,
  contentPadding: `${(e.controlHeightLG - e.fontSize * e.lineHeight) / 2}px ${e.paddingSM}px`
}), D_ = $n("Message", (e) => {
  const t = Jt(e, {
    height: 150
  });
  return [pB(t)];
}, gB);
var mB = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const vB = {
  info: /* @__PURE__ */ O.createElement(kg, null),
  success: /* @__PURE__ */ O.createElement(ff, null),
  error: /* @__PURE__ */ O.createElement(bl, null),
  warning: /* @__PURE__ */ O.createElement(yl, null),
  loading: /* @__PURE__ */ O.createElement(wl, null)
}, __ = (e) => {
  let {
    prefixCls: t,
    type: n,
    icon: r,
    children: i
  } = e;
  return /* @__PURE__ */ O.createElement("div", {
    className: se(`${t}-custom-content`, `${t}-${n}`)
  }, r || vB[n], /* @__PURE__ */ O.createElement("span", null, i));
}, bB = (e) => {
  const {
    prefixCls: t,
    className: n,
    type: r,
    icon: i,
    content: o
  } = e, s = mB(e, ["prefixCls", "className", "type", "icon", "content"]), {
    getPrefixCls: a
  } = O.useContext(rt), l = t || a("message"), u = Kn(l), [c, d, f] = D_(l, u);
  return c(/* @__PURE__ */ O.createElement(Pw, Object.assign({}, s, {
    prefixCls: l,
    className: se(n, d, `${l}-notice-pure-panel`, f, u),
    eventKey: "pure",
    duration: null,
    content: /* @__PURE__ */ O.createElement(__, {
      prefixCls: l,
      type: r,
      icon: i
    }, o)
  })));
};
function yB(e, t) {
  return {
    motionName: t ?? `${e}-move-up`
  };
}
function Nw(e) {
  let t;
  const n = new Promise((i) => {
    t = e(() => {
      i(!0);
    });
  }), r = () => {
    t == null || t();
  };
  return r.then = (i, o) => n.then(i, o), r.promise = n, r;
}
var wB = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const CB = 8, SB = 3, xB = (e) => {
  let {
    children: t,
    prefixCls: n
  } = e;
  const r = Kn(n), [i, o, s] = D_(n, r);
  return i(/* @__PURE__ */ O.createElement(x_, {
    classNames: {
      list: se(o, s, r)
    }
  }, t));
}, EB = (e, t) => {
  let {
    prefixCls: n,
    key: r
  } = t;
  return /* @__PURE__ */ O.createElement(xB, {
    prefixCls: n,
    key: r
  }, e);
}, $B = /* @__PURE__ */ O.forwardRef((e, t) => {
  const {
    top: n,
    prefixCls: r,
    getContainer: i,
    maxCount: o,
    duration: s = SB,
    rtl: a,
    transitionName: l,
    onAllRemoved: u
  } = e, {
    getPrefixCls: c,
    getPopupContainer: d,
    message: f,
    direction: h
  } = O.useContext(rt), p = r || c("message"), g = () => ({
    left: "50%",
    transform: "translateX(-50%)",
    top: n ?? CB
  }), m = () => se({
    [`${p}-rtl`]: a ?? h === "rtl"
  }), v = () => yB(p, l), b = /* @__PURE__ */ O.createElement("span", {
    className: `${p}-close-x`
  }, /* @__PURE__ */ O.createElement(To, {
    className: `${p}-close-icon`
  })), [x, w] = O_({
    prefixCls: p,
    style: g,
    className: m,
    motion: v,
    closable: !1,
    closeIcon: b,
    duration: s,
    getContainer: () => (i == null ? void 0 : i()) || (d == null ? void 0 : d()) || document.body,
    maxCount: o,
    onAllRemoved: u,
    renderNotifications: EB
  });
  return O.useImperativeHandle(t, () => Object.assign(Object.assign({}, x), {
    prefixCls: p,
    message: f
  })), w;
});
let ex = 0;
function T_(e) {
  const t = O.useRef(null), n = Zt("Message");
  return [O.useMemo(() => {
    const i = (u) => {
      var c;
      (c = t.current) === null || c === void 0 || c.close(u);
    }, o = (u) => {
      if (!t.current) {
        process.env.NODE_ENV !== "production" && n(!1, "usage", "You are calling notice in render which will break in React 18 concurrent mode. Please trigger in effect instead.");
        const S = () => {
        };
        return S.then = () => {
        }, S;
      }
      const {
        open: c,
        prefixCls: d,
        message: f
      } = t.current, h = `${d}-notice`, {
        content: p,
        icon: g,
        type: m,
        key: v,
        className: b,
        style: x,
        onClose: w
      } = u, C = wB(u, ["content", "icon", "type", "key", "className", "style", "onClose"]);
      let y = v;
      return y == null && (ex += 1, y = `antd-message-${ex}`), Nw((S) => (c(Object.assign(Object.assign({}, C), {
        key: y,
        content: /* @__PURE__ */ O.createElement(__, {
          prefixCls: d,
          type: m,
          icon: g
        }, p),
        placement: "top",
        className: se(m && `${h}-${m}`, b, f == null ? void 0 : f.className),
        style: Object.assign(Object.assign({}, f == null ? void 0 : f.style), x),
        onClose: () => {
          w == null || w(), S();
        }
      })), () => {
        i(y);
      }));
    }, a = {
      open: o,
      destroy: (u) => {
        var c;
        u !== void 0 ? i(u) : (c = t.current) === null || c === void 0 || c.destroy();
      }
    };
    return ["info", "success", "warning", "error", "loading"].forEach((u) => {
      const c = (d, f, h) => {
        let p;
        d && typeof d == "object" && "content" in d ? p = d : p = {
          content: d
        };
        let g, m;
        typeof f == "function" ? m = f : (g = f, m = h);
        const v = Object.assign(Object.assign({
          onClose: m,
          duration: g
        }, p), {
          type: u
        });
        return o(v);
      };
      a[u] = c;
    }), a;
  }, []), /* @__PURE__ */ O.createElement($B, Object.assign({
    key: "message-holder"
  }, e, {
    ref: t
  }))];
}
function OB(e) {
  return T_(e);
}
function AB() {
  const [e, t] = O.useState([]), n = O.useCallback((r) => (t((i) => [].concat(_e(i), [r])), () => {
    t((i) => i.filter((o) => o !== r));
  }), []);
  return [e, n];
}
function si() {
  si = function() {
    return t;
  };
  var e, t = {}, n = Object.prototype, r = n.hasOwnProperty, i = Object.defineProperty || function(I, k, P) {
    I[k] = P.value;
  }, o = typeof Symbol == "function" ? Symbol : {}, s = o.iterator || "@@iterator", a = o.asyncIterator || "@@asyncIterator", l = o.toStringTag || "@@toStringTag";
  function u(I, k, P) {
    return Object.defineProperty(I, k, {
      value: P,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), I[k];
  }
  try {
    u({}, "");
  } catch {
    u = function(P, L, N) {
      return P[L] = N;
    };
  }
  function c(I, k, P, L) {
    var N = k && k.prototype instanceof v ? k : v, F = Object.create(N.prototype), B = new E(L || []);
    return i(F, "_invoke", {
      value: M(I, P, B)
    }), F;
  }
  function d(I, k, P) {
    try {
      return {
        type: "normal",
        arg: I.call(k, P)
      };
    } catch (L) {
      return {
        type: "throw",
        arg: L
      };
    }
  }
  t.wrap = c;
  var f = "suspendedStart", h = "suspendedYield", p = "executing", g = "completed", m = {};
  function v() {
  }
  function b() {
  }
  function x() {
  }
  var w = {};
  u(w, s, function() {
    return this;
  });
  var C = Object.getPrototypeOf, y = C && C(C(R([])));
  y && y !== n && r.call(y, s) && (w = y);
  var S = x.prototype = v.prototype = Object.create(w);
  function A(I) {
    ["next", "throw", "return"].forEach(function(k) {
      u(I, k, function(P) {
        return this._invoke(k, P);
      });
    });
  }
  function $(I, k) {
    function P(N, F, B, j) {
      var z = d(I[N], I, F);
      if (z.type !== "throw") {
        var H = z.arg, W = H.value;
        return W && wt(W) == "object" && r.call(W, "__await") ? k.resolve(W.__await).then(function(G) {
          P("next", G, B, j);
        }, function(G) {
          P("throw", G, B, j);
        }) : k.resolve(W).then(function(G) {
          H.value = G, B(H);
        }, function(G) {
          return P("throw", G, B, j);
        });
      }
      j(z.arg);
    }
    var L;
    i(this, "_invoke", {
      value: function(F, B) {
        function j() {
          return new k(function(z, H) {
            P(F, B, z, H);
          });
        }
        return L = L ? L.then(j, j) : j();
      }
    });
  }
  function M(I, k, P) {
    var L = f;
    return function(N, F) {
      if (L === p)
        throw Error("Generator is already running");
      if (L === g) {
        if (N === "throw")
          throw F;
        return {
          value: e,
          done: !0
        };
      }
      for (P.method = N, P.arg = F; ; ) {
        var B = P.delegate;
        if (B) {
          var j = _(B, P);
          if (j) {
            if (j === m)
              continue;
            return j;
          }
        }
        if (P.method === "next")
          P.sent = P._sent = P.arg;
        else if (P.method === "throw") {
          if (L === f)
            throw L = g, P.arg;
          P.dispatchException(P.arg);
        } else
          P.method === "return" && P.abrupt("return", P.arg);
        L = p;
        var z = d(I, k, P);
        if (z.type === "normal") {
          if (L = P.done ? g : h, z.arg === m)
            continue;
          return {
            value: z.arg,
            done: P.done
          };
        }
        z.type === "throw" && (L = g, P.method = "throw", P.arg = z.arg);
      }
    };
  }
  function _(I, k) {
    var P = k.method, L = I.iterator[P];
    if (L === e)
      return k.delegate = null, P === "throw" && I.iterator.return && (k.method = "return", k.arg = e, _(I, k), k.method === "throw") || P !== "return" && (k.method = "throw", k.arg = new TypeError("The iterator does not provide a '" + P + "' method")), m;
    var N = d(L, I.iterator, k.arg);
    if (N.type === "throw")
      return k.method = "throw", k.arg = N.arg, k.delegate = null, m;
    var F = N.arg;
    return F ? F.done ? (k[I.resultName] = F.value, k.next = I.nextLoc, k.method !== "return" && (k.method = "next", k.arg = e), k.delegate = null, m) : F : (k.method = "throw", k.arg = new TypeError("iterator result is not an object"), k.delegate = null, m);
  }
  function T(I) {
    var k = {
      tryLoc: I[0]
    };
    1 in I && (k.catchLoc = I[1]), 2 in I && (k.finallyLoc = I[2], k.afterLoc = I[3]), this.tryEntries.push(k);
  }
  function D(I) {
    var k = I.completion || {};
    k.type = "normal", delete k.arg, I.completion = k;
  }
  function E(I) {
    this.tryEntries = [{
      tryLoc: "root"
    }], I.forEach(T, this), this.reset(!0);
  }
  function R(I) {
    if (I || I === "") {
      var k = I[s];
      if (k)
        return k.call(I);
      if (typeof I.next == "function")
        return I;
      if (!isNaN(I.length)) {
        var P = -1, L = function N() {
          for (; ++P < I.length; )
            if (r.call(I, P))
              return N.value = I[P], N.done = !1, N;
          return N.value = e, N.done = !0, N;
        };
        return L.next = L;
      }
    }
    throw new TypeError(wt(I) + " is not iterable");
  }
  return b.prototype = x, i(S, "constructor", {
    value: x,
    configurable: !0
  }), i(x, "constructor", {
    value: b,
    configurable: !0
  }), b.displayName = u(x, l, "GeneratorFunction"), t.isGeneratorFunction = function(I) {
    var k = typeof I == "function" && I.constructor;
    return !!k && (k === b || (k.displayName || k.name) === "GeneratorFunction");
  }, t.mark = function(I) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(I, x) : (I.__proto__ = x, u(I, l, "GeneratorFunction")), I.prototype = Object.create(S), I;
  }, t.awrap = function(I) {
    return {
      __await: I
    };
  }, A($.prototype), u($.prototype, a, function() {
    return this;
  }), t.AsyncIterator = $, t.async = function(I, k, P, L, N) {
    N === void 0 && (N = Promise);
    var F = new $(c(I, k, P, L), N);
    return t.isGeneratorFunction(k) ? F : F.next().then(function(B) {
      return B.done ? B.value : F.next();
    });
  }, A(S), u(S, l, "Generator"), u(S, s, function() {
    return this;
  }), u(S, "toString", function() {
    return "[object Generator]";
  }), t.keys = function(I) {
    var k = Object(I), P = [];
    for (var L in k)
      P.push(L);
    return P.reverse(), function N() {
      for (; P.length; ) {
        var F = P.pop();
        if (F in k)
          return N.value = F, N.done = !1, N;
      }
      return N.done = !0, N;
    };
  }, t.values = R, E.prototype = {
    constructor: E,
    reset: function(k) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(D), !k)
        for (var P in this)
          P.charAt(0) === "t" && r.call(this, P) && !isNaN(+P.slice(1)) && (this[P] = e);
    },
    stop: function() {
      this.done = !0;
      var k = this.tryEntries[0].completion;
      if (k.type === "throw")
        throw k.arg;
      return this.rval;
    },
    dispatchException: function(k) {
      if (this.done)
        throw k;
      var P = this;
      function L(H, W) {
        return B.type = "throw", B.arg = k, P.next = H, W && (P.method = "next", P.arg = e), !!W;
      }
      for (var N = this.tryEntries.length - 1; N >= 0; --N) {
        var F = this.tryEntries[N], B = F.completion;
        if (F.tryLoc === "root")
          return L("end");
        if (F.tryLoc <= this.prev) {
          var j = r.call(F, "catchLoc"), z = r.call(F, "finallyLoc");
          if (j && z) {
            if (this.prev < F.catchLoc)
              return L(F.catchLoc, !0);
            if (this.prev < F.finallyLoc)
              return L(F.finallyLoc);
          } else if (j) {
            if (this.prev < F.catchLoc)
              return L(F.catchLoc, !0);
          } else {
            if (!z)
              throw Error("try statement without catch or finally");
            if (this.prev < F.finallyLoc)
              return L(F.finallyLoc);
          }
        }
      }
    },
    abrupt: function(k, P) {
      for (var L = this.tryEntries.length - 1; L >= 0; --L) {
        var N = this.tryEntries[L];
        if (N.tryLoc <= this.prev && r.call(N, "finallyLoc") && this.prev < N.finallyLoc) {
          var F = N;
          break;
        }
      }
      F && (k === "break" || k === "continue") && F.tryLoc <= P && P <= F.finallyLoc && (F = null);
      var B = F ? F.completion : {};
      return B.type = k, B.arg = P, F ? (this.method = "next", this.next = F.finallyLoc, m) : this.complete(B);
    },
    complete: function(k, P) {
      if (k.type === "throw")
        throw k.arg;
      return k.type === "break" || k.type === "continue" ? this.next = k.arg : k.type === "return" ? (this.rval = this.arg = k.arg, this.method = "return", this.next = "end") : k.type === "normal" && P && (this.next = P), m;
    },
    finish: function(k) {
      for (var P = this.tryEntries.length - 1; P >= 0; --P) {
        var L = this.tryEntries[P];
        if (L.finallyLoc === k)
          return this.complete(L.completion, L.afterLoc), D(L), m;
      }
    },
    catch: function(k) {
      for (var P = this.tryEntries.length - 1; P >= 0; --P) {
        var L = this.tryEntries[P];
        if (L.tryLoc === k) {
          var N = L.completion;
          if (N.type === "throw") {
            var F = N.arg;
            D(L);
          }
          return F;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function(k, P, L) {
      return this.delegate = {
        iterator: R(k),
        resultName: P,
        nextLoc: L
      }, this.method === "next" && (this.arg = e), m;
    }
  }, t;
}
function tx(e, t, n, r, i, o, s) {
  try {
    var a = e[o](s), l = a.value;
  } catch (u) {
    n(u);
    return;
  }
  a.done ? t(l) : Promise.resolve(l).then(r, i);
}
function Cl(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, i) {
      var o = e.apply(t, n);
      function s(l) {
        tx(o, r, i, s, a, "next", l);
      }
      function a(l) {
        tx(o, r, i, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
var pf = ie({}, aF), DB = pf.version, _B = pf.render, TB = pf.unmountComponentAtNode, Ng;
try {
  var RB = Number((DB || "").split(".")[0]);
  RB >= 18 && (Ng = pf.createRoot);
} catch {
}
function nx(e) {
  var t = pf.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  t && wt(t) === "object" && (t.usingClientEntryPoint = e);
}
var Dp = "__rc_react_root__";
function MB(e, t) {
  nx(!0);
  var n = t[Dp] || Ng(t);
  nx(!1), n.render(e), t[Dp] = n;
}
function IB(e, t) {
  _B(e, t);
}
function Lg(e, t) {
  if (Ng) {
    MB(e, t);
    return;
  }
  IB(e, t);
}
function kB(e) {
  return ab.apply(this, arguments);
}
function ab() {
  return ab = Cl(/* @__PURE__ */ si().mark(function e(t) {
    return si().wrap(function(r) {
      for (; ; )
        switch (r.prev = r.next) {
          case 0:
            return r.abrupt("return", Promise.resolve().then(function() {
              var i;
              (i = t[Dp]) === null || i === void 0 || i.unmount(), delete t[Dp];
            }));
          case 1:
          case "end":
            return r.stop();
        }
    }, e);
  })), ab.apply(this, arguments);
}
function PB(e) {
  TB(e);
}
function R_(e) {
  return lb.apply(this, arguments);
}
function lb() {
  return lb = Cl(/* @__PURE__ */ si().mark(function e(t) {
    return si().wrap(function(r) {
      for (; ; )
        switch (r.prev = r.next) {
          case 0:
            if (Ng === void 0) {
              r.next = 2;
              break;
            }
            return r.abrupt("return", kB(t));
          case 2:
            PB(t);
          case 3:
          case "end":
            return r.stop();
        }
    }, e);
  })), lb.apply(this, arguments);
}
const qm = () => ({
  height: 0,
  opacity: 0
}), rx = (e) => {
  const {
    scrollHeight: t
  } = e;
  return {
    height: t,
    opacity: 1
  };
}, NB = (e) => ({
  height: e ? e.offsetHeight : 0
}), Qm = (e, t) => (t == null ? void 0 : t.deadline) === !0 || t.propertyName === "height", cb = function() {
  return {
    motionName: `${arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant"}-motion-collapse`,
    onAppearStart: qm,
    onEnterStart: qm,
    onAppearActive: rx,
    onEnterActive: rx,
    onLeaveStart: NB,
    onLeaveActive: qm,
    onAppearEnd: Qm,
    onEnterEnd: Qm,
    onLeaveEnd: Qm,
    motionDeadline: 500
  };
}, Xo = (e, t, n) => n !== void 0 ? n : `${e}-${t}`, Fg = function(e) {
  if (!e)
    return !1;
  if (e instanceof Element) {
    if (e.offsetParent)
      return !0;
    if (e.getBBox) {
      var t = e.getBBox(), n = t.width, r = t.height;
      if (n || r)
        return !0;
    }
    if (e.getBoundingClientRect) {
      var i = e.getBoundingClientRect(), o = i.width, s = i.height;
      if (o || s)
        return !0;
    }
  }
  return !1;
}, LB = (e) => {
  const {
    componentCls: t,
    colorPrimary: n
  } = e;
  return {
    [t]: {
      position: "absolute",
      background: "transparent",
      pointerEvents: "none",
      boxSizing: "border-box",
      color: `var(--wave-color, ${n})`,
      boxShadow: "0 0 0 0 currentcolor",
      opacity: 0.2,
      // =================== Motion ===================
      "&.wave-motion-appear": {
        transition: [`box-shadow 0.4s ${e.motionEaseOutCirc}`, `opacity 2s ${e.motionEaseOutCirc}`].join(","),
        "&-active": {
          boxShadow: "0 0 0 6px currentcolor",
          opacity: 0
        },
        "&.wave-quick": {
          transition: [`box-shadow ${e.motionDurationSlow} ${e.motionEaseInOut}`, `opacity ${e.motionDurationSlow} ${e.motionEaseInOut}`].join(",")
        }
      }
    }
  };
}, FB = Mg("Wave", (e) => [LB(e)]), Lw = "ant-wave-target";
function BB(e) {
  const t = (e || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  return t && t[1] && t[2] && t[3] ? !(t[1] === t[2] && t[2] === t[3]) : !0;
}
function Zm(e) {
  return e && e !== "#fff" && e !== "#ffffff" && e !== "rgb(255, 255, 255)" && e !== "rgba(255, 255, 255, 1)" && BB(e) && !/rgba\((?:\d*, ){3}0\)/.test(e) && // any transparent rgba color
  e !== "transparent";
}
function jB(e) {
  const {
    borderTopColor: t,
    borderColor: n,
    backgroundColor: r
  } = getComputedStyle(e);
  return Zm(t) ? t : Zm(n) ? n : Zm(r) ? r : null;
}
function Jm(e) {
  return Number.isNaN(e) ? 0 : e;
}
const zB = (e) => {
  const {
    className: t,
    target: n,
    component: r
  } = e, i = O.useRef(null), [o, s] = O.useState(null), [a, l] = O.useState([]), [u, c] = O.useState(0), [d, f] = O.useState(0), [h, p] = O.useState(0), [g, m] = O.useState(0), [v, b] = O.useState(!1), x = {
    left: u,
    top: d,
    width: h,
    height: g,
    borderRadius: a.map((y) => `${y}px`).join(" ")
  };
  o && (x["--wave-color"] = o);
  function w() {
    const y = getComputedStyle(n);
    s(jB(n));
    const S = y.position === "static", {
      borderLeftWidth: A,
      borderTopWidth: $
    } = y;
    c(S ? n.offsetLeft : Jm(-parseFloat(A))), f(S ? n.offsetTop : Jm(-parseFloat($))), p(n.offsetWidth), m(n.offsetHeight);
    const {
      borderTopLeftRadius: M,
      borderTopRightRadius: _,
      borderBottomLeftRadius: T,
      borderBottomRightRadius: D
    } = y;
    l([M, _, D, T].map((E) => Jm(parseFloat(E))));
  }
  if (O.useEffect(() => {
    if (n) {
      const y = rn(() => {
        w(), b(!0);
      });
      let S;
      return typeof ResizeObserver < "u" && (S = new ResizeObserver(w), S.observe(n)), () => {
        rn.cancel(y), S == null || S.disconnect();
      };
    }
  }, []), !v)
    return null;
  const C = (r === "Checkbox" || r === "Radio") && (n == null ? void 0 : n.classList.contains(Lw));
  return /* @__PURE__ */ O.createElement(qo, {
    visible: !0,
    motionAppear: !0,
    motionName: "wave-motion",
    motionDeadline: 5e3,
    onAppearEnd: (y, S) => {
      var A;
      if (S.deadline || S.propertyName === "opacity") {
        const $ = (A = i.current) === null || A === void 0 ? void 0 : A.parentElement;
        R_($).then(() => {
          $ == null || $.remove();
        });
      }
      return !1;
    }
  }, (y) => {
    let {
      className: S
    } = y;
    return /* @__PURE__ */ O.createElement("div", {
      ref: i,
      className: se(t, {
        "wave-quick": C
      }, S),
      style: x
    });
  });
}, HB = (e, t) => {
  var n;
  const {
    component: r
  } = t;
  if (r === "Checkbox" && !(!((n = e.querySelector("input")) === null || n === void 0) && n.checked))
    return;
  const i = document.createElement("div");
  i.style.position = "absolute", i.style.left = "0px", i.style.top = "0px", e == null || e.insertBefore(i, e == null ? void 0 : e.firstChild), Lg(/* @__PURE__ */ O.createElement(zB, Object.assign({}, t, {
    target: e
  })), i);
}, VB = (e, t, n) => {
  const {
    wave: r
  } = O.useContext(rt), [, i, o] = Sr(), s = Nn((u) => {
    const c = e.current;
    if (r != null && r.disabled || !c)
      return;
    const d = c.querySelector(`.${Lw}`) || c, {
      showEffect: f
    } = r || {};
    (f || HB)(d, {
      className: t,
      token: i,
      component: n,
      event: u,
      hashId: o
    });
  }), a = O.useRef();
  return (u) => {
    rn.cancel(a.current), a.current = rn(() => {
      s(u);
    });
  };
}, Fw = (e) => {
  const {
    children: t,
    disabled: n,
    component: r
  } = e, {
    getPrefixCls: i
  } = Yt(rt), o = he(null), s = i("wave"), [, a] = FB(s), l = VB(o, se(s, a), r);
  if (U.useEffect(() => {
    const c = o.current;
    if (!c || c.nodeType !== 1 || n)
      return;
    const d = (f) => {
      !Fg(f.target) || // No need wave
      !c.getAttribute || c.getAttribute("disabled") || c.disabled || c.className.includes("disabled") || c.className.includes("-leave") || l(f);
    };
    return c.addEventListener("click", d, !0), () => {
      c.removeEventListener("click", d, !0);
    };
  }, [n]), !/* @__PURE__ */ U.isValidElement(t))
    return t ?? null;
  const u = Ms(t) ? xi(t.ref, o) : o;
  return oi(t, {
    ref: u
  });
};
process.env.NODE_ENV !== "production" && (Fw.displayName = "Wave");
const so = (e) => {
  const t = U.useContext(Qa);
  return U.useMemo(() => e ? typeof e == "string" ? e ?? t : e instanceof Function ? e(t) : t : t, [e, t]);
}, WB = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      "&-block": {
        display: "flex",
        width: "100%"
      },
      "&-vertical": {
        flexDirection: "column"
      }
    }
  };
}, UB = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e;
  return {
    [t]: {
      display: "inline-flex",
      "&-rtl": {
        direction: "rtl"
      },
      "&-vertical": {
        flexDirection: "column"
      },
      "&-align": {
        flexDirection: "column",
        "&-center": {
          alignItems: "center"
        },
        "&-start": {
          alignItems: "flex-start"
        },
        "&-end": {
          alignItems: "flex-end"
        },
        "&-baseline": {
          alignItems: "baseline"
        }
      },
      [`${t}-item:empty`]: {
        display: "none"
      },
      // https://github.com/ant-design/ant-design/issues/47875
      [`${t}-item > ${n}-badge-not-a-wrapper:only-child`]: {
        display: "block"
      }
    }
  };
}, GB = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      "&-gap-row-small": {
        rowGap: e.spaceGapSmallSize
      },
      "&-gap-row-middle": {
        rowGap: e.spaceGapMiddleSize
      },
      "&-gap-row-large": {
        rowGap: e.spaceGapLargeSize
      },
      "&-gap-col-small": {
        columnGap: e.spaceGapSmallSize
      },
      "&-gap-col-middle": {
        columnGap: e.spaceGapMiddleSize
      },
      "&-gap-col-large": {
        columnGap: e.spaceGapLargeSize
      }
    }
  };
}, M_ = $n("Space", (e) => {
  const t = Jt(e, {
    spaceGapSmallSize: e.paddingXS,
    spaceGapMiddleSize: e.padding,
    spaceGapLargeSize: e.paddingLG
  });
  return [UB(t), GB(t), WB(t)];
}, () => ({}), {
  // Space component don't apply extra font style
  // https://github.com/ant-design/ant-design/issues/40315
  resetStyle: !1
});
var I_ = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const Bg = /* @__PURE__ */ O.createContext(null), Jc = (e, t) => {
  const n = O.useContext(Bg), r = O.useMemo(() => {
    if (!n)
      return "";
    const {
      compactDirection: i,
      isFirstItem: o,
      isLastItem: s
    } = n, a = i === "vertical" ? "-vertical-" : "-";
    return se(`${e}-compact${a}item`, {
      [`${e}-compact${a}first-item`]: o,
      [`${e}-compact${a}last-item`]: s,
      [`${e}-compact${a}item-rtl`]: t === "rtl"
    });
  }, [e, t, n]);
  return {
    compactSize: n == null ? void 0 : n.compactSize,
    compactDirection: n == null ? void 0 : n.compactDirection,
    compactItemClassnames: r
  };
}, wd = (e) => {
  let {
    children: t
  } = e;
  return /* @__PURE__ */ O.createElement(Bg.Provider, {
    value: null
  }, t);
}, KB = (e) => {
  var {
    children: t
  } = e, n = I_(e, ["children"]);
  return /* @__PURE__ */ O.createElement(Bg.Provider, {
    value: n
  }, t);
}, XB = (e) => {
  const {
    getPrefixCls: t,
    direction: n
  } = O.useContext(rt), {
    size: r,
    direction: i,
    block: o,
    prefixCls: s,
    className: a,
    rootClassName: l,
    children: u
  } = e, c = I_(e, ["size", "direction", "block", "prefixCls", "className", "rootClassName", "children"]), d = so((x) => r ?? x), f = t("space-compact", s), [h, p] = M_(f), g = se(f, p, {
    [`${f}-rtl`]: n === "rtl",
    [`${f}-block`]: o,
    [`${f}-vertical`]: i === "vertical"
  }, a, l), m = O.useContext(Bg), v = Xr(u), b = O.useMemo(() => v.map((x, w) => {
    const C = x && x.key || `${f}-item-${w}`;
    return /* @__PURE__ */ O.createElement(KB, {
      key: C,
      compactSize: d,
      compactDirection: i,
      isFirstItem: w === 0 && (!m || (m == null ? void 0 : m.isFirstItem)),
      isLastItem: w === v.length - 1 && (!m || (m == null ? void 0 : m.isLastItem))
    }, x);
  }), [r, v, m]);
  return v.length === 0 ? null : h(/* @__PURE__ */ O.createElement("div", Object.assign({
    className: g
  }, c), b));
};
var YB = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const k_ = /* @__PURE__ */ O.createContext(void 0), qB = (e) => {
  const {
    getPrefixCls: t,
    direction: n
  } = O.useContext(rt), {
    prefixCls: r,
    size: i,
    className: o
  } = e, s = YB(e, ["prefixCls", "size", "className"]), a = t("btn-group", r), [, , l] = Sr();
  let u = "";
  switch (i) {
    case "large":
      u = "lg";
      break;
    case "small":
      u = "sm";
      break;
  }
  if (process.env.NODE_ENV !== "production") {
    const d = Zt("Button.Group");
    process.env.NODE_ENV !== "production" && d(!i || ["large", "small", "middle"].includes(i), "usage", "Invalid prop `size`.");
  }
  const c = se(a, {
    [`${a}-${u}`]: u,
    [`${a}-rtl`]: n === "rtl"
  }, o, l);
  return /* @__PURE__ */ O.createElement(k_.Provider, {
    value: i
  }, /* @__PURE__ */ O.createElement("div", Object.assign({}, s, {
    className: c
  })));
}, ix = /^[\u4e00-\u9fa5]{2}$/, ub = ix.test.bind(ix);
function Bw(e) {
  return e === "danger" ? {
    danger: !0
  } : {
    type: e
  };
}
function ox(e) {
  return typeof e == "string";
}
function Qf(e) {
  return e === "text" || e === "link";
}
function QB(e, t) {
  if (e == null)
    return;
  const n = t ? " " : "";
  return typeof e != "string" && typeof e != "number" && ox(e.type) && ub(e.props.children) ? oi(e, {
    children: e.props.children.split("").join(n)
  }) : ox(e) ? ub(e) ? /* @__PURE__ */ U.createElement("span", null, e.split("").join(n)) : /* @__PURE__ */ U.createElement("span", null, e) : C_(e) ? /* @__PURE__ */ U.createElement("span", null, e) : e;
}
function ZB(e, t) {
  let n = !1;
  const r = [];
  return U.Children.forEach(e, (i) => {
    const o = typeof i, s = o === "string" || o === "number";
    if (n && s) {
      const a = r.length - 1, l = r[a];
      r[a] = `${l}${i}`;
    } else
      r.push(i);
    n = s;
  }), U.Children.map(r, (i) => QB(i, t));
}
const P_ = /* @__PURE__ */ li((e, t) => {
  const {
    className: n,
    style: r,
    children: i,
    prefixCls: o
  } = e, s = se(`${o}-icon`, n);
  return /* @__PURE__ */ U.createElement("span", {
    ref: t,
    className: s,
    style: r
  }, i);
}), sx = /* @__PURE__ */ li((e, t) => {
  let {
    prefixCls: n,
    className: r,
    style: i,
    iconClassName: o
  } = e;
  const s = se(`${n}-loading-icon`, r);
  return /* @__PURE__ */ U.createElement(P_, {
    prefixCls: n,
    className: s,
    style: i,
    ref: t
  }, /* @__PURE__ */ U.createElement(wl, {
    className: o
  }));
}), ev = () => ({
  width: 0,
  opacity: 0,
  transform: "scale(0)"
}), tv = (e) => ({
  width: e.scrollWidth,
  opacity: 1,
  transform: "scale(1)"
}), JB = (e) => {
  const {
    prefixCls: t,
    loading: n,
    existIcon: r,
    className: i,
    style: o
  } = e, s = !!n;
  return r ? /* @__PURE__ */ U.createElement(sx, {
    prefixCls: t,
    className: i,
    style: o
  }) : /* @__PURE__ */ U.createElement(qo, {
    visible: s,
    // We do not really use this motionName
    motionName: `${t}-loading-icon-motion`,
    motionLeave: s,
    removeOnLeave: !0,
    onAppearStart: ev,
    onAppearActive: tv,
    onEnterStart: ev,
    onEnterActive: tv,
    onLeaveStart: tv,
    onLeaveActive: ev
  }, (a, l) => {
    let {
      className: u,
      style: c
    } = a;
    return /* @__PURE__ */ U.createElement(sx, {
      prefixCls: t,
      className: i,
      style: Object.assign(Object.assign({}, o), c),
      ref: l,
      iconClassName: u
    });
  });
}, ax = (e, t) => ({
  // Border
  [`> span, > ${e}`]: {
    "&:not(:last-child)": {
      [`&, & > ${e}`]: {
        "&:not(:disabled)": {
          borderInlineEndColor: t
        }
      }
    },
    "&:not(:first-child)": {
      [`&, & > ${e}`]: {
        "&:not(:disabled)": {
          borderInlineStartColor: t
        }
      }
    }
  }
}), e6 = (e) => {
  const {
    componentCls: t,
    fontSize: n,
    lineWidth: r,
    groupBorderColor: i,
    colorErrorHover: o
  } = e;
  return {
    [`${t}-group`]: [
      {
        position: "relative",
        display: "inline-flex",
        // Border
        [`> span, > ${t}`]: {
          "&:not(:last-child)": {
            [`&, & > ${t}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          "&:not(:first-child)": {
            marginInlineStart: e.calc(r).mul(-1).equal(),
            [`&, & > ${t}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        },
        [t]: {
          position: "relative",
          zIndex: 1,
          "&:hover,\n          &:focus,\n          &:active": {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        },
        [`${t}-icon-only`]: {
          fontSize: n
        }
      },
      // Border Color
      ax(`${t}-primary`, i),
      ax(`${t}-danger`, o)
    ]
  };
}, N_ = (e) => {
  const {
    paddingInline: t,
    onlyIconSize: n,
    paddingBlock: r
  } = e;
  return Jt(e, {
    buttonPaddingHorizontal: t,
    buttonPaddingVertical: r,
    buttonIconOnlyFontSize: n
  });
}, L_ = (e) => {
  var t, n, r, i, o, s;
  const a = (t = e.contentFontSize) !== null && t !== void 0 ? t : e.fontSize, l = (n = e.contentFontSizeSM) !== null && n !== void 0 ? n : e.fontSize, u = (r = e.contentFontSizeLG) !== null && r !== void 0 ? r : e.fontSizeLG, c = (i = e.contentLineHeight) !== null && i !== void 0 ? i : Zh(a), d = (o = e.contentLineHeightSM) !== null && o !== void 0 ? o : Zh(l), f = (s = e.contentLineHeightLG) !== null && s !== void 0 ? s : Zh(u);
  return {
    fontWeight: 400,
    defaultShadow: `0 ${e.controlOutlineWidth}px 0 ${e.controlTmpOutline}`,
    primaryShadow: `0 ${e.controlOutlineWidth}px 0 ${e.controlOutline}`,
    dangerShadow: `0 ${e.controlOutlineWidth}px 0 ${e.colorErrorOutline}`,
    primaryColor: e.colorTextLightSolid,
    dangerColor: e.colorTextLightSolid,
    borderColorDisabled: e.colorBorder,
    defaultGhostColor: e.colorBgContainer,
    ghostBg: "transparent",
    defaultGhostBorderColor: e.colorBgContainer,
    paddingInline: e.paddingContentHorizontal - e.lineWidth,
    paddingInlineLG: e.paddingContentHorizontal - e.lineWidth,
    paddingInlineSM: 8 - e.lineWidth,
    onlyIconSize: e.fontSizeLG,
    onlyIconSizeSM: e.fontSizeLG - 2,
    onlyIconSizeLG: e.fontSizeLG + 2,
    groupBorderColor: e.colorPrimaryHover,
    linkHoverBg: "transparent",
    textHoverBg: e.colorBgTextHover,
    defaultColor: e.colorText,
    defaultBg: e.colorBgContainer,
    defaultBorderColor: e.colorBorder,
    defaultBorderColorDisabled: e.colorBorder,
    defaultHoverBg: e.colorBgContainer,
    defaultHoverColor: e.colorPrimaryHover,
    defaultHoverBorderColor: e.colorPrimaryHover,
    defaultActiveBg: e.colorBgContainer,
    defaultActiveColor: e.colorPrimaryActive,
    defaultActiveBorderColor: e.colorPrimaryActive,
    contentFontSize: a,
    contentFontSizeSM: l,
    contentFontSizeLG: u,
    contentLineHeight: c,
    contentLineHeightSM: d,
    contentLineHeightLG: f,
    paddingBlock: Math.max((e.controlHeight - a * c) / 2 - e.lineWidth, 0),
    paddingBlockSM: Math.max((e.controlHeightSM - l * d) / 2 - e.lineWidth, 0),
    paddingBlockLG: Math.max((e.controlHeightLG - u * f) / 2 - e.lineWidth, 0)
  };
}, t6 = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    fontWeight: r
  } = e;
  return {
    [t]: {
      outline: "none",
      position: "relative",
      display: "inline-block",
      fontWeight: r,
      whiteSpace: "nowrap",
      textAlign: "center",
      backgroundImage: "none",
      background: "transparent",
      border: `${le(e.lineWidth)} ${e.lineType} transparent`,
      cursor: "pointer",
      transition: `all ${e.motionDurationMid} ${e.motionEaseInOut}`,
      userSelect: "none",
      touchAction: "manipulation",
      color: e.colorText,
      "&:disabled > *": {
        pointerEvents: "none"
      },
      "> span": {
        display: "inline-block"
      },
      [`${t}-icon`]: {
        lineHeight: 0
      },
      // Leave a space between icon and text.
      [`> ${n} + span, > span + ${n}`]: {
        marginInlineStart: e.marginXS
      },
      [`&:not(${t}-icon-only) > ${t}-icon`]: {
        [`&${t}-loading-icon, &:not(:last-child)`]: {
          marginInlineEnd: e.marginXS
        }
      },
      "> a": {
        color: "currentColor"
      },
      "&:not(:disabled)": Object.assign({}, Za(e)),
      [`&${t}-two-chinese-chars::first-letter`]: {
        letterSpacing: "0.34em"
      },
      [`&${t}-two-chinese-chars > *:not(${n})`]: {
        marginInlineEnd: "-0.34em",
        letterSpacing: "0.34em"
      },
      // make `btn-icon-only` not too narrow
      [`&-icon-only${t}-compact-item`]: {
        flex: "none"
      }
    }
  };
}, Os = (e, t, n) => ({
  [`&:not(:disabled):not(${e}-disabled)`]: {
    "&:hover": t,
    "&:active": n
  }
}), n6 = (e) => ({
  minWidth: e.controlHeight,
  paddingInlineStart: 0,
  paddingInlineEnd: 0,
  borderRadius: "50%"
}), r6 = (e) => ({
  borderRadius: e.controlHeight,
  paddingInlineStart: e.calc(e.controlHeight).div(2).equal(),
  paddingInlineEnd: e.calc(e.controlHeight).div(2).equal()
}), i6 = (e) => ({
  cursor: "not-allowed",
  borderColor: e.borderColorDisabled,
  color: e.colorTextDisabled,
  background: e.colorBgContainerDisabled,
  boxShadow: "none"
}), Cd = (e, t, n, r, i, o, s, a) => ({
  [`&${e}-background-ghost`]: Object.assign(Object.assign({
    color: n || void 0,
    background: t,
    borderColor: r || void 0,
    boxShadow: "none"
  }, Os(e, Object.assign({
    background: t
  }, s), Object.assign({
    background: t
  }, a))), {
    "&:disabled": {
      cursor: "not-allowed",
      color: i || void 0,
      borderColor: o || void 0
    }
  })
}), jw = (e) => ({
  [`&:disabled, &${e.componentCls}-disabled`]: Object.assign({}, i6(e))
}), F_ = (e) => Object.assign({}, jw(e)), _p = (e) => ({
  [`&:disabled, &${e.componentCls}-disabled`]: {
    cursor: "not-allowed",
    color: e.colorTextDisabled
  }
}), B_ = (e) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, F_(e)), {
  background: e.defaultBg,
  borderColor: e.defaultBorderColor,
  color: e.defaultColor,
  boxShadow: e.defaultShadow
}), Os(e.componentCls, {
  color: e.defaultHoverColor,
  borderColor: e.defaultHoverBorderColor,
  background: e.defaultHoverBg
}, {
  color: e.defaultActiveColor,
  borderColor: e.defaultActiveBorderColor,
  background: e.defaultActiveBg
})), Cd(e.componentCls, e.ghostBg, e.defaultGhostColor, e.defaultGhostBorderColor, e.colorTextDisabled, e.colorBorder)), {
  [`&${e.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
    color: e.colorError,
    borderColor: e.colorError
  }, Os(e.componentCls, {
    color: e.colorErrorHover,
    borderColor: e.colorErrorBorderHover
  }, {
    color: e.colorErrorActive,
    borderColor: e.colorErrorActive
  })), Cd(e.componentCls, e.ghostBg, e.colorError, e.colorError, e.colorTextDisabled, e.colorBorder)), jw(e))
}), o6 = (e) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, F_(e)), {
  color: e.primaryColor,
  background: e.colorPrimary,
  boxShadow: e.primaryShadow
}), Os(e.componentCls, {
  color: e.colorTextLightSolid,
  background: e.colorPrimaryHover
}, {
  color: e.colorTextLightSolid,
  background: e.colorPrimaryActive
})), Cd(e.componentCls, e.ghostBg, e.colorPrimary, e.colorPrimary, e.colorTextDisabled, e.colorBorder, {
  color: e.colorPrimaryHover,
  borderColor: e.colorPrimaryHover
}, {
  color: e.colorPrimaryActive,
  borderColor: e.colorPrimaryActive
})), {
  [`&${e.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
    background: e.colorError,
    boxShadow: e.dangerShadow,
    color: e.dangerColor
  }, Os(e.componentCls, {
    background: e.colorErrorHover
  }, {
    background: e.colorErrorActive
  })), Cd(e.componentCls, e.ghostBg, e.colorError, e.colorError, e.colorTextDisabled, e.colorBorder, {
    color: e.colorErrorHover,
    borderColor: e.colorErrorHover
  }, {
    color: e.colorErrorActive,
    borderColor: e.colorErrorActive
  })), jw(e))
}), s6 = (e) => Object.assign(Object.assign({}, B_(e)), {
  borderStyle: "dashed"
}), a6 = (e) => Object.assign(Object.assign(Object.assign({
  color: e.colorLink
}, Os(e.componentCls, {
  color: e.colorLinkHover,
  background: e.linkHoverBg
}, {
  color: e.colorLinkActive
})), _p(e)), {
  [`&${e.componentCls}-dangerous`]: Object.assign(Object.assign({
    color: e.colorError
  }, Os(e.componentCls, {
    color: e.colorErrorHover
  }, {
    color: e.colorErrorActive
  })), _p(e))
}), l6 = (e) => Object.assign(Object.assign(Object.assign({}, Os(e.componentCls, {
  color: e.colorText,
  background: e.textHoverBg
}, {
  color: e.colorText,
  background: e.colorBgTextActive
})), _p(e)), {
  [`&${e.componentCls}-dangerous`]: Object.assign(Object.assign({
    color: e.colorError
  }, _p(e)), Os(e.componentCls, {
    color: e.colorErrorHover,
    background: e.colorErrorBg
  }, {
    color: e.colorErrorHover,
    background: e.colorErrorBg
  }))
}), c6 = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-default`]: B_(e),
    [`${t}-primary`]: o6(e),
    [`${t}-dashed`]: s6(e),
    [`${t}-link`]: a6(e),
    [`${t}-text`]: l6(e),
    [`${t}-ghost`]: Cd(e.componentCls, e.ghostBg, e.colorBgContainer, e.colorBgContainer, e.colorTextDisabled, e.colorBorder)
  };
}, zw = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  const {
    componentCls: n,
    controlHeight: r,
    fontSize: i,
    lineHeight: o,
    borderRadius: s,
    buttonPaddingHorizontal: a,
    iconCls: l,
    buttonPaddingVertical: u
  } = e, c = `${n}-icon-only`;
  return [
    {
      [`${t}`]: {
        fontSize: i,
        lineHeight: o,
        height: r,
        padding: `${le(u)} ${le(a)}`,
        borderRadius: s,
        [`&${c}`]: {
          display: "inline-flex",
          alignItems: "center",
          justifyContent: "center",
          width: r,
          paddingInlineStart: 0,
          paddingInlineEnd: 0,
          [`&${n}-round`]: {
            width: "auto"
          },
          [l]: {
            fontSize: e.buttonIconOnlyFontSize
          }
        },
        // Loading
        [`&${n}-loading`]: {
          opacity: e.opacityLoading,
          cursor: "default"
        },
        [`${n}-loading-icon`]: {
          transition: `width ${e.motionDurationSlow} ${e.motionEaseInOut}, opacity ${e.motionDurationSlow} ${e.motionEaseInOut}`
        }
      }
    },
    // Shape - patch prefixCls again to override solid border radius style
    {
      [`${n}${n}-circle${t}`]: n6(e)
    },
    {
      [`${n}${n}-round${t}`]: r6(e)
    }
  ];
}, u6 = (e) => {
  const t = Jt(e, {
    fontSize: e.contentFontSize,
    lineHeight: e.contentLineHeight
  });
  return zw(t, e.componentCls);
}, d6 = (e) => {
  const t = Jt(e, {
    controlHeight: e.controlHeightSM,
    fontSize: e.contentFontSizeSM,
    lineHeight: e.contentLineHeightSM,
    padding: e.paddingXS,
    buttonPaddingHorizontal: e.paddingInlineSM,
    buttonPaddingVertical: e.paddingBlockSM,
    borderRadius: e.borderRadiusSM,
    buttonIconOnlyFontSize: e.onlyIconSizeSM
  });
  return zw(t, `${e.componentCls}-sm`);
}, f6 = (e) => {
  const t = Jt(e, {
    controlHeight: e.controlHeightLG,
    fontSize: e.contentFontSizeLG,
    lineHeight: e.contentLineHeightLG,
    buttonPaddingHorizontal: e.paddingInlineLG,
    buttonPaddingVertical: e.paddingBlockLG,
    borderRadius: e.borderRadiusLG,
    buttonIconOnlyFontSize: e.onlyIconSizeLG
  });
  return zw(t, `${e.componentCls}-lg`);
}, h6 = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      [`&${t}-block`]: {
        width: "100%"
      }
    }
  };
}, p6 = $n("Button", (e) => {
  const t = N_(e);
  return [
    // Shared
    t6(t),
    // Size
    u6(t),
    d6(t),
    f6(t),
    // Block
    h6(t),
    // Group (type, ghost, danger, loading)
    c6(t),
    // Button Group
    e6(t)
  ];
}, L_, {
  unitless: {
    fontWeight: !0,
    contentLineHeight: !0,
    contentLineHeightSM: !0,
    contentLineHeightLG: !0
  }
});
function g6(e, t, n) {
  const {
    focusElCls: r,
    focus: i,
    borderElCls: o
  } = n, s = o ? "> *" : "", a = ["hover", i ? "focus" : null, "active"].filter(Boolean).map((l) => `&:${l} ${s}`).join(",");
  return {
    [`&-item:not(${t}-last-item)`]: {
      marginInlineEnd: e.calc(e.lineWidth).mul(-1).equal()
    },
    "&-item": Object.assign(Object.assign({
      [a]: {
        zIndex: 2
      }
    }, r ? {
      [`&${r}`]: {
        zIndex: 2
      }
    } : {}), {
      [`&[disabled] ${s}`]: {
        zIndex: 0
      }
    })
  };
}
function m6(e, t, n) {
  const {
    borderElCls: r
  } = n, i = r ? `> ${r}` : "";
  return {
    [`&-item:not(${t}-first-item):not(${t}-last-item) ${i}`]: {
      borderRadius: 0
    },
    [`&-item:not(${t}-last-item)${t}-first-item`]: {
      [`& ${i}, &${e}-sm ${i}, &${e}-lg ${i}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${t}-first-item)${t}-last-item`]: {
      [`& ${i}, &${e}-sm ${i}, &${e}-lg ${i}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
function jg(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    focus: !0
  };
  const {
    componentCls: n
  } = e, r = `${n}-compact`;
  return {
    [r]: Object.assign(Object.assign({}, g6(e, r, t)), m6(n, r, t))
  };
}
function v6(e, t) {
  return {
    // border collapse
    [`&-item:not(${t}-last-item)`]: {
      marginBottom: e.calc(e.lineWidth).mul(-1).equal()
    },
    "&-item": {
      "&:hover,&:focus,&:active": {
        zIndex: 2
      },
      "&[disabled]": {
        zIndex: 0
      }
    }
  };
}
function b6(e, t) {
  return {
    [`&-item:not(${t}-first-item):not(${t}-last-item)`]: {
      borderRadius: 0
    },
    [`&-item${t}-first-item:not(${t}-last-item)`]: {
      [`&, &${e}-sm, &${e}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&-item${t}-last-item:not(${t}-first-item)`]: {
      [`&, &${e}-sm, &${e}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0
      }
    }
  };
}
function y6(e) {
  const t = `${e.componentCls}-compact-vertical`;
  return {
    [t]: Object.assign(Object.assign({}, v6(e, t)), b6(e.componentCls, t))
  };
}
const w6 = (e) => {
  const {
    componentCls: t,
    calc: n
  } = e;
  return {
    [t]: {
      // Special styles for Primary Button
      [`&-compact-item${t}-primary`]: {
        [`&:not([disabled]) + ${t}-compact-item${t}-primary:not([disabled])`]: {
          position: "relative",
          "&:before": {
            position: "absolute",
            top: n(e.lineWidth).mul(-1).equal(),
            insetInlineStart: n(e.lineWidth).mul(-1).equal(),
            display: "inline-block",
            width: e.lineWidth,
            height: `calc(100% + ${le(e.lineWidth)} * 2)`,
            backgroundColor: e.colorPrimaryHover,
            content: '""'
          }
        }
      },
      // Special styles for Primary Button
      "&-compact-vertical-item": {
        [`&${t}-primary`]: {
          [`&:not([disabled]) + ${t}-compact-vertical-item${t}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: n(e.lineWidth).mul(-1).equal(),
              insetInlineStart: n(e.lineWidth).mul(-1).equal(),
              display: "inline-block",
              width: `calc(100% + ${le(e.lineWidth)} * 2)`,
              height: e.lineWidth,
              backgroundColor: e.colorPrimaryHover,
              content: '""'
            }
          }
        }
      }
    }
  };
}, C6 = Ig(["Button", "compact"], (e) => {
  const t = N_(e);
  return [
    // Space Compact
    jg(t),
    y6(t),
    w6(t)
  ];
}, L_);
var S6 = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
function x6(e) {
  if (typeof e == "object" && e) {
    let t = e == null ? void 0 : e.delay;
    return t = !Number.isNaN(t) && typeof t == "number" ? t : 0, {
      loading: t <= 0,
      delay: t
    };
  }
  return {
    loading: !!e,
    delay: 0
  };
}
const E6 = /* @__PURE__ */ U.forwardRef((e, t) => {
  var n, r;
  const {
    loading: i = !1,
    prefixCls: o,
    type: s,
    danger: a,
    shape: l = "default",
    size: u,
    styles: c,
    disabled: d,
    className: f,
    rootClassName: h,
    children: p,
    icon: g,
    ghost: m = !1,
    block: v = !1,
    // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
    htmlType: b = "button",
    classNames: x,
    style: w = {}
  } = e, C = S6(e, ["loading", "prefixCls", "type", "danger", "shape", "size", "styles", "disabled", "className", "rootClassName", "children", "icon", "ghost", "block", "htmlType", "classNames", "style"]), y = s || "default", {
    getPrefixCls: S,
    autoInsertSpaceInButton: A,
    direction: $,
    button: M
  } = Yt(rt), _ = S("btn", o), [T, D, E] = p6(_), R = Yt(Ko), I = d ?? R, k = Yt(k_), P = mt(() => x6(i), [i]), [L, N] = ht(P.loading), [F, B] = ht(!1), z = xi(t, /* @__PURE__ */ Uh()), H = oF.count(p) === 1 && !g && !Qf(y);
  Pe(() => {
    let Re = null;
    P.delay > 0 ? Re = setTimeout(() => {
      Re = null, N(!0);
    }, P.delay) : N(P.loading);
    function De() {
      Re && (clearTimeout(Re), Re = null);
    }
    return De;
  }, [P]), Pe(() => {
    if (!z || !z.current || A === !1)
      return;
    const Re = z.current.textContent;
    H && ub(Re) ? F || B(!0) : F && B(!1);
  }, [z]);
  const W = (Re) => {
    const {
      onClick: De
    } = e;
    if (L || I) {
      Re.preventDefault();
      return;
    }
    De == null || De(Re);
  };
  if (process.env.NODE_ENV !== "production") {
    const Re = Zt("Button");
    process.env.NODE_ENV !== "production" && Re(!(typeof g == "string" && g.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${g}\` at https://ant.design/components/icon`), process.env.NODE_ENV !== "production" && Re(!(m && Qf(y)), "usage", "`link` or `text` button can't be a `ghost` button.");
  }
  const G = A !== !1, {
    compactSize: K,
    compactItemClassnames: Y
  } = Jc(_, $), X = {
    large: "lg",
    small: "sm",
    middle: void 0
  }, Z = so((Re) => {
    var De, Me;
    return (Me = (De = u ?? K) !== null && De !== void 0 ? De : k) !== null && Me !== void 0 ? Me : Re;
  }), Q = Z && X[Z] || "", ne = L ? "loading" : g, q = zn(C, ["navigate"]), te = se(_, D, E, {
    [`${_}-${l}`]: l !== "default" && l,
    [`${_}-${y}`]: y,
    [`${_}-${Q}`]: Q,
    [`${_}-icon-only`]: !p && p !== 0 && !!ne,
    [`${_}-background-ghost`]: m && !Qf(y),
    [`${_}-loading`]: L,
    [`${_}-two-chinese-chars`]: F && G && !L,
    [`${_}-block`]: v,
    [`${_}-dangerous`]: !!a,
    [`${_}-rtl`]: $ === "rtl"
  }, Y, f, h, M == null ? void 0 : M.className), fe = Object.assign(Object.assign({}, M == null ? void 0 : M.style), w), Se = se(x == null ? void 0 : x.icon, (n = M == null ? void 0 : M.classNames) === null || n === void 0 ? void 0 : n.icon), de = Object.assign(Object.assign({}, (c == null ? void 0 : c.icon) || {}), ((r = M == null ? void 0 : M.styles) === null || r === void 0 ? void 0 : r.icon) || {}), ce = g && !L ? /* @__PURE__ */ U.createElement(P_, {
    prefixCls: _,
    className: Se,
    style: de
  }, g) : /* @__PURE__ */ U.createElement(JB, {
    existIcon: !!g,
    prefixCls: _,
    loading: !!L
  }), pe = p || p === 0 ? ZB(p, H && G) : null;
  if (q.href !== void 0)
    return T(/* @__PURE__ */ U.createElement("a", Object.assign({}, q, {
      className: se(te, {
        [`${_}-disabled`]: I
      }),
      href: I ? void 0 : q.href,
      style: fe,
      onClick: W,
      ref: z,
      tabIndex: I ? -1 : 0
    }), ce, pe));
  let Oe = /* @__PURE__ */ U.createElement("button", Object.assign({}, C, {
    type: b,
    className: te,
    style: fe,
    onClick: W,
    disabled: I,
    ref: z
  }), ce, pe, !!Y && /* @__PURE__ */ U.createElement(C6, {
    key: "compact",
    prefixCls: _
  }));
  return Qf(y) || (Oe = /* @__PURE__ */ U.createElement(Fw, {
    component: "Button",
    disabled: !!L
  }, Oe)), T(Oe);
}), Ut = E6;
Ut.Group = qB;
Ut.__ANT_BUTTON = !0;
process.env.NODE_ENV !== "production" && (Ut.displayName = "Button");
function lx(e) {
  return !!(e && e.then);
}
const Hw = (e) => {
  const {
    type: t,
    children: n,
    prefixCls: r,
    buttonProps: i,
    close: o,
    autoFocus: s,
    emitEvent: a,
    isSilent: l,
    quitOnNullishReturnValue: u,
    actionFn: c
  } = e, d = O.useRef(!1), f = O.useRef(null), [h, p] = ta(!1), g = function() {
    o == null || o.apply(void 0, arguments);
  };
  O.useEffect(() => {
    let b = null;
    return s && (b = setTimeout(() => {
      var x;
      (x = f.current) === null || x === void 0 || x.focus();
    })), () => {
      b && clearTimeout(b);
    };
  }, []);
  const m = (b) => {
    lx(b) && (p(!0), b.then(function() {
      p(!1, !0), g.apply(void 0, arguments), d.current = !1;
    }, (x) => {
      if (p(!1, !0), d.current = !1, !(l != null && l()))
        return Promise.reject(x);
    }));
  }, v = (b) => {
    if (d.current)
      return;
    if (d.current = !0, !c) {
      g();
      return;
    }
    let x;
    if (a) {
      if (x = c(b), u && !lx(x)) {
        d.current = !1, g(b);
        return;
      }
    } else if (c.length)
      x = c(o), d.current = !1;
    else if (x = c(), !x) {
      g();
      return;
    }
    m(x);
  };
  return /* @__PURE__ */ O.createElement(Ut, Object.assign({}, Bw(t), {
    onClick: v,
    loading: h,
    prefixCls: r
  }, i, {
    ref: f
  }), n);
}, gf = /* @__PURE__ */ U.createContext({}), {
  Provider: j_
} = gf, cx = () => {
  const {
    autoFocusButton: e,
    cancelButtonProps: t,
    cancelTextLocale: n,
    isSilent: r,
    mergedOkCancel: i,
    rootPrefixCls: o,
    close: s,
    onCancel: a,
    onConfirm: l
  } = Yt(gf);
  return i ? /* @__PURE__ */ U.createElement(Hw, {
    isSilent: r,
    actionFn: a,
    close: function() {
      s == null || s.apply(void 0, arguments), l == null || l(!1);
    },
    autoFocus: e === "cancel",
    buttonProps: t,
    prefixCls: `${o}-btn`
  }, n) : null;
}, ux = () => {
  const {
    autoFocusButton: e,
    close: t,
    isSilent: n,
    okButtonProps: r,
    rootPrefixCls: i,
    okTextLocale: o,
    okType: s,
    onConfirm: a,
    onOk: l
  } = Yt(gf);
  return /* @__PURE__ */ U.createElement(Hw, {
    isSilent: n,
    type: s || "primary",
    actionFn: l,
    close: function() {
      t == null || t.apply(void 0, arguments), a == null || a(!0);
    },
    autoFocus: e === "ok",
    buttonProps: r,
    prefixCls: `${i}-btn`
  }, o);
};
var z_ = /* @__PURE__ */ O.createContext(null), dx = [];
function $6(e, t) {
  var n = O.useState(function() {
    if (!Ir())
      return null;
    var p = document.createElement("div");
    return process.env.NODE_ENV !== "production" && t && p.setAttribute("data-debug", t), p;
  }), r = ae(n, 1), i = r[0], o = O.useRef(!1), s = O.useContext(z_), a = O.useState(dx), l = ae(a, 2), u = l[0], c = l[1], d = s || (o.current ? void 0 : function(p) {
    c(function(g) {
      var m = [p].concat(_e(g));
      return m;
    });
  });
  function f() {
    i.parentElement || document.body.appendChild(i), o.current = !0;
  }
  function h() {
    var p;
    (p = i.parentElement) === null || p === void 0 || p.removeChild(i), o.current = !1;
  }
  return sn(function() {
    return e ? s ? s(f) : f() : h(), h;
  }, [e]), sn(function() {
    u.length && (u.forEach(function(p) {
      return p();
    }), c(dx));
  }, [u]), [i, d];
}
function O6(e) {
  var t = "rc-scrollbar-measure-".concat(Math.random().toString(36).substring(7)), n = document.createElement("div");
  n.id = t;
  var r = n.style;
  r.position = "absolute", r.left = "0", r.top = "0", r.width = "100px", r.height = "100px", r.overflow = "scroll";
  var i, o;
  if (e) {
    var s = getComputedStyle(e);
    r.scrollbarColor = s.scrollbarColor, r.scrollbarWidth = s.scrollbarWidth;
    var a = getComputedStyle(e, "::-webkit-scrollbar"), l = parseInt(a.width, 10), u = parseInt(a.height, 10);
    try {
      var c = l ? "width: ".concat(a.width, ";") : "", d = u ? "height: ".concat(a.height, ";") : "";
      vs(`
#`.concat(t, `::-webkit-scrollbar {
`).concat(c, `
`).concat(d, `
}`), t);
    } catch (p) {
      console.error(p), i = l, o = u;
    }
  }
  document.body.appendChild(n);
  var f = e && i && !isNaN(i) ? i : n.offsetWidth - n.clientWidth, h = e && o && !isNaN(o) ? o : n.offsetHeight - n.clientHeight;
  return document.body.removeChild(n), hd(t), {
    width: f,
    height: h
  };
}
function A6(e) {
  return typeof document > "u" || !e || !(e instanceof Element) ? {
    width: 0,
    height: 0
  } : O6(e);
}
function D6() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
var _6 = "rc-util-locker-".concat(Date.now()), fx = 0;
function T6(e) {
  var t = !!e, n = O.useState(function() {
    return fx += 1, "".concat(_6, "_").concat(fx);
  }), r = ae(n, 1), i = r[0];
  sn(function() {
    if (t) {
      var o = A6(document.body).width, s = D6();
      vs(`
html body {
  overflow-y: hidden;
  `.concat(s ? "width: calc(100% - ".concat(o, "px);") : "", `
}`), i);
    } else
      hd(i);
    return function() {
      hd(i);
    };
  }, [t, i]);
}
var R6 = !1;
function M6(e) {
  return R6;
}
var hx = function(t) {
  return t === !1 ? !1 : !Ir() || !t ? null : typeof t == "string" ? document.querySelector(t) : typeof t == "function" ? t() : t;
}, zg = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.open, r = e.autoLock, i = e.getContainer, o = e.debug, s = e.autoDestroy, a = s === void 0 ? !0 : s, l = e.children, u = O.useState(n), c = ae(u, 2), d = c[0], f = c[1], h = d || n;
  process.env.NODE_ENV !== "production" && $t(Ir() || !n, "Portal only work in client side. Please call 'useEffect' to show Portal instead default render in SSR."), O.useEffect(function() {
    (a || n) && f(n);
  }, [n, a]);
  var p = O.useState(function() {
    return hx(i);
  }), g = ae(p, 2), m = g[0], v = g[1];
  O.useEffect(function() {
    var T = hx(i);
    v(T ?? null);
  });
  var b = $6(h && !m, o), x = ae(b, 2), w = x[0], C = x[1], y = m ?? w;
  T6(r && n && Ir() && (y === w || y === document.body));
  var S = null;
  if (l && Ms(l) && t) {
    var A = l;
    S = A.ref;
  }
  var $ = ba(S, t);
  if (!h || !Ir() || m === void 0)
    return null;
  var M = y === !1 || M6(), _ = l;
  return t && (_ = /* @__PURE__ */ O.cloneElement(l, {
    ref: $
  })), /* @__PURE__ */ O.createElement(z_.Provider, {
    value: C
  }, M ? _ : /* @__PURE__ */ gw(_, y));
});
process.env.NODE_ENV !== "production" && (zg.displayName = "Portal");
var H_ = /* @__PURE__ */ O.createContext({});
function I6() {
  var e = ie({}, O);
  return e.useId;
}
var px = 0, gx = I6();
const V_ = gx ? (
  // Use React `useId`
  function(t) {
    var n = gx();
    return t || (process.env.NODE_ENV === "test" ? "test-id" : n);
  }
) : (
  // Use compatible of `useId`
  function(t) {
    var n = O.useState("ssr-id"), r = ae(n, 2), i = r[0], o = r[1];
    return O.useEffect(function() {
      var s = px;
      px += 1, o("rc_unique_".concat(s));
    }, []), t || (process.env.NODE_ENV === "test" ? "test-id" : i);
  }
);
function mx(e, t, n) {
  var r = t;
  return !r && n && (r = "".concat(e, "-").concat(n)), r;
}
function vx(e, t) {
  var n = e["page".concat(t ? "Y" : "X", "Offset")], r = "scroll".concat(t ? "Top" : "Left");
  if (typeof n != "number") {
    var i = e.document;
    n = i.documentElement[r], typeof n != "number" && (n = i.body[r]);
  }
  return n;
}
function k6(e) {
  var t = e.getBoundingClientRect(), n = {
    left: t.left,
    top: t.top
  }, r = e.ownerDocument, i = r.defaultView || r.parentWindow;
  return n.left += vx(i), n.top += vx(i, !0), n;
}
const P6 = /* @__PURE__ */ O.memo(function(e) {
  var t = e.children;
  return t;
}, function(e, t) {
  var n = t.shouldUpdate;
  return !n;
});
var bx = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none"
}, N6 = {
  outline: "none"
}, Vw = /* @__PURE__ */ U.forwardRef(function(e, t) {
  var n = e.prefixCls, r = e.className, i = e.style, o = e.title, s = e.ariaId, a = e.footer, l = e.closable, u = e.closeIcon, c = e.onClose, d = e.children, f = e.bodyStyle, h = e.bodyProps, p = e.modalRender, g = e.onMouseDown, m = e.onMouseUp, v = e.holderRef, b = e.visible, x = e.forceRender, w = e.width, C = e.height, y = e.classNames, S = e.styles, A = U.useContext(H_), $ = A.panel, M = ba(v, $), _ = he(), T = he(), D = he();
  U.useImperativeHandle(t, function() {
    return {
      focus: function() {
        var B;
        (B = D.current) === null || B === void 0 || B.focus();
      },
      changeActive: function(B) {
        var j = document, z = j.activeElement;
        B && z === T.current ? _.current.focus() : !B && z === _.current && T.current.focus();
      }
    };
  });
  var E = {};
  w !== void 0 && (E.width = w), C !== void 0 && (E.height = C);
  var R;
  a && (R = /* @__PURE__ */ U.createElement("div", {
    className: se("".concat(n, "-footer"), y == null ? void 0 : y.footer),
    style: ie({}, S == null ? void 0 : S.footer)
  }, a));
  var I;
  o && (I = /* @__PURE__ */ U.createElement("div", {
    className: se("".concat(n, "-header"), y == null ? void 0 : y.header),
    style: ie({}, S == null ? void 0 : S.header)
  }, /* @__PURE__ */ U.createElement("div", {
    className: "".concat(n, "-title"),
    id: s
  }, o)));
  var k = mt(function() {
    return wt(l) === "object" && l !== null ? l : l ? {
      closeIcon: u ?? /* @__PURE__ */ U.createElement("span", {
        className: "".concat(n, "-close-x")
      })
    } : {};
  }, [l, u]), P = $s(k, !0), L;
  l && (L = /* @__PURE__ */ U.createElement("button", we({
    type: "button",
    onClick: c,
    "aria-label": "Close"
  }, P, {
    className: "".concat(n, "-close")
  }), k.closeIcon));
  var N = /* @__PURE__ */ U.createElement("div", {
    className: se("".concat(n, "-content"), y == null ? void 0 : y.content),
    style: S == null ? void 0 : S.content
  }, L, I, /* @__PURE__ */ U.createElement("div", we({
    className: se("".concat(n, "-body"), y == null ? void 0 : y.body),
    style: ie(ie({}, f), S == null ? void 0 : S.body)
  }, h), d), R);
  return /* @__PURE__ */ U.createElement("div", {
    key: "dialog-element",
    role: "dialog",
    "aria-labelledby": o ? s : null,
    "aria-modal": "true",
    ref: M,
    style: ie(ie({}, i), E),
    className: se(n, r),
    onMouseDown: g,
    onMouseUp: m
  }, /* @__PURE__ */ U.createElement("div", {
    tabIndex: 0,
    ref: _,
    style: bx,
    "aria-hidden": "true"
  }), /* @__PURE__ */ U.createElement("div", {
    ref: D,
    tabIndex: -1,
    style: N6
  }, /* @__PURE__ */ U.createElement(P6, {
    shouldUpdate: b || x
  }, p ? p(N) : N)), /* @__PURE__ */ U.createElement("div", {
    tabIndex: 0,
    ref: T,
    style: bx,
    "aria-hidden": "true"
  }));
});
process.env.NODE_ENV !== "production" && (Vw.displayName = "Panel");
var W_ = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.prefixCls, r = e.title, i = e.style, o = e.className, s = e.visible, a = e.forceRender, l = e.destroyOnClose, u = e.motionName, c = e.ariaId, d = e.onVisibleChanged, f = e.mousePosition, h = he(), p = O.useState(), g = ae(p, 2), m = g[0], v = g[1], b = {};
  m && (b.transformOrigin = m);
  function x() {
    var w = k6(h.current);
    v(f ? "".concat(f.x - w.left, "px ").concat(f.y - w.top, "px") : "");
  }
  return /* @__PURE__ */ O.createElement(qo, {
    visible: s,
    onVisibleChanged: d,
    onAppearPrepare: x,
    onEnterPrepare: x,
    forceRender: a,
    motionName: u,
    removeOnLeave: l,
    ref: h
  }, function(w, C) {
    var y = w.className, S = w.style;
    return /* @__PURE__ */ O.createElement(Vw, we({}, e, {
      ref: t,
      title: r,
      ariaId: c,
      prefixCls: n,
      holderRef: C,
      style: ie(ie(ie({}, S), i), b),
      className: se(o, y)
    }));
  });
});
W_.displayName = "Content";
function L6(e) {
  var t = e.prefixCls, n = e.style, r = e.visible, i = e.maskProps, o = e.motionName, s = e.className;
  return /* @__PURE__ */ O.createElement(qo, {
    key: "mask",
    visible: r,
    motionName: o,
    leavedClassName: "".concat(t, "-mask-hidden")
  }, function(a, l) {
    var u = a.className, c = a.style;
    return /* @__PURE__ */ O.createElement("div", we({
      ref: l,
      style: ie(ie({}, c), n),
      className: se("".concat(t, "-mask"), u, s)
    }, i));
  });
}
function F6(e) {
  var t = e.prefixCls, n = t === void 0 ? "rc-dialog" : t, r = e.zIndex, i = e.visible, o = i === void 0 ? !1 : i, s = e.keyboard, a = s === void 0 ? !0 : s, l = e.focusTriggerAfterClose, u = l === void 0 ? !0 : l, c = e.wrapStyle, d = e.wrapClassName, f = e.wrapProps, h = e.onClose, p = e.afterOpenChange, g = e.afterClose, m = e.transitionName, v = e.animation, b = e.closable, x = b === void 0 ? !0 : b, w = e.mask, C = w === void 0 ? !0 : w, y = e.maskTransitionName, S = e.maskAnimation, A = e.maskClosable, $ = A === void 0 ? !0 : A, M = e.maskStyle, _ = e.maskProps, T = e.rootClassName, D = e.classNames, E = e.styles;
  process.env.NODE_ENV !== "production" && (["wrapStyle", "bodyStyle", "maskStyle"].forEach(function(ne) {
    Ss(!(ne in e), "".concat(ne, " is deprecated, please use styles instead."));
  }), "wrapClassName" in e && Ss(!1, "wrapClassName is deprecated, please use classNames instead."));
  var R = he(), I = he(), k = he(), P = O.useState(o), L = ae(P, 2), N = L[0], F = L[1], B = V_();
  function j() {
    z0(I.current, document.activeElement) || (R.current = document.activeElement);
  }
  function z() {
    if (!z0(I.current, document.activeElement)) {
      var ne;
      (ne = k.current) === null || ne === void 0 || ne.focus();
    }
  }
  function H(ne) {
    if (ne)
      z();
    else {
      if (F(!1), C && R.current && u) {
        try {
          R.current.focus({
            preventScroll: !0
          });
        } catch {
        }
        R.current = null;
      }
      N && (g == null || g());
    }
    p == null || p(ne);
  }
  function W(ne) {
    h == null || h(ne);
  }
  var G = he(!1), K = he(), Y = function() {
    clearTimeout(K.current), G.current = !0;
  }, X = function() {
    K.current = setTimeout(function() {
      G.current = !1;
    });
  }, Z = null;
  $ && (Z = function(q) {
    G.current ? G.current = !1 : I.current === q.target && W(q);
  });
  function Q(ne) {
    if (a && ne.keyCode === xe.ESC) {
      ne.stopPropagation(), W(ne);
      return;
    }
    o && ne.keyCode === xe.TAB && k.current.changeActive(!ne.shiftKey);
  }
  return Pe(function() {
    o && (F(!0), j());
  }, [o]), Pe(function() {
    return function() {
      clearTimeout(K.current);
    };
  }, []), /* @__PURE__ */ O.createElement("div", we({
    className: se("".concat(n, "-root"), T)
  }, $s(e, {
    data: !0
  })), /* @__PURE__ */ O.createElement(L6, {
    prefixCls: n,
    visible: C && o,
    motionName: mx(n, y, S),
    style: ie(ie({
      zIndex: r
    }, M), E == null ? void 0 : E.mask),
    maskProps: _,
    className: D == null ? void 0 : D.mask
  }), /* @__PURE__ */ O.createElement("div", we({
    tabIndex: -1,
    onKeyDown: Q,
    className: se("".concat(n, "-wrap"), d, D == null ? void 0 : D.wrapper),
    ref: I,
    onClick: Z,
    style: ie(ie(ie({
      zIndex: r
    }, c), E == null ? void 0 : E.wrapper), {}, {
      display: N ? null : "none"
    })
  }, f), /* @__PURE__ */ O.createElement(W_, we({}, e, {
    onMouseDown: Y,
    onMouseUp: X,
    ref: k,
    closable: x,
    ariaId: B,
    prefixCls: n,
    visible: o && N,
    onClose: W,
    onVisibleChanged: H,
    motionName: mx(n, m, v)
  }))));
}
var U_ = function(t) {
  var n = t.visible, r = t.getContainer, i = t.forceRender, o = t.destroyOnClose, s = o === void 0 ? !1 : o, a = t.afterClose, l = t.panelRef, u = O.useState(n), c = ae(u, 2), d = c[0], f = c[1], h = O.useMemo(function() {
    return {
      panel: l
    };
  }, [l]);
  return O.useEffect(function() {
    n && f(!0);
  }, [n]), !i && s && !d ? null : /* @__PURE__ */ O.createElement(H_.Provider, {
    value: h
  }, /* @__PURE__ */ O.createElement(zg, {
    open: n || i || d,
    autoDestroy: !1,
    getContainer: r,
    autoLock: n || d
  }, /* @__PURE__ */ O.createElement(F6, we({}, t, {
    destroyOnClose: s,
    afterClose: function() {
      a == null || a(), f(!1);
    }
  }))));
};
U_.displayName = "Dialog";
function yx(e) {
  if (e)
    return {
      closable: e.closable,
      closeIcon: e.closeIcon
    };
}
function wx(e) {
  const {
    closable: t,
    closeIcon: n
  } = e || {};
  return U.useMemo(() => {
    if (
      // If `closable`, whatever rest be should be true
      !t && (t === !1 || n === !1 || n === null)
    )
      return !1;
    if (t === void 0 && n === void 0)
      return null;
    let r = {
      closeIcon: typeof n != "boolean" && n !== null ? n : void 0
    };
    return t && typeof t == "object" && (r = Object.assign(Object.assign({}, r), t)), r;
  }, [t, n]);
}
function Cx() {
  const e = {};
  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  return n.forEach((i) => {
    i && Object.keys(i).forEach((o) => {
      i[o] !== void 0 && (e[o] = i[o]);
    });
  }), e;
}
const B6 = {};
function j6(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : B6;
  const r = wx(e), i = wx(t), o = U.useMemo(() => Object.assign({
    closeIcon: /* @__PURE__ */ U.createElement(To, null)
  }, n), [n]), s = U.useMemo(() => r === !1 ? !1 : r ? Cx(o, i, r) : i === !1 ? !1 : i ? Cx(o, i) : o.closable ? o : !1, [r, i, o]);
  return U.useMemo(() => {
    if (s === !1)
      return [!1, null];
    const {
      closeIconRender: a
    } = o, {
      closeIcon: l
    } = s;
    let u = l;
    if (u != null) {
      a && (u = a(l));
      const c = $s(s, !0);
      Object.keys(c).length && (u = /* @__PURE__ */ U.isValidElement(u) ? /* @__PURE__ */ U.cloneElement(u, c) : /* @__PURE__ */ U.createElement("span", Object.assign({}, c), u));
    }
    return [!0, u];
  }, [s, o]);
}
var G_ = function(t) {
  if (Ir() && window.document.documentElement) {
    var n = Array.isArray(t) ? t : [t], r = window.document.documentElement;
    return n.some(function(i) {
      return i in r.style;
    });
  }
  return !1;
}, z6 = function(t, n) {
  if (!G_(t))
    return !1;
  var r = document.createElement("div"), i = r.style[t];
  return r.style[t] = n, r.style[t] !== i;
};
function Sx(e, t) {
  return !Array.isArray(e) && t !== void 0 ? z6(e, t) : G_(e);
}
const H6 = () => Ir() && window.document.documentElement;
var Na = "RC_FORM_INTERNAL_HOOKS", gn = function() {
  $t(!1, "Can not find FormContext. Please make sure you wrap Field under Form.");
}, Ja = /* @__PURE__ */ O.createContext({
  getFieldValue: gn,
  getFieldsValue: gn,
  getFieldError: gn,
  getFieldWarning: gn,
  getFieldsError: gn,
  isFieldsTouched: gn,
  isFieldTouched: gn,
  isFieldValidating: gn,
  isFieldsValidating: gn,
  resetFields: gn,
  setFields: gn,
  setFieldValue: gn,
  setFieldsValue: gn,
  validateFields: gn,
  submit: gn,
  getInternalHooks: function() {
    return gn(), {
      dispatch: gn,
      initEntityValue: gn,
      registerField: gn,
      useSubscribe: gn,
      setInitialValues: gn,
      destroyForm: gn,
      setCallbacks: gn,
      registerWatch: gn,
      getFields: gn,
      setValidateMessages: gn,
      setPreserve: gn,
      getInitialValue: gn
    };
  }
}), Sd = /* @__PURE__ */ O.createContext(null);
function db(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function V6(e) {
  return e && !!e._init;
}
function La() {
  return La = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var r in n)
        Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
    }
    return e;
  }, La.apply(this, arguments);
}
function W6(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, xd(e, t);
}
function fb(e) {
  return fb = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, fb(e);
}
function xd(e, t) {
  return xd = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, xd(e, t);
}
function U6() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function ep(e, t, n) {
  return U6() ? ep = Reflect.construct.bind() : ep = function(i, o, s) {
    var a = [null];
    a.push.apply(a, o);
    var l = Function.bind.apply(i, a), u = new l();
    return s && xd(u, s.prototype), u;
  }, ep.apply(null, arguments);
}
function G6(e) {
  return Function.toString.call(e).indexOf("[native code]") !== -1;
}
function hb(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return hb = function(r) {
    if (r === null || !G6(r))
      return r;
    if (typeof r != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof t < "u") {
      if (t.has(r))
        return t.get(r);
      t.set(r, i);
    }
    function i() {
      return ep(r, arguments, fb(this).constructor);
    }
    return i.prototype = Object.create(r.prototype, {
      constructor: {
        value: i,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), xd(i, r);
  }, hb(e);
}
var K6 = /%[sdj%]/g, K_ = function() {
};
typeof process < "u" && process.env && process.env.NODE_ENV !== "production" && typeof window < "u" && typeof document < "u" && (K_ = function(t, n) {
  typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && n.every(function(r) {
    return typeof r == "string";
  }) && console.warn(t, n);
});
function pb(e) {
  if (!e || !e.length)
    return null;
  var t = {};
  return e.forEach(function(n) {
    var r = n.field;
    t[r] = t[r] || [], t[r].push(n);
  }), t;
}
function Pi(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  var i = 0, o = n.length;
  if (typeof e == "function")
    return e.apply(null, n);
  if (typeof e == "string") {
    var s = e.replace(K6, function(a) {
      if (a === "%%")
        return "%";
      if (i >= o)
        return a;
      switch (a) {
        case "%s":
          return String(n[i++]);
        case "%d":
          return Number(n[i++]);
        case "%j":
          try {
            return JSON.stringify(n[i++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return a;
      }
    });
    return s;
  }
  return e;
}
function X6(e) {
  return e === "string" || e === "url" || e === "hex" || e === "email" || e === "date" || e === "pattern";
}
function hr(e, t) {
  return !!(e == null || t === "array" && Array.isArray(e) && !e.length || X6(t) && typeof e == "string" && !e);
}
function Y6(e, t, n) {
  var r = [], i = 0, o = e.length;
  function s(a) {
    r.push.apply(r, a || []), i++, i === o && n(r);
  }
  e.forEach(function(a) {
    t(a, s);
  });
}
function xx(e, t, n) {
  var r = 0, i = e.length;
  function o(s) {
    if (s && s.length) {
      n(s);
      return;
    }
    var a = r;
    r = r + 1, a < i ? t(e[a], o) : n([]);
  }
  o([]);
}
function q6(e) {
  var t = [];
  return Object.keys(e).forEach(function(n) {
    t.push.apply(t, e[n] || []);
  }), t;
}
var Ex = /* @__PURE__ */ function(e) {
  W6(t, e);
  function t(n, r) {
    var i;
    return i = e.call(this, "Async Validation Error") || this, i.errors = n, i.fields = r, i;
  }
  return t;
}(/* @__PURE__ */ hb(Error));
function Q6(e, t, n, r, i) {
  if (t.first) {
    var o = new Promise(function(f, h) {
      var p = function(v) {
        return r(v), v.length ? h(new Ex(v, pb(v))) : f(i);
      }, g = q6(e);
      xx(g, n, p);
    });
    return o.catch(function(f) {
      return f;
    }), o;
  }
  var s = t.firstFields === !0 ? Object.keys(e) : t.firstFields || [], a = Object.keys(e), l = a.length, u = 0, c = [], d = new Promise(function(f, h) {
    var p = function(m) {
      if (c.push.apply(c, m), u++, u === l)
        return r(c), c.length ? h(new Ex(c, pb(c))) : f(i);
    };
    a.length || (r(c), f(i)), a.forEach(function(g) {
      var m = e[g];
      s.indexOf(g) !== -1 ? xx(m, n, p) : Y6(m, n, p);
    });
  });
  return d.catch(function(f) {
    return f;
  }), d;
}
function Z6(e) {
  return !!(e && e.message !== void 0);
}
function J6(e, t) {
  for (var n = e, r = 0; r < t.length; r++) {
    if (n == null)
      return n;
    n = n[t[r]];
  }
  return n;
}
function $x(e, t) {
  return function(n) {
    var r;
    return e.fullFields ? r = J6(t, e.fullFields) : r = t[n.field || e.fullField], Z6(n) ? (n.field = n.field || e.fullField, n.fieldValue = r, n) : {
      message: typeof n == "function" ? n() : n,
      fieldValue: r,
      field: n.field || e.fullField
    };
  };
}
function Ox(e, t) {
  if (t) {
    for (var n in t)
      if (t.hasOwnProperty(n)) {
        var r = t[n];
        typeof r == "object" && typeof e[n] == "object" ? e[n] = La({}, e[n], r) : e[n] = r;
      }
  }
  return e;
}
var X_ = function(t, n, r, i, o, s) {
  t.required && (!r.hasOwnProperty(t.field) || hr(n, s || t.type)) && i.push(Pi(o.messages.required, t.fullField));
}, e8 = function(t, n, r, i, o) {
  (/^\s+$/.test(n) || n === "") && i.push(Pi(o.messages.whitespace, t.fullField));
}, Zf, t8 = function() {
  if (Zf)
    return Zf;
  var e = "[a-fA-F\\d:]", t = function(w) {
    return w && w.includeBoundaries ? "(?:(?<=\\s|^)(?=" + e + ")|(?<=" + e + ")(?=\\s|$))" : "";
  }, n = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", r = "[a-fA-F\\d]{1,4}", i = (`
(?:
(?:` + r + ":){7}(?:" + r + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + r + ":){6}(?:" + n + "|:" + r + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + r + ":){5}(?::" + n + "|(?::" + r + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + r + ":){4}(?:(?::" + r + "){0,1}:" + n + "|(?::" + r + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + r + ":){3}(?:(?::" + r + "){0,2}:" + n + "|(?::" + r + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + r + ":){2}(?:(?::" + r + "){0,3}:" + n + "|(?::" + r + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + r + ":){1}(?:(?::" + r + "){0,4}:" + n + "|(?::" + r + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + r + "){0,5}:" + n + "|(?::" + r + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), o = new RegExp("(?:^" + n + "$)|(?:^" + i + "$)"), s = new RegExp("^" + n + "$"), a = new RegExp("^" + i + "$"), l = function(w) {
    return w && w.exact ? o : new RegExp("(?:" + t(w) + n + t(w) + ")|(?:" + t(w) + i + t(w) + ")", "g");
  };
  l.v4 = function(x) {
    return x && x.exact ? s : new RegExp("" + t(x) + n + t(x), "g");
  }, l.v6 = function(x) {
    return x && x.exact ? a : new RegExp("" + t(x) + i + t(x), "g");
  };
  var u = "(?:(?:[a-z]+:)?//)", c = "(?:\\S+(?::\\S*)?@)?", d = l.v4().source, f = l.v6().source, h = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", p = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", g = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", m = "(?::\\d{2,5})?", v = '(?:[/?#][^\\s"]*)?', b = "(?:" + u + "|www\\.)" + c + "(?:localhost|" + d + "|" + f + "|" + h + p + g + ")" + m + v;
  return Zf = new RegExp("(?:^" + b + "$)", "i"), Zf;
}, Ax = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, Pu = {
  integer: function(t) {
    return Pu.number(t) && parseInt(t, 10) === t;
  },
  float: function(t) {
    return Pu.number(t) && !Pu.integer(t);
  },
  array: function(t) {
    return Array.isArray(t);
  },
  regexp: function(t) {
    if (t instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(t);
    } catch {
      return !1;
    }
  },
  date: function(t) {
    return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime());
  },
  number: function(t) {
    return isNaN(t) ? !1 : typeof t == "number";
  },
  object: function(t) {
    return typeof t == "object" && !Pu.array(t);
  },
  method: function(t) {
    return typeof t == "function";
  },
  email: function(t) {
    return typeof t == "string" && t.length <= 320 && !!t.match(Ax.email);
  },
  url: function(t) {
    return typeof t == "string" && t.length <= 2048 && !!t.match(t8());
  },
  hex: function(t) {
    return typeof t == "string" && !!t.match(Ax.hex);
  }
}, n8 = function(t, n, r, i, o) {
  if (t.required && n === void 0) {
    X_(t, n, r, i, o);
    return;
  }
  var s = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], a = t.type;
  s.indexOf(a) > -1 ? Pu[a](n) || i.push(Pi(o.messages.types[a], t.fullField, t.type)) : a && typeof n !== t.type && i.push(Pi(o.messages.types[a], t.fullField, t.type));
}, r8 = function(t, n, r, i, o) {
  var s = typeof t.len == "number", a = typeof t.min == "number", l = typeof t.max == "number", u = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, c = n, d = null, f = typeof n == "number", h = typeof n == "string", p = Array.isArray(n);
  if (f ? d = "number" : h ? d = "string" : p && (d = "array"), !d)
    return !1;
  p && (c = n.length), h && (c = n.replace(u, "_").length), s ? c !== t.len && i.push(Pi(o.messages[d].len, t.fullField, t.len)) : a && !l && c < t.min ? i.push(Pi(o.messages[d].min, t.fullField, t.min)) : l && !a && c > t.max ? i.push(Pi(o.messages[d].max, t.fullField, t.max)) : a && l && (c < t.min || c > t.max) && i.push(Pi(o.messages[d].range, t.fullField, t.min, t.max));
}, kl = "enum", i8 = function(t, n, r, i, o) {
  t[kl] = Array.isArray(t[kl]) ? t[kl] : [], t[kl].indexOf(n) === -1 && i.push(Pi(o.messages[kl], t.fullField, t[kl].join(", ")));
}, o8 = function(t, n, r, i, o) {
  if (t.pattern) {
    if (t.pattern instanceof RegExp)
      t.pattern.lastIndex = 0, t.pattern.test(n) || i.push(Pi(o.messages.pattern.mismatch, t.fullField, n, t.pattern));
    else if (typeof t.pattern == "string") {
      var s = new RegExp(t.pattern);
      s.test(n) || i.push(Pi(o.messages.pattern.mismatch, t.fullField, n, t.pattern));
    }
  }
}, Qt = {
  required: X_,
  whitespace: e8,
  type: n8,
  range: r8,
  enum: i8,
  pattern: o8
}, s8 = function(t, n, r, i, o) {
  var s = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (hr(n, "string") && !t.required)
      return r();
    Qt.required(t, n, i, s, o, "string"), hr(n, "string") || (Qt.type(t, n, i, s, o), Qt.range(t, n, i, s, o), Qt.pattern(t, n, i, s, o), t.whitespace === !0 && Qt.whitespace(t, n, i, s, o));
  }
  r(s);
}, a8 = function(t, n, r, i, o) {
  var s = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (hr(n) && !t.required)
      return r();
    Qt.required(t, n, i, s, o), n !== void 0 && Qt.type(t, n, i, s, o);
  }
  r(s);
}, l8 = function(t, n, r, i, o) {
  var s = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (n === "" && (n = void 0), hr(n) && !t.required)
      return r();
    Qt.required(t, n, i, s, o), n !== void 0 && (Qt.type(t, n, i, s, o), Qt.range(t, n, i, s, o));
  }
  r(s);
}, c8 = function(t, n, r, i, o) {
  var s = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (hr(n) && !t.required)
      return r();
    Qt.required(t, n, i, s, o), n !== void 0 && Qt.type(t, n, i, s, o);
  }
  r(s);
}, u8 = function(t, n, r, i, o) {
  var s = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (hr(n) && !t.required)
      return r();
    Qt.required(t, n, i, s, o), hr(n) || Qt.type(t, n, i, s, o);
  }
  r(s);
}, d8 = function(t, n, r, i, o) {
  var s = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (hr(n) && !t.required)
      return r();
    Qt.required(t, n, i, s, o), n !== void 0 && (Qt.type(t, n, i, s, o), Qt.range(t, n, i, s, o));
  }
  r(s);
}, f8 = function(t, n, r, i, o) {
  var s = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (hr(n) && !t.required)
      return r();
    Qt.required(t, n, i, s, o), n !== void 0 && (Qt.type(t, n, i, s, o), Qt.range(t, n, i, s, o));
  }
  r(s);
}, h8 = function(t, n, r, i, o) {
  var s = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (n == null && !t.required)
      return r();
    Qt.required(t, n, i, s, o, "array"), n != null && (Qt.type(t, n, i, s, o), Qt.range(t, n, i, s, o));
  }
  r(s);
}, p8 = function(t, n, r, i, o) {
  var s = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (hr(n) && !t.required)
      return r();
    Qt.required(t, n, i, s, o), n !== void 0 && Qt.type(t, n, i, s, o);
  }
  r(s);
}, g8 = "enum", m8 = function(t, n, r, i, o) {
  var s = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (hr(n) && !t.required)
      return r();
    Qt.required(t, n, i, s, o), n !== void 0 && Qt[g8](t, n, i, s, o);
  }
  r(s);
}, v8 = function(t, n, r, i, o) {
  var s = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (hr(n, "string") && !t.required)
      return r();
    Qt.required(t, n, i, s, o), hr(n, "string") || Qt.pattern(t, n, i, s, o);
  }
  r(s);
}, b8 = function(t, n, r, i, o) {
  var s = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (hr(n, "date") && !t.required)
      return r();
    if (Qt.required(t, n, i, s, o), !hr(n, "date")) {
      var l;
      n instanceof Date ? l = n : l = new Date(n), Qt.type(t, l, i, s, o), l && Qt.range(t, l.getTime(), i, s, o);
    }
  }
  r(s);
}, y8 = function(t, n, r, i, o) {
  var s = [], a = Array.isArray(n) ? "array" : typeof n;
  Qt.required(t, n, i, s, o, a), r(s);
}, nv = function(t, n, r, i, o) {
  var s = t.type, a = [], l = t.required || !t.required && i.hasOwnProperty(t.field);
  if (l) {
    if (hr(n, s) && !t.required)
      return r();
    Qt.required(t, n, i, a, o, s), hr(n, s) || Qt.type(t, n, i, a, o);
  }
  r(a);
}, w8 = function(t, n, r, i, o) {
  var s = [], a = t.required || !t.required && i.hasOwnProperty(t.field);
  if (a) {
    if (hr(n) && !t.required)
      return r();
    Qt.required(t, n, i, s, o);
  }
  r(s);
}, Ju = {
  string: s8,
  method: a8,
  number: l8,
  boolean: c8,
  regexp: u8,
  integer: d8,
  float: f8,
  array: h8,
  object: p8,
  enum: m8,
  pattern: v8,
  date: b8,
  url: nv,
  hex: nv,
  email: nv,
  required: y8,
  any: w8
};
function gb() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var t = JSON.parse(JSON.stringify(this));
      return t.clone = this.clone, t;
    }
  };
}
var mb = gb(), mf = /* @__PURE__ */ function() {
  function e(n) {
    this.rules = null, this._messages = mb, this.define(n);
  }
  var t = e.prototype;
  return t.define = function(r) {
    var i = this;
    if (!r)
      throw new Error("Cannot configure a schema with no rules");
    if (typeof r != "object" || Array.isArray(r))
      throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(r).forEach(function(o) {
      var s = r[o];
      i.rules[o] = Array.isArray(s) ? s : [s];
    });
  }, t.messages = function(r) {
    return r && (this._messages = Ox(gb(), r)), this._messages;
  }, t.validate = function(r, i, o) {
    var s = this;
    i === void 0 && (i = {}), o === void 0 && (o = function() {
    });
    var a = r, l = i, u = o;
    if (typeof l == "function" && (u = l, l = {}), !this.rules || Object.keys(this.rules).length === 0)
      return u && u(null, a), Promise.resolve(a);
    function c(g) {
      var m = [], v = {};
      function b(w) {
        if (Array.isArray(w)) {
          var C;
          m = (C = m).concat.apply(C, w);
        } else
          m.push(w);
      }
      for (var x = 0; x < g.length; x++)
        b(g[x]);
      m.length ? (v = pb(m), u(m, v)) : u(null, a);
    }
    if (l.messages) {
      var d = this.messages();
      d === mb && (d = gb()), Ox(d, l.messages), l.messages = d;
    } else
      l.messages = this.messages();
    var f = {}, h = l.keys || Object.keys(this.rules);
    h.forEach(function(g) {
      var m = s.rules[g], v = a[g];
      m.forEach(function(b) {
        var x = b;
        typeof x.transform == "function" && (a === r && (a = La({}, a)), v = a[g] = x.transform(v)), typeof x == "function" ? x = {
          validator: x
        } : x = La({}, x), x.validator = s.getValidationMethod(x), x.validator && (x.field = g, x.fullField = x.fullField || g, x.type = s.getType(x), f[g] = f[g] || [], f[g].push({
          rule: x,
          value: v,
          source: a,
          field: g
        }));
      });
    });
    var p = {};
    return Q6(f, l, function(g, m) {
      var v = g.rule, b = (v.type === "object" || v.type === "array") && (typeof v.fields == "object" || typeof v.defaultField == "object");
      b = b && (v.required || !v.required && g.value), v.field = g.field;
      function x(y, S) {
        return La({}, S, {
          fullField: v.fullField + "." + y,
          fullFields: v.fullFields ? [].concat(v.fullFields, [y]) : [y]
        });
      }
      function w(y) {
        y === void 0 && (y = []);
        var S = Array.isArray(y) ? y : [y];
        !l.suppressWarning && S.length && e.warning("async-validator:", S), S.length && v.message !== void 0 && (S = [].concat(v.message));
        var A = S.map($x(v, a));
        if (l.first && A.length)
          return p[v.field] = 1, m(A);
        if (!b)
          m(A);
        else {
          if (v.required && !g.value)
            return v.message !== void 0 ? A = [].concat(v.message).map($x(v, a)) : l.error && (A = [l.error(v, Pi(l.messages.required, v.field))]), m(A);
          var $ = {};
          v.defaultField && Object.keys(g.value).map(function(T) {
            $[T] = v.defaultField;
          }), $ = La({}, $, g.rule.fields);
          var M = {};
          Object.keys($).forEach(function(T) {
            var D = $[T], E = Array.isArray(D) ? D : [D];
            M[T] = E.map(x.bind(null, T));
          });
          var _ = new e(M);
          _.messages(l.messages), g.rule.options && (g.rule.options.messages = l.messages, g.rule.options.error = l.error), _.validate(g.value, g.rule.options || l, function(T) {
            var D = [];
            A && A.length && D.push.apply(D, A), T && T.length && D.push.apply(D, T), m(D.length ? D : null);
          });
        }
      }
      var C;
      if (v.asyncValidator)
        C = v.asyncValidator(v, g.value, w, g.source, l);
      else if (v.validator) {
        try {
          C = v.validator(v, g.value, w, g.source, l);
        } catch (y) {
          console.error == null || console.error(y), l.suppressValidatorError || setTimeout(function() {
            throw y;
          }, 0), w(y.message);
        }
        C === !0 ? w() : C === !1 ? w(typeof v.message == "function" ? v.message(v.fullField || v.field) : v.message || (v.fullField || v.field) + " fails") : C instanceof Array ? w(C) : C instanceof Error && w(C.message);
      }
      C && C.then && C.then(function() {
        return w();
      }, function(y) {
        return w(y);
      });
    }, function(g) {
      c(g);
    }, a);
  }, t.getType = function(r) {
    if (r.type === void 0 && r.pattern instanceof RegExp && (r.type = "pattern"), typeof r.validator != "function" && r.type && !Ju.hasOwnProperty(r.type))
      throw new Error(Pi("Unknown rule type %s", r.type));
    return r.type || "string";
  }, t.getValidationMethod = function(r) {
    if (typeof r.validator == "function")
      return r.validator;
    var i = Object.keys(r), o = i.indexOf("message");
    return o !== -1 && i.splice(o, 1), i.length === 1 && i[0] === "required" ? Ju.required : Ju[this.getType(r)] || void 0;
  }, e;
}();
mf.register = function(t, n) {
  if (typeof n != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  Ju[t] = n;
};
mf.warning = K_;
mf.messages = mb;
mf.validators = Ju;
var Ai = "'${name}' is not a valid ${type}", Y_ = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: Ai,
    method: Ai,
    array: Ai,
    object: Ai,
    number: Ai,
    date: Ai,
    boolean: Ai,
    integer: Ai,
    float: Ai,
    regexp: Ai,
    email: Ai,
    url: Ai,
    hex: Ai
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
}, Dx = mf;
function C8(e, t) {
  return e.replace(/\$\{\w+\}/g, function(n) {
    var r = n.slice(2, -1);
    return t[r];
  });
}
var _x = "CODE_LOGIC_ERROR";
function vb(e, t, n, r, i) {
  return bb.apply(this, arguments);
}
function bb() {
  return bb = Cl(/* @__PURE__ */ si().mark(function e(t, n, r, i, o) {
    var s, a, l, u, c, d, f, h, p;
    return si().wrap(function(m) {
      for (; ; )
        switch (m.prev = m.next) {
          case 0:
            return s = ie({}, r), delete s.ruleIndex, Dx.warning = function() {
            }, s.validator && (a = s.validator, s.validator = function() {
              try {
                return a.apply(void 0, arguments);
              } catch (v) {
                return console.error(v), Promise.reject(_x);
              }
            }), l = null, s && s.type === "array" && s.defaultField && (l = s.defaultField, delete s.defaultField), u = new Dx(re({}, t, [s])), c = rc(Y_, i.validateMessages), u.messages(c), d = [], m.prev = 10, m.next = 13, Promise.resolve(u.validate(re({}, t, n), ie({}, i)));
          case 13:
            m.next = 18;
            break;
          case 15:
            m.prev = 15, m.t0 = m.catch(10), m.t0.errors && (d = m.t0.errors.map(function(v, b) {
              var x = v.message, w = x === _x ? c.default : x;
              return /* @__PURE__ */ O.isValidElement(w) ? (
                // Wrap ReactNode with `key`
                /* @__PURE__ */ O.cloneElement(w, {
                  key: "error_".concat(b)
                })
              ) : w;
            }));
          case 18:
            if (!(!d.length && l)) {
              m.next = 23;
              break;
            }
            return m.next = 21, Promise.all(n.map(function(v, b) {
              return vb("".concat(t, ".").concat(b), v, l, i, o);
            }));
          case 21:
            return f = m.sent, m.abrupt("return", f.reduce(function(v, b) {
              return [].concat(_e(v), _e(b));
            }, []));
          case 23:
            return h = ie(ie({}, r), {}, {
              name: t,
              enum: (r.enum || []).join(", ")
            }, o), p = d.map(function(v) {
              return typeof v == "string" ? C8(v, h) : v;
            }), m.abrupt("return", p);
          case 26:
          case "end":
            return m.stop();
        }
    }, e, null, [[10, 15]]);
  })), bb.apply(this, arguments);
}
function S8(e, t, n, r, i, o) {
  var s = e.join("."), a = n.map(function(c, d) {
    var f = c.validator, h = ie(ie({}, c), {}, {
      ruleIndex: d
    });
    return f && (h.validator = function(p, g, m) {
      var v = !1, b = function() {
        for (var C = arguments.length, y = new Array(C), S = 0; S < C; S++)
          y[S] = arguments[S];
        Promise.resolve().then(function() {
          $t(!v, "Your validator function has already return a promise. `callback` will be ignored."), v || m.apply(void 0, y);
        });
      }, x = f(p, g, b);
      v = x && typeof x.then == "function" && typeof x.catch == "function", $t(v, "`callback` is deprecated. Please return a promise instead."), v && x.then(function() {
        m();
      }).catch(function(w) {
        m(w || " ");
      });
    }), h;
  }).sort(function(c, d) {
    var f = c.warningOnly, h = c.ruleIndex, p = d.warningOnly, g = d.ruleIndex;
    return !!f == !!p ? h - g : f ? 1 : -1;
  }), l;
  if (i === !0)
    l = new Promise(/* @__PURE__ */ function() {
      var c = Cl(/* @__PURE__ */ si().mark(function d(f, h) {
        var p, g, m;
        return si().wrap(function(b) {
          for (; ; )
            switch (b.prev = b.next) {
              case 0:
                p = 0;
              case 1:
                if (!(p < a.length)) {
                  b.next = 12;
                  break;
                }
                return g = a[p], b.next = 5, vb(s, t, g, r, o);
              case 5:
                if (m = b.sent, !m.length) {
                  b.next = 9;
                  break;
                }
                return h([{
                  errors: m,
                  rule: g
                }]), b.abrupt("return");
              case 9:
                p += 1, b.next = 1;
                break;
              case 12:
                f([]);
              case 13:
              case "end":
                return b.stop();
            }
        }, d);
      }));
      return function(d, f) {
        return c.apply(this, arguments);
      };
    }());
  else {
    var u = a.map(function(c) {
      return vb(s, t, c, r, o).then(function(d) {
        return {
          errors: d,
          rule: c
        };
      });
    });
    l = (i ? E8(u) : x8(u)).then(function(c) {
      return Promise.reject(c);
    });
  }
  return l.catch(function(c) {
    return c;
  }), l;
}
function x8(e) {
  return yb.apply(this, arguments);
}
function yb() {
  return yb = Cl(/* @__PURE__ */ si().mark(function e(t) {
    return si().wrap(function(r) {
      for (; ; )
        switch (r.prev = r.next) {
          case 0:
            return r.abrupt("return", Promise.all(t).then(function(i) {
              var o, s = (o = []).concat.apply(o, _e(i));
              return s;
            }));
          case 1:
          case "end":
            return r.stop();
        }
    }, e);
  })), yb.apply(this, arguments);
}
function E8(e) {
  return wb.apply(this, arguments);
}
function wb() {
  return wb = Cl(/* @__PURE__ */ si().mark(function e(t) {
    var n;
    return si().wrap(function(i) {
      for (; ; )
        switch (i.prev = i.next) {
          case 0:
            return n = 0, i.abrupt("return", new Promise(function(o) {
              t.forEach(function(s) {
                s.then(function(a) {
                  a.errors.length && o([a]), n += 1, n === t.length && o([]);
                });
              });
            }));
          case 2:
          case "end":
            return i.stop();
        }
    }, e);
  })), wb.apply(this, arguments);
}
function tr(e) {
  return db(e);
}
function Tx(e, t) {
  var n = {};
  return t.forEach(function(r) {
    var i = Wo(e, r);
    n = co(n, r, i);
  }), n;
}
function dc(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return e && e.some(function(r) {
    return q_(t, r, n);
  });
}
function q_(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return !e || !t || !n && e.length !== t.length ? !1 : t.every(function(r, i) {
    return e[i] === r;
  });
}
function $8(e, t) {
  if (e === t)
    return !0;
  if (!e && t || e && !t || !e || !t || wt(e) !== "object" || wt(t) !== "object")
    return !1;
  var n = Object.keys(e), r = Object.keys(t), i = new Set([].concat(n, r));
  return _e(i).every(function(o) {
    var s = e[o], a = t[o];
    return typeof s == "function" && typeof a == "function" ? !0 : s === a;
  });
}
function O8(e) {
  var t = arguments.length <= 1 ? void 0 : arguments[1];
  return t && t.target && wt(t.target) === "object" && e in t.target ? t.target[e] : t;
}
function Rx(e, t, n) {
  var r = e.length;
  if (t < 0 || t >= r || n < 0 || n >= r)
    return e;
  var i = e[t], o = t - n;
  return o > 0 ? [].concat(_e(e.slice(0, n)), [i], _e(e.slice(n, t)), _e(e.slice(t + 1, r))) : o < 0 ? [].concat(_e(e.slice(0, t)), _e(e.slice(t + 1, n + 1)), [i], _e(e.slice(n + 1, r))) : e;
}
var A8 = ["name"], Ui = [];
function Mx(e, t, n, r, i, o) {
  return typeof e == "function" ? e(t, n, "source" in o ? {
    source: o.source
  } : {}) : r !== i;
}
var Ww = /* @__PURE__ */ function(e) {
  pl(n, e);
  var t = cf(n);
  function n(r) {
    var i;
    if (ci(this, n), i = t.call(this, r), re(tn(i), "state", {
      resetCount: 0
    }), re(tn(i), "cancelRegisterFunc", null), re(tn(i), "mounted", !1), re(tn(i), "touched", !1), re(tn(i), "dirty", !1), re(tn(i), "validatePromise", void 0), re(tn(i), "prevValidating", void 0), re(tn(i), "errors", Ui), re(tn(i), "warnings", Ui), re(tn(i), "cancelRegister", function() {
      var l = i.props, u = l.preserve, c = l.isListField, d = l.name;
      i.cancelRegisterFunc && i.cancelRegisterFunc(c, u, tr(d)), i.cancelRegisterFunc = null;
    }), re(tn(i), "getNamePath", function() {
      var l = i.props, u = l.name, c = l.fieldContext, d = c.prefixName, f = d === void 0 ? [] : d;
      return u !== void 0 ? [].concat(_e(f), _e(u)) : [];
    }), re(tn(i), "getRules", function() {
      var l = i.props, u = l.rules, c = u === void 0 ? [] : u, d = l.fieldContext;
      return c.map(function(f) {
        return typeof f == "function" ? f(d) : f;
      });
    }), re(tn(i), "refresh", function() {
      i.mounted && i.setState(function(l) {
        var u = l.resetCount;
        return {
          resetCount: u + 1
        };
      });
    }), re(tn(i), "metaCache", null), re(tn(i), "triggerMetaEvent", function(l) {
      var u = i.props.onMetaChange;
      if (u) {
        var c = ie(ie({}, i.getMeta()), {}, {
          destroy: l
        });
        pd(i.metaCache, c) || u(c), i.metaCache = c;
      } else
        i.metaCache = null;
    }), re(tn(i), "onStoreChange", function(l, u, c) {
      var d = i.props, f = d.shouldUpdate, h = d.dependencies, p = h === void 0 ? [] : h, g = d.onReset, m = c.store, v = i.getNamePath(), b = i.getValue(l), x = i.getValue(m), w = u && dc(u, v);
      switch (c.type === "valueUpdate" && c.source === "external" && !pd(b, x) && (i.touched = !0, i.dirty = !0, i.validatePromise = null, i.errors = Ui, i.warnings = Ui, i.triggerMetaEvent()), c.type) {
        case "reset":
          if (!u || w) {
            i.touched = !1, i.dirty = !1, i.validatePromise = void 0, i.errors = Ui, i.warnings = Ui, i.triggerMetaEvent(), g == null || g(), i.refresh();
            return;
          }
          break;
        case "remove": {
          if (f) {
            i.reRender();
            return;
          }
          break;
        }
        case "setField": {
          var C = c.data;
          if (w) {
            "touched" in C && (i.touched = C.touched), "validating" in C && !("originRCField" in C) && (i.validatePromise = C.validating ? Promise.resolve([]) : null), "errors" in C && (i.errors = C.errors || Ui), "warnings" in C && (i.warnings = C.warnings || Ui), i.dirty = !0, i.triggerMetaEvent(), i.reRender();
            return;
          } else if ("value" in C && dc(u, v, !0)) {
            i.reRender();
            return;
          }
          if (f && !v.length && Mx(f, l, m, b, x, c)) {
            i.reRender();
            return;
          }
          break;
        }
        case "dependenciesUpdate": {
          var y = p.map(tr);
          if (y.some(function(S) {
            return dc(c.relatedFields, S);
          })) {
            i.reRender();
            return;
          }
          break;
        }
        default:
          if (w || (!p.length || v.length || f) && Mx(f, l, m, b, x, c)) {
            i.reRender();
            return;
          }
          break;
      }
      f === !0 && i.reRender();
    }), re(tn(i), "validateRules", function(l) {
      var u = i.getNamePath(), c = i.getValue(), d = l || {}, f = d.triggerName, h = d.validateOnly, p = h === void 0 ? !1 : h, g = Promise.resolve().then(/* @__PURE__ */ Cl(/* @__PURE__ */ si().mark(function m() {
        var v, b, x, w, C, y, S;
        return si().wrap(function($) {
          for (; ; )
            switch ($.prev = $.next) {
              case 0:
                if (i.mounted) {
                  $.next = 2;
                  break;
                }
                return $.abrupt("return", []);
              case 2:
                if (v = i.props, b = v.validateFirst, x = b === void 0 ? !1 : b, w = v.messageVariables, C = v.validateDebounce, y = i.getRules(), f && (y = y.filter(function(M) {
                  return M;
                }).filter(function(M) {
                  var _ = M.validateTrigger;
                  if (!_)
                    return !0;
                  var T = db(_);
                  return T.includes(f);
                })), !(C && f)) {
                  $.next = 10;
                  break;
                }
                return $.next = 8, new Promise(function(M) {
                  setTimeout(M, C);
                });
              case 8:
                if (i.validatePromise === g) {
                  $.next = 10;
                  break;
                }
                return $.abrupt("return", []);
              case 10:
                return S = S8(u, c, y, l, x, w), S.catch(function(M) {
                  return M;
                }).then(function() {
                  var M = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Ui;
                  if (i.validatePromise === g) {
                    var _;
                    i.validatePromise = null;
                    var T = [], D = [];
                    (_ = M.forEach) === null || _ === void 0 || _.call(M, function(E) {
                      var R = E.rule.warningOnly, I = E.errors, k = I === void 0 ? Ui : I;
                      R ? D.push.apply(D, _e(k)) : T.push.apply(T, _e(k));
                    }), i.errors = T, i.warnings = D, i.triggerMetaEvent(), i.reRender();
                  }
                }), $.abrupt("return", S);
              case 13:
              case "end":
                return $.stop();
            }
        }, m);
      })));
      return p || (i.validatePromise = g, i.dirty = !0, i.errors = Ui, i.warnings = Ui, i.triggerMetaEvent(), i.reRender()), g;
    }), re(tn(i), "isFieldValidating", function() {
      return !!i.validatePromise;
    }), re(tn(i), "isFieldTouched", function() {
      return i.touched;
    }), re(tn(i), "isFieldDirty", function() {
      if (i.dirty || i.props.initialValue !== void 0)
        return !0;
      var l = i.props.fieldContext, u = l.getInternalHooks(Na), c = u.getInitialValue;
      return c(i.getNamePath()) !== void 0;
    }), re(tn(i), "getErrors", function() {
      return i.errors;
    }), re(tn(i), "getWarnings", function() {
      return i.warnings;
    }), re(tn(i), "isListField", function() {
      return i.props.isListField;
    }), re(tn(i), "isList", function() {
      return i.props.isList;
    }), re(tn(i), "isPreserve", function() {
      return i.props.preserve;
    }), re(tn(i), "getMeta", function() {
      i.prevValidating = i.isFieldValidating();
      var l = {
        touched: i.isFieldTouched(),
        validating: i.prevValidating,
        errors: i.errors,
        warnings: i.warnings,
        name: i.getNamePath(),
        validated: i.validatePromise === null
      };
      return l;
    }), re(tn(i), "getOnlyChild", function(l) {
      if (typeof l == "function") {
        var u = i.getMeta();
        return ie(ie({}, i.getOnlyChild(l(i.getControlled(), u, i.props.fieldContext))), {}, {
          isFunction: !0
        });
      }
      var c = Xr(l);
      return c.length !== 1 || !/* @__PURE__ */ O.isValidElement(c[0]) ? {
        child: c,
        isFunction: !1
      } : {
        child: c[0],
        isFunction: !1
      };
    }), re(tn(i), "getValue", function(l) {
      var u = i.props.fieldContext.getFieldsValue, c = i.getNamePath();
      return Wo(l || u(!0), c);
    }), re(tn(i), "getControlled", function() {
      var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = i.props, c = u.name, d = u.trigger, f = u.validateTrigger, h = u.getValueFromEvent, p = u.normalize, g = u.valuePropName, m = u.getValueProps, v = u.fieldContext, b = f !== void 0 ? f : v.validateTrigger, x = i.getNamePath(), w = v.getInternalHooks, C = v.getFieldsValue, y = w(Na), S = y.dispatch, A = i.getValue(), $ = m || function(E) {
        return re({}, g, E);
      }, M = l[d], _ = c !== void 0 ? $(A) : {};
      process.env.NODE_ENV !== "production" && _ && Object.keys(_).forEach(function(E) {
        $t(typeof _[E] != "function", "It's not recommended to generate dynamic function prop by `getValueProps`. Please pass it to child component directly (prop: ".concat(E, ")"));
      });
      var T = ie(ie({}, l), _);
      T[d] = function() {
        i.touched = !0, i.dirty = !0, i.triggerMetaEvent();
        for (var E, R = arguments.length, I = new Array(R), k = 0; k < R; k++)
          I[k] = arguments[k];
        h ? E = h.apply(void 0, I) : E = O8.apply(void 0, [g].concat(I)), p && (E = p(E, A, C(!0))), S({
          type: "updateValue",
          namePath: x,
          value: E
        }), M && M.apply(void 0, I);
      };
      var D = db(b || []);
      return D.forEach(function(E) {
        var R = T[E];
        T[E] = function() {
          R && R.apply(void 0, arguments);
          var I = i.props.rules;
          I && I.length && S({
            type: "validateField",
            namePath: x,
            triggerName: E
          });
        };
      }), T;
    }), r.fieldContext) {
      var o = r.fieldContext.getInternalHooks, s = o(Na), a = s.initEntityValue;
      a(tn(i));
    }
    return i;
  }
  return ui(n, [{
    key: "componentDidMount",
    value: function() {
      var i = this.props, o = i.shouldUpdate, s = i.fieldContext;
      if (this.mounted = !0, s) {
        var a = s.getInternalHooks, l = a(Na), u = l.registerField;
        this.cancelRegisterFunc = u(this);
      }
      o === !0 && this.reRender();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.cancelRegister(), this.triggerMetaEvent(!0), this.mounted = !1;
    }
  }, {
    key: "reRender",
    value: function() {
      this.mounted && this.forceUpdate();
    }
  }, {
    key: "render",
    value: function() {
      var i = this.state.resetCount, o = this.props.children, s = this.getOnlyChild(o), a = s.child, l = s.isFunction, u;
      return l ? u = a : /* @__PURE__ */ O.isValidElement(a) ? u = /* @__PURE__ */ O.cloneElement(a, this.getControlled(a.props)) : ($t(!a, "`children` of Field is not validate ReactElement."), u = a), /* @__PURE__ */ O.createElement(O.Fragment, {
        key: i
      }, u);
    }
  }]), n;
}(O.Component);
re(Ww, "contextType", Ja);
re(Ww, "defaultProps", {
  trigger: "onChange",
  valuePropName: "value"
});
function Uw(e) {
  var t = e.name, n = Rt(e, A8), r = O.useContext(Ja), i = O.useContext(Sd), o = t !== void 0 ? tr(t) : void 0, s = "keep";
  return n.isListField || (s = "_".concat((o || []).join("_"))), process.env.NODE_ENV !== "production" && n.preserve === !1 && n.isListField && o.length <= 1 && $t(!1, "`preserve` should not apply on Form.List fields."), /* @__PURE__ */ O.createElement(Ww, we({
    key: s,
    name: o,
    isListField: !!i
  }, n, {
    fieldContext: r
  }));
}
function Q_(e) {
  var t = e.name, n = e.initialValue, r = e.children, i = e.rules, o = e.validateTrigger, s = e.isListField, a = O.useContext(Ja), l = O.useContext(Sd), u = O.useRef({
    keys: [],
    id: 0
  }), c = u.current, d = O.useMemo(function() {
    var g = tr(a.prefixName) || [];
    return [].concat(_e(g), _e(tr(t)));
  }, [a.prefixName, t]), f = O.useMemo(function() {
    return ie(ie({}, a), {}, {
      prefixName: d
    });
  }, [a, d]), h = O.useMemo(function() {
    return {
      getKey: function(m) {
        var v = d.length, b = m[v];
        return [c.keys[b], m.slice(v + 1)];
      }
    };
  }, [d]);
  if (typeof r != "function")
    return $t(!1, "Form.List only accepts function as children."), null;
  var p = function(m, v, b) {
    var x = b.source;
    return x === "internal" ? !1 : m !== v;
  };
  return /* @__PURE__ */ O.createElement(Sd.Provider, {
    value: h
  }, /* @__PURE__ */ O.createElement(Ja.Provider, {
    value: f
  }, /* @__PURE__ */ O.createElement(Uw, {
    name: [],
    shouldUpdate: p,
    rules: i,
    validateTrigger: o,
    initialValue: n,
    isList: !0,
    isListField: s ?? !!l
  }, function(g, m) {
    var v = g.value, b = v === void 0 ? [] : v, x = g.onChange, w = a.getFieldValue, C = function() {
      var $ = w(d || []);
      return $ || [];
    }, y = {
      add: function($, M) {
        var _ = C();
        M >= 0 && M <= _.length ? (c.keys = [].concat(_e(c.keys.slice(0, M)), [c.id], _e(c.keys.slice(M))), x([].concat(_e(_.slice(0, M)), [$], _e(_.slice(M))))) : (process.env.NODE_ENV !== "production" && (M < 0 || M > _.length) && $t(!1, "The second parameter of the add function should be a valid positive number."), c.keys = [].concat(_e(c.keys), [c.id]), x([].concat(_e(_), [$]))), c.id += 1;
      },
      remove: function($) {
        var M = C(), _ = new Set(Array.isArray($) ? $ : [$]);
        _.size <= 0 || (c.keys = c.keys.filter(function(T, D) {
          return !_.has(D);
        }), x(M.filter(function(T, D) {
          return !_.has(D);
        })));
      },
      move: function($, M) {
        if ($ !== M) {
          var _ = C();
          $ < 0 || $ >= _.length || M < 0 || M >= _.length || (c.keys = Rx(c.keys, $, M), x(Rx(_, $, M)));
        }
      }
    }, S = b || [];
    return Array.isArray(S) || (S = [], process.env.NODE_ENV !== "production" && $t(!1, "Current value of '".concat(d.join(" > "), "' is not an array type."))), r(S.map(function(A, $) {
      var M = c.keys[$];
      return M === void 0 && (c.keys[$] = c.id, M = c.keys[$], c.id += 1), {
        name: $,
        key: M,
        isListField: !0
      };
    }), y, m);
  })));
}
function D8(e) {
  var t = !1, n = e.length, r = [];
  return e.length ? new Promise(function(i, o) {
    e.forEach(function(s, a) {
      s.catch(function(l) {
        return t = !0, l;
      }).then(function(l) {
        n -= 1, r[a] = l, !(n > 0) && (t && o(r), i(r));
      });
    });
  }) : Promise.resolve([]);
}
var Z_ = "__@field_split__";
function rv(e) {
  return e.map(function(t) {
    return "".concat(wt(t), ":").concat(t);
  }).join(Z_);
}
var Pl = /* @__PURE__ */ function() {
  function e() {
    ci(this, e), re(this, "kvs", /* @__PURE__ */ new Map());
  }
  return ui(e, [{
    key: "set",
    value: function(n, r) {
      this.kvs.set(rv(n), r);
    }
  }, {
    key: "get",
    value: function(n) {
      return this.kvs.get(rv(n));
    }
  }, {
    key: "update",
    value: function(n, r) {
      var i = this.get(n), o = r(i);
      o ? this.set(n, o) : this.delete(n);
    }
  }, {
    key: "delete",
    value: function(n) {
      this.kvs.delete(rv(n));
    }
    // Since we only use this in test, let simply realize this
  }, {
    key: "map",
    value: function(n) {
      return _e(this.kvs.entries()).map(function(r) {
        var i = ae(r, 2), o = i[0], s = i[1], a = o.split(Z_);
        return n({
          key: a.map(function(l) {
            var u = l.match(/^([^:]*):(.*)$/), c = ae(u, 3), d = c[1], f = c[2];
            return d === "number" ? Number(f) : f;
          }),
          value: s
        });
      });
    }
  }, {
    key: "toJSON",
    value: function() {
      var n = {};
      return this.map(function(r) {
        var i = r.key, o = r.value;
        return n[i.join(".")] = o, null;
      }), n;
    }
  }]), e;
}(), _8 = ["name"], T8 = /* @__PURE__ */ ui(function e(t) {
  var n = this;
  ci(this, e), re(this, "formHooked", !1), re(this, "forceRootUpdate", void 0), re(this, "subscribable", !0), re(this, "store", {}), re(this, "fieldEntities", []), re(this, "initialValues", {}), re(this, "callbacks", {}), re(this, "validateMessages", null), re(this, "preserve", null), re(this, "lastValidatePromise", null), re(this, "getForm", function() {
    return {
      getFieldValue: n.getFieldValue,
      getFieldsValue: n.getFieldsValue,
      getFieldError: n.getFieldError,
      getFieldWarning: n.getFieldWarning,
      getFieldsError: n.getFieldsError,
      isFieldsTouched: n.isFieldsTouched,
      isFieldTouched: n.isFieldTouched,
      isFieldValidating: n.isFieldValidating,
      isFieldsValidating: n.isFieldsValidating,
      resetFields: n.resetFields,
      setFields: n.setFields,
      setFieldValue: n.setFieldValue,
      setFieldsValue: n.setFieldsValue,
      validateFields: n.validateFields,
      submit: n.submit,
      _init: !0,
      getInternalHooks: n.getInternalHooks
    };
  }), re(this, "getInternalHooks", function(r) {
    return r === Na ? (n.formHooked = !0, {
      dispatch: n.dispatch,
      initEntityValue: n.initEntityValue,
      registerField: n.registerField,
      useSubscribe: n.useSubscribe,
      setInitialValues: n.setInitialValues,
      destroyForm: n.destroyForm,
      setCallbacks: n.setCallbacks,
      setValidateMessages: n.setValidateMessages,
      getFields: n.getFields,
      setPreserve: n.setPreserve,
      getInitialValue: n.getInitialValue,
      registerWatch: n.registerWatch
    }) : ($t(!1, "`getInternalHooks` is internal usage. Should not call directly."), null);
  }), re(this, "useSubscribe", function(r) {
    n.subscribable = r;
  }), re(this, "prevWithoutPreserves", null), re(this, "setInitialValues", function(r, i) {
    if (n.initialValues = r || {}, i) {
      var o, s = rc(r, n.store);
      (o = n.prevWithoutPreserves) === null || o === void 0 || o.map(function(a) {
        var l = a.key;
        s = co(s, l, Wo(r, l));
      }), n.prevWithoutPreserves = null, n.updateStore(s);
    }
  }), re(this, "destroyForm", function() {
    var r = new Pl();
    n.getFieldEntities(!0).forEach(function(i) {
      n.isMergedPreserve(i.isPreserve()) || r.set(i.getNamePath(), !0);
    }), n.prevWithoutPreserves = r;
  }), re(this, "getInitialValue", function(r) {
    var i = Wo(n.initialValues, r);
    return r.length ? rc(i) : i;
  }), re(this, "setCallbacks", function(r) {
    n.callbacks = r;
  }), re(this, "setValidateMessages", function(r) {
    n.validateMessages = r;
  }), re(this, "setPreserve", function(r) {
    n.preserve = r;
  }), re(this, "watchList", []), re(this, "registerWatch", function(r) {
    return n.watchList.push(r), function() {
      n.watchList = n.watchList.filter(function(i) {
        return i !== r;
      });
    };
  }), re(this, "notifyWatch", function() {
    var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    if (n.watchList.length) {
      var i = n.getFieldsValue(), o = n.getFieldsValue(!0);
      n.watchList.forEach(function(s) {
        s(i, o, r);
      });
    }
  }), re(this, "timeoutId", null), re(this, "warningUnhooked", function() {
    process.env.NODE_ENV !== "production" && !n.timeoutId && typeof window < "u" && (n.timeoutId = setTimeout(function() {
      n.timeoutId = null, n.formHooked || $t(!1, "Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?");
    }));
  }), re(this, "updateStore", function(r) {
    n.store = r;
  }), re(this, "getFieldEntities", function() {
    var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    return r ? n.fieldEntities.filter(function(i) {
      return i.getNamePath().length;
    }) : n.fieldEntities;
  }), re(this, "getFieldsMap", function() {
    var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, i = new Pl();
    return n.getFieldEntities(r).forEach(function(o) {
      var s = o.getNamePath();
      i.set(s, o);
    }), i;
  }), re(this, "getFieldEntitiesForNamePathList", function(r) {
    if (!r)
      return n.getFieldEntities(!0);
    var i = n.getFieldsMap(!0);
    return r.map(function(o) {
      var s = tr(o);
      return i.get(s) || {
        INVALIDATE_NAME_PATH: tr(o)
      };
    });
  }), re(this, "getFieldsValue", function(r, i) {
    n.warningUnhooked();
    var o, s, a;
    if (r === !0 || Array.isArray(r) ? (o = r, s = i) : r && wt(r) === "object" && (a = r.strict, s = r.filter), o === !0 && !s)
      return n.store;
    var l = n.getFieldEntitiesForNamePathList(Array.isArray(o) ? o : null), u = [];
    return l.forEach(function(c) {
      var d, f, h = "INVALIDATE_NAME_PATH" in c ? c.INVALIDATE_NAME_PATH : c.getNamePath();
      if (a) {
        var p, g;
        if ((p = (g = c).isList) !== null && p !== void 0 && p.call(g))
          return;
      } else if (!o && (d = (f = c).isListField) !== null && d !== void 0 && d.call(f))
        return;
      if (!s)
        u.push(h);
      else {
        var m = "getMeta" in c ? c.getMeta() : null;
        s(m) && u.push(h);
      }
    }), Tx(n.store, u.map(tr));
  }), re(this, "getFieldValue", function(r) {
    n.warningUnhooked();
    var i = tr(r);
    return Wo(n.store, i);
  }), re(this, "getFieldsError", function(r) {
    n.warningUnhooked();
    var i = n.getFieldEntitiesForNamePathList(r);
    return i.map(function(o, s) {
      return o && !("INVALIDATE_NAME_PATH" in o) ? {
        name: o.getNamePath(),
        errors: o.getErrors(),
        warnings: o.getWarnings()
      } : {
        name: tr(r[s]),
        errors: [],
        warnings: []
      };
    });
  }), re(this, "getFieldError", function(r) {
    n.warningUnhooked();
    var i = tr(r), o = n.getFieldsError([i])[0];
    return o.errors;
  }), re(this, "getFieldWarning", function(r) {
    n.warningUnhooked();
    var i = tr(r), o = n.getFieldsError([i])[0];
    return o.warnings;
  }), re(this, "isFieldsTouched", function() {
    n.warningUnhooked();
    for (var r = arguments.length, i = new Array(r), o = 0; o < r; o++)
      i[o] = arguments[o];
    var s = i[0], a = i[1], l, u = !1;
    i.length === 0 ? l = null : i.length === 1 ? Array.isArray(s) ? (l = s.map(tr), u = !1) : (l = null, u = s) : (l = s.map(tr), u = a);
    var c = n.getFieldEntities(!0), d = function(m) {
      return m.isFieldTouched();
    };
    if (!l)
      return u ? c.every(function(g) {
        return d(g) || g.isList();
      }) : c.some(d);
    var f = new Pl();
    l.forEach(function(g) {
      f.set(g, []);
    }), c.forEach(function(g) {
      var m = g.getNamePath();
      l.forEach(function(v) {
        v.every(function(b, x) {
          return m[x] === b;
        }) && f.update(v, function(b) {
          return [].concat(_e(b), [g]);
        });
      });
    });
    var h = function(m) {
      return m.some(d);
    }, p = f.map(function(g) {
      var m = g.value;
      return m;
    });
    return u ? p.every(h) : p.some(h);
  }), re(this, "isFieldTouched", function(r) {
    return n.warningUnhooked(), n.isFieldsTouched([r]);
  }), re(this, "isFieldsValidating", function(r) {
    n.warningUnhooked();
    var i = n.getFieldEntities();
    if (!r)
      return i.some(function(s) {
        return s.isFieldValidating();
      });
    var o = r.map(tr);
    return i.some(function(s) {
      var a = s.getNamePath();
      return dc(o, a) && s.isFieldValidating();
    });
  }), re(this, "isFieldValidating", function(r) {
    return n.warningUnhooked(), n.isFieldsValidating([r]);
  }), re(this, "resetWithFieldInitialValue", function() {
    var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, i = new Pl(), o = n.getFieldEntities(!0);
    o.forEach(function(l) {
      var u = l.props.initialValue, c = l.getNamePath();
      if (u !== void 0) {
        var d = i.get(c) || /* @__PURE__ */ new Set();
        d.add({
          entity: l,
          value: u
        }), i.set(c, d);
      }
    });
    var s = function(u) {
      u.forEach(function(c) {
        var d = c.props.initialValue;
        if (d !== void 0) {
          var f = c.getNamePath(), h = n.getInitialValue(f);
          if (h !== void 0)
            $t(!1, "Form already set 'initialValues' with path '".concat(f.join("."), "'. Field can not overwrite it."));
          else {
            var p = i.get(f);
            if (p && p.size > 1)
              $t(!1, "Multiple Field with path '".concat(f.join("."), "' set 'initialValue'. Can not decide which one to pick."));
            else if (p) {
              var g = n.getFieldValue(f), m = c.isListField();
              !m && (!r.skipExist || g === void 0) && n.updateStore(co(n.store, f, _e(p)[0].value));
            }
          }
        }
      });
    }, a;
    r.entities ? a = r.entities : r.namePathList ? (a = [], r.namePathList.forEach(function(l) {
      var u = i.get(l);
      if (u) {
        var c;
        (c = a).push.apply(c, _e(_e(u).map(function(d) {
          return d.entity;
        })));
      }
    })) : a = o, s(a);
  }), re(this, "resetFields", function(r) {
    n.warningUnhooked();
    var i = n.store;
    if (!r) {
      n.updateStore(rc(n.initialValues)), n.resetWithFieldInitialValue(), n.notifyObservers(i, null, {
        type: "reset"
      }), n.notifyWatch();
      return;
    }
    var o = r.map(tr);
    o.forEach(function(s) {
      var a = n.getInitialValue(s);
      n.updateStore(co(n.store, s, a));
    }), n.resetWithFieldInitialValue({
      namePathList: o
    }), n.notifyObservers(i, o, {
      type: "reset"
    }), n.notifyWatch(o);
  }), re(this, "setFields", function(r) {
    n.warningUnhooked();
    var i = n.store, o = [];
    r.forEach(function(s) {
      var a = s.name, l = Rt(s, _8), u = tr(a);
      o.push(u), "value" in l && n.updateStore(co(n.store, u, l.value)), n.notifyObservers(i, [u], {
        type: "setField",
        data: s
      });
    }), n.notifyWatch(o);
  }), re(this, "getFields", function() {
    var r = n.getFieldEntities(!0), i = r.map(function(o) {
      var s = o.getNamePath(), a = o.getMeta(), l = ie(ie({}, a), {}, {
        name: s,
        value: n.getFieldValue(s)
      });
      return Object.defineProperty(l, "originRCField", {
        value: !0
      }), l;
    });
    return i;
  }), re(this, "initEntityValue", function(r) {
    var i = r.props.initialValue;
    if (i !== void 0) {
      var o = r.getNamePath(), s = Wo(n.store, o);
      s === void 0 && n.updateStore(co(n.store, o, i));
    }
  }), re(this, "isMergedPreserve", function(r) {
    var i = r !== void 0 ? r : n.preserve;
    return i ?? !0;
  }), re(this, "registerField", function(r) {
    n.fieldEntities.push(r);
    var i = r.getNamePath();
    if (n.notifyWatch([i]), r.props.initialValue !== void 0) {
      var o = n.store;
      n.resetWithFieldInitialValue({
        entities: [r],
        skipExist: !0
      }), n.notifyObservers(o, [r.getNamePath()], {
        type: "valueUpdate",
        source: "internal"
      });
    }
    return function(s, a) {
      var l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      if (n.fieldEntities = n.fieldEntities.filter(function(d) {
        return d !== r;
      }), !n.isMergedPreserve(a) && (!s || l.length > 1)) {
        var u = s ? void 0 : n.getInitialValue(i);
        if (i.length && n.getFieldValue(i) !== u && n.fieldEntities.every(function(d) {
          return (
            // Only reset when no namePath exist
            !q_(d.getNamePath(), i)
          );
        })) {
          var c = n.store;
          n.updateStore(co(c, i, u, !0)), n.notifyObservers(c, [i], {
            type: "remove"
          }), n.triggerDependenciesUpdate(c, i);
        }
      }
      n.notifyWatch([i]);
    };
  }), re(this, "dispatch", function(r) {
    switch (r.type) {
      case "updateValue": {
        var i = r.namePath, o = r.value;
        n.updateValue(i, o);
        break;
      }
      case "validateField": {
        var s = r.namePath, a = r.triggerName;
        n.validateFields([s], {
          triggerName: a
        });
        break;
      }
    }
  }), re(this, "notifyObservers", function(r, i, o) {
    if (n.subscribable) {
      var s = ie(ie({}, o), {}, {
        store: n.getFieldsValue(!0)
      });
      n.getFieldEntities().forEach(function(a) {
        var l = a.onStoreChange;
        l(r, i, s);
      });
    } else
      n.forceRootUpdate();
  }), re(this, "triggerDependenciesUpdate", function(r, i) {
    var o = n.getDependencyChildrenFields(i);
    return o.length && n.validateFields(o), n.notifyObservers(r, o, {
      type: "dependenciesUpdate",
      relatedFields: [i].concat(_e(o))
    }), o;
  }), re(this, "updateValue", function(r, i) {
    var o = tr(r), s = n.store;
    n.updateStore(co(n.store, o, i)), n.notifyObservers(s, [o], {
      type: "valueUpdate",
      source: "internal"
    }), n.notifyWatch([o]);
    var a = n.triggerDependenciesUpdate(s, o), l = n.callbacks.onValuesChange;
    if (l) {
      var u = Tx(n.store, [o]);
      l(u, n.getFieldsValue());
    }
    n.triggerOnFieldsChange([o].concat(_e(a)));
  }), re(this, "setFieldsValue", function(r) {
    n.warningUnhooked();
    var i = n.store;
    if (r) {
      var o = rc(n.store, r);
      n.updateStore(o);
    }
    n.notifyObservers(i, null, {
      type: "valueUpdate",
      source: "external"
    }), n.notifyWatch();
  }), re(this, "setFieldValue", function(r, i) {
    n.setFields([{
      name: r,
      value: i
    }]);
  }), re(this, "getDependencyChildrenFields", function(r) {
    var i = /* @__PURE__ */ new Set(), o = [], s = new Pl();
    n.getFieldEntities().forEach(function(l) {
      var u = l.props.dependencies;
      (u || []).forEach(function(c) {
        var d = tr(c);
        s.update(d, function() {
          var f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
          return f.add(l), f;
        });
      });
    });
    var a = function l(u) {
      var c = s.get(u) || /* @__PURE__ */ new Set();
      c.forEach(function(d) {
        if (!i.has(d)) {
          i.add(d);
          var f = d.getNamePath();
          d.isFieldDirty() && f.length && (o.push(f), l(f));
        }
      });
    };
    return a(r), o;
  }), re(this, "triggerOnFieldsChange", function(r, i) {
    var o = n.callbacks.onFieldsChange;
    if (o) {
      var s = n.getFields();
      if (i) {
        var a = new Pl();
        i.forEach(function(u) {
          var c = u.name, d = u.errors;
          a.set(c, d);
        }), s.forEach(function(u) {
          u.errors = a.get(u.name) || u.errors;
        });
      }
      var l = s.filter(function(u) {
        var c = u.name;
        return dc(r, c);
      });
      l.length && o(l, s);
    }
  }), re(this, "validateFields", function(r, i) {
    n.warningUnhooked();
    var o, s;
    Array.isArray(r) || typeof r == "string" || typeof i == "string" ? (o = r, s = i) : s = r;
    var a = !!o, l = a ? o.map(tr) : [], u = [], c = String(Date.now()), d = /* @__PURE__ */ new Set(), f = s || {}, h = f.recursive, p = f.dirty;
    n.getFieldEntities(!0).forEach(function(b) {
      if (a || l.push(b.getNamePath()), !(!b.props.rules || !b.props.rules.length) && !(p && !b.isFieldDirty())) {
        var x = b.getNamePath();
        if (d.add(x.join(c)), !a || dc(l, x, h)) {
          var w = b.validateRules(ie({
            validateMessages: ie(ie({}, Y_), n.validateMessages)
          }, s));
          u.push(w.then(function() {
            return {
              name: x,
              errors: [],
              warnings: []
            };
          }).catch(function(C) {
            var y, S = [], A = [];
            return (y = C.forEach) === null || y === void 0 || y.call(C, function($) {
              var M = $.rule.warningOnly, _ = $.errors;
              M ? A.push.apply(A, _e(_)) : S.push.apply(S, _e(_));
            }), S.length ? Promise.reject({
              name: x,
              errors: S,
              warnings: A
            }) : {
              name: x,
              errors: S,
              warnings: A
            };
          }));
        }
      }
    });
    var g = D8(u);
    n.lastValidatePromise = g, g.catch(function(b) {
      return b;
    }).then(function(b) {
      var x = b.map(function(w) {
        var C = w.name;
        return C;
      });
      n.notifyObservers(n.store, x, {
        type: "validateFinish"
      }), n.triggerOnFieldsChange(x, b);
    });
    var m = g.then(function() {
      return n.lastValidatePromise === g ? Promise.resolve(n.getFieldsValue(l)) : Promise.reject([]);
    }).catch(function(b) {
      var x = b.filter(function(w) {
        return w && w.errors.length;
      });
      return Promise.reject({
        values: n.getFieldsValue(l),
        errorFields: x,
        outOfDate: n.lastValidatePromise !== g
      });
    });
    m.catch(function(b) {
      return b;
    });
    var v = l.filter(function(b) {
      return d.has(b.join(c));
    });
    return n.triggerOnFieldsChange(v), m;
  }), re(this, "submit", function() {
    n.warningUnhooked(), n.validateFields().then(function(r) {
      var i = n.callbacks.onFinish;
      if (i)
        try {
          i(r);
        } catch (o) {
          console.error(o);
        }
    }).catch(function(r) {
      var i = n.callbacks.onFinishFailed;
      i && i(r);
    });
  }), this.forceRootUpdate = t;
});
function Gw(e) {
  var t = O.useRef(), n = O.useState({}), r = ae(n, 2), i = r[1];
  if (!t.current)
    if (e)
      t.current = e;
    else {
      var o = function() {
        i({});
      }, s = new T8(o);
      t.current = s.getForm();
    }
  return [t.current];
}
var Cb = /* @__PURE__ */ O.createContext({
  triggerFormChange: function() {
  },
  triggerFormFinish: function() {
  },
  registerForm: function() {
  },
  unregisterForm: function() {
  }
}), J_ = function(t) {
  var n = t.validateMessages, r = t.onFormChange, i = t.onFormFinish, o = t.children, s = O.useContext(Cb), a = O.useRef({});
  return /* @__PURE__ */ O.createElement(Cb.Provider, {
    value: ie(ie({}, s), {}, {
      validateMessages: ie(ie({}, s.validateMessages), n),
      // =========================================================
      // =                  Global Form Control                  =
      // =========================================================
      triggerFormChange: function(u, c) {
        r && r(u, {
          changedFields: c,
          forms: a.current
        }), s.triggerFormChange(u, c);
      },
      triggerFormFinish: function(u, c) {
        i && i(u, {
          values: c,
          forms: a.current
        }), s.triggerFormFinish(u, c);
      },
      registerForm: function(u, c) {
        u && (a.current = ie(ie({}, a.current), {}, re({}, u, c))), s.registerForm(u, c);
      },
      unregisterForm: function(u) {
        var c = ie({}, a.current);
        delete c[u], a.current = c, s.unregisterForm(u);
      }
    })
  }, o);
}, R8 = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed"], M8 = function(t, n) {
  var r = t.name, i = t.initialValues, o = t.fields, s = t.form, a = t.preserve, l = t.children, u = t.component, c = u === void 0 ? "form" : u, d = t.validateMessages, f = t.validateTrigger, h = f === void 0 ? "onChange" : f, p = t.onValuesChange, g = t.onFieldsChange, m = t.onFinish, v = t.onFinishFailed, b = Rt(t, R8), x = O.useContext(Cb), w = Gw(s), C = ae(w, 1), y = C[0], S = y.getInternalHooks(Na), A = S.useSubscribe, $ = S.setInitialValues, M = S.setCallbacks, _ = S.setValidateMessages, T = S.setPreserve, D = S.destroyForm;
  O.useImperativeHandle(n, function() {
    return y;
  }), O.useEffect(function() {
    return x.registerForm(r, y), function() {
      x.unregisterForm(r);
    };
  }, [x, y, r]), _(ie(ie({}, x.validateMessages), d)), M({
    onValuesChange: p,
    onFieldsChange: function(B) {
      if (x.triggerFormChange(r, B), g) {
        for (var j = arguments.length, z = new Array(j > 1 ? j - 1 : 0), H = 1; H < j; H++)
          z[H - 1] = arguments[H];
        g.apply(void 0, [B].concat(z));
      }
    },
    onFinish: function(B) {
      x.triggerFormFinish(r, B), m && m(B);
    },
    onFinishFailed: v
  }), T(a);
  var E = O.useRef(null);
  $(i, !E.current), E.current || (E.current = !0), O.useEffect(
    function() {
      return D;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  var R, I = typeof l == "function";
  if (I) {
    var k = y.getFieldsValue(!0);
    R = l(k, y);
  } else
    R = l;
  A(!I);
  var P = O.useRef();
  O.useEffect(function() {
    $8(P.current || [], o || []) || y.setFields(o || []), P.current = o;
  }, [o, y]);
  var L = O.useMemo(function() {
    return ie(ie({}, y), {}, {
      validateTrigger: h
    });
  }, [y, h]), N = /* @__PURE__ */ O.createElement(Sd.Provider, {
    value: null
  }, /* @__PURE__ */ O.createElement(Ja.Provider, {
    value: L
  }, R));
  return c === !1 ? N : /* @__PURE__ */ O.createElement(c, we({}, b, {
    onSubmit: function(B) {
      B.preventDefault(), B.stopPropagation(), y.submit();
    },
    onReset: function(B) {
      var j;
      B.preventDefault(), y.resetFields(), (j = b.onReset) === null || j === void 0 || j.call(b, B);
    }
  }), N);
};
function Ix(e) {
  try {
    return JSON.stringify(e);
  } catch {
    return Math.random();
  }
}
var I8 = process.env.NODE_ENV !== "production" ? function(e) {
  var t = e.join("__RC_FIELD_FORM_SPLIT__"), n = he(t);
  $t(n.current === t, "`useWatch` is not support dynamic `namePath`. Please provide static instead.");
} : function() {
};
function eT() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  var r = t[0], i = t[1], o = i === void 0 ? {} : i, s = V6(o) ? {
    form: o
  } : o, a = s.form, l = ht(), u = ae(l, 2), c = u[0], d = u[1], f = mt(function() {
    return Ix(c);
  }, [c]), h = he(f);
  h.current = f;
  var p = Yt(Ja), g = a || p, m = g && g._init;
  process.env.NODE_ENV !== "production" && $t(t.length === 2 ? a ? m : !0 : m, "useWatch requires a form instance since it can not auto detect from context.");
  var v = tr(r), b = he(v);
  return b.current = v, I8(v), Pe(
    function() {
      if (m) {
        var x = g.getFieldsValue, w = g.getInternalHooks, C = w(Na), y = C.registerWatch, S = function(_, T) {
          var D = s.preserve ? T : _;
          return typeof r == "function" ? r(D) : Wo(D, b.current);
        }, A = y(function(M, _) {
          var T = S(M, _), D = Ix(T);
          h.current !== D && (h.current = D, d(T));
        }), $ = S(x(), x(!0));
        return c !== $ && d($), A;
      }
    },
    // We do not need re-register since namePath content is the same
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [m]
  ), c;
}
var k8 = /* @__PURE__ */ O.forwardRef(M8), eu = k8;
eu.FormProvider = J_;
eu.Field = Uw;
eu.List = Q_;
eu.useForm = Gw;
eu.useWatch = eT;
const As = /* @__PURE__ */ O.createContext({
  labelAlign: "right",
  vertical: !1,
  itemRef: () => {
  }
}), tT = /* @__PURE__ */ O.createContext(null), nT = (e) => {
  const t = zn(e, ["prefixCls"]);
  return /* @__PURE__ */ O.createElement(J_, Object.assign({}, t));
}, Kw = /* @__PURE__ */ O.createContext({
  prefixCls: ""
}), Yr = /* @__PURE__ */ O.createContext({});
process.env.NODE_ENV !== "production" && (Yr.displayName = "FormItemInputContext");
const Sb = (e) => {
  let {
    children: t,
    status: n,
    override: r
  } = e;
  const i = Yt(Yr), o = mt(() => {
    const s = Object.assign({}, i);
    return r && delete s.isFormItemInput, n && (delete s.status, delete s.hasFeedback, delete s.feedbackIcon), s;
  }, [n, r, i]);
  return /* @__PURE__ */ O.createElement(Yr.Provider, {
    value: o
  }, t);
}, rT = /* @__PURE__ */ Yo(void 0);
function kx() {
}
const P8 = /* @__PURE__ */ O.createContext({
  add: kx,
  remove: kx
});
function N8(e) {
  const t = O.useContext(P8), n = O.useRef();
  return Nn((i) => {
    if (i) {
      const o = e ? i.querySelector(e) : i;
      t.add(o), n.current = o;
    } else
      t.remove(n.current);
  });
}
const Px = () => {
  const {
    cancelButtonProps: e,
    cancelTextLocale: t,
    onCancel: n
  } = Yt(gf);
  return /* @__PURE__ */ U.createElement(Ut, Object.assign({
    onClick: n
  }, e), t);
}, Nx = () => {
  const {
    confirmLoading: e,
    okButtonProps: t,
    okType: n,
    okTextLocale: r,
    onOk: i
  } = Yt(gf);
  return /* @__PURE__ */ U.createElement(Ut, Object.assign({}, Bw(n), {
    loading: e,
    onClick: i
  }, t), r);
};
function iT(e, t) {
  return /* @__PURE__ */ U.createElement("span", {
    className: `${e}-close-x`
  }, t || /* @__PURE__ */ U.createElement(To, {
    className: `${e}-close-icon`
  }));
}
const oT = (e) => {
  const {
    okText: t,
    okType: n = "primary",
    cancelText: r,
    confirmLoading: i,
    onOk: o,
    onCancel: s,
    okButtonProps: a,
    cancelButtonProps: l,
    footer: u
  } = e, [c] = ml("Modal", kD()), d = t || (c == null ? void 0 : c.okText), f = r || (c == null ? void 0 : c.cancelText), h = {
    confirmLoading: i,
    okButtonProps: a,
    cancelButtonProps: l,
    okTextLocale: d,
    cancelTextLocale: f,
    okType: n,
    onOk: o,
    onCancel: s
  }, p = U.useMemo(() => h, _e(Object.values(h)));
  let g;
  return typeof u == "function" || typeof u > "u" ? (g = /* @__PURE__ */ U.createElement(U.Fragment, null, /* @__PURE__ */ U.createElement(Px, null), /* @__PURE__ */ U.createElement(Nx, null)), typeof u == "function" && (g = u(g, {
    OkBtn: Nx,
    CancelBtn: Px
  })), g = /* @__PURE__ */ U.createElement(j_, {
    value: p
  }, g)) : g = u, /* @__PURE__ */ U.createElement(Tw, {
    disabled: !1
  }, g);
}, sT = (e) => ({
  [e.componentCls]: {
    // For common/openAnimation
    [`${e.antCls}-motion-collapse-legacy`]: {
      overflow: "hidden",
      "&-active": {
        transition: `height ${e.motionDurationMid} ${e.motionEaseInOut},
        opacity ${e.motionDurationMid} ${e.motionEaseInOut} !important`
      }
    },
    [`${e.antCls}-motion-collapse`]: {
      overflow: "hidden",
      transition: `height ${e.motionDurationMid} ${e.motionEaseInOut},
        opacity ${e.motionDurationMid} ${e.motionEaseInOut} !important`
    }
  }
}), L8 = (e) => ({
  animationDuration: e,
  animationFillMode: "both"
}), F8 = (e) => ({
  animationDuration: e,
  animationFillMode: "both"
}), Hg = function(e, t, n, r) {
  const o = (arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1) ? "&" : "";
  return {
    [`
      ${o}${e}-enter,
      ${o}${e}-appear
    `]: Object.assign(Object.assign({}, L8(r)), {
      animationPlayState: "paused"
    }),
    [`${o}${e}-leave`]: Object.assign(Object.assign({}, F8(r)), {
      animationPlayState: "paused"
    }),
    [`
      ${o}${e}-enter${e}-enter-active,
      ${o}${e}-appear${e}-appear-active
    `]: {
      animationName: t,
      animationPlayState: "running"
    },
    [`${o}${e}-leave${e}-leave-active`]: {
      animationName: n,
      animationPlayState: "running",
      pointerEvents: "none"
    }
  };
}, B8 = new Gt("antFadeIn", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
}), j8 = new Gt("antFadeOut", {
  "0%": {
    opacity: 1
  },
  "100%": {
    opacity: 0
  }
}), z8 = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const {
    antCls: n
  } = e, r = `${n}-fade`, i = t ? "&" : "";
  return [Hg(r, B8, j8, e.motionDurationMid, t), {
    [`
        ${i}${r}-enter,
        ${i}${r}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: "linear"
    },
    [`${i}${r}-leave`]: {
      animationTimingFunction: "linear"
    }
  }];
}, H8 = new Gt("antMoveDownIn", {
  "0%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), V8 = new Gt("antMoveDownOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), W8 = new Gt("antMoveLeftIn", {
  "0%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), U8 = new Gt("antMoveLeftOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), G8 = new Gt("antMoveRightIn", {
  "0%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), K8 = new Gt("antMoveRightOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), X8 = new Gt("antMoveUpIn", {
  "0%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), Y8 = new Gt("antMoveUpOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), q8 = {
  "move-up": {
    inKeyframes: X8,
    outKeyframes: Y8
  },
  "move-down": {
    inKeyframes: H8,
    outKeyframes: V8
  },
  "move-left": {
    inKeyframes: W8,
    outKeyframes: U8
  },
  "move-right": {
    inKeyframes: G8,
    outKeyframes: K8
  }
}, Tp = (e, t) => {
  const {
    antCls: n
  } = e, r = `${n}-${t}`, {
    inKeyframes: i,
    outKeyframes: o
  } = q8[t];
  return [Hg(r, i, o, e.motionDurationMid), {
    [`
        ${r}-enter,
        ${r}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: e.motionEaseOutCirc
    },
    [`${r}-leave`]: {
      animationTimingFunction: e.motionEaseInOutCirc
    }
  }];
}, Xw = new Gt("antSlideUpIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), Yw = new Gt("antSlideUpOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), qw = new Gt("antSlideDownIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  }
}), Qw = new Gt("antSlideDownOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  }
}), Q8 = new Gt("antSlideLeftIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), Z8 = new Gt("antSlideLeftOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), J8 = new Gt("antSlideRightIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  }
}), ej = new Gt("antSlideRightOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  }
}), tj = {
  "slide-up": {
    inKeyframes: Xw,
    outKeyframes: Yw
  },
  "slide-down": {
    inKeyframes: qw,
    outKeyframes: Qw
  },
  "slide-left": {
    inKeyframes: Q8,
    outKeyframes: Z8
  },
  "slide-right": {
    inKeyframes: J8,
    outKeyframes: ej
  }
}, ua = (e, t) => {
  const {
    antCls: n
  } = e, r = `${n}-${t}`, {
    inKeyframes: i,
    outKeyframes: o
  } = tj[t];
  return [Hg(r, i, o, e.motionDurationMid), {
    [`
      ${r}-enter,
      ${r}-appear
    `]: {
      transform: "scale(0)",
      transformOrigin: "0% 0%",
      opacity: 0,
      animationTimingFunction: e.motionEaseOutQuint,
      "&-prepare": {
        transform: "scale(1)"
      }
    },
    [`${r}-leave`]: {
      animationTimingFunction: e.motionEaseInQuint
    }
  }];
}, Zw = new Gt("antZoomIn", {
  "0%": {
    transform: "scale(0.2)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), nj = new Gt("antZoomOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.2)",
    opacity: 0
  }
}), Lx = new Gt("antZoomBigIn", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), Fx = new Gt("antZoomBigOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.8)",
    opacity: 0
  }
}), rj = new Gt("antZoomUpIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  }
}), ij = new Gt("antZoomUpOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  }
}), oj = new Gt("antZoomLeftIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  }
}), sj = new Gt("antZoomLeftOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  }
}), aj = new Gt("antZoomRightIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  }
}), lj = new Gt("antZoomRightOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  }
}), cj = new Gt("antZoomDownIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  }
}), uj = new Gt("antZoomDownOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  }
}), dj = {
  zoom: {
    inKeyframes: Zw,
    outKeyframes: nj
  },
  "zoom-big": {
    inKeyframes: Lx,
    outKeyframes: Fx
  },
  "zoom-big-fast": {
    inKeyframes: Lx,
    outKeyframes: Fx
  },
  "zoom-left": {
    inKeyframes: oj,
    outKeyframes: sj
  },
  "zoom-right": {
    inKeyframes: aj,
    outKeyframes: lj
  },
  "zoom-up": {
    inKeyframes: rj,
    outKeyframes: ij
  },
  "zoom-down": {
    inKeyframes: cj,
    outKeyframes: uj
  }
}, vf = (e, t) => {
  const {
    antCls: n
  } = e, r = `${n}-${t}`, {
    inKeyframes: i,
    outKeyframes: o
  } = dj[t];
  return [Hg(r, i, o, t === "zoom-big-fast" ? e.motionDurationFast : e.motionDurationMid), {
    [`
        ${r}-enter,
        ${r}-appear
      `]: {
      transform: "scale(0)",
      opacity: 0,
      animationTimingFunction: e.motionEaseOutCirc,
      "&-prepare": {
        transform: "none"
      }
    },
    [`${r}-leave`]: {
      animationTimingFunction: e.motionEaseInOutCirc
    }
  }];
};
function Bx(e) {
  return {
    position: e,
    inset: 0
  };
}
const fj = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e;
  return [{
    [`${t}-root`]: {
      [`${t}${n}-zoom-enter, ${t}${n}-zoom-appear`]: {
        // reset scale avoid mousePosition bug
        transform: "none",
        opacity: 0,
        animationDuration: e.motionDurationSlow,
        // https://github.com/ant-design/ant-design/issues/11777
        userSelect: "none"
      },
      // https://github.com/ant-design/ant-design/issues/37329
      // https://github.com/ant-design/ant-design/issues/40272
      [`${t}${n}-zoom-leave ${t}-content`]: {
        pointerEvents: "none"
      },
      [`${t}-mask`]: Object.assign(Object.assign({}, Bx("fixed")), {
        zIndex: e.zIndexPopupBase,
        height: "100%",
        backgroundColor: e.colorBgMask,
        pointerEvents: "none",
        [`${t}-hidden`]: {
          display: "none"
        }
      }),
      [`${t}-wrap`]: Object.assign(Object.assign({}, Bx("fixed")), {
        zIndex: e.zIndexPopupBase,
        overflow: "auto",
        outline: 0,
        WebkitOverflowScrolling: "touch"
      })
    }
  }, {
    [`${t}-root`]: z8(e)
  }];
}, hj = (e) => {
  const {
    componentCls: t
  } = e;
  return [
    // ======================== Root =========================
    {
      [`${t}-root`]: {
        [`${t}-wrap-rtl`]: {
          direction: "rtl"
        },
        [`${t}-centered`]: {
          textAlign: "center",
          "&::before": {
            display: "inline-block",
            width: 0,
            height: "100%",
            verticalAlign: "middle",
            content: '""'
          },
          [t]: {
            top: 0,
            display: "inline-block",
            paddingBottom: 0,
            textAlign: "start",
            verticalAlign: "middle"
          }
        },
        [`@media (max-width: ${e.screenSMMax}px)`]: {
          [t]: {
            maxWidth: "calc(100vw - 16px)",
            margin: `${le(e.marginXS)} auto`
          },
          [`${t}-centered`]: {
            [t]: {
              flex: 1
            }
          }
        }
      }
    },
    // ======================== Modal ========================
    {
      [t]: Object.assign(Object.assign({}, Gn(e)), {
        pointerEvents: "none",
        position: "relative",
        top: 100,
        width: "auto",
        maxWidth: `calc(100vw - ${le(e.calc(e.margin).mul(2).equal())})`,
        margin: "0 auto",
        paddingBottom: e.paddingLG,
        [`${t}-title`]: {
          margin: 0,
          color: e.titleColor,
          fontWeight: e.fontWeightStrong,
          fontSize: e.titleFontSize,
          lineHeight: e.titleLineHeight,
          wordWrap: "break-word"
        },
        [`${t}-content`]: {
          position: "relative",
          backgroundColor: e.contentBg,
          backgroundClip: "padding-box",
          border: 0,
          borderRadius: e.borderRadiusLG,
          boxShadow: e.boxShadow,
          pointerEvents: "auto",
          padding: e.contentPadding
        },
        [`${t}-close`]: Object.assign({
          position: "absolute",
          top: e.calc(e.modalHeaderHeight).sub(e.modalCloseBtnSize).div(2).equal(),
          insetInlineEnd: e.calc(e.modalHeaderHeight).sub(e.modalCloseBtnSize).div(2).equal(),
          zIndex: e.calc(e.zIndexPopupBase).add(10).equal(),
          padding: 0,
          color: e.modalCloseIconColor,
          fontWeight: e.fontWeightStrong,
          lineHeight: 1,
          textDecoration: "none",
          background: "transparent",
          borderRadius: e.borderRadiusSM,
          width: e.modalCloseBtnSize,
          height: e.modalCloseBtnSize,
          border: 0,
          outline: 0,
          cursor: "pointer",
          transition: `color ${e.motionDurationMid}, background-color ${e.motionDurationMid}`,
          "&-x": {
            display: "flex",
            fontSize: e.fontSizeLG,
            fontStyle: "normal",
            lineHeight: `${le(e.modalCloseBtnSize)}`,
            justifyContent: "center",
            textTransform: "none",
            textRendering: "auto"
          },
          "&:hover": {
            color: e.modalCloseIconHoverColor,
            backgroundColor: e.colorBgTextHover,
            textDecoration: "none"
          },
          "&:active": {
            backgroundColor: e.colorBgTextActive
          }
        }, Za(e)),
        [`${t}-header`]: {
          color: e.colorText,
          background: e.headerBg,
          borderRadius: `${le(e.borderRadiusLG)} ${le(e.borderRadiusLG)} 0 0`,
          marginBottom: e.headerMarginBottom,
          padding: e.headerPadding,
          borderBottom: e.headerBorderBottom
        },
        [`${t}-body`]: {
          fontSize: e.fontSize,
          lineHeight: e.lineHeight,
          wordWrap: "break-word",
          padding: e.bodyPadding
        },
        [`${t}-footer`]: {
          textAlign: "end",
          background: e.footerBg,
          marginTop: e.footerMarginTop,
          padding: e.footerPadding,
          borderTop: e.footerBorderTop,
          borderRadius: e.footerBorderRadius,
          [`> ${e.antCls}-btn + ${e.antCls}-btn`]: {
            marginInlineStart: e.marginXS
          }
        },
        [`${t}-open`]: {
          overflow: "hidden"
        }
      })
    },
    // ======================== Pure =========================
    {
      [`${t}-pure-panel`]: {
        top: "auto",
        padding: 0,
        display: "flex",
        flexDirection: "column",
        [`${t}-content,
          ${t}-body,
          ${t}-confirm-body-wrapper`]: {
          display: "flex",
          flexDirection: "column",
          flex: "auto"
        },
        [`${t}-confirm-body`]: {
          marginBottom: "auto"
        }
      }
    }
  ];
}, pj = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-root`]: {
      [`${t}-wrap-rtl`]: {
        direction: "rtl",
        [`${t}-confirm-body`]: {
          direction: "rtl"
        }
      }
    }
  };
}, aT = (e) => {
  const t = e.padding, n = e.fontSizeHeading5, r = e.lineHeightHeading5;
  return Jt(e, {
    modalHeaderHeight: e.calc(e.calc(r).mul(n).equal()).add(e.calc(t).mul(2).equal()).equal(),
    modalFooterBorderColorSplit: e.colorSplit,
    modalFooterBorderStyle: e.lineType,
    modalFooterBorderWidth: e.lineWidth,
    modalCloseIconColor: e.colorIcon,
    modalCloseIconHoverColor: e.colorIconHover,
    modalCloseBtnSize: e.controlHeight,
    modalConfirmIconSize: e.fontHeight,
    modalTitleHeight: e.calc(e.titleFontSize).mul(e.titleLineHeight).equal()
  });
}, lT = (e) => ({
  footerBg: "transparent",
  headerBg: e.colorBgElevated,
  titleLineHeight: e.lineHeightHeading5,
  titleFontSize: e.fontSizeHeading5,
  contentBg: e.colorBgElevated,
  titleColor: e.colorTextHeading,
  // internal
  contentPadding: e.wireframe ? 0 : `${le(e.paddingMD)} ${le(e.paddingContentHorizontalLG)}`,
  headerPadding: e.wireframe ? `${le(e.padding)} ${le(e.paddingLG)}` : 0,
  headerBorderBottom: e.wireframe ? `${le(e.lineWidth)} ${e.lineType} ${e.colorSplit}` : "none",
  headerMarginBottom: e.wireframe ? 0 : e.marginXS,
  bodyPadding: e.wireframe ? e.paddingLG : 0,
  footerPadding: e.wireframe ? `${le(e.paddingXS)} ${le(e.padding)}` : 0,
  footerBorderTop: e.wireframe ? `${le(e.lineWidth)} ${e.lineType} ${e.colorSplit}` : "none",
  footerBorderRadius: e.wireframe ? `0 0 ${le(e.borderRadiusLG)} ${le(e.borderRadiusLG)}` : 0,
  footerMarginTop: e.wireframe ? 0 : e.marginSM,
  confirmBodyPadding: e.wireframe ? `${le(e.padding * 2)} ${le(e.padding * 2)} ${le(e.paddingLG)}` : 0,
  confirmIconMarginInlineEnd: e.wireframe ? e.margin : e.marginSM,
  confirmBtnsMarginTop: e.wireframe ? e.marginLG : e.marginSM
}), cT = $n("Modal", (e) => {
  const t = aT(e);
  return [hj(t), pj(t), fj(t), vf(t, "zoom")];
}, lT, {
  unitless: {
    titleLineHeight: !0
  }
});
var gj = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
let xb;
const mj = (e) => {
  xb = {
    x: e.pageX,
    y: e.pageY
  }, setTimeout(() => {
    xb = null;
  }, 100);
};
H6() && document.documentElement.addEventListener("click", mj, !0);
const uT = (e) => {
  var t;
  const {
    getPopupContainer: n,
    getPrefixCls: r,
    direction: i,
    modal: o
  } = O.useContext(rt), s = (N) => {
    const {
      onCancel: F
    } = e;
    F == null || F(N);
  }, a = (N) => {
    const {
      onOk: F
    } = e;
    F == null || F(N);
  };
  if (process.env.NODE_ENV !== "production") {
    const N = Zt("Modal");
    [["visible", "open"], ["bodyStyle", "styles.body"], ["maskStyle", "styles.mask"]].forEach((F) => {
      let [B, j] = F;
      N.deprecated(!(B in e), B, j);
    });
  }
  const {
    prefixCls: l,
    className: u,
    rootClassName: c,
    open: d,
    wrapClassName: f,
    centered: h,
    getContainer: p,
    focusTriggerAfterClose: g = !0,
    style: m,
    // Deprecated
    visible: v,
    width: b = 520,
    footer: x,
    classNames: w,
    styles: C
  } = e, y = gj(e, ["prefixCls", "className", "rootClassName", "open", "wrapClassName", "centered", "getContainer", "focusTriggerAfterClose", "style", "visible", "width", "footer", "classNames", "styles"]), S = r("modal", l), A = r(), $ = Kn(S), [M, _, T] = cT(S, $), D = se(f, {
    [`${S}-centered`]: !!h,
    [`${S}-wrap-rtl`]: i === "rtl"
  }), E = x !== null && /* @__PURE__ */ O.createElement(oT, Object.assign({}, e, {
    onOk: a,
    onCancel: s
  })), [R, I] = j6(yx(e), yx(o), {
    closable: !0,
    closeIcon: /* @__PURE__ */ O.createElement(To, {
      className: `${S}-close-icon`
    }),
    closeIconRender: (N) => iT(S, N)
  }), k = N8(`.${S}-content`), [P, L] = Zc("Modal", y.zIndex);
  return M(/* @__PURE__ */ O.createElement(wd, null, /* @__PURE__ */ O.createElement(Sb, {
    status: !0,
    override: !0
  }, /* @__PURE__ */ O.createElement(hf.Provider, {
    value: L
  }, /* @__PURE__ */ O.createElement(U_, Object.assign({
    width: b
  }, y, {
    zIndex: P,
    getContainer: p === void 0 ? n : p,
    prefixCls: S,
    rootClassName: se(_, c, T, $),
    footer: E,
    visible: d ?? v,
    mousePosition: (t = y.mousePosition) !== null && t !== void 0 ? t : xb,
    onClose: s,
    closable: R,
    closeIcon: I,
    focusTriggerAfterClose: g,
    transitionName: Xo(A, "zoom", e.transitionName),
    maskTransitionName: Xo(A, "fade", e.maskTransitionName),
    className: se(_, u, o == null ? void 0 : o.className),
    style: Object.assign(Object.assign({}, o == null ? void 0 : o.style), m),
    classNames: Object.assign(Object.assign(Object.assign({}, o == null ? void 0 : o.classNames), w), {
      wrapper: se(D, w == null ? void 0 : w.wrapper)
    }),
    styles: Object.assign(Object.assign({}, o == null ? void 0 : o.styles), C),
    panelRef: k
  }))))));
}, vj = (e) => {
  const {
    componentCls: t,
    titleFontSize: n,
    titleLineHeight: r,
    modalConfirmIconSize: i,
    fontSize: o,
    lineHeight: s,
    modalTitleHeight: a,
    fontHeight: l,
    confirmBodyPadding: u
  } = e, c = `${t}-confirm`;
  return {
    [c]: {
      "&-rtl": {
        direction: "rtl"
      },
      [`${e.antCls}-modal-header`]: {
        display: "none"
      },
      [`${c}-body-wrapper`]: Object.assign({}, ca()),
      [`&${t} ${t}-body`]: {
        padding: u
      },
      // ====================== Body ======================
      [`${c}-body`]: {
        display: "flex",
        flexWrap: "nowrap",
        alignItems: "start",
        [`> ${e.iconCls}`]: {
          flex: "none",
          fontSize: i,
          marginInlineEnd: e.confirmIconMarginInlineEnd,
          marginTop: e.calc(e.calc(l).sub(i).equal()).div(2).equal()
        },
        [`&-has-title > ${e.iconCls}`]: {
          marginTop: e.calc(e.calc(a).sub(i).equal()).div(2).equal()
        }
      },
      [`${c}-paragraph`]: {
        display: "flex",
        flexDirection: "column",
        flex: "auto",
        rowGap: e.marginXS
      },
      // https://github.com/ant-design/ant-design/issues/48159
      [`${e.iconCls} + ${c}-paragraph`]: {
        maxWidth: `calc(100% - ${le(e.calc(e.modalConfirmIconSize).add(e.marginSM).equal())})`
      },
      [`${c}-title`]: {
        color: e.colorTextHeading,
        fontWeight: e.fontWeightStrong,
        fontSize: n,
        lineHeight: r
      },
      [`${c}-content`]: {
        color: e.colorText,
        fontSize: o,
        lineHeight: s
      },
      // ===================== Footer =====================
      [`${c}-btns`]: {
        textAlign: "end",
        marginTop: e.confirmBtnsMarginTop,
        [`${e.antCls}-btn + ${e.antCls}-btn`]: {
          marginBottom: 0,
          marginInlineStart: e.marginXS
        }
      }
    },
    [`${c}-error ${c}-body > ${e.iconCls}`]: {
      color: e.colorError
    },
    [`${c}-warning ${c}-body > ${e.iconCls},
        ${c}-confirm ${c}-body > ${e.iconCls}`]: {
      color: e.colorWarning
    },
    [`${c}-info ${c}-body > ${e.iconCls}`]: {
      color: e.colorInfo
    },
    [`${c}-success ${c}-body > ${e.iconCls}`]: {
      color: e.colorSuccess
    }
  };
}, bj = Ig(["Modal", "confirm"], (e) => {
  const t = aT(e);
  return [vj(t)];
}, lT, {
  // confirm is weak than modal since no conflict here
  order: -1e3
});
var yj = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
function dT(e) {
  const {
    prefixCls: t,
    icon: n,
    okText: r,
    cancelText: i,
    confirmPrefixCls: o,
    type: s,
    okCancel: a,
    footer: l,
    // Legacy for static function usage
    locale: u
  } = e, c = yj(e, ["prefixCls", "icon", "okText", "cancelText", "confirmPrefixCls", "type", "okCancel", "footer", "locale"]);
  if (process.env.NODE_ENV !== "production") {
    const S = Zt("Modal");
    process.env.NODE_ENV !== "production" && S(!(typeof n == "string" && n.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${n}\` at https://ant.design/components/icon`);
  }
  let d = n;
  if (!n && n !== null)
    switch (s) {
      case "info":
        d = /* @__PURE__ */ O.createElement(kg, null);
        break;
      case "success":
        d = /* @__PURE__ */ O.createElement(ff, null);
        break;
      case "error":
        d = /* @__PURE__ */ O.createElement(bl, null);
        break;
      default:
        d = /* @__PURE__ */ O.createElement(yl, null);
    }
  const f = a ?? s === "confirm", h = e.autoFocusButton === null ? !1 : e.autoFocusButton || "ok", [p] = ml("Modal"), g = u || p, m = r || (f ? g == null ? void 0 : g.okText : g == null ? void 0 : g.justOkText), v = i || (g == null ? void 0 : g.cancelText), b = Object.assign({
    autoFocusButton: h,
    cancelTextLocale: v,
    okTextLocale: m,
    mergedOkCancel: f
  }, c), x = O.useMemo(() => b, _e(Object.values(b))), w = /* @__PURE__ */ O.createElement(O.Fragment, null, /* @__PURE__ */ O.createElement(cx, null), /* @__PURE__ */ O.createElement(ux, null)), C = e.title !== void 0 && e.title !== null, y = `${o}-body`;
  return /* @__PURE__ */ O.createElement("div", {
    className: `${o}-body-wrapper`
  }, /* @__PURE__ */ O.createElement("div", {
    className: se(y, {
      [`${y}-has-title`]: C
    })
  }, d, /* @__PURE__ */ O.createElement("div", {
    className: `${o}-paragraph`
  }, C && /* @__PURE__ */ O.createElement("span", {
    className: `${o}-title`
  }, e.title), /* @__PURE__ */ O.createElement("div", {
    className: `${o}-content`
  }, e.content))), l === void 0 || typeof l == "function" ? /* @__PURE__ */ O.createElement(j_, {
    value: x
  }, /* @__PURE__ */ O.createElement("div", {
    className: `${o}-btns`
  }, typeof l == "function" ? l(w, {
    OkBtn: ux,
    CancelBtn: cx
  }) : w)) : l, /* @__PURE__ */ O.createElement(bj, {
    prefixCls: t
  }));
}
const fT = (e) => {
  const {
    close: t,
    zIndex: n,
    afterClose: r,
    open: i,
    keyboard: o,
    centered: s,
    getContainer: a,
    maskStyle: l,
    direction: u,
    prefixCls: c,
    wrapClassName: d,
    rootPrefixCls: f,
    bodyStyle: h,
    closable: p = !1,
    closeIcon: g,
    modalRender: m,
    focusTriggerAfterClose: v,
    onConfirm: b,
    styles: x
  } = e;
  if (process.env.NODE_ENV !== "production") {
    const T = Zt("Modal");
    [["visible", "open"], ["bodyStyle", "styles.body"], ["maskStyle", "styles.mask"]].forEach((D) => {
      let [E, R] = D;
      T.deprecated(!(E in e), E, R);
    });
  }
  const w = `${c}-confirm`, C = e.width || 416, y = e.style || {}, S = e.mask === void 0 ? !0 : e.mask, A = e.maskClosable === void 0 ? !1 : e.maskClosable, $ = se(w, `${w}-${e.type}`, {
    [`${w}-rtl`]: u === "rtl"
  }, e.className), [, M] = Sr(), _ = O.useMemo(() => n !== void 0 ? n : M.zIndexPopupBase + Pg, [n, M]);
  return /* @__PURE__ */ O.createElement(uT, {
    prefixCls: c,
    className: $,
    wrapClassName: se({
      [`${w}-centered`]: !!e.centered
    }, d),
    onCancel: () => {
      t == null || t({
        triggerCancel: !0
      }), b == null || b(!1);
    },
    open: i,
    title: "",
    footer: null,
    transitionName: Xo(f || "", "zoom", e.transitionName),
    maskTransitionName: Xo(f || "", "fade", e.maskTransitionName),
    mask: S,
    maskClosable: A,
    style: y,
    styles: Object.assign({
      body: h,
      mask: l
    }, x),
    width: C,
    zIndex: _,
    afterClose: r,
    keyboard: o,
    centered: s,
    getContainer: a,
    closable: p,
    closeIcon: g,
    modalRender: m,
    focusTriggerAfterClose: v
  }, /* @__PURE__ */ O.createElement(dT, Object.assign({}, e, {
    confirmPrefixCls: w
  })));
}, Jw = (e) => {
  const {
    rootPrefixCls: t,
    iconPrefixCls: n,
    direction: r,
    theme: i
  } = e;
  return /* @__PURE__ */ O.createElement(qc, {
    prefixCls: t,
    iconPrefixCls: n,
    direction: r,
    theme: i
  }, /* @__PURE__ */ O.createElement(fT, Object.assign({}, e)));
};
process.env.NODE_ENV !== "production" && (fT.displayName = "ConfirmDialog", Jw.displayName = "ConfirmDialogWrapper");
const Fa = [];
let hT = "";
function pT() {
  return hT;
}
const wj = (e) => {
  var t, n;
  const {
    prefixCls: r,
    getContainer: i,
    direction: o
  } = e, s = kD(), a = Yt(rt), l = pT() || a.getPrefixCls(), u = r || `${l}-modal`;
  let c = i;
  return c === !1 && (c = void 0, process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && gl(!1, "Modal", "Static method not support `getContainer` to be `false` since it do not have context env.")), /* @__PURE__ */ U.createElement(Jw, Object.assign({}, e, {
    rootPrefixCls: l,
    prefixCls: u,
    iconPrefixCls: a.iconPrefixCls,
    theme: a.theme,
    direction: o ?? a.direction,
    locale: (n = (t = a.locale) === null || t === void 0 ? void 0 : t.Modal) !== null && n !== void 0 ? n : s,
    getContainer: c
  }));
};
function bf(e) {
  const t = df();
  process.env.NODE_ENV !== "production" && !t.holderRender && kw("Modal");
  const n = document.createDocumentFragment();
  let r = Object.assign(Object.assign({}, e), {
    close: a,
    open: !0
  }), i;
  function o() {
    for (var u = arguments.length, c = new Array(u), d = 0; d < u; d++)
      c[d] = arguments[d];
    const f = c.some((h) => h && h.triggerCancel);
    e.onCancel && f && e.onCancel.apply(e, [() => {
    }].concat(_e(c.slice(1))));
    for (let h = 0; h < Fa.length; h++)
      if (Fa[h] === a) {
        Fa.splice(h, 1);
        break;
      }
    R_(n);
  }
  function s(u) {
    clearTimeout(i), i = setTimeout(() => {
      const c = t.getPrefixCls(void 0, pT()), d = t.getIconPrefixCls(), f = t.getTheme(), h = /* @__PURE__ */ U.createElement(wj, Object.assign({}, u));
      Lg(/* @__PURE__ */ U.createElement(qc, {
        prefixCls: c,
        iconPrefixCls: d,
        theme: f
      }, t.holderRender ? t.holderRender(h) : h), n);
    });
  }
  function a() {
    for (var u = arguments.length, c = new Array(u), d = 0; d < u; d++)
      c[d] = arguments[d];
    r = Object.assign(Object.assign({}, r), {
      open: !1,
      afterClose: () => {
        typeof e.afterClose == "function" && e.afterClose(), o.apply(this, c);
      }
    }), r.visible && delete r.visible, s(r);
  }
  function l(u) {
    typeof u == "function" ? r = u(r) : r = Object.assign(Object.assign({}, r), u), s(r);
  }
  return s(r), Fa.push(a), {
    destroy: a,
    update: l
  };
}
function gT(e) {
  return Object.assign(Object.assign({}, e), {
    type: "warning"
  });
}
function mT(e) {
  return Object.assign(Object.assign({}, e), {
    type: "info"
  });
}
function vT(e) {
  return Object.assign(Object.assign({}, e), {
    type: "success"
  });
}
function bT(e) {
  return Object.assign(Object.assign({}, e), {
    type: "error"
  });
}
function yT(e) {
  return Object.assign(Object.assign({}, e), {
    type: "confirm"
  });
}
function Cj(e) {
  let {
    rootPrefixCls: t
  } = e;
  process.env.NODE_ENV !== "production" && gl(!1, "Modal", "Modal.config is deprecated. Please use ConfigProvider.config instead."), hT = t;
}
var Sj = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const xj = (e, t) => {
  var n, {
    afterClose: r,
    config: i
  } = e, o = Sj(e, ["afterClose", "config"]);
  const [s, a] = O.useState(!0), [l, u] = O.useState(i), {
    direction: c,
    getPrefixCls: d
  } = O.useContext(rt), f = d("modal"), h = d(), p = () => {
    var b;
    r(), (b = l.afterClose) === null || b === void 0 || b.call(l);
  }, g = function() {
    a(!1);
    for (var b = arguments.length, x = new Array(b), w = 0; w < b; w++)
      x[w] = arguments[w];
    const C = x.some((y) => y && y.triggerCancel);
    l.onCancel && C && l.onCancel.apply(l, [() => {
    }].concat(_e(x.slice(1))));
  };
  O.useImperativeHandle(t, () => ({
    destroy: g,
    update: (b) => {
      u((x) => Object.assign(Object.assign({}, x), b));
    }
  }));
  const m = (n = l.okCancel) !== null && n !== void 0 ? n : l.type === "confirm", [v] = ml("Modal", xs.Modal);
  return /* @__PURE__ */ O.createElement(Jw, Object.assign({
    prefixCls: f,
    rootPrefixCls: h
  }, l, {
    close: g,
    open: s,
    afterClose: p,
    okText: l.okText || (m ? v == null ? void 0 : v.okText : v == null ? void 0 : v.justOkText),
    direction: l.direction || c,
    cancelText: l.cancelText || (v == null ? void 0 : v.cancelText)
  }, o));
}, Ej = /* @__PURE__ */ O.forwardRef(xj);
let jx = 0;
const $j = /* @__PURE__ */ O.memo(/* @__PURE__ */ O.forwardRef((e, t) => {
  const [n, r] = AB();
  return O.useImperativeHandle(t, () => ({
    patchElement: r
  }), []), /* @__PURE__ */ O.createElement(O.Fragment, null, n);
}));
function Oj() {
  const e = O.useRef(null), [t, n] = O.useState([]);
  O.useEffect(() => {
    t.length && (_e(t).forEach((s) => {
      s();
    }), n([]));
  }, [t]);
  const r = O.useCallback((o) => function(a) {
    var l;
    jx += 1;
    const u = /* @__PURE__ */ O.createRef();
    let c;
    const d = new Promise((m) => {
      c = m;
    });
    let f = !1, h;
    const p = /* @__PURE__ */ O.createElement(Ej, {
      key: `modal-${jx}`,
      config: o(a),
      ref: u,
      afterClose: () => {
        h == null || h();
      },
      isSilent: () => f,
      onConfirm: (m) => {
        c(m);
      }
    });
    return h = (l = e.current) === null || l === void 0 ? void 0 : l.patchElement(p), h && Fa.push(h), {
      destroy: () => {
        function m() {
          var v;
          (v = u.current) === null || v === void 0 || v.destroy();
        }
        u.current ? m() : n((v) => [].concat(_e(v), [m]));
      },
      update: (m) => {
        function v() {
          var b;
          (b = u.current) === null || b === void 0 || b.update(m);
        }
        u.current ? v() : n((b) => [].concat(_e(b), [v]));
      },
      then: (m) => (f = !0, d.then(m))
    };
  }, []);
  return [O.useMemo(() => ({
    info: r(mT),
    success: r(vT),
    error: r(bT),
    warning: r(gT),
    confirm: r(yT)
  }), []), /* @__PURE__ */ O.createElement($j, {
    key: "modal-holder",
    ref: e
  })];
}
const Aj = (e) => {
  const {
    componentCls: t,
    notificationMarginEdge: n,
    animationMaxHeight: r
  } = e, i = `${t}-notice`, o = new Gt("antNotificationFadeIn", {
    "0%": {
      transform: "translate3d(100%, 0, 0)",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      opacity: 1
    }
  }), s = new Gt("antNotificationTopFadeIn", {
    "0%": {
      top: -r,
      opacity: 0
    },
    "100%": {
      top: 0,
      opacity: 1
    }
  }), a = new Gt("antNotificationBottomFadeIn", {
    "0%": {
      bottom: e.calc(r).mul(-1).equal(),
      opacity: 0
    },
    "100%": {
      bottom: 0,
      opacity: 1
    }
  }), l = new Gt("antNotificationLeftFadeIn", {
    "0%": {
      transform: "translate3d(-100%, 0, 0)",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      opacity: 1
    }
  });
  return {
    [t]: {
      [`&${t}-top, &${t}-bottom`]: {
        marginInline: 0,
        [i]: {
          marginInline: "auto auto"
        }
      },
      [`&${t}-top`]: {
        [`${t}-fade-enter${t}-fade-enter-active, ${t}-fade-appear${t}-fade-appear-active`]: {
          animationName: s
        }
      },
      [`&${t}-bottom`]: {
        [`${t}-fade-enter${t}-fade-enter-active, ${t}-fade-appear${t}-fade-appear-active`]: {
          animationName: a
        }
      },
      [`&${t}-topRight, &${t}-bottomRight`]: {
        [`${t}-fade-enter${t}-fade-enter-active, ${t}-fade-appear${t}-fade-appear-active`]: {
          animationName: o
        }
      },
      [`&${t}-topLeft, &${t}-bottomLeft`]: {
        marginRight: {
          value: 0,
          _skip_check_: !0
        },
        marginLeft: {
          value: n,
          _skip_check_: !0
        },
        [i]: {
          marginInlineEnd: "auto",
          marginInlineStart: 0
        },
        [`${t}-fade-enter${t}-fade-enter-active, ${t}-fade-appear${t}-fade-appear-active`]: {
          animationName: l
        }
      }
    }
  };
}, Dj = ["top", "topLeft", "topRight", "bottom", "bottomLeft", "bottomRight"], _j = {
  topLeft: "left",
  topRight: "right",
  bottomLeft: "left",
  bottomRight: "right",
  top: "left",
  bottom: "left"
}, Tj = (e, t) => {
  const {
    componentCls: n
  } = e;
  return {
    [`${n}-${t}`]: {
      [`&${n}-stack > ${n}-notice-wrapper`]: {
        [t.startsWith("top") ? "top" : "bottom"]: 0,
        [_j[t]]: {
          value: 0,
          _skip_check_: !0
        }
      }
    }
  };
}, Rj = (e) => {
  const t = {};
  for (let n = 1; n < e.notificationStackLayer; n++)
    t[`&:nth-last-child(${n + 1})`] = {
      overflow: "hidden",
      [`& > ${e.componentCls}-notice`]: {
        opacity: 0,
        transition: `opacity ${e.motionDurationMid}`
      }
    };
  return Object.assign({
    [`&:not(:nth-last-child(-n+${e.notificationStackLayer}))`]: {
      opacity: 0,
      overflow: "hidden",
      color: "transparent",
      pointerEvents: "none"
    }
  }, t);
}, Mj = (e) => {
  const t = {};
  for (let n = 1; n < e.notificationStackLayer; n++)
    t[`&:nth-last-child(${n + 1})`] = {
      background: e.colorBgBlur,
      backdropFilter: "blur(10px)",
      "-webkit-backdrop-filter": "blur(10px)"
    };
  return Object.assign({}, t);
}, Ij = (e) => {
  const {
    componentCls: t
  } = e;
  return Object.assign({
    [`${t}-stack`]: {
      [`& > ${t}-notice-wrapper`]: Object.assign({
        transition: `all ${e.motionDurationSlow}, backdrop-filter 0s`,
        position: "absolute"
      }, Rj(e))
    },
    [`${t}-stack:not(${t}-stack-expanded)`]: {
      [`& > ${t}-notice-wrapper`]: Object.assign({}, Mj(e))
    },
    [`${t}-stack${t}-stack-expanded`]: {
      [`& > ${t}-notice-wrapper`]: {
        "&:not(:nth-last-child(-n + 1))": {
          opacity: 1,
          overflow: "unset",
          color: "inherit",
          pointerEvents: "auto",
          [`& > ${e.componentCls}-notice`]: {
            opacity: 1
          }
        },
        "&:after": {
          content: '""',
          position: "absolute",
          height: e.margin,
          width: "100%",
          insetInline: 0,
          bottom: e.calc(e.margin).mul(-1).equal(),
          background: "transparent",
          pointerEvents: "auto"
        }
      }
    }
  }, Dj.map((n) => Tj(e, n)).reduce((n, r) => Object.assign(Object.assign({}, n), r), {}));
}, wT = (e) => {
  const {
    iconCls: t,
    componentCls: n,
    // .ant-notification
    boxShadow: r,
    fontSizeLG: i,
    notificationMarginBottom: o,
    borderRadiusLG: s,
    colorSuccess: a,
    colorInfo: l,
    colorWarning: u,
    colorError: c,
    colorTextHeading: d,
    notificationBg: f,
    notificationPadding: h,
    notificationMarginEdge: p,
    fontSize: g,
    lineHeight: m,
    width: v,
    notificationIconSize: b,
    colorText: x
  } = e, w = `${n}-notice`;
  return {
    position: "relative",
    marginBottom: o,
    marginInlineStart: "auto",
    background: f,
    borderRadius: s,
    boxShadow: r,
    [w]: {
      padding: h,
      width: v,
      maxWidth: `calc(100vw - ${le(e.calc(p).mul(2).equal())})`,
      overflow: "hidden",
      lineHeight: m,
      wordWrap: "break-word"
    },
    [`${w}-message`]: {
      marginBottom: e.marginXS,
      color: d,
      fontSize: i,
      lineHeight: e.lineHeightLG
    },
    [`${w}-description`]: {
      fontSize: g,
      color: x
    },
    [`${w}-closable ${w}-message`]: {
      paddingInlineEnd: e.paddingLG
    },
    [`${w}-with-icon ${w}-message`]: {
      marginBottom: e.marginXS,
      marginInlineStart: e.calc(e.marginSM).add(b).equal(),
      fontSize: i
    },
    [`${w}-with-icon ${w}-description`]: {
      marginInlineStart: e.calc(e.marginSM).add(b).equal(),
      fontSize: g
    },
    // Icon & color style in different selector level
    // https://github.com/ant-design/ant-design/issues/16503
    // https://github.com/ant-design/ant-design/issues/15512
    [`${w}-icon`]: {
      position: "absolute",
      fontSize: b,
      lineHeight: 1,
      // icon-font
      [`&-success${t}`]: {
        color: a
      },
      [`&-info${t}`]: {
        color: l
      },
      [`&-warning${t}`]: {
        color: u
      },
      [`&-error${t}`]: {
        color: c
      }
    },
    [`${w}-close`]: Object.assign({
      position: "absolute",
      top: e.notificationPaddingVertical,
      insetInlineEnd: e.notificationPaddingHorizontal,
      color: e.colorIcon,
      outline: "none",
      width: e.notificationCloseButtonSize,
      height: e.notificationCloseButtonSize,
      borderRadius: e.borderRadiusSM,
      transition: `background-color ${e.motionDurationMid}, color ${e.motionDurationMid}`,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      "&:hover": {
        color: e.colorIconHover,
        backgroundColor: e.colorBgTextHover
      },
      "&:active": {
        backgroundColor: e.colorBgTextActive
      }
    }, Za(e)),
    [`${w}-btn`]: {
      float: "right",
      marginTop: e.marginSM
    }
  };
}, kj = (e) => {
  const {
    componentCls: t,
    // .ant-notification
    notificationMarginBottom: n,
    notificationMarginEdge: r,
    motionDurationMid: i,
    motionEaseInOut: o
  } = e, s = `${t}-notice`, a = new Gt("antNotificationFadeOut", {
    "0%": {
      maxHeight: e.animationMaxHeight,
      marginBottom: n
    },
    "100%": {
      maxHeight: 0,
      marginBottom: 0,
      paddingTop: 0,
      paddingBottom: 0,
      opacity: 0
    }
  });
  return [
    // ============================ Holder ============================
    {
      [t]: Object.assign(Object.assign({}, Gn(e)), {
        position: "fixed",
        zIndex: e.zIndexPopup,
        marginRight: {
          value: r,
          _skip_check_: !0
        },
        [`${t}-hook-holder`]: {
          position: "relative"
        },
        //  animation
        [`${t}-fade-appear-prepare`]: {
          opacity: "0 !important"
        },
        [`${t}-fade-enter, ${t}-fade-appear`]: {
          animationDuration: e.motionDurationMid,
          animationTimingFunction: o,
          animationFillMode: "both",
          opacity: 0,
          animationPlayState: "paused"
        },
        [`${t}-fade-leave`]: {
          animationTimingFunction: o,
          animationFillMode: "both",
          animationDuration: i,
          animationPlayState: "paused"
        },
        [`${t}-fade-enter${t}-fade-enter-active, ${t}-fade-appear${t}-fade-appear-active`]: {
          animationPlayState: "running"
        },
        [`${t}-fade-leave${t}-fade-leave-active`]: {
          animationName: a,
          animationPlayState: "running"
        },
        // RTL
        "&-rtl": {
          direction: "rtl",
          [`${s}-btn`]: {
            float: "left"
          }
        }
      })
    },
    // ============================ Notice ============================
    {
      [t]: {
        [`${s}-wrapper`]: Object.assign({}, wT(e))
      }
    }
  ];
}, CT = (e) => ({
  zIndexPopup: e.zIndexPopupBase + Pg + 50,
  width: 384
}), ST = (e) => {
  const t = e.paddingMD, n = e.paddingLG;
  return Jt(e, {
    notificationBg: e.colorBgElevated,
    notificationPaddingVertical: t,
    notificationPaddingHorizontal: n,
    notificationIconSize: e.calc(e.fontSizeLG).mul(e.lineHeightLG).equal(),
    notificationCloseButtonSize: e.calc(e.controlHeightLG).mul(0.55).equal(),
    notificationMarginBottom: e.margin,
    notificationPadding: `${le(e.paddingMD)} ${le(e.paddingContentHorizontalLG)}`,
    notificationMarginEdge: e.marginLG,
    animationMaxHeight: 150,
    notificationStackLayer: 3
  });
}, xT = $n("Notification", (e) => {
  const t = ST(e);
  return [kj(t), Aj(t), Ij(t)];
}, CT), Pj = Ig(["Notification", "PurePanel"], (e) => {
  const t = `${e.componentCls}-notice`, n = ST(e);
  return {
    [`${t}-pure-panel`]: Object.assign(Object.assign({}, wT(n)), {
      width: n.width,
      maxWidth: `calc(100vw - ${le(e.calc(n.notificationMarginEdge).mul(2).equal())})`,
      margin: 0
    })
  };
}, CT);
var Nj = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
function e1(e, t) {
  return t === null || t === !1 ? null : t || /* @__PURE__ */ O.createElement(To, {
    className: `${e}-close-icon`
  });
}
const Lj = {
  success: ff,
  info: kg,
  error: bl,
  warning: yl
}, ET = (e) => {
  const {
    prefixCls: t,
    icon: n,
    type: r,
    message: i,
    description: o,
    btn: s,
    role: a = "alert"
  } = e;
  let l = null;
  return n ? l = /* @__PURE__ */ O.createElement("span", {
    className: `${t}-icon`
  }, n) : r && (l = /* @__PURE__ */ O.createElement(Lj[r] || null, {
    className: se(`${t}-icon`, `${t}-icon-${r}`)
  })), /* @__PURE__ */ O.createElement("div", {
    className: se({
      [`${t}-with-icon`]: l
    }),
    role: a
  }, l, /* @__PURE__ */ O.createElement("div", {
    className: `${t}-message`
  }, i), /* @__PURE__ */ O.createElement("div", {
    className: `${t}-description`
  }, o), s && /* @__PURE__ */ O.createElement("div", {
    className: `${t}-btn`
  }, s));
}, Fj = (e) => {
  const {
    prefixCls: t,
    className: n,
    icon: r,
    type: i,
    message: o,
    description: s,
    btn: a,
    closable: l = !0,
    closeIcon: u,
    className: c
  } = e, d = Nj(e, ["prefixCls", "className", "icon", "type", "message", "description", "btn", "closable", "closeIcon", "className"]), {
    getPrefixCls: f
  } = O.useContext(rt), h = t || f("notification"), p = `${h}-notice`, g = Kn(h), [m, v, b] = xT(h, g);
  return m(/* @__PURE__ */ O.createElement("div", {
    className: se(`${p}-pure-panel`, v, n, b, g)
  }, /* @__PURE__ */ O.createElement(Pj, {
    prefixCls: h
  }), /* @__PURE__ */ O.createElement(Pw, Object.assign({}, d, {
    prefixCls: h,
    eventKey: "pure",
    duration: null,
    closable: l,
    className: se({
      notificationClassName: c
    }),
    closeIcon: e1(h, u),
    content: /* @__PURE__ */ O.createElement(ET, {
      prefixCls: p,
      icon: r,
      type: i,
      message: o,
      description: s,
      btn: a
    })
  }))));
};
function Bj(e, t, n) {
  let r;
  switch (e) {
    case "top":
      r = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top: t,
        bottom: "auto"
      };
      break;
    case "topLeft":
      r = {
        left: 0,
        top: t,
        bottom: "auto"
      };
      break;
    case "topRight":
      r = {
        right: 0,
        top: t,
        bottom: "auto"
      };
      break;
    case "bottom":
      r = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top: "auto",
        bottom: n
      };
      break;
    case "bottomLeft":
      r = {
        left: 0,
        top: "auto",
        bottom: n
      };
      break;
    default:
      r = {
        right: 0,
        top: "auto",
        bottom: n
      };
      break;
  }
  return r;
}
function jj(e) {
  return {
    motionName: `${e}-fade`
  };
}
var zj = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const zx = 24, Hj = 4.5, Vj = "topRight", Wj = (e) => {
  let {
    children: t,
    prefixCls: n
  } = e;
  const r = Kn(n), [i, o, s] = xT(n, r);
  return i(/* @__PURE__ */ U.createElement(x_, {
    classNames: {
      list: se(o, s, r)
    }
  }, t));
}, Uj = (e, t) => {
  let {
    prefixCls: n,
    key: r
  } = t;
  return /* @__PURE__ */ U.createElement(Wj, {
    prefixCls: n,
    key: r
  }, e);
}, Gj = /* @__PURE__ */ U.forwardRef((e, t) => {
  const {
    top: n,
    bottom: r,
    prefixCls: i,
    getContainer: o,
    maxCount: s,
    rtl: a,
    onAllRemoved: l,
    stack: u,
    duration: c
  } = e, {
    getPrefixCls: d,
    getPopupContainer: f,
    notification: h,
    direction: p
  } = Yt(rt), [, g] = Sr(), m = i || d("notification"), v = (y) => Bj(y, n ?? zx, r ?? zx), b = () => se({
    [`${m}-rtl`]: a ?? p === "rtl"
  }), x = () => jj(m), [w, C] = O_({
    prefixCls: m,
    style: v,
    className: b,
    motion: x,
    closable: !0,
    closeIcon: e1(m),
    duration: c ?? Hj,
    getContainer: () => (o == null ? void 0 : o()) || (f == null ? void 0 : f()) || document.body,
    maxCount: s,
    onAllRemoved: l,
    renderNotifications: Uj,
    stack: u === !1 ? !1 : {
      threshold: typeof u == "object" ? u == null ? void 0 : u.threshold : void 0,
      offset: 8,
      gap: g.margin
    }
  });
  return U.useImperativeHandle(t, () => Object.assign(Object.assign({}, w), {
    prefixCls: m,
    notification: h
  })), C;
});
function $T(e) {
  const t = U.useRef(null), n = Zt("Notification");
  return [U.useMemo(() => {
    const i = (l) => {
      var u;
      if (!t.current) {
        process.env.NODE_ENV !== "production" && n(!1, "usage", "You are calling notice in render which will break in React 18 concurrent mode. Please trigger in effect instead.");
        return;
      }
      const {
        open: c,
        prefixCls: d,
        notification: f
      } = t.current, h = `${d}-notice`, {
        message: p,
        description: g,
        icon: m,
        type: v,
        btn: b,
        className: x,
        style: w,
        role: C = "alert",
        closeIcon: y,
        closable: S
      } = l, A = zj(l, ["message", "description", "icon", "type", "btn", "className", "style", "role", "closeIcon", "closable"]), $ = e1(h, typeof y < "u" ? y : f == null ? void 0 : f.closeIcon);
      return c(Object.assign(Object.assign({
        // use placement from props instead of hard-coding "topRight"
        placement: (u = e == null ? void 0 : e.placement) !== null && u !== void 0 ? u : Vj
      }, A), {
        content: /* @__PURE__ */ U.createElement(ET, {
          prefixCls: h,
          icon: m,
          type: v,
          message: p,
          description: g,
          btn: b,
          role: C
        }),
        className: se(v && `${h}-${v}`, x, f == null ? void 0 : f.className),
        style: Object.assign(Object.assign({}, f == null ? void 0 : f.style), w),
        closeIcon: $,
        closable: S ?? !!$
      }));
    }, s = {
      open: i,
      destroy: (l) => {
        var u, c;
        l !== void 0 ? (u = t.current) === null || u === void 0 || u.close(l) : (c = t.current) === null || c === void 0 || c.destroy();
      }
    };
    return ["success", "info", "warning", "error"].forEach((l) => {
      s[l] = (u) => i(Object.assign(Object.assign({}, u), {
        type: l
      }));
    }), s;
  }, []), /* @__PURE__ */ U.createElement(Gj, Object.assign({
    key: "notification-holder"
  }, e, {
    ref: t
  }))];
}
function Kj(e) {
  return $T(e);
}
const OT = /* @__PURE__ */ U.createContext({});
function AT(e) {
  return (t) => /* @__PURE__ */ O.createElement(qc, {
    theme: {
      token: {
        motion: !1,
        zIndexPopupBase: 0
      }
    }
  }, /* @__PURE__ */ O.createElement(e, Object.assign({}, t)));
}
const t1 = (e, t, n, r) => AT((o) => {
  const {
    prefixCls: s,
    style: a
  } = o, l = O.useRef(null), [u, c] = O.useState(0), [d, f] = O.useState(0), [h, p] = Un(!1, {
    value: o.open
  }), {
    getPrefixCls: g
  } = O.useContext(rt), m = g(t || "select", s);
  O.useEffect(() => {
    if (p(!0), typeof ResizeObserver < "u") {
      const x = new ResizeObserver((C) => {
        const y = C[0].target;
        c(y.offsetHeight + 8), f(y.offsetWidth);
      }), w = setInterval(() => {
        var C;
        const y = n ? `.${n(m)}` : `.${m}-dropdown`, S = (C = l.current) === null || C === void 0 ? void 0 : C.querySelector(y);
        S && (clearInterval(w), x.observe(S));
      }, 10);
      return () => {
        clearInterval(w), x.disconnect();
      };
    }
  }, []);
  let v = Object.assign(Object.assign({}, o), {
    style: Object.assign(Object.assign({}, a), {
      margin: 0
    }),
    open: h,
    visible: h,
    getPopupContainer: () => l.current
  });
  r && (v = r(v));
  const b = {
    paddingBottom: u,
    position: "relative",
    minWidth: d
  };
  return /* @__PURE__ */ O.createElement("div", {
    ref: l,
    style: b
  }, /* @__PURE__ */ O.createElement(e, Object.assign({}, v)));
}), n1 = function() {
  if (typeof navigator > "u" || typeof window > "u")
    return !1;
  var e = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(e == null ? void 0 : e.substr(0, 4));
};
var Vg = function(t) {
  var n = t.className, r = t.customizeIcon, i = t.customizeIconProps, o = t.children, s = t.onMouseDown, a = t.onClick, l = typeof r == "function" ? r(i) : r;
  return /* @__PURE__ */ O.createElement("span", {
    className: n,
    onMouseDown: function(c) {
      c.preventDefault(), s == null || s(c);
    },
    style: {
      userSelect: "none",
      WebkitUserSelect: "none"
    },
    unselectable: "on",
    onClick: a,
    "aria-hidden": !0
  }, l !== void 0 ? l : /* @__PURE__ */ O.createElement("span", {
    className: se(n.split(/\s+/).map(function(u) {
      return "".concat(u, "-icon");
    }))
  }, o));
}, Xj = function(t, n, r, i, o) {
  var s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1, a = arguments.length > 6 ? arguments[6] : void 0, l = arguments.length > 7 ? arguments[7] : void 0, u = U.useMemo(function() {
    if (wt(i) === "object")
      return i.clearIcon;
    if (o)
      return o;
  }, [i, o]), c = U.useMemo(function() {
    return !!(!s && i && (r.length || a) && !(l === "combobox" && a === ""));
  }, [i, s, r.length, a, l]);
  return {
    allowClear: c,
    clearIcon: /* @__PURE__ */ U.createElement(Vg, {
      className: "".concat(t, "-clear"),
      onMouseDown: n,
      customizeIcon: u
    }, "")
  };
}, DT = /* @__PURE__ */ O.createContext(null);
function _T() {
  return O.useContext(DT);
}
function Yj() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10, t = O.useState(!1), n = ae(t, 2), r = n[0], i = n[1], o = O.useRef(null), s = function() {
    window.clearTimeout(o.current);
  };
  O.useEffect(function() {
    return s;
  }, []);
  var a = function(u, c) {
    s(), o.current = window.setTimeout(function() {
      i(u), c && c();
    }, e);
  };
  return [r, a, s];
}
function TT() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250, t = O.useRef(null), n = O.useRef(null);
  O.useEffect(function() {
    return function() {
      window.clearTimeout(n.current);
    };
  }, []);
  function r(i) {
    (i || t.current === null) && (t.current = i), window.clearTimeout(n.current), n.current = window.setTimeout(function() {
      t.current = null;
    }, e);
  }
  return [function() {
    return t.current;
  }, r];
}
function qj(e, t, n, r) {
  var i = O.useRef(null);
  i.current = {
    open: t,
    triggerOpen: n,
    customizedTrigger: r
  }, O.useEffect(function() {
    function o(s) {
      var a;
      if (!((a = i.current) !== null && a !== void 0 && a.customizedTrigger)) {
        var l = s.target;
        l.shadowRoot && s.composed && (l = s.composedPath()[0] || l), i.current.open && e().filter(function(u) {
          return u;
        }).every(function(u) {
          return !u.contains(l) && u !== l;
        }) && i.current.triggerOpen(!1);
      }
    }
    return window.addEventListener("mousedown", o), function() {
      return window.removeEventListener("mousedown", o);
    };
  }, []);
}
function Qj(e) {
  return ![
    // System function button
    xe.ESC,
    xe.SHIFT,
    xe.BACKSPACE,
    xe.TAB,
    xe.WIN_KEY,
    xe.ALT,
    xe.META,
    xe.WIN_KEY_RIGHT,
    xe.CTRL,
    xe.SEMICOLON,
    xe.EQUALS,
    xe.CAPS_LOCK,
    xe.CONTEXT_MENU,
    // F1-F12
    xe.F1,
    xe.F2,
    xe.F3,
    xe.F4,
    xe.F5,
    xe.F6,
    xe.F7,
    xe.F8,
    xe.F9,
    xe.F10,
    xe.F11,
    xe.F12
  ].includes(e);
}
var Zj = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"], Nl = void 0;
function Jj(e, t) {
  var n = e.prefixCls, r = e.invalidate, i = e.item, o = e.renderItem, s = e.responsive, a = e.responsiveDisabled, l = e.registerSize, u = e.itemKey, c = e.className, d = e.style, f = e.children, h = e.display, p = e.order, g = e.component, m = g === void 0 ? "div" : g, v = Rt(e, Zj), b = s && !h;
  function x(A) {
    l(u, A);
  }
  O.useEffect(function() {
    return function() {
      x(null);
    };
  }, []);
  var w = o && i !== Nl ? o(i) : f, C;
  r || (C = {
    opacity: b ? 0 : 1,
    height: b ? 0 : Nl,
    overflowY: b ? "hidden" : Nl,
    order: s ? p : Nl,
    pointerEvents: b ? "none" : Nl,
    position: b ? "absolute" : Nl
  });
  var y = {};
  b && (y["aria-hidden"] = !0);
  var S = /* @__PURE__ */ O.createElement(m, we({
    className: se(!r && n, c),
    style: ie(ie({}, C), d)
  }, y, v, {
    ref: t
  }), w);
  return s && (S = /* @__PURE__ */ O.createElement(Ci, {
    onResize: function($) {
      var M = $.offsetWidth;
      x(M);
    },
    disabled: a
  }, S)), S;
}
var ed = /* @__PURE__ */ O.forwardRef(Jj);
ed.displayName = "Item";
function ez(e) {
  if (typeof MessageChannel > "u")
    rn(e);
  else {
    var t = new MessageChannel();
    t.port1.onmessage = function() {
      return e();
    }, t.port2.postMessage(void 0);
  }
}
function tz() {
  var e = O.useRef(null), t = function(r) {
    e.current || (e.current = [], ez(function() {
      cF(function() {
        e.current.forEach(function(i) {
          i();
        }), e.current = null;
      });
    })), e.current.push(r);
  };
  return t;
}
function yu(e, t) {
  var n = O.useState(t), r = ae(n, 2), i = r[0], o = r[1], s = Nn(function(a) {
    e(function() {
      o(a);
    });
  });
  return [i, s];
}
var Rp = /* @__PURE__ */ U.createContext(null), nz = ["component"], rz = ["className"], iz = ["className"], oz = function(t, n) {
  var r = O.useContext(Rp);
  if (!r) {
    var i = t.component, o = i === void 0 ? "div" : i, s = Rt(t, nz);
    return /* @__PURE__ */ O.createElement(o, we({}, s, {
      ref: n
    }));
  }
  var a = r.className, l = Rt(r, rz), u = t.className, c = Rt(t, iz);
  return /* @__PURE__ */ O.createElement(Rp.Provider, {
    value: null
  }, /* @__PURE__ */ O.createElement(ed, we({
    ref: n,
    className: se(a, u)
  }, l, c)));
}, RT = /* @__PURE__ */ O.forwardRef(oz);
RT.displayName = "RawItem";
var sz = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"], MT = "responsive", IT = "invalidate";
function az(e) {
  return "+ ".concat(e.length, " ...");
}
function lz(e, t) {
  var n = e.prefixCls, r = n === void 0 ? "rc-overflow" : n, i = e.data, o = i === void 0 ? [] : i, s = e.renderItem, a = e.renderRawItem, l = e.itemKey, u = e.itemWidth, c = u === void 0 ? 10 : u, d = e.ssr, f = e.style, h = e.className, p = e.maxCount, g = e.renderRest, m = e.renderRawRest, v = e.suffix, b = e.component, x = b === void 0 ? "div" : b, w = e.itemComponent, C = e.onVisibleChange, y = Rt(e, sz), S = d === "full", A = tz(), $ = yu(A, null), M = ae($, 2), _ = M[0], T = M[1], D = _ || 0, E = yu(A, /* @__PURE__ */ new Map()), R = ae(E, 2), I = R[0], k = R[1], P = yu(A, 0), L = ae(P, 2), N = L[0], F = L[1], B = yu(A, 0), j = ae(B, 2), z = j[0], H = j[1], W = yu(A, 0), G = ae(W, 2), K = G[0], Y = G[1], X = ht(null), Z = ae(X, 2), Q = Z[0], ne = Z[1], q = ht(null), te = ae(q, 2), fe = te[0], Se = te[1], de = O.useMemo(function() {
    return fe === null && S ? Number.MAX_SAFE_INTEGER : fe || 0;
  }, [fe, _]), ce = ht(!1), pe = ae(ce, 2), Oe = pe[0], Re = pe[1], De = "".concat(r, "-item"), Me = Math.max(N, z), Ue = p === MT, oe = o.length && Ue, Ce = p === IT, ge = oe || typeof p == "number" && o.length > p, ve = mt(function() {
    var je = o;
    return oe ? _ === null && S ? je = o : je = o.slice(0, Math.min(o.length, D / c)) : typeof p == "number" && (je = o.slice(0, p)), je;
  }, [o, c, _, p, oe]), me = mt(function() {
    return oe ? o.slice(de + 1) : o.slice(ve.length);
  }, [o, ve, oe, de]), Fe = Kt(function(je, Le) {
    var ot;
    return typeof l == "function" ? l(je) : (ot = l && (je == null ? void 0 : je[l])) !== null && ot !== void 0 ? ot : Le;
  }, [l]), Be = Kt(s || function(je) {
    return je;
  }, [s]);
  function qe(je, Le, ot) {
    fe === je && (Le === void 0 || Le === Q) || (Se(je), ot || (Re(je < o.length - 1), C == null || C(je)), Le !== void 0 && ne(Le));
  }
  function Ve(je, Le) {
    T(Le.clientWidth);
  }
  function We(je, Le) {
    k(function(ot) {
      var yt = new Map(ot);
      return Le === null ? yt.delete(je) : yt.set(je, Le), yt;
    });
  }
  function Ge(je, Le) {
    H(Le), F(z);
  }
  function $e(je, Le) {
    Y(Le);
  }
  function ze(je) {
    return I.get(Fe(ve[je], je));
  }
  sn(function() {
    if (D && typeof Me == "number" && ve) {
      var je = K, Le = ve.length, ot = Le - 1;
      if (!Le) {
        qe(0, null);
        return;
      }
      for (var yt = 0; yt < Le; yt += 1) {
        var He = ze(yt);
        if (S && (He = He || 0), He === void 0) {
          qe(yt - 1, void 0, !0);
          break;
        }
        if (je += He, // Only one means `totalWidth` is the final width
        ot === 0 && je <= D || // Last two width will be the final width
        yt === ot - 1 && je + ze(ot) <= D) {
          qe(ot, null);
          break;
        } else if (je + Me > D) {
          qe(yt - 1, je - He - K + z);
          break;
        }
      }
      v && ze(0) + K > D && ne(null);
    }
  }, [D, I, z, K, Fe, ve]);
  var at = Oe && !!me.length, xt = {};
  Q !== null && oe && (xt = {
    position: "absolute",
    left: Q,
    top: 0
  });
  var jt = {
    prefixCls: De,
    responsive: oe,
    component: w,
    invalidate: Ce
  }, Lt = a ? function(je, Le) {
    var ot = Fe(je, Le);
    return /* @__PURE__ */ O.createElement(Rp.Provider, {
      key: ot,
      value: ie(ie({}, jt), {}, {
        order: Le,
        item: je,
        itemKey: ot,
        registerSize: We,
        display: Le <= de
      })
    }, a(je, Le));
  } : function(je, Le) {
    var ot = Fe(je, Le);
    return /* @__PURE__ */ O.createElement(ed, we({}, jt, {
      order: Le,
      key: ot,
      item: je,
      renderItem: Be,
      itemKey: ot,
      registerSize: We,
      display: Le <= de
    }));
  }, At, Et = {
    order: at ? de : Number.MAX_SAFE_INTEGER,
    className: "".concat(De, "-rest"),
    registerSize: Ge,
    display: at
  };
  if (m)
    m && (At = /* @__PURE__ */ O.createElement(Rp.Provider, {
      value: ie(ie({}, jt), Et)
    }, m(me)));
  else {
    var nt = g || az;
    At = /* @__PURE__ */ O.createElement(ed, we({}, jt, Et), typeof nt == "function" ? nt(me) : nt);
  }
  var it = /* @__PURE__ */ O.createElement(x, we({
    className: se(!Ce && r, h),
    style: f,
    ref: t
  }, y), ve.map(Lt), ge ? At : null, v && /* @__PURE__ */ O.createElement(ed, we({}, jt, {
    responsive: Ue,
    responsiveDisabled: !oe,
    order: de,
    className: "".concat(De, "-suffix"),
    registerSize: $e,
    display: !0,
    style: xt
  }), v));
  return Ue && (it = /* @__PURE__ */ O.createElement(Ci, {
    onResize: Ve,
    disabled: !oe
  }, it)), it;
}
var Uo = /* @__PURE__ */ O.forwardRef(lz);
Uo.displayName = "Overflow";
Uo.Item = RT;
Uo.RESPONSIVE = MT;
Uo.INVALIDATE = IT;
var cz = function(t, n) {
  var r, i = t.prefixCls, o = t.id, s = t.inputElement, a = t.disabled, l = t.tabIndex, u = t.autoFocus, c = t.autoComplete, d = t.editable, f = t.activeDescendantId, h = t.value, p = t.maxLength, g = t.onKeyDown, m = t.onMouseDown, v = t.onChange, b = t.onPaste, x = t.onCompositionStart, w = t.onCompositionEnd, C = t.open, y = t.attrs, S = s || /* @__PURE__ */ O.createElement("input", null), A = S, $ = A.ref, M = A.props, _ = M.onKeyDown, T = M.onChange, D = M.onMouseDown, E = M.onCompositionStart, R = M.onCompositionEnd, I = M.style;
  return Ss(!("maxLength" in S.props), "Passing 'maxLength' to input element directly may not work because input in BaseSelect is controlled."), S = /* @__PURE__ */ O.cloneElement(S, ie(ie(ie({
    type: "search"
  }, M), {}, {
    // Override over origin props
    id: o,
    ref: xi(n, $),
    disabled: a,
    tabIndex: l,
    autoComplete: c || "off",
    autoFocus: u,
    className: se("".concat(i, "-selection-search-input"), (r = S) === null || r === void 0 || (r = r.props) === null || r === void 0 ? void 0 : r.className),
    role: "combobox",
    "aria-expanded": C || !1,
    "aria-haspopup": "listbox",
    "aria-owns": "".concat(o, "_list"),
    "aria-autocomplete": "list",
    "aria-controls": "".concat(o, "_list"),
    "aria-activedescendant": C ? f : void 0
  }, y), {}, {
    value: d ? h : "",
    maxLength: p,
    readOnly: !d,
    unselectable: d ? null : "on",
    style: ie(ie({}, I), {}, {
      opacity: d ? null : 0
    }),
    onKeyDown: function(P) {
      g(P), _ && _(P);
    },
    onMouseDown: function(P) {
      m(P), D && D(P);
    },
    onChange: function(P) {
      v(P), T && T(P);
    },
    onCompositionStart: function(P) {
      x(P), E && E(P);
    },
    onCompositionEnd: function(P) {
      w(P), R && R(P);
    },
    onPaste: b
  })), S;
}, r1 = /* @__PURE__ */ O.forwardRef(cz);
process.env.NODE_ENV !== "production" && (r1.displayName = "Input");
function i1(e) {
  return Array.isArray(e) ? e : e !== void 0 ? [e] : [];
}
var uz = typeof window < "u" && window.document && window.document.documentElement, dz = process.env.NODE_ENV !== "test" && uz;
function fz(e) {
  return e != null;
}
function hz(e) {
  return !e && e !== 0;
}
function Hx(e) {
  return ["string", "number"].includes(wt(e));
}
function kT(e) {
  var t = void 0;
  return e && (Hx(e.title) ? t = e.title.toString() : Hx(e.label) && (t = e.label.toString())), t;
}
function pz(e, t) {
  dz ? O.useLayoutEffect(e, t) : O.useEffect(e, t);
}
function gz(e) {
  var t;
  return (t = e.key) !== null && t !== void 0 ? t : e.value;
}
var Vx = function(t) {
  t.preventDefault(), t.stopPropagation();
}, mz = function(t) {
  var n = t.id, r = t.prefixCls, i = t.values, o = t.open, s = t.searchValue, a = t.autoClearSearchValue, l = t.inputRef, u = t.placeholder, c = t.disabled, d = t.mode, f = t.showSearch, h = t.autoFocus, p = t.autoComplete, g = t.activeDescendantId, m = t.tabIndex, v = t.removeIcon, b = t.maxTagCount, x = t.maxTagTextLength, w = t.maxTagPlaceholder, C = w === void 0 ? function(ne) {
    return "+ ".concat(ne.length, " ...");
  } : w, y = t.tagRender, S = t.onToggleOpen, A = t.onRemove, $ = t.onInputChange, M = t.onInputPaste, _ = t.onInputKeyDown, T = t.onInputMouseDown, D = t.onInputCompositionStart, E = t.onInputCompositionEnd, R = O.useRef(null), I = ht(0), k = ae(I, 2), P = k[0], L = k[1], N = ht(!1), F = ae(N, 2), B = F[0], j = F[1], z = "".concat(r, "-selection"), H = o || d === "multiple" && a === !1 || d === "tags" ? s : "", W = d === "tags" || d === "multiple" && a === !1 || f && (o || B);
  pz(function() {
    L(R.current.scrollWidth);
  }, [H]);
  var G = function(q, te, fe, Se, de) {
    return /* @__PURE__ */ O.createElement("span", {
      title: kT(q),
      className: se("".concat(z, "-item"), re({}, "".concat(z, "-item-disabled"), fe))
    }, /* @__PURE__ */ O.createElement("span", {
      className: "".concat(z, "-item-content")
    }, te), Se && /* @__PURE__ */ O.createElement(Vg, {
      className: "".concat(z, "-item-remove"),
      onMouseDown: Vx,
      onClick: de,
      customizeIcon: v
    }, ""));
  }, K = function(q, te, fe, Se, de) {
    var ce = function(Oe) {
      Vx(Oe), S(!o);
    };
    return /* @__PURE__ */ O.createElement("span", {
      onMouseDown: ce
    }, y({
      label: te,
      value: q,
      disabled: fe,
      closable: Se,
      onClose: de
    }));
  }, Y = function(q) {
    var te = q.disabled, fe = q.label, Se = q.value, de = !c && !te, ce = fe;
    if (typeof x == "number" && (typeof fe == "string" || typeof fe == "number")) {
      var pe = String(ce);
      pe.length > x && (ce = "".concat(pe.slice(0, x), "..."));
    }
    var Oe = function(De) {
      De && De.stopPropagation(), A(q);
    };
    return typeof y == "function" ? K(Se, ce, te, de, Oe) : G(q, ce, te, de, Oe);
  }, X = function(q) {
    var te = typeof C == "function" ? C(q) : C;
    return G({
      title: te
    }, te, !1);
  }, Z = /* @__PURE__ */ O.createElement("div", {
    className: "".concat(z, "-search"),
    style: {
      width: P
    },
    onFocus: function() {
      j(!0);
    },
    onBlur: function() {
      j(!1);
    }
  }, /* @__PURE__ */ O.createElement(r1, {
    ref: l,
    open: o,
    prefixCls: r,
    id: n,
    inputElement: null,
    disabled: c,
    autoFocus: h,
    autoComplete: p,
    editable: W,
    activeDescendantId: g,
    value: H,
    onKeyDown: _,
    onMouseDown: T,
    onChange: $,
    onPaste: M,
    onCompositionStart: D,
    onCompositionEnd: E,
    tabIndex: m,
    attrs: $s(t, !0)
  }), /* @__PURE__ */ O.createElement("span", {
    ref: R,
    className: "".concat(z, "-search-mirror"),
    "aria-hidden": !0
  }, H, "")), Q = /* @__PURE__ */ O.createElement(Uo, {
    prefixCls: "".concat(z, "-overflow"),
    data: i,
    renderItem: Y,
    renderRest: X,
    suffix: Z,
    itemKey: gz,
    maxCount: b
  });
  return /* @__PURE__ */ O.createElement(O.Fragment, null, Q, !i.length && !H && /* @__PURE__ */ O.createElement("span", {
    className: "".concat(z, "-placeholder")
  }, u));
}, vz = function(t) {
  var n = t.inputElement, r = t.prefixCls, i = t.id, o = t.inputRef, s = t.disabled, a = t.autoFocus, l = t.autoComplete, u = t.activeDescendantId, c = t.mode, d = t.open, f = t.values, h = t.placeholder, p = t.tabIndex, g = t.showSearch, m = t.searchValue, v = t.activeValue, b = t.maxLength, x = t.onInputKeyDown, w = t.onInputMouseDown, C = t.onInputChange, y = t.onInputPaste, S = t.onInputCompositionStart, A = t.onInputCompositionEnd, $ = t.title, M = O.useState(!1), _ = ae(M, 2), T = _[0], D = _[1], E = c === "combobox", R = E || g, I = f[0], k = m || "";
  E && v && !T && (k = v), O.useEffect(function() {
    E && D(!1);
  }, [E, v]);
  var P = c !== "combobox" && !d && !g ? !1 : !!k, L = $ === void 0 ? kT(I) : $, N = O.useMemo(function() {
    return I ? null : /* @__PURE__ */ O.createElement("span", {
      className: "".concat(r, "-selection-placeholder"),
      style: P ? {
        visibility: "hidden"
      } : void 0
    }, h);
  }, [I, P, h, r]);
  return /* @__PURE__ */ O.createElement(O.Fragment, null, /* @__PURE__ */ O.createElement("span", {
    className: "".concat(r, "-selection-search")
  }, /* @__PURE__ */ O.createElement(r1, {
    ref: o,
    prefixCls: r,
    id: i,
    open: d,
    inputElement: n,
    disabled: s,
    autoFocus: a,
    autoComplete: l,
    editable: R,
    activeDescendantId: u,
    value: k,
    onKeyDown: x,
    onMouseDown: w,
    onChange: function(B) {
      D(!0), C(B);
    },
    onPaste: y,
    onCompositionStart: S,
    onCompositionEnd: A,
    tabIndex: p,
    attrs: $s(t, !0),
    maxLength: E ? b : void 0
  })), !E && I ? /* @__PURE__ */ O.createElement("span", {
    className: "".concat(r, "-selection-item"),
    title: L,
    style: P ? {
      visibility: "hidden"
    } : void 0
  }, I.label) : null, N);
}, bz = function(t, n) {
  var r = he(null), i = he(!1), o = t.prefixCls, s = t.open, a = t.mode, l = t.showSearch, u = t.tokenWithEnter, c = t.autoClearSearchValue, d = t.onSearch, f = t.onSearchSubmit, h = t.onToggleOpen, p = t.onInputKeyDown, g = t.domRef;
  O.useImperativeHandle(n, function() {
    return {
      focus: function(k) {
        r.current.focus(k);
      },
      blur: function() {
        r.current.blur();
      }
    };
  });
  var m = TT(0), v = ae(m, 2), b = v[0], x = v[1], w = function(k) {
    var P = k.which;
    (P === xe.UP || P === xe.DOWN) && k.preventDefault(), p && p(k), P === xe.ENTER && a === "tags" && !i.current && !s && (f == null || f(k.target.value)), Qj(P) && h(!0);
  }, C = function() {
    x(!0);
  }, y = he(null), S = function(k) {
    d(k, !0, i.current) !== !1 && h(!0);
  }, A = function() {
    i.current = !0;
  }, $ = function(k) {
    i.current = !1, a !== "combobox" && S(k.target.value);
  }, M = function(k) {
    var P = k.target.value;
    if (u && y.current && /[\r\n]/.test(y.current)) {
      var L = y.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
      P = P.replace(L, y.current);
    }
    y.current = null, S(P);
  }, _ = function(k) {
    var P = k.clipboardData, L = P == null ? void 0 : P.getData("text");
    y.current = L || "";
  }, T = function(k) {
    var P = k.target;
    if (P !== r.current) {
      var L = document.body.style.msTouchAction !== void 0;
      L ? setTimeout(function() {
        r.current.focus();
      }) : r.current.focus();
    }
  }, D = function(k) {
    var P = b();
    k.target !== r.current && !P && a !== "combobox" && k.preventDefault(), (a !== "combobox" && (!l || !P) || !s) && (s && c !== !1 && d("", !0, !1), h());
  }, E = {
    inputRef: r,
    onInputKeyDown: w,
    onInputMouseDown: C,
    onInputChange: M,
    onInputPaste: _,
    onInputCompositionStart: A,
    onInputCompositionEnd: $
  }, R = a === "multiple" || a === "tags" ? /* @__PURE__ */ O.createElement(mz, we({}, t, E)) : /* @__PURE__ */ O.createElement(vz, we({}, t, E));
  return /* @__PURE__ */ O.createElement("div", {
    ref: g,
    className: "".concat(o, "-selector"),
    onClick: T,
    onMouseDown: D
  }, R);
}, PT = /* @__PURE__ */ O.forwardRef(bz);
process.env.NODE_ENV !== "production" && (PT.displayName = "Selector");
function yz(e) {
  var t = e.prefixCls, n = e.align, r = e.arrow, i = e.arrowPos, o = r || {}, s = o.className, a = o.content, l = i.x, u = l === void 0 ? 0 : l, c = i.y, d = c === void 0 ? 0 : c, f = O.useRef();
  if (!n || !n.points)
    return null;
  var h = {
    position: "absolute"
  };
  if (n.autoArrow !== !1) {
    var p = n.points[0], g = n.points[1], m = p[0], v = p[1], b = g[0], x = g[1];
    m === b || !["t", "b"].includes(m) ? h.top = d : m === "t" ? h.top = 0 : h.bottom = 0, v === x || !["l", "r"].includes(v) ? h.left = u : v === "l" ? h.left = 0 : h.right = 0;
  }
  return /* @__PURE__ */ O.createElement("div", {
    ref: f,
    className: se("".concat(t, "-arrow"), s),
    style: h
  }, a);
}
function wz(e) {
  var t = e.prefixCls, n = e.open, r = e.zIndex, i = e.mask, o = e.motion;
  return i ? /* @__PURE__ */ O.createElement(qo, we({}, o, {
    motionAppear: !0,
    visible: n,
    removeOnLeave: !0
  }), function(s) {
    var a = s.className;
    return /* @__PURE__ */ O.createElement("div", {
      style: {
        zIndex: r
      },
      className: se("".concat(t, "-mask"), a)
    });
  }) : null;
}
var NT = /* @__PURE__ */ O.memo(function(e) {
  var t = e.children;
  return t;
}, function(e, t) {
  return t.cache;
});
process.env.NODE_ENV !== "production" && (NT.displayName = "PopupContent");
var LT = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.popup, r = e.className, i = e.prefixCls, o = e.style, s = e.target, a = e.onVisibleChanged, l = e.open, u = e.keepDom, c = e.fresh, d = e.onClick, f = e.mask, h = e.arrow, p = e.arrowPos, g = e.align, m = e.motion, v = e.maskMotion, b = e.forceRender, x = e.getPopupContainer, w = e.autoDestroy, C = e.portal, y = e.zIndex, S = e.onMouseEnter, A = e.onMouseLeave, $ = e.onPointerEnter, M = e.ready, _ = e.offsetX, T = e.offsetY, D = e.offsetR, E = e.offsetB, R = e.onAlign, I = e.onPrepare, k = e.stretch, P = e.targetWidth, L = e.targetHeight, N = typeof n == "function" ? n() : n, F = l || u, B = (x == null ? void 0 : x.length) > 0, j = O.useState(!x || !B), z = ae(j, 2), H = z[0], W = z[1];
  if (sn(function() {
    !H && B && s && W(!0);
  }, [H, B, s]), !H)
    return null;
  var G = "auto", K = {
    left: "-1000vw",
    top: "-1000vh",
    right: G,
    bottom: G
  };
  if (M || !l) {
    var Y, X = g.points, Z = g.dynamicInset || ((Y = g._experimental) === null || Y === void 0 ? void 0 : Y.dynamicInset), Q = Z && X[0][1] === "r", ne = Z && X[0][0] === "b";
    Q ? (K.right = D, K.left = G) : (K.left = _, K.right = G), ne ? (K.bottom = E, K.top = G) : (K.top = T, K.bottom = G);
  }
  var q = {};
  return k && (k.includes("height") && L ? q.height = L : k.includes("minHeight") && L && (q.minHeight = L), k.includes("width") && P ? q.width = P : k.includes("minWidth") && P && (q.minWidth = P)), l || (q.pointerEvents = "none"), /* @__PURE__ */ O.createElement(C, {
    open: b || F,
    getContainer: x && function() {
      return x(s);
    },
    autoDestroy: w
  }, /* @__PURE__ */ O.createElement(wz, {
    prefixCls: i,
    open: l,
    zIndex: y,
    mask: f,
    motion: v
  }), /* @__PURE__ */ O.createElement(Ci, {
    onResize: R,
    disabled: !l
  }, function(te) {
    return /* @__PURE__ */ O.createElement(qo, we({
      motionAppear: !0,
      motionEnter: !0,
      motionLeave: !0,
      removeOnLeave: !1,
      forceRender: b,
      leavedClassName: "".concat(i, "-hidden")
    }, m, {
      onAppearPrepare: I,
      onEnterPrepare: I,
      visible: l,
      onVisibleChanged: function(Se) {
        var de;
        m == null || (de = m.onVisibleChanged) === null || de === void 0 || de.call(m, Se), a(Se);
      }
    }), function(fe, Se) {
      var de = fe.className, ce = fe.style, pe = se(i, de, r);
      return /* @__PURE__ */ O.createElement("div", {
        ref: xi(te, t, Se),
        className: pe,
        style: ie(ie(ie(ie({
          "--arrow-x": "".concat(p.x || 0, "px"),
          "--arrow-y": "".concat(p.y || 0, "px")
        }, K), q), ce), {}, {
          boxSizing: "border-box",
          zIndex: y
        }, o),
        onMouseEnter: S,
        onMouseLeave: A,
        onPointerEnter: $,
        onClick: d
      }, h && /* @__PURE__ */ O.createElement(yz, {
        prefixCls: i,
        arrow: h,
        arrowPos: p,
        align: g
      }), /* @__PURE__ */ O.createElement(NT, {
        cache: !l && !c
      }, N));
    });
  }));
});
process.env.NODE_ENV !== "production" && (LT.displayName = "Popup");
var FT = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.children, r = e.getTriggerDOMNode, i = Ms(n), o = O.useCallback(function(a) {
    vw(t, r ? r(a) : a);
  }, [r]), s = ba(o, n.ref);
  return i ? /* @__PURE__ */ O.cloneElement(n, {
    ref: s
  }) : n;
});
process.env.NODE_ENV !== "production" && (FT.displayName = "TriggerWrapper");
var Wx = /* @__PURE__ */ O.createContext(null);
function Ux(e) {
  return e ? Array.isArray(e) ? e : [e] : [];
}
function Cz(e, t, n, r) {
  return O.useMemo(function() {
    var i = Ux(n ?? t), o = Ux(r ?? t), s = new Set(i), a = new Set(o);
    return e && (s.has("hover") && (s.delete("hover"), s.add("click")), a.has("hover") && (a.delete("hover"), a.add("click"))), [s, a];
  }, [e, t, n, r]);
}
function Sz() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], n = arguments.length > 2 ? arguments[2] : void 0;
  return n ? e[0] === t[0] : e[0] === t[0] && e[1] === t[1];
}
function xz(e, t, n, r) {
  for (var i = n.points, o = Object.keys(e), s = 0; s < o.length; s += 1) {
    var a, l = o[s];
    if (Sz((a = e[l]) === null || a === void 0 ? void 0 : a.points, i, r))
      return "".concat(t, "-placement-").concat(l);
  }
  return "";
}
function Gx(e, t, n, r) {
  return t || (n ? {
    motionName: "".concat(e, "-").concat(n)
  } : r ? {
    motionName: r
  } : null);
}
function yf(e) {
  return e.ownerDocument.defaultView;
}
function Eb(e) {
  for (var t = [], n = e == null ? void 0 : e.parentElement, r = ["hidden", "scroll", "clip", "auto"]; n; ) {
    var i = yf(n).getComputedStyle(n), o = i.overflowX, s = i.overflowY, a = i.overflow;
    [o, s, a].some(function(l) {
      return r.includes(l);
    }) && t.push(n), n = n.parentElement;
  }
  return t;
}
function Ed(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  return Number.isNaN(e) ? t : e;
}
function wu(e) {
  return Ed(parseFloat(e), 0);
}
function Kx(e, t) {
  var n = ie({}, e);
  return (t || []).forEach(function(r) {
    if (!(r instanceof HTMLBodyElement || r instanceof HTMLHtmlElement)) {
      var i = yf(r).getComputedStyle(r), o = i.overflow, s = i.overflowClipMargin, a = i.borderTopWidth, l = i.borderBottomWidth, u = i.borderLeftWidth, c = i.borderRightWidth, d = r.getBoundingClientRect(), f = r.offsetHeight, h = r.clientHeight, p = r.offsetWidth, g = r.clientWidth, m = wu(a), v = wu(l), b = wu(u), x = wu(c), w = Ed(Math.round(d.width / p * 1e3) / 1e3), C = Ed(Math.round(d.height / f * 1e3) / 1e3), y = (p - g - b - x) * w, S = (f - h - m - v) * C, A = m * C, $ = v * C, M = b * w, _ = x * w, T = 0, D = 0;
      if (o === "clip") {
        var E = wu(s);
        T = E * w, D = E * C;
      }
      var R = d.x + M - T, I = d.y + A - D, k = R + d.width + 2 * T - M - _ - y, P = I + d.height + 2 * D - A - $ - S;
      n.left = Math.max(n.left, R), n.top = Math.max(n.top, I), n.right = Math.min(n.right, k), n.bottom = Math.min(n.bottom, P);
    }
  }), n;
}
function Xx(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = "".concat(t), r = n.match(/^(.*)\%$/);
  return r ? e * (parseFloat(r[1]) / 100) : parseFloat(n);
}
function Yx(e, t) {
  var n = t || [], r = ae(n, 2), i = r[0], o = r[1];
  return [Xx(e.width, i), Xx(e.height, o)];
}
function qx() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  return [e[0], e[1]];
}
function Ll(e, t) {
  var n = t[0], r = t[1], i, o;
  return n === "t" ? o = e.y : n === "b" ? o = e.y + e.height : o = e.y + e.height / 2, r === "l" ? i = e.x : r === "r" ? i = e.x + e.width : i = e.x + e.width / 2, {
    x: i,
    y: o
  };
}
function Ls(e, t) {
  var n = {
    t: "b",
    b: "t",
    l: "r",
    r: "l"
  };
  return e.map(function(r, i) {
    return i === t ? n[r] || "c" : r;
  }).join("");
}
function Ez(e, t, n, r, i, o, s) {
  var a = O.useState({
    ready: !1,
    offsetX: 0,
    offsetY: 0,
    offsetR: 0,
    offsetB: 0,
    arrowX: 0,
    arrowY: 0,
    scaleX: 1,
    scaleY: 1,
    align: i[r] || {}
  }), l = ae(a, 2), u = l[0], c = l[1], d = O.useRef(0), f = O.useMemo(function() {
    return t ? Eb(t) : [];
  }, [t]), h = O.useRef({}), p = function() {
    h.current = {};
  };
  e || p();
  var g = Nn(function() {
    if (t && n && e) {
      let Jn = function(Al, er) {
        var Is = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : pe, Dl = N.x + Al, ks = N.y + er, _l = Dl + Y, Ca = ks + K, Hi = Math.max(Dl, Is.left), Tl = Math.max(ks, Is.top), pu = Math.min(_l, Is.right), Ps = Math.min(Ca, Is.bottom);
        return Math.max(0, (pu - Hi) * (Ps - Tl));
      }, Ol = function() {
        be = N.y + nt, Ee = be + K, ye = N.x + Et, Ke = ye + Y;
      };
      var b, x, w = t, C = w.ownerDocument, y = yf(w), S = y.getComputedStyle(w), A = S.width, $ = S.height, M = S.position, _ = w.style.left, T = w.style.top, D = w.style.right, E = w.style.bottom, R = w.style.overflow, I = ie(ie({}, i[r]), o), k = C.createElement("div");
      (b = w.parentElement) === null || b === void 0 || b.appendChild(k), k.style.left = "".concat(w.offsetLeft, "px"), k.style.top = "".concat(w.offsetTop, "px"), k.style.position = M, k.style.height = "".concat(w.offsetHeight, "px"), k.style.width = "".concat(w.offsetWidth, "px"), w.style.left = "0", w.style.top = "0", w.style.right = "auto", w.style.bottom = "auto", w.style.overflow = "hidden";
      var P;
      if (Array.isArray(n))
        P = {
          x: n[0],
          y: n[1],
          width: 0,
          height: 0
        };
      else {
        var L = n.getBoundingClientRect();
        P = {
          x: L.x,
          y: L.y,
          width: L.width,
          height: L.height
        };
      }
      var N = w.getBoundingClientRect(), F = C.documentElement, B = F.clientWidth, j = F.clientHeight, z = F.scrollWidth, H = F.scrollHeight, W = F.scrollTop, G = F.scrollLeft, K = N.height, Y = N.width, X = P.height, Z = P.width, Q = {
        left: 0,
        top: 0,
        right: B,
        bottom: j
      }, ne = {
        left: -G,
        top: -W,
        right: z - G,
        bottom: H - W
      }, q = I.htmlRegion, te = "visible", fe = "visibleFirst";
      q !== "scroll" && q !== fe && (q = te);
      var Se = q === fe, de = Kx(ne, f), ce = Kx(Q, f), pe = q === te ? ce : de, Oe = Se ? ce : pe;
      w.style.left = "auto", w.style.top = "auto", w.style.right = "0", w.style.bottom = "0";
      var Re = w.getBoundingClientRect();
      w.style.left = _, w.style.top = T, w.style.right = D, w.style.bottom = E, w.style.overflow = R, (x = w.parentElement) === null || x === void 0 || x.removeChild(k);
      var De = Ed(Math.round(Y / parseFloat(A) * 1e3) / 1e3), Me = Ed(Math.round(K / parseFloat($) * 1e3) / 1e3);
      if (De === 0 || Me === 0 || Sp(n) && !Fg(n))
        return;
      var Ue = I.offset, oe = I.targetOffset, Ce = Yx(N, Ue), ge = ae(Ce, 2), ve = ge[0], me = ge[1], Fe = Yx(P, oe), Be = ae(Fe, 2), qe = Be[0], Ve = Be[1];
      P.x -= qe, P.y -= Ve;
      var We = I.points || [], Ge = ae(We, 2), $e = Ge[0], ze = Ge[1], at = qx(ze), xt = qx($e), jt = Ll(P, at), Lt = Ll(N, xt), At = ie({}, I), Et = jt.x - Lt.x + ve, nt = jt.y - Lt.y + me, it = Jn(Et, nt), je = Jn(Et, nt, ce), Le = Ll(P, ["t", "l"]), ot = Ll(N, ["t", "l"]), yt = Ll(P, ["b", "r"]), He = Ll(N, ["b", "r"]), Je = I.overflow || {}, Qe = Je.adjustX, lt = Je.adjustY, pt = Je.shiftX, vt = Je.shiftY, ee = function(er) {
        return typeof er == "boolean" ? er : er >= 0;
      }, be, Ee, ye, Ke;
      Ol();
      var et = ee(lt), Ie = xt[0] === at[0];
      if (et && xt[0] === "t" && (Ee > Oe.bottom || h.current.bt)) {
        var Ae = nt;
        Ie ? Ae -= K - X : Ae = Le.y - He.y - me;
        var tt = Jn(Et, Ae), dt = Jn(Et, Ae, ce);
        // Of course use larger one
        tt > it || tt === it && (!Se || // Choose recommend one
        dt >= je) ? (h.current.bt = !0, nt = Ae, me = -me, At.points = [Ls(xt, 0), Ls(at, 0)]) : h.current.bt = !1;
      }
      if (et && xt[0] === "b" && (be < Oe.top || h.current.tb)) {
        var Tt = nt;
        Ie ? Tt += K - X : Tt = yt.y - ot.y - me;
        var Ct = Jn(Et, Tt), vn = Jn(Et, Tt, ce);
        // Of course use larger one
        Ct > it || Ct === it && (!Se || // Choose recommend one
        vn >= je) ? (h.current.tb = !0, nt = Tt, me = -me, At.points = [Ls(xt, 0), Ls(at, 0)]) : h.current.tb = !1;
      }
      var Hn = ee(Qe), pn = xt[1] === at[1];
      if (Hn && xt[1] === "l" && (Ke > Oe.right || h.current.rl)) {
        var Qn = Et;
        pn ? Qn -= Y - Z : Qn = Le.x - He.x - ve;
        var Fr = Jn(Qn, nt), Qr = Jn(Qn, nt, ce);
        // Of course use larger one
        Fr > it || Fr === it && (!Se || // Choose recommend one
        Qr >= je) ? (h.current.rl = !0, Et = Qn, ve = -ve, At.points = [Ls(xt, 1), Ls(at, 1)]) : h.current.rl = !1;
      }
      if (Hn && xt[1] === "r" && (ye < Oe.left || h.current.lr)) {
        var Br = Et;
        pn ? Br += Y - Z : Br = yt.x - ot.x - ve;
        var gr = Jn(Br, nt), Er = Jn(Br, nt, ce);
        // Of course use larger one
        gr > it || gr === it && (!Se || // Choose recommend one
        Er >= je) ? (h.current.lr = !0, Et = Br, ve = -ve, At.points = [Ls(xt, 1), Ls(at, 1)]) : h.current.lr = !1;
      }
      Ol();
      var jr = pt === !0 ? 0 : pt;
      typeof jr == "number" && (ye < ce.left && (Et -= ye - ce.left - ve, P.x + Z < ce.left + jr && (Et += P.x - ce.left + Z - jr)), Ke > ce.right && (Et -= Ke - ce.right - ve, P.x > ce.right - jr && (Et += P.x - ce.right + jr)));
      var zr = vt === !0 ? 0 : vt;
      typeof zr == "number" && (be < ce.top && (nt -= be - ce.top - me, P.y + X < ce.top + zr && (nt += P.y - ce.top + X - zr)), Ee > ce.bottom && (nt -= Ee - ce.bottom - me, P.y > ce.bottom - zr && (nt += P.y - ce.bottom + zr)));
      var zi = N.x + Et, Mo = zi + Y, fi = N.y + nt, Ei = fi + K, Zr = P.x, hi = Zr + Z, Ze = P.y, Ye = Ze + X, Dt = Math.max(zi, Zr), en = Math.min(Mo, hi), zt = (Dt + en) / 2, xn = zt - zi, or = Math.max(fi, Ze), $r = Math.min(Ei, Ye), mr = (or + $r) / 2, Jr = mr - fi;
      s == null || s(t, At);
      var Zn = Re.right - N.x - (Et + N.width), vr = Re.bottom - N.y - (nt + N.height);
      c({
        ready: !0,
        offsetX: Et / De,
        offsetY: nt / Me,
        offsetR: Zn / De,
        offsetB: vr / Me,
        arrowX: xn / De,
        arrowY: Jr / Me,
        scaleX: De,
        scaleY: Me,
        align: At
      });
    }
  }), m = function() {
    d.current += 1;
    var x = d.current;
    Promise.resolve().then(function() {
      d.current === x && g();
    });
  }, v = function() {
    c(function(x) {
      return ie(ie({}, x), {}, {
        ready: !1
      });
    });
  };
  return sn(v, [r]), sn(function() {
    e || v();
  }, [e]), [u.ready, u.offsetX, u.offsetY, u.offsetR, u.offsetB, u.arrowX, u.arrowY, u.scaleX, u.scaleY, u.align, m];
}
function $z(e, t, n, r, i) {
  sn(function() {
    if (e && t && n) {
      let d = function() {
        r(), i();
      };
      var o = t, s = n, a = Eb(o), l = Eb(s), u = yf(s), c = new Set([u].concat(_e(a), _e(l)));
      return c.forEach(function(f) {
        f.addEventListener("scroll", d, {
          passive: !0
        });
      }), u.addEventListener("resize", d, {
        passive: !0
      }), r(), function() {
        c.forEach(function(f) {
          f.removeEventListener("scroll", d), u.removeEventListener("resize", d);
        });
      };
    }
  }, [e, t, n]);
}
function Oz(e, t, n, r, i, o, s, a) {
  var l = O.useRef(e);
  l.current = e, O.useEffect(function() {
    if (t && r && (!i || o)) {
      var u = function(v) {
        var b = v.target;
        l.current && !s(b) && a(!1);
      }, c = yf(r);
      c.addEventListener("mousedown", u, !0), c.addEventListener("contextmenu", u, !0);
      var d = Ap(n);
      if (d && (d.addEventListener("mousedown", u, !0), d.addEventListener("contextmenu", u, !0)), process.env.NODE_ENV !== "production") {
        var f, h, p = n == null || (f = n.getRootNode) === null || f === void 0 ? void 0 : f.call(n), g = (h = r.getRootNode) === null || h === void 0 ? void 0 : h.call(r);
        Ss(p === g, "trigger element and popup element should in same shadow root.");
      }
      return function() {
        c.removeEventListener("mousedown", u, !0), c.removeEventListener("contextmenu", u, !0), d && (d.removeEventListener("mousedown", u, !0), d.removeEventListener("contextmenu", u, !0));
      };
    }
  }, [t, n, r, i, o]);
}
var Az = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "fresh", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];
function Dz() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : zg, t = /* @__PURE__ */ O.forwardRef(function(n, r) {
    var i = n.prefixCls, o = i === void 0 ? "rc-trigger-popup" : i, s = n.children, a = n.action, l = a === void 0 ? "hover" : a, u = n.showAction, c = n.hideAction, d = n.popupVisible, f = n.defaultPopupVisible, h = n.onPopupVisibleChange, p = n.afterPopupVisibleChange, g = n.mouseEnterDelay, m = n.mouseLeaveDelay, v = m === void 0 ? 0.1 : m, b = n.focusDelay, x = n.blurDelay, w = n.mask, C = n.maskClosable, y = C === void 0 ? !0 : C, S = n.getPopupContainer, A = n.forceRender, $ = n.autoDestroy, M = n.destroyPopupOnHide, _ = n.popup, T = n.popupClassName, D = n.popupStyle, E = n.popupPlacement, R = n.builtinPlacements, I = R === void 0 ? {} : R, k = n.popupAlign, P = n.zIndex, L = n.stretch, N = n.getPopupClassNameFromAlign, F = n.fresh, B = n.alignPoint, j = n.onPopupClick, z = n.onPopupAlign, H = n.arrow, W = n.popupMotion, G = n.maskMotion, K = n.popupTransitionName, Y = n.popupAnimation, X = n.maskTransitionName, Z = n.maskAnimation, Q = n.className, ne = n.getTriggerDOMNode, q = Rt(n, Az), te = $ || M || !1, fe = O.useState(!1), Se = ae(fe, 2), de = Se[0], ce = Se[1];
    sn(function() {
      ce(n1());
    }, []);
    var pe = O.useRef({}), Oe = O.useContext(Wx), Re = O.useMemo(function() {
      return {
        registerSubPopup: function(_t, On) {
          pe.current[_t] = On, Oe == null || Oe.registerSubPopup(_t, On);
        }
      };
    }, [Oe]), De = V_(), Me = O.useState(null), Ue = ae(Me, 2), oe = Ue[0], Ce = Ue[1], ge = O.useRef(null), ve = Nn(function(ct) {
      ge.current = ct, Sp(ct) && oe !== ct && Ce(ct), Oe == null || Oe.registerSubPopup(De, ct);
    }), me = O.useState(null), Fe = ae(me, 2), Be = Fe[0], qe = Fe[1], Ve = O.useRef(null), We = Nn(function(ct) {
      Sp(ct) && Be !== ct && (qe(ct), Ve.current = ct);
    }), Ge = O.Children.only(s), $e = (Ge == null ? void 0 : Ge.props) || {}, ze = {}, at = Nn(function(ct) {
      var _t, On, Xn = Be;
      return (Xn == null ? void 0 : Xn.contains(ct)) || ((_t = Ap(Xn)) === null || _t === void 0 ? void 0 : _t.host) === ct || ct === Xn || (oe == null ? void 0 : oe.contains(ct)) || ((On = Ap(oe)) === null || On === void 0 ? void 0 : On.host) === ct || ct === oe || Object.values(pe.current).some(function(An) {
        return (An == null ? void 0 : An.contains(ct)) || ct === An;
      });
    }), xt = Gx(o, W, Y, K), jt = Gx(o, G, Z, X), Lt = O.useState(f || !1), At = ae(Lt, 2), Et = At[0], nt = At[1], it = d ?? Et, je = Nn(function(ct) {
      d === void 0 && nt(ct);
    });
    sn(function() {
      nt(d || !1);
    }, [d]);
    var Le = O.useRef(it);
    Le.current = it;
    var ot = O.useRef([]);
    ot.current = [];
    var yt = Nn(function(ct) {
      var _t;
      je(ct), ((_t = ot.current[ot.current.length - 1]) !== null && _t !== void 0 ? _t : it) !== ct && (ot.current.push(ct), h == null || h(ct));
    }), He = O.useRef(), Je = function() {
      clearTimeout(He.current);
    }, Qe = function(_t) {
      var On = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      Je(), On === 0 ? yt(_t) : He.current = setTimeout(function() {
        yt(_t);
      }, On * 1e3);
    };
    O.useEffect(function() {
      return Je;
    }, []);
    var lt = O.useState(!1), pt = ae(lt, 2), vt = pt[0], ee = pt[1];
    sn(function(ct) {
      (!ct || it) && ee(!0);
    }, [it]);
    var be = O.useState(null), Ee = ae(be, 2), ye = Ee[0], Ke = Ee[1], et = O.useState([0, 0]), Ie = ae(et, 2), Ae = Ie[0], tt = Ie[1], dt = function(_t) {
      tt([_t.clientX, _t.clientY]);
    }, Tt = Ez(it, oe, B ? Ae : Be, E, I, k, z), Ct = ae(Tt, 11), vn = Ct[0], Hn = Ct[1], pn = Ct[2], Qn = Ct[3], Fr = Ct[4], Qr = Ct[5], Br = Ct[6], gr = Ct[7], Er = Ct[8], jr = Ct[9], zr = Ct[10], zi = Cz(de, l, u, c), Mo = ae(zi, 2), fi = Mo[0], Ei = Mo[1], Zr = fi.has("click"), hi = Ei.has("click") || Ei.has("contextMenu"), Ze = Nn(function() {
      vt || zr();
    }), Ye = function() {
      Le.current && B && hi && Qe(!1);
    };
    $z(it, Be, oe, Ze, Ye), sn(function() {
      Ze();
    }, [Ae, E]), sn(function() {
      it && !(I != null && I[E]) && Ze();
    }, [JSON.stringify(k)]);
    var Dt = O.useMemo(function() {
      var ct = xz(I, o, jr, B);
      return se(ct, N == null ? void 0 : N(jr));
    }, [jr, N, I, o, B]);
    O.useImperativeHandle(r, function() {
      return {
        nativeElement: Ve.current,
        popupElement: ge.current,
        forceAlign: Ze
      };
    });
    var en = O.useState(0), zt = ae(en, 2), xn = zt[0], or = zt[1], $r = O.useState(0), mr = ae($r, 2), Jr = mr[0], Zn = mr[1], vr = function() {
      if (L && Be) {
        var _t = Be.getBoundingClientRect();
        or(_t.width), Zn(_t.height);
      }
    }, Jn = function() {
      vr(), Ze();
    }, Ol = function(_t) {
      ee(!1), zr(), p == null || p(_t);
    }, Al = function() {
      return new Promise(function(_t) {
        vr(), Ke(function() {
          return _t;
        });
      });
    };
    sn(function() {
      ye && (zr(), ye(), Ke(null));
    }, [ye]);
    function er(ct, _t, On, Xn) {
      ze[ct] = function(An) {
        var Io;
        Xn == null || Xn(An), Qe(_t, On);
        for (var Rl = arguments.length, Lf = new Array(Rl > 1 ? Rl - 1 : 0), Ml = 1; Ml < Rl; Ml++)
          Lf[Ml - 1] = arguments[Ml];
        (Io = $e[ct]) === null || Io === void 0 || Io.call.apply(Io, [$e, An].concat(Lf));
      };
    }
    (Zr || hi) && (ze.onClick = function(ct) {
      var _t;
      Le.current && hi ? Qe(!1) : !Le.current && Zr && (dt(ct), Qe(!0));
      for (var On = arguments.length, Xn = new Array(On > 1 ? On - 1 : 0), An = 1; An < On; An++)
        Xn[An - 1] = arguments[An];
      (_t = $e.onClick) === null || _t === void 0 || _t.call.apply(_t, [$e, ct].concat(Xn));
    }), Oz(it, hi, Be, oe, w, y, at, Qe);
    var Is = fi.has("hover"), Dl = Ei.has("hover"), ks, _l;
    Is && (er("onMouseEnter", !0, g, function(ct) {
      dt(ct);
    }), er("onPointerEnter", !0, g, function(ct) {
      dt(ct);
    }), ks = function(_t) {
      (it || vt) && oe !== null && oe !== void 0 && oe.contains(_t.target) && Qe(!0, g);
    }, B && (ze.onMouseMove = function(ct) {
      var _t;
      (_t = $e.onMouseMove) === null || _t === void 0 || _t.call($e, ct);
    })), Dl && (er("onMouseLeave", !1, v), er("onPointerLeave", !1, v), _l = function() {
      Qe(!1, v);
    }), fi.has("focus") && er("onFocus", !0, b), Ei.has("focus") && er("onBlur", !1, x), fi.has("contextMenu") && (ze.onContextMenu = function(ct) {
      var _t;
      Le.current && Ei.has("contextMenu") ? Qe(!1) : (dt(ct), Qe(!0)), ct.preventDefault();
      for (var On = arguments.length, Xn = new Array(On > 1 ? On - 1 : 0), An = 1; An < On; An++)
        Xn[An - 1] = arguments[An];
      (_t = $e.onContextMenu) === null || _t === void 0 || _t.call.apply(_t, [$e, ct].concat(Xn));
    }), Q && (ze.className = se($e.className, Q));
    var Ca = ie(ie({}, $e), ze), Hi = {}, Tl = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
    Tl.forEach(function(ct) {
      q[ct] && (Hi[ct] = function() {
        for (var _t, On = arguments.length, Xn = new Array(On), An = 0; An < On; An++)
          Xn[An] = arguments[An];
        (_t = Ca[ct]) === null || _t === void 0 || _t.call.apply(_t, [Ca].concat(Xn)), q[ct].apply(q, Xn);
      });
    });
    var pu = /* @__PURE__ */ O.cloneElement(Ge, ie(ie({}, Ca), Hi)), Ps = {
      x: Qr,
      y: Br
    }, Pm = H ? ie({}, H !== !0 ? H : {}) : null;
    return /* @__PURE__ */ O.createElement(O.Fragment, null, /* @__PURE__ */ O.createElement(Ci, {
      disabled: !it,
      ref: We,
      onResize: Jn
    }, /* @__PURE__ */ O.createElement(FT, {
      getTriggerDOMNode: ne
    }, pu)), /* @__PURE__ */ O.createElement(Wx.Provider, {
      value: Re
    }, /* @__PURE__ */ O.createElement(LT, {
      portal: e,
      ref: ve,
      prefixCls: o,
      popup: _,
      className: se(T, Dt),
      style: D,
      target: Be,
      onMouseEnter: ks,
      onMouseLeave: _l,
      onPointerEnter: ks,
      zIndex: P,
      open: it,
      keepDom: vt,
      fresh: F,
      onClick: j,
      mask: w,
      motion: xt,
      maskMotion: jt,
      onVisibleChanged: Ol,
      onPrepare: Al,
      forceRender: A,
      autoDestroy: te,
      getPopupContainer: S,
      align: jr,
      arrow: Pm,
      arrowPos: Ps,
      ready: vn,
      offsetX: Hn,
      offsetY: pn,
      offsetR: Qn,
      offsetB: Fr,
      onAlign: Ze,
      stretch: L,
      targetWidth: xn / gr,
      targetHeight: Jr / Er
    })));
  });
  return process.env.NODE_ENV !== "production" && (t.displayName = "Trigger"), t;
}
const Wg = Dz(zg);
var _z = ["prefixCls", "disabled", "visible", "children", "popupElement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "direction", "placement", "builtinPlacements", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "getPopupContainer", "empty", "getTriggerDOMNode", "onPopupVisibleChange", "onPopupMouseEnter"], Tz = function(t) {
  var n = t === !0 ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX: n,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX: n,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX: n,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX: n,
        adjustY: 1
      },
      htmlRegion: "scroll"
    }
  };
}, Rz = function(t, n) {
  var r = t.prefixCls;
  t.disabled;
  var i = t.visible, o = t.children, s = t.popupElement, a = t.animation, l = t.transitionName, u = t.dropdownStyle, c = t.dropdownClassName, d = t.direction, f = d === void 0 ? "ltr" : d, h = t.placement, p = t.builtinPlacements, g = t.dropdownMatchSelectWidth, m = t.dropdownRender, v = t.dropdownAlign, b = t.getPopupContainer, x = t.empty, w = t.getTriggerDOMNode, C = t.onPopupVisibleChange, y = t.onPopupMouseEnter, S = Rt(t, _z), A = "".concat(r, "-dropdown"), $ = s;
  m && ($ = m(s));
  var M = O.useMemo(function() {
    return p || Tz(g);
  }, [p, g]), _ = a ? "".concat(A, "-").concat(a) : l, T = typeof g == "number", D = O.useMemo(function() {
    return T ? null : g === !1 ? "minWidth" : "width";
  }, [g, T]), E = u;
  T && (E = ie(ie({}, E), {}, {
    width: g
  }));
  var R = O.useRef(null);
  return O.useImperativeHandle(n, function() {
    return {
      getPopupElement: function() {
        var k;
        return (k = R.current) === null || k === void 0 ? void 0 : k.popupElement;
      }
    };
  }), /* @__PURE__ */ O.createElement(Wg, we({}, S, {
    showAction: C ? ["click"] : [],
    hideAction: C ? ["click"] : [],
    popupPlacement: h || (f === "rtl" ? "bottomRight" : "bottomLeft"),
    builtinPlacements: M,
    prefixCls: A,
    popupTransitionName: _,
    popup: /* @__PURE__ */ O.createElement("div", {
      onMouseEnter: y
    }, $),
    ref: R,
    stretch: D,
    popupAlign: v,
    popupVisible: i,
    getPopupContainer: b,
    popupClassName: se(c, re({}, "".concat(A, "-empty"), x)),
    popupStyle: E,
    getTriggerDOMNode: w,
    onPopupVisibleChange: C
  }), o);
}, BT = /* @__PURE__ */ O.forwardRef(Rz);
process.env.NODE_ENV !== "production" && (BT.displayName = "SelectTrigger");
function Qx(e, t) {
  var n = e.key, r;
  return "value" in e && (r = e.value), n ?? (r !== void 0 ? r : "rc-index-key-".concat(t));
}
function $b(e) {
  return typeof e < "u" && !Number.isNaN(e);
}
function jT(e, t) {
  var n = e || {}, r = n.label, i = n.value, o = n.options, s = n.groupLabel, a = r || (t ? "children" : "label");
  return {
    label: a,
    value: i || "value",
    options: o || "options",
    groupLabel: s || a
  };
}
function Mz(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.fieldNames, r = t.childrenAsData, i = [], o = jT(n, !1), s = o.label, a = o.value, l = o.options, u = o.groupLabel;
  function c(d, f) {
    Array.isArray(d) && d.forEach(function(h) {
      if (f || !(l in h)) {
        var p = h[a];
        i.push({
          key: Qx(h, i.length),
          groupOption: f,
          data: h,
          label: h[s],
          value: p
        });
      } else {
        var g = h[u];
        g === void 0 && r && (g = h.label), i.push({
          key: Qx(h, i.length),
          group: !0,
          data: h,
          label: g
        }), c(h[l], !0);
      }
    });
  }
  return c(e, !1), i;
}
function Ob(e) {
  var t = ie({}, e);
  return "props" in t || Object.defineProperty(t, "props", {
    get: function() {
      return $t(!1, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`."), t;
    }
  }), t;
}
var Iz = function(t, n, r) {
  if (!n || !n.length)
    return null;
  var i = !1, o = function a(l, u) {
    var c = DD(u), d = c[0], f = c.slice(1);
    if (!d)
      return [l];
    var h = l.split(d);
    return i = i || h.length > 1, h.reduce(function(p, g) {
      return [].concat(_e(p), _e(a(g, f)));
    }, []).filter(Boolean);
  }, s = o(t, n);
  return i ? typeof r < "u" ? s.slice(0, r) : s : null;
}, o1 = /* @__PURE__ */ O.createContext(null), kz = ["id", "prefixCls", "className", "showSearch", "tagRender", "direction", "omitDomProps", "displayValues", "onDisplayValuesChange", "emptyOptions", "notFoundContent", "onClear", "mode", "disabled", "loading", "getInputElement", "getRawInputElement", "open", "defaultOpen", "onDropdownVisibleChange", "activeValue", "onActiveValueChange", "activeDescendantId", "searchValue", "autoClearSearchValue", "onSearch", "onSearchSplit", "tokenSeparators", "allowClear", "suffixIcon", "clearIcon", "OptionList", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "placement", "builtinPlacements", "getPopupContainer", "showAction", "onFocus", "onBlur", "onKeyUp", "onKeyDown", "onMouseDown"], Pz = ["value", "onChange", "removeIcon", "placeholder", "autoFocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabIndex"], Mp = function(t) {
  return t === "tags" || t === "multiple";
}, s1 = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n, r = e.id, i = e.prefixCls, o = e.className, s = e.showSearch, a = e.tagRender, l = e.direction, u = e.omitDomProps, c = e.displayValues, d = e.onDisplayValuesChange, f = e.emptyOptions, h = e.notFoundContent, p = h === void 0 ? "Not Found" : h, g = e.onClear, m = e.mode, v = e.disabled, b = e.loading, x = e.getInputElement, w = e.getRawInputElement, C = e.open, y = e.defaultOpen, S = e.onDropdownVisibleChange, A = e.activeValue, $ = e.onActiveValueChange, M = e.activeDescendantId, _ = e.searchValue, T = e.autoClearSearchValue, D = e.onSearch, E = e.onSearchSplit, R = e.tokenSeparators, I = e.allowClear, k = e.suffixIcon, P = e.clearIcon, L = e.OptionList, N = e.animation, F = e.transitionName, B = e.dropdownStyle, j = e.dropdownClassName, z = e.dropdownMatchSelectWidth, H = e.dropdownRender, W = e.dropdownAlign, G = e.placement, K = e.builtinPlacements, Y = e.getPopupContainer, X = e.showAction, Z = X === void 0 ? [] : X, Q = e.onFocus, ne = e.onBlur, q = e.onKeyUp, te = e.onKeyDown, fe = e.onMouseDown, Se = Rt(e, kz), de = Mp(m), ce = (s !== void 0 ? s : de) || m === "combobox", pe = ie({}, Se);
  Pz.forEach(function(Ze) {
    delete pe[Ze];
  }), u == null || u.forEach(function(Ze) {
    delete pe[Ze];
  });
  var Oe = O.useState(!1), Re = ae(Oe, 2), De = Re[0], Me = Re[1];
  O.useEffect(function() {
    Me(n1());
  }, []);
  var Ue = O.useRef(null), oe = O.useRef(null), Ce = O.useRef(null), ge = O.useRef(null), ve = O.useRef(null), me = O.useRef(!1), Fe = Yj(), Be = ae(Fe, 3), qe = Be[0], Ve = Be[1], We = Be[2];
  O.useImperativeHandle(t, function() {
    var Ze, Ye;
    return {
      focus: (Ze = ge.current) === null || Ze === void 0 ? void 0 : Ze.focus,
      blur: (Ye = ge.current) === null || Ye === void 0 ? void 0 : Ye.blur,
      scrollTo: function(en) {
        var zt;
        return (zt = ve.current) === null || zt === void 0 ? void 0 : zt.scrollTo(en);
      }
    };
  });
  var Ge = O.useMemo(function() {
    var Ze;
    if (m !== "combobox")
      return _;
    var Ye = (Ze = c[0]) === null || Ze === void 0 ? void 0 : Ze.value;
    return typeof Ye == "string" || typeof Ye == "number" ? String(Ye) : "";
  }, [_, m, c]), $e = m === "combobox" && typeof x == "function" && x() || null, ze = typeof w == "function" && w(), at = ba(oe, ze == null || (n = ze.props) === null || n === void 0 ? void 0 : n.ref), xt = O.useState(!1), jt = ae(xt, 2), Lt = jt[0], At = jt[1];
  sn(function() {
    At(!0);
  }, []);
  var Et = Un(!1, {
    defaultValue: y,
    value: C
  }), nt = ae(Et, 2), it = nt[0], je = nt[1], Le = Lt ? it : !1, ot = !p && f;
  (v || ot && Le && m === "combobox") && (Le = !1);
  var yt = ot ? !1 : Le, He = O.useCallback(function(Ze) {
    var Ye = Ze !== void 0 ? Ze : !Le;
    v || (je(Ye), Le !== Ye && (S == null || S(Ye)));
  }, [v, Le, je, S]), Je = O.useMemo(function() {
    return (R || []).some(function(Ze) {
      return [`
`, `\r
`].includes(Ze);
    });
  }, [R]), Qe = O.useContext(o1) || {}, lt = Qe.maxCount, pt = Qe.rawValues, vt = function(Ye, Dt, en) {
    if (!(de && $b(lt) && (pt == null ? void 0 : pt.size) >= lt)) {
      var zt = !0, xn = Ye;
      $ == null || $(null);
      var or = Iz(Ye, R, $b(lt) ? lt - pt.size : void 0), $r = en ? null : or;
      return m !== "combobox" && $r && (xn = "", E == null || E($r), He(!1), zt = !1), D && Ge !== xn && D(xn, {
        source: Dt ? "typing" : "effect"
      }), zt;
    }
  }, ee = function(Ye) {
    !Ye || !Ye.trim() || D(Ye, {
      source: "submit"
    });
  };
  O.useEffect(function() {
    !Le && !de && m !== "combobox" && vt("", !1, !1);
  }, [Le]), O.useEffect(function() {
    it && v && je(!1), v && !me.current && Ve(!1);
  }, [v]);
  var be = TT(), Ee = ae(be, 2), ye = Ee[0], Ke = Ee[1], et = function(Ye) {
    var Dt = ye(), en = Ye.which;
    if (en === xe.ENTER && (m !== "combobox" && Ye.preventDefault(), Le || He(!0)), Ke(!!Ge), en === xe.BACKSPACE && !Dt && de && !Ge && c.length) {
      for (var zt = _e(c), xn = null, or = zt.length - 1; or >= 0; or -= 1) {
        var $r = zt[or];
        if (!$r.disabled) {
          zt.splice(or, 1), xn = $r;
          break;
        }
      }
      xn && d(zt, {
        type: "remove",
        values: [xn]
      });
    }
    for (var mr = arguments.length, Jr = new Array(mr > 1 ? mr - 1 : 0), Zn = 1; Zn < mr; Zn++)
      Jr[Zn - 1] = arguments[Zn];
    if (Le) {
      var vr;
      (vr = ve.current) === null || vr === void 0 || vr.onKeyDown.apply(vr, [Ye].concat(Jr));
    }
    te == null || te.apply(void 0, [Ye].concat(Jr));
  }, Ie = function(Ye) {
    for (var Dt = arguments.length, en = new Array(Dt > 1 ? Dt - 1 : 0), zt = 1; zt < Dt; zt++)
      en[zt - 1] = arguments[zt];
    if (Le) {
      var xn;
      (xn = ve.current) === null || xn === void 0 || xn.onKeyUp.apply(xn, [Ye].concat(en));
    }
    q == null || q.apply(void 0, [Ye].concat(en));
  }, Ae = function(Ye) {
    var Dt = c.filter(function(en) {
      return en !== Ye;
    });
    d(Dt, {
      type: "remove",
      values: [Ye]
    });
  }, tt = O.useRef(!1), dt = function() {
    Ve(!0), v || (Q && !tt.current && Q.apply(void 0, arguments), Z.includes("focus") && He(!0)), tt.current = !0;
  }, Tt = function() {
    me.current = !0, Ve(!1, function() {
      tt.current = !1, me.current = !1, He(!1);
    }), !v && (Ge && (m === "tags" ? D(Ge, {
      source: "submit"
    }) : m === "multiple" && D("", {
      source: "blur"
    })), ne && ne.apply(void 0, arguments));
  }, Ct = [];
  O.useEffect(function() {
    return function() {
      Ct.forEach(function(Ze) {
        return clearTimeout(Ze);
      }), Ct.splice(0, Ct.length);
    };
  }, []);
  var vn = function(Ye) {
    var Dt, en = Ye.target, zt = (Dt = Ce.current) === null || Dt === void 0 ? void 0 : Dt.getPopupElement();
    if (zt && zt.contains(en)) {
      var xn = setTimeout(function() {
        var Jr = Ct.indexOf(xn);
        if (Jr !== -1 && Ct.splice(Jr, 1), We(), !De && !zt.contains(document.activeElement)) {
          var Zn;
          (Zn = ge.current) === null || Zn === void 0 || Zn.focus();
        }
      });
      Ct.push(xn);
    }
    for (var or = arguments.length, $r = new Array(or > 1 ? or - 1 : 0), mr = 1; mr < or; mr++)
      $r[mr - 1] = arguments[mr];
    fe == null || fe.apply(void 0, [Ye].concat($r));
  }, Hn = O.useState({}), pn = ae(Hn, 2), Qn = pn[1];
  function Fr() {
    Qn({});
  }
  var Qr;
  ze && (Qr = function(Ye) {
    He(Ye);
  }), qj(function() {
    var Ze;
    return [Ue.current, (Ze = Ce.current) === null || Ze === void 0 ? void 0 : Ze.getPopupElement()];
  }, yt, He, !!ze);
  var Br = O.useMemo(function() {
    return ie(ie({}, e), {}, {
      notFoundContent: p,
      open: Le,
      triggerOpen: yt,
      id: r,
      showSearch: ce,
      multiple: de,
      toggleOpen: He
    });
  }, [e, p, yt, Le, r, ce, de, He]), gr = !!k || b, Er;
  gr && (Er = /* @__PURE__ */ O.createElement(Vg, {
    className: se("".concat(i, "-arrow"), re({}, "".concat(i, "-arrow-loading"), b)),
    customizeIcon: k,
    customizeIconProps: {
      loading: b,
      searchValue: Ge,
      open: Le,
      focused: qe,
      showSearch: ce
    }
  }));
  var jr = function() {
    var Ye;
    g == null || g(), (Ye = ge.current) === null || Ye === void 0 || Ye.focus(), d([], {
      type: "clear",
      values: c
    }), vt("", !1, !1);
  }, zr = Xj(i, jr, c, I, P, v, Ge, m), zi = zr.allowClear, Mo = zr.clearIcon, fi = /* @__PURE__ */ O.createElement(L, {
    ref: ve
  }), Ei = se(i, o, re(re(re(re(re(re(re(re(re(re({}, "".concat(i, "-focused"), qe), "".concat(i, "-multiple"), de), "".concat(i, "-single"), !de), "".concat(i, "-allow-clear"), I), "".concat(i, "-show-arrow"), gr), "".concat(i, "-disabled"), v), "".concat(i, "-loading"), b), "".concat(i, "-open"), Le), "".concat(i, "-customize-input"), $e), "".concat(i, "-show-search"), ce)), Zr = /* @__PURE__ */ O.createElement(BT, {
    ref: Ce,
    disabled: v,
    prefixCls: i,
    visible: yt,
    popupElement: fi,
    animation: N,
    transitionName: F,
    dropdownStyle: B,
    dropdownClassName: j,
    direction: l,
    dropdownMatchSelectWidth: z,
    dropdownRender: H,
    dropdownAlign: W,
    placement: G,
    builtinPlacements: K,
    getPopupContainer: Y,
    empty: f,
    getTriggerDOMNode: function() {
      return oe.current;
    },
    onPopupVisibleChange: Qr,
    onPopupMouseEnter: Fr
  }, ze ? /* @__PURE__ */ O.cloneElement(ze, {
    ref: at
  }) : /* @__PURE__ */ O.createElement(PT, we({}, e, {
    domRef: oe,
    prefixCls: i,
    inputElement: $e,
    ref: ge,
    id: r,
    showSearch: ce,
    autoClearSearchValue: T,
    mode: m,
    activeDescendantId: M,
    tagRender: a,
    values: c,
    open: Le,
    onToggleOpen: He,
    activeValue: A,
    searchValue: Ge,
    onSearch: vt,
    onSearchSubmit: ee,
    onRemove: Ae,
    tokenWithEnter: Je
  }))), hi;
  return ze ? hi = Zr : hi = /* @__PURE__ */ O.createElement("div", we({
    className: Ei
  }, pe, {
    ref: Ue,
    onMouseDown: vn,
    onKeyDown: et,
    onKeyUp: Ie,
    onFocus: dt,
    onBlur: Tt
  }), qe && !Le && /* @__PURE__ */ O.createElement("span", {
    "aria-live": "polite",
    style: {
      width: 0,
      height: 0,
      position: "absolute",
      overflow: "hidden",
      opacity: 0
    }
  }, "".concat(c.map(function(Ze) {
    var Ye = Ze.label, Dt = Ze.value;
    return ["number", "string"].includes(wt(Ye)) ? Ye : Dt;
  }).join(", "))), Zr, Er, zi && Mo), /* @__PURE__ */ O.createElement(DT.Provider, {
    value: Br
  }, hi);
});
process.env.NODE_ENV !== "production" && (s1.displayName = "BaseSelect");
var a1 = function() {
  return null;
};
a1.isSelectOptGroup = !0;
var l1 = function() {
  return null;
};
l1.isSelectOption = !0;
var zT = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.height, r = e.offsetY, i = e.offsetX, o = e.children, s = e.prefixCls, a = e.onInnerResize, l = e.innerProps, u = e.rtl, c = e.extra, d = {}, f = {
    display: "flex",
    flexDirection: "column"
  };
  return r !== void 0 && (d = {
    height: n,
    position: "relative",
    overflow: "hidden"
  }, f = ie(ie({}, f), {}, re(re(re(re(re({
    transform: "translateY(".concat(r, "px)")
  }, u ? "marginRight" : "marginLeft", -i), "position", "absolute"), "left", 0), "right", 0), "top", 0))), /* @__PURE__ */ O.createElement("div", {
    style: d
  }, /* @__PURE__ */ O.createElement(Ci, {
    onResize: function(p) {
      var g = p.offsetHeight;
      g && a && a();
    }
  }, /* @__PURE__ */ O.createElement("div", we({
    style: f,
    className: se(re({}, "".concat(s, "-holder-inner"), s)),
    ref: t
  }, l), o, c)));
});
zT.displayName = "Filler";
function Zx(e, t) {
  var n = "touches" in e ? e.touches[0] : e;
  return n[t ? "pageX" : "pageY"];
}
var Ab = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.prefixCls, r = e.rtl, i = e.scrollOffset, o = e.scrollRange, s = e.onStartMove, a = e.onStopMove, l = e.onScroll, u = e.horizontal, c = e.spinSize, d = e.containerSize, f = e.style, h = e.thumbStyle, p = O.useState(!1), g = ae(p, 2), m = g[0], v = g[1], b = O.useState(null), x = ae(b, 2), w = x[0], C = x[1], y = O.useState(null), S = ae(y, 2), A = S[0], $ = S[1], M = !r, _ = O.useRef(), T = O.useRef(), D = O.useState(!1), E = ae(D, 2), R = E[0], I = E[1], k = O.useRef(), P = function() {
    clearTimeout(k.current), I(!0), k.current = setTimeout(function() {
      I(!1);
    }, 3e3);
  }, L = o - d || 0, N = d - c || 0, F = O.useMemo(function() {
    if (i === 0 || L === 0)
      return 0;
    var X = i / L;
    return X * N;
  }, [i, L, N]), B = function(Z) {
    Z.stopPropagation(), Z.preventDefault();
  }, j = O.useRef({
    top: F,
    dragging: m,
    pageY: w,
    startTop: A
  });
  j.current = {
    top: F,
    dragging: m,
    pageY: w,
    startTop: A
  };
  var z = function(Z) {
    v(!0), C(Zx(Z, u)), $(j.current.top), s(), Z.stopPropagation(), Z.preventDefault();
  };
  O.useEffect(function() {
    var X = function(q) {
      q.preventDefault();
    }, Z = _.current, Q = T.current;
    return Z.addEventListener("touchstart", X), Q.addEventListener("touchstart", z), function() {
      Z.removeEventListener("touchstart", X), Q.removeEventListener("touchstart", z);
    };
  }, []);
  var H = O.useRef();
  H.current = L;
  var W = O.useRef();
  W.current = N, O.useEffect(function() {
    if (m) {
      var X, Z = function(q) {
        var te = j.current, fe = te.dragging, Se = te.pageY, de = te.startTop;
        if (rn.cancel(X), fe) {
          var ce = Zx(q, u) - Se, pe = de;
          !M && u ? pe -= ce : pe += ce;
          var Oe = H.current, Re = W.current, De = Re ? pe / Re : 0, Me = Math.ceil(De * Oe);
          Me = Math.max(Me, 0), Me = Math.min(Me, Oe), X = rn(function() {
            l(Me, u);
          });
        }
      }, Q = function() {
        v(!1), a();
      };
      return window.addEventListener("mousemove", Z), window.addEventListener("touchmove", Z), window.addEventListener("mouseup", Q), window.addEventListener("touchend", Q), function() {
        window.removeEventListener("mousemove", Z), window.removeEventListener("touchmove", Z), window.removeEventListener("mouseup", Q), window.removeEventListener("touchend", Q), rn.cancel(X);
      };
    }
  }, [m]), O.useEffect(function() {
    P();
  }, [i]), O.useImperativeHandle(t, function() {
    return {
      delayHidden: P
    };
  });
  var G = "".concat(n, "-scrollbar"), K = {
    position: "absolute",
    visibility: R ? null : "hidden"
  }, Y = {
    position: "absolute",
    background: "rgba(0, 0, 0, 0.5)",
    borderRadius: 99,
    cursor: "pointer",
    userSelect: "none"
  };
  return u ? (K.height = 8, K.left = 0, K.right = 0, K.bottom = 0, Y.height = "100%", Y.width = c, M ? Y.left = F : Y.right = F) : (K.width = 8, K.top = 0, K.bottom = 0, M ? K.right = 0 : K.left = 0, Y.width = "100%", Y.height = c, Y.top = F), /* @__PURE__ */ O.createElement("div", {
    ref: _,
    className: se(G, re(re(re({}, "".concat(G, "-horizontal"), u), "".concat(G, "-vertical"), !u), "".concat(G, "-visible"), R)),
    style: ie(ie({}, K), f),
    onMouseDown: B,
    onMouseMove: P
  }, /* @__PURE__ */ O.createElement("div", {
    ref: T,
    className: se("".concat(G, "-thumb"), re({}, "".concat(G, "-thumb-moving"), m)),
    style: ie(ie({}, Y), h),
    onMouseDown: z
  }));
});
process.env.NODE_ENV !== "production" && (Ab.displayName = "ScrollBar");
function Nz(e) {
  var t = e.children, n = e.setRef, r = O.useCallback(function(i) {
    n(i);
  }, []);
  return /* @__PURE__ */ O.cloneElement(t, {
    ref: r
  });
}
function Lz(e, t, n, r, i, o, s) {
  var a = s.getKey;
  return e.slice(t, n + 1).map(function(l, u) {
    var c = t + u, d = o(l, c, {
      style: {
        width: r
      }
    }), f = a(l);
    return /* @__PURE__ */ O.createElement(Nz, {
      key: f,
      setRef: function(p) {
        return i(l, p);
      }
    }, d);
  });
}
var Fz = /* @__PURE__ */ function() {
  function e() {
    ci(this, e), re(this, "maps", void 0), re(this, "id", 0), this.maps = /* @__PURE__ */ Object.create(null);
  }
  return ui(e, [{
    key: "set",
    value: function(n, r) {
      this.maps[n] = r, this.id += 1;
    }
  }, {
    key: "get",
    value: function(n) {
      return this.maps[n];
    }
  }]), e;
}();
function Bz(e, t, n) {
  var r = O.useState(0), i = ae(r, 2), o = i[0], s = i[1], a = he(/* @__PURE__ */ new Map()), l = he(new Fz()), u = he();
  function c() {
    rn.cancel(u.current);
  }
  function d() {
    var h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    c();
    var p = function() {
      a.current.forEach(function(m, v) {
        if (m && m.offsetParent) {
          var b = Yu(m), x = b.offsetHeight;
          l.current.get(v) !== x && l.current.set(v, b.offsetHeight);
        }
      }), s(function(m) {
        return m + 1;
      });
    };
    h ? p() : u.current = rn(p);
  }
  function f(h, p) {
    var g = e(h);
    a.current.get(g), p ? (a.current.set(g, p), d()) : a.current.delete(g);
  }
  return Pe(function() {
    return c;
  }, []), [f, d, l.current, o];
}
var Jx = 10;
function jz(e, t, n, r, i, o, s, a) {
  var l = O.useRef(), u = O.useState(null), c = ae(u, 2), d = c[0], f = c[1];
  return sn(function() {
    if (d && d.times < Jx) {
      if (!e.current) {
        f(function(L) {
          return ie({}, L);
        });
        return;
      }
      o();
      var h = d.targetAlign, p = d.originAlign, g = d.index, m = d.offset, v = e.current.clientHeight, b = !1, x = h, w = null;
      if (v) {
        for (var C = h || p, y = 0, S = 0, A = 0, $ = Math.min(t.length - 1, g), M = 0; M <= $; M += 1) {
          var _ = i(t[M]);
          S = y;
          var T = n.get(_);
          A = S + (T === void 0 ? r : T), y = A;
        }
        for (var D = C === "top" ? m : v - m, E = $; E >= 0; E -= 1) {
          var R = i(t[E]), I = n.get(R);
          if (I === void 0) {
            b = !0;
            break;
          }
          if (D -= I, D <= 0)
            break;
        }
        switch (C) {
          case "top":
            w = S - m;
            break;
          case "bottom":
            w = A - v + m;
            break;
          default: {
            var k = e.current.scrollTop, P = k + v;
            S < k ? x = "top" : A > P && (x = "bottom");
          }
        }
        w !== null && s(w), w !== d.lastTop && (b = !0);
      }
      b && f(ie(ie({}, d), {}, {
        times: d.times + 1,
        targetAlign: x,
        lastTop: w
      }));
    } else
      process.env.NODE_ENV !== "production" && (d == null ? void 0 : d.times) === Jx && $t(!1, "Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.");
  }, [d, e.current]), function(h) {
    if (h == null) {
      a();
      return;
    }
    if (rn.cancel(l.current), typeof h == "number")
      s(h);
    else if (h && wt(h) === "object") {
      var p, g = h.align;
      "index" in h ? p = h.index : p = t.findIndex(function(b) {
        return i(b) === h.key;
      });
      var m = h.offset, v = m === void 0 ? 0 : m;
      f({
        times: 0,
        index: p,
        offset: v,
        originAlign: g
      });
    }
  };
}
function zz(e, t, n) {
  var r = e.length, i = t.length, o, s;
  if (r === 0 && i === 0)
    return null;
  r < i ? (o = e, s = t) : (o = t, s = e);
  var a = {
    __EMPTY_ITEM__: !0
  };
  function l(p) {
    return p !== void 0 ? n(p) : a;
  }
  for (var u = null, c = Math.abs(r - i) !== 1, d = 0; d < s.length; d += 1) {
    var f = l(o[d]), h = l(s[d]);
    if (f !== h) {
      u = d, c = c || f !== l(s[d + 1]);
      break;
    }
  }
  return u === null ? null : {
    index: u,
    multiple: c
  };
}
function Hz(e, t, n) {
  var r = O.useState(e), i = ae(r, 2), o = i[0], s = i[1], a = O.useState(null), l = ae(a, 2), u = l[0], c = l[1];
  return O.useEffect(function() {
    var d = zz(o || [], e || [], t);
    (d == null ? void 0 : d.index) !== void 0 && c(e[d.index]), s(e);
  }, [e]), [u];
}
var eE = (typeof navigator > "u" ? "undefined" : wt(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
const HT = function(e, t) {
  var n = he(!1), r = he(null);
  function i() {
    clearTimeout(r.current), n.current = !0, r.current = setTimeout(function() {
      n.current = !1;
    }, 50);
  }
  var o = he({
    top: e,
    bottom: t
  });
  return o.current.top = e, o.current.bottom = t, function(s) {
    var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, l = (
      // Pass origin wheel when on the top
      s < 0 && o.current.top || // Pass origin wheel when on the bottom
      s > 0 && o.current.bottom
    );
    return a && l ? (clearTimeout(r.current), n.current = !1) : (!l || n.current) && i(), !n.current && l;
  };
};
function Vz(e, t, n, r, i) {
  var o = he(0), s = he(null), a = he(null), l = he(!1), u = HT(t, n);
  function c(m, v) {
    rn.cancel(s.current), o.current += v, a.current = v, !u(v) && (eE || m.preventDefault(), s.current = rn(function() {
      var b = l.current ? 10 : 1;
      i(o.current * b), o.current = 0;
    }));
  }
  function d(m, v) {
    i(v, !0), eE || m.preventDefault();
  }
  var f = he(null), h = he(null);
  function p(m) {
    if (e) {
      rn.cancel(h.current), h.current = rn(function() {
        f.current = null;
      }, 2);
      var v = m.deltaX, b = m.deltaY, x = m.shiftKey, w = v, C = b;
      (f.current === "sx" || !f.current && x && b && !v) && (w = b, C = 0, f.current = "sx");
      var y = Math.abs(w), S = Math.abs(C);
      f.current === null && (f.current = r && y > S ? "x" : "y"), f.current === "y" ? c(m, C) : d(m, w);
    }
  }
  function g(m) {
    e && (l.current = m.detail === a.current);
  }
  return [p, g];
}
var Wz = 14 / 15;
function Uz(e, t, n) {
  var r = he(!1), i = he(0), o = he(null), s = he(null), a, l = function(f) {
    if (r.current) {
      var h = Math.ceil(f.touches[0].pageY), p = i.current - h;
      i.current = h, n(p) && f.preventDefault(), clearInterval(s.current), s.current = setInterval(function() {
        p *= Wz, (!n(p, !0) || Math.abs(p) <= 0.1) && clearInterval(s.current);
      }, 16);
    }
  }, u = function() {
    r.current = !1, a();
  }, c = function(f) {
    a(), f.touches.length === 1 && !r.current && (r.current = !0, i.current = Math.ceil(f.touches[0].pageY), o.current = f.target, o.current.addEventListener("touchmove", l), o.current.addEventListener("touchend", u));
  };
  a = function() {
    o.current && (o.current.removeEventListener("touchmove", l), o.current.removeEventListener("touchend", u));
  }, sn(function() {
    return e && t.current.addEventListener("touchstart", c), function() {
      var d;
      (d = t.current) === null || d === void 0 || d.removeEventListener("touchstart", c), a(), clearInterval(s.current);
    };
  }, [e]);
}
var Gz = 20;
function tE() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = e / t * e;
  return isNaN(n) && (n = 0), n = Math.max(n, Gz), Math.floor(n);
}
function Kz(e, t, n, r) {
  var i = O.useMemo(function() {
    return [/* @__PURE__ */ new Map(), []];
  }, [e, n.id, r]), o = ae(i, 2), s = o[0], a = o[1], l = function(c) {
    var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c, f = s.get(c), h = s.get(d);
    if (f === void 0 || h === void 0)
      for (var p = e.length, g = a.length; g < p; g += 1) {
        var m, v = e[g], b = t(v);
        s.set(b, g);
        var x = (m = n.get(b)) !== null && m !== void 0 ? m : r;
        if (a[g] = (a[g - 1] || 0) + x, b === c && (f = g), b === d && (h = g), f !== void 0 && h !== void 0)
          break;
      }
    return {
      top: a[f - 1] || 0,
      bottom: a[h]
    };
  };
  return l;
}
var Xz = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "direction", "scrollWidth", "component", "onScroll", "onVirtualScroll", "onVisibleChange", "innerProps", "extraRender", "styles"], Yz = [], qz = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function Qz(e, t) {
  var n = e.prefixCls, r = n === void 0 ? "rc-virtual-list" : n, i = e.className, o = e.height, s = e.itemHeight, a = e.fullHeight, l = a === void 0 ? !0 : a, u = e.style, c = e.data, d = e.children, f = e.itemKey, h = e.virtual, p = e.direction, g = e.scrollWidth, m = e.component, v = m === void 0 ? "div" : m, b = e.onScroll, x = e.onVirtualScroll, w = e.onVisibleChange, C = e.innerProps, y = e.extraRender, S = e.styles, A = Rt(e, Xz), $ = O.useCallback(function(Ie) {
    return typeof f == "function" ? f(Ie) : Ie == null ? void 0 : Ie[f];
  }, [f]), M = Bz($), _ = ae(M, 4), T = _[0], D = _[1], E = _[2], R = _[3], I = !!(h !== !1 && o && s), k = O.useMemo(function() {
    return Object.values(E.maps).reduce(function(Ie, Ae) {
      return Ie + Ae;
    }, 0);
  }, [E.id, E.maps]), P = I && c && (Math.max(s * c.length, k) > o || !!g), L = p === "rtl", N = se(r, re({}, "".concat(r, "-rtl"), L), i), F = c || Yz, B = he(), j = he(), z = ht(0), H = ae(z, 2), W = H[0], G = H[1], K = ht(0), Y = ae(K, 2), X = Y[0], Z = Y[1], Q = ht(!1), ne = ae(Q, 2), q = ne[0], te = ne[1], fe = function() {
    te(!0);
  }, Se = function() {
    te(!1);
  }, de = {
    getKey: $
  };
  function ce(Ie) {
    G(function(Ae) {
      var tt;
      typeof Ie == "function" ? tt = Ie(Ae) : tt = Ie;
      var dt = jt(tt);
      return B.current.scrollTop = dt, dt;
    });
  }
  var pe = he({
    start: 0,
    end: F.length
  }), Oe = he(), Re = Hz(F, $), De = ae(Re, 1), Me = De[0];
  Oe.current = Me;
  var Ue = O.useMemo(function() {
    if (!I)
      return {
        scrollHeight: void 0,
        start: 0,
        end: F.length - 1,
        offset: void 0
      };
    if (!P) {
      var Ie;
      return {
        scrollHeight: ((Ie = j.current) === null || Ie === void 0 ? void 0 : Ie.offsetHeight) || 0,
        start: 0,
        end: F.length - 1,
        offset: void 0
      };
    }
    for (var Ae = 0, tt, dt, Tt, Ct = F.length, vn = 0; vn < Ct; vn += 1) {
      var Hn = F[vn], pn = $(Hn), Qn = E.get(pn), Fr = Ae + (Qn === void 0 ? s : Qn);
      Fr >= W && tt === void 0 && (tt = vn, dt = Ae), Fr > W + o && Tt === void 0 && (Tt = vn), Ae = Fr;
    }
    return tt === void 0 && (tt = 0, dt = 0, Tt = Math.ceil(o / s)), Tt === void 0 && (Tt = F.length - 1), Tt = Math.min(Tt + 1, F.length - 1), {
      scrollHeight: Ae,
      start: tt,
      end: Tt,
      offset: dt
    };
  }, [P, I, W, F, R, o]), oe = Ue.scrollHeight, Ce = Ue.start, ge = Ue.end, ve = Ue.offset;
  pe.current.start = Ce, pe.current.end = ge;
  var me = O.useState({
    width: 0,
    height: o
  }), Fe = ae(me, 2), Be = Fe[0], qe = Fe[1], Ve = function(Ae) {
    qe({
      width: Ae.width || Ae.offsetWidth,
      height: Ae.height || Ae.offsetHeight
    });
  }, We = he(), Ge = he(), $e = O.useMemo(function() {
    return tE(Be.width, g);
  }, [Be.width, g]), ze = O.useMemo(function() {
    return tE(Be.height, oe);
  }, [Be.height, oe]), at = oe - o, xt = he(at);
  xt.current = at;
  function jt(Ie) {
    var Ae = Ie;
    return Number.isNaN(xt.current) || (Ae = Math.min(Ae, xt.current)), Ae = Math.max(Ae, 0), Ae;
  }
  var Lt = W <= 0, At = W >= at, Et = HT(Lt, At), nt = function() {
    return {
      x: L ? -X : X,
      y: W
    };
  }, it = he(nt()), je = Nn(function() {
    if (x) {
      var Ie = nt();
      (it.current.x !== Ie.x || it.current.y !== Ie.y) && (x(Ie), it.current = Ie);
    }
  });
  function Le(Ie, Ae) {
    var tt = Ie;
    Ae ? (Cp(function() {
      Z(tt);
    }), je()) : ce(tt);
  }
  function ot(Ie) {
    var Ae = Ie.currentTarget.scrollTop;
    Ae !== W && ce(Ae), b == null || b(Ie), je();
  }
  var yt = function(Ae) {
    var tt = Ae, dt = g ? g - Be.width : 0;
    return tt = Math.max(tt, 0), tt = Math.min(tt, dt), tt;
  }, He = Nn(function(Ie, Ae) {
    Ae ? (Cp(function() {
      Z(function(tt) {
        var dt = tt + (L ? -Ie : Ie);
        return yt(dt);
      });
    }), je()) : ce(function(tt) {
      var dt = tt + Ie;
      return dt;
    });
  }), Je = Vz(I, Lt, At, !!g, He), Qe = ae(Je, 2), lt = Qe[0], pt = Qe[1];
  Uz(I, B, function(Ie, Ae) {
    return Et(Ie, Ae) ? !1 : (lt({
      preventDefault: function() {
      },
      deltaY: Ie
    }), !0);
  }), sn(function() {
    function Ie(tt) {
      I && tt.preventDefault();
    }
    var Ae = B.current;
    return Ae.addEventListener("wheel", lt), Ae.addEventListener("DOMMouseScroll", pt), Ae.addEventListener("MozMousePixelScroll", Ie), function() {
      Ae.removeEventListener("wheel", lt), Ae.removeEventListener("DOMMouseScroll", pt), Ae.removeEventListener("MozMousePixelScroll", Ie);
    };
  }, [I]), sn(function() {
    g && Z(function(Ie) {
      return yt(Ie);
    });
  }, [Be.width, g]);
  var vt = function() {
    var Ae, tt;
    (Ae = We.current) === null || Ae === void 0 || Ae.delayHidden(), (tt = Ge.current) === null || tt === void 0 || tt.delayHidden();
  }, ee = jz(B, F, E, s, $, function() {
    return D(!0);
  }, ce, vt);
  O.useImperativeHandle(t, function() {
    return {
      getScrollInfo: nt,
      scrollTo: function(Ae) {
        function tt(dt) {
          return dt && wt(dt) === "object" && ("left" in dt || "top" in dt);
        }
        tt(Ae) ? (Ae.left !== void 0 && Z(yt(Ae.left)), ee(Ae.top)) : ee(Ae);
      }
    };
  }), sn(function() {
    if (w) {
      var Ie = F.slice(Ce, ge + 1);
      w(Ie, F);
    }
  }, [Ce, ge, F]);
  var be = Kz(F, $, E, s), Ee = y == null ? void 0 : y({
    start: Ce,
    end: ge,
    virtual: P,
    offsetX: X,
    offsetY: ve,
    rtl: L,
    getSize: be
  }), ye = Lz(F, Ce, ge, g, T, d, de), Ke = null;
  o && (Ke = ie(re({}, l ? "height" : "maxHeight", o), qz), I && (Ke.overflowY = "hidden", g && (Ke.overflowX = "hidden"), q && (Ke.pointerEvents = "none")));
  var et = {};
  return L && (et.dir = "rtl"), /* @__PURE__ */ O.createElement("div", we({
    style: ie(ie({}, u), {}, {
      position: "relative"
    }),
    className: N
  }, et, A), /* @__PURE__ */ O.createElement(Ci, {
    onResize: Ve
  }, /* @__PURE__ */ O.createElement(v, {
    className: "".concat(r, "-holder"),
    style: Ke,
    ref: B,
    onScroll: ot,
    onMouseEnter: vt
  }, /* @__PURE__ */ O.createElement(zT, {
    prefixCls: r,
    height: oe,
    offsetX: X,
    offsetY: ve,
    scrollWidth: g,
    onInnerResize: D,
    ref: j,
    innerProps: C,
    rtl: L,
    extra: Ee
  }, ye))), P && oe > o && /* @__PURE__ */ O.createElement(Ab, {
    ref: We,
    prefixCls: r,
    scrollOffset: W,
    scrollRange: oe,
    rtl: L,
    onScroll: Le,
    onStartMove: fe,
    onStopMove: Se,
    spinSize: ze,
    containerSize: Be.height,
    style: S == null ? void 0 : S.verticalScrollBar,
    thumbStyle: S == null ? void 0 : S.verticalScrollBarThumb
  }), P && g > Be.width && /* @__PURE__ */ O.createElement(Ab, {
    ref: Ge,
    prefixCls: r,
    scrollOffset: X,
    scrollRange: g,
    rtl: L,
    onScroll: Le,
    onStartMove: fe,
    onStopMove: Se,
    spinSize: $e,
    containerSize: Be.width,
    horizontal: !0,
    style: S == null ? void 0 : S.horizontalScrollBar,
    thumbStyle: S == null ? void 0 : S.horizontalScrollBarThumb
  }));
}
var VT = /* @__PURE__ */ O.forwardRef(Qz);
VT.displayName = "List";
function Zz() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
var Jz = ["disabled", "title", "children", "style", "className"];
function nE(e) {
  return typeof e == "string" || typeof e == "number";
}
var eH = function(t, n) {
  var r = _T(), i = r.prefixCls, o = r.id, s = r.open, a = r.multiple, l = r.mode, u = r.searchValue, c = r.toggleOpen, d = r.notFoundContent, f = r.onPopupScroll, h = O.useContext(o1), p = h.maxCount, g = h.flattenOptions, m = h.onActiveValue, v = h.defaultActiveFirstOption, b = h.onSelect, x = h.menuItemSelectedIcon, w = h.rawValues, C = h.fieldNames, y = h.virtual, S = h.direction, A = h.listHeight, $ = h.listItemHeight, M = h.optionRender, _ = "".concat(i, "-item"), T = lf(function() {
    return g;
  }, [s, g], function(X, Z) {
    return Z[0] && X[1] !== Z[1];
  }), D = O.useRef(null), E = O.useMemo(function() {
    return a && $b(p) && (w == null ? void 0 : w.size) >= p;
  }, [a, p, w == null ? void 0 : w.size]), R = function(Z) {
    Z.preventDefault();
  }, I = function(Z) {
    var Q;
    (Q = D.current) === null || Q === void 0 || Q.scrollTo(typeof Z == "number" ? {
      index: Z
    } : Z);
  }, k = function(Z) {
    for (var Q = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, ne = T.length, q = 0; q < ne; q += 1) {
      var te = (Z + q * Q + ne) % ne, fe = T[te] || {}, Se = fe.group, de = fe.data;
      if (!Se && !(de != null && de.disabled) && !E)
        return te;
    }
    return -1;
  }, P = O.useState(function() {
    return k(0);
  }), L = ae(P, 2), N = L[0], F = L[1], B = function(Z) {
    var Q = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    F(Z);
    var ne = {
      source: Q ? "keyboard" : "mouse"
    }, q = T[Z];
    if (!q) {
      m(null, -1, ne);
      return;
    }
    m(q.value, Z, ne);
  };
  Pe(function() {
    B(v !== !1 ? k(0) : -1);
  }, [T.length, u]);
  var j = O.useCallback(function(X) {
    return w.has(X) && l !== "combobox";
  }, [l, _e(w).toString(), w.size]);
  Pe(function() {
    var X = setTimeout(function() {
      if (!a && s && w.size === 1) {
        var Q = Array.from(w)[0], ne = T.findIndex(function(q) {
          var te = q.data;
          return te.value === Q;
        });
        ne !== -1 && (B(ne), I(ne));
      }
    });
    if (s) {
      var Z;
      (Z = D.current) === null || Z === void 0 || Z.scrollTo(void 0);
    }
    return function() {
      return clearTimeout(X);
    };
  }, [s, u]);
  var z = function(Z) {
    Z !== void 0 && b(Z, {
      selected: !w.has(Z)
    }), a || c(!1);
  };
  if (O.useImperativeHandle(n, function() {
    return {
      onKeyDown: function(Z) {
        var Q = Z.which, ne = Z.ctrlKey;
        switch (Q) {
          case xe.N:
          case xe.P:
          case xe.UP:
          case xe.DOWN: {
            var q = 0;
            if (Q === xe.UP ? q = -1 : Q === xe.DOWN ? q = 1 : Zz() && ne && (Q === xe.N ? q = 1 : Q === xe.P && (q = -1)), q !== 0) {
              var te = k(N + q, q);
              I(te), B(te, !0);
            }
            break;
          }
          case xe.ENTER: {
            var fe, Se = T[N];
            Se && !(Se != null && (fe = Se.data) !== null && fe !== void 0 && fe.disabled) && !E ? z(Se.value) : z(void 0), s && Z.preventDefault();
            break;
          }
          case xe.ESC:
            c(!1), s && Z.stopPropagation();
        }
      },
      onKeyUp: function() {
      },
      scrollTo: function(Z) {
        I(Z);
      }
    };
  }), T.length === 0)
    return /* @__PURE__ */ O.createElement("div", {
      role: "listbox",
      id: "".concat(o, "_list"),
      className: "".concat(_, "-empty"),
      onMouseDown: R
    }, d);
  var H = Object.keys(C).map(function(X) {
    return C[X];
  }), W = function(Z) {
    return Z.label;
  };
  function G(X, Z) {
    var Q = X.group;
    return {
      role: Q ? "presentation" : "option",
      id: "".concat(o, "_list_").concat(Z)
    };
  }
  var K = function(Z) {
    var Q = T[Z];
    if (!Q)
      return null;
    var ne = Q.data || {}, q = ne.value, te = Q.group, fe = $s(ne, !0), Se = W(Q);
    return Q ? /* @__PURE__ */ O.createElement("div", we({
      "aria-label": typeof Se == "string" && !te ? Se : null
    }, fe, {
      key: Z
    }, G(Q, Z), {
      "aria-selected": j(q)
    }), q) : null;
  }, Y = {
    role: "listbox",
    id: "".concat(o, "_list")
  };
  return /* @__PURE__ */ O.createElement(O.Fragment, null, y && /* @__PURE__ */ O.createElement("div", we({}, Y, {
    style: {
      height: 0,
      width: 0,
      overflow: "hidden"
    }
  }), K(N - 1), K(N), K(N + 1)), /* @__PURE__ */ O.createElement(VT, {
    itemKey: "key",
    ref: D,
    data: T,
    height: A,
    itemHeight: $,
    fullHeight: !1,
    onMouseDown: R,
    onScroll: f,
    virtual: y,
    direction: S,
    innerProps: y ? null : Y
  }, function(X, Z) {
    var Q = X.group, ne = X.groupOption, q = X.data, te = X.label, fe = X.value, Se = q.key;
    if (Q) {
      var de, ce = (de = q.title) !== null && de !== void 0 ? de : nE(te) ? te.toString() : void 0;
      return /* @__PURE__ */ O.createElement("div", {
        className: se(_, "".concat(_, "-group"), q.className),
        title: ce
      }, te !== void 0 ? te : Se);
    }
    var pe = q.disabled, Oe = q.title;
    q.children;
    var Re = q.style, De = q.className, Me = Rt(q, Jz), Ue = zn(Me, H), oe = j(fe), Ce = pe || !oe && E, ge = "".concat(_, "-option"), ve = se(_, ge, De, re(re(re(re({}, "".concat(ge, "-grouped"), ne), "".concat(ge, "-active"), N === Z && !Ce), "".concat(ge, "-disabled"), Ce), "".concat(ge, "-selected"), oe)), me = W(X), Fe = !x || typeof x == "function" || oe, Be = typeof me == "number" ? me : me || fe, qe = nE(Be) ? Be.toString() : void 0;
    return Oe !== void 0 && (qe = Oe), /* @__PURE__ */ O.createElement("div", we({}, $s(Ue), y ? {} : G(X, Z), {
      "aria-selected": oe,
      className: ve,
      title: qe,
      onMouseMove: function() {
        N === Z || Ce || B(Z);
      },
      onClick: function() {
        Ce || z(fe);
      },
      style: Re
    }), /* @__PURE__ */ O.createElement("div", {
      className: "".concat(ge, "-content")
    }, typeof M == "function" ? M(X, {
      index: Z
    }) : Be), /* @__PURE__ */ O.isValidElement(x) || oe, Fe && /* @__PURE__ */ O.createElement(Vg, {
      className: "".concat(_, "-option-state"),
      customizeIcon: x,
      customizeIconProps: {
        value: fe,
        disabled: Ce,
        isSelected: oe
      }
    }, oe ? "" : null));
  }));
}, WT = /* @__PURE__ */ O.forwardRef(eH);
process.env.NODE_ENV !== "production" && (WT.displayName = "OptionList");
const tH = function(e, t) {
  var n = O.useRef({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  }), r = O.useMemo(function() {
    var o = n.current, s = o.values, a = o.options, l = e.map(function(d) {
      if (d.label === void 0) {
        var f;
        return ie(ie({}, d), {}, {
          label: (f = s.get(d.value)) === null || f === void 0 ? void 0 : f.label
        });
      }
      return d;
    }), u = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map();
    return l.forEach(function(d) {
      u.set(d.value, d), c.set(d.value, t.get(d.value) || a.get(d.value));
    }), n.current.values = u, n.current.options = c, l;
  }, [e, t]), i = O.useCallback(function(o) {
    return t.get(o) || n.current.options.get(o);
  }, [t]);
  return [r, i];
};
function iv(e, t) {
  return i1(e).join("").toUpperCase().includes(t);
}
const nH = function(e, t, n, r, i) {
  return O.useMemo(function() {
    if (!n || r === !1)
      return e;
    var o = t.options, s = t.label, a = t.value, l = [], u = typeof r == "function", c = n.toUpperCase(), d = u ? r : function(h, p) {
      return i ? iv(p[i], c) : p[o] ? iv(p[s !== "children" ? s : "label"], c) : iv(p[a], c);
    }, f = u ? function(h) {
      return Ob(h);
    } : function(h) {
      return h;
    };
    return e.forEach(function(h) {
      if (h[o]) {
        var p = d(n, f(h));
        if (p)
          l.push(h);
        else {
          var g = h[o].filter(function(m) {
            return d(n, f(m));
          });
          g.length && l.push(ie(ie({}, h), {}, re({}, o, g)));
        }
        return;
      }
      d(n, f(h)) && l.push(h);
    }), l;
  }, [e, r, i, n, t]);
};
var rE = 0, rH = process.env.NODE_ENV !== "test" && Ir();
function iH() {
  var e;
  return rH ? (e = rE, rE += 1) : e = "TEST_OR_SSR", e;
}
function UT(e) {
  var t = O.useState(), n = ae(t, 2), r = n[0], i = n[1];
  return O.useEffect(function() {
    i("rc_select_".concat(iH()));
  }, []), e || r;
}
var oH = ["children", "value"], sH = ["children"];
function aH(e) {
  var t = e, n = t.key, r = t.props, i = r.children, o = r.value, s = Rt(r, oH);
  return ie({
    key: n,
    value: o !== void 0 ? o : n,
    children: i
  }, s);
}
function c1(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  return Xr(e).map(function(n, r) {
    if (!/* @__PURE__ */ O.isValidElement(n) || !n.type)
      return null;
    var i = n, o = i.type.isSelectOptGroup, s = i.key, a = i.props, l = a.children, u = Rt(a, sH);
    return t || !o ? aH(n) : ie(ie({
      key: "__RC_SELECT_GRP__".concat(s === null ? r : s, "__"),
      label: s
    }, u), {}, {
      options: c1(l)
    });
  }).filter(function(n) {
    return n;
  });
}
var lH = function(t, n, r, i, o) {
  return O.useMemo(function() {
    var s = t, a = !t;
    a && (s = c1(n));
    var l = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map(), c = function(h, p, g) {
      g && typeof g == "string" && h.set(p[g], p);
    }, d = function f(h) {
      for (var p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, g = 0; g < h.length; g += 1) {
        var m = h[g];
        !m[r.options] || p ? (l.set(m[r.value], m), c(u, m, r.label), c(u, m, i), c(u, m, o)) : f(m[r.options], !0);
      }
    };
    return d(s), {
      options: s,
      valueOptions: l,
      labelOptions: u
    };
  }, [t, n, r, i, o]);
};
function iE(e) {
  var t = O.useRef();
  t.current = e;
  var n = O.useCallback(function() {
    return t.current.apply(t, arguments);
  }, []);
  return n;
}
function cH(e) {
  var t = e.mode, n = e.options, r = e.children, i = e.backfill, o = e.allowClear, s = e.placeholder, a = e.getInputElement, l = e.showSearch, u = e.onSearch, c = e.defaultOpen, d = e.autoFocus, f = e.labelInValue, h = e.value, p = e.inputValue, g = e.optionLabelProp, m = Mp(t), v = l !== void 0 ? l : m || t === "combobox", b = n || c1(r);
  if ($t(t !== "tags" || b.every(function(y) {
    return !y.disabled;
  }), "Please avoid setting option to disabled in tags mode since user can always type text as tag."), t === "tags" || t === "combobox") {
    var x = b.some(function(y) {
      return y.options ? y.options.some(function(S) {
        return typeof ("value" in S ? S.value : S.key) == "number";
      }) : typeof ("value" in y ? y.value : y.key) == "number";
    });
    $t(!x, "`value` of Option should not use number type when `mode` is `tags` or `combobox`.");
  }
  if ($t(t !== "combobox" || !g, "`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly."), $t(t === "combobox" || !i, "`backfill` only works with `combobox` mode."), $t(t === "combobox" || !a, "`getInputElement` only work with `combobox` mode."), N0(t !== "combobox" || !a || !o || !s, "Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`."), u && !v && t !== "combobox" && t !== "tags" && $t(!1, "`onSearch` should work with `showSearch` instead of use alone."), N0(!c || d, "`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autoFocus` if needed."), h != null) {
    var w = i1(h);
    $t(!f || w.every(function(y) {
      return wt(y) === "object" && ("key" in y || "value" in y);
    }), "`value` should in shape of `{ value: string | number, label?: ReactNode }` when you set `labelInValue` to `true`"), $t(!m || Array.isArray(h), "`value` should be array when `mode` is `multiple` or `tags`");
  }
  if (r) {
    var C = null;
    Xr(r).some(function(y) {
      if (!/* @__PURE__ */ O.isValidElement(y) || !y.type)
        return !1;
      var S = y, A = S.type;
      if (A.isSelectOption)
        return !1;
      if (A.isSelectOptGroup) {
        var $ = Xr(y.props.children).every(function(M) {
          return !/* @__PURE__ */ O.isValidElement(M) || !y.type || M.type.isSelectOption ? !0 : (C = M.type, !1);
        });
        return !$;
      }
      return C = A, !0;
    }), C && $t(!1, "`children` should be `Select.Option` or `Select.OptGroup` instead of `".concat(C.displayName || C.name || C, "`.")), $t(p === void 0, "`inputValue` is deprecated, please use `searchValue` instead.");
  }
}
function uH(e, t) {
  if (e) {
    var n = function r(i) {
      for (var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, s = 0; s < i.length; s++) {
        var a = i[s];
        if (a[t == null ? void 0 : t.value] === null)
          return $t(!1, "`value` in Select options should not be `null`."), !0;
        if (!o && Array.isArray(a[t == null ? void 0 : t.options]) && r(a[t == null ? void 0 : t.options], !0))
          break;
      }
    };
    n(e);
  }
}
var dH = ["id", "mode", "prefixCls", "backfill", "fieldNames", "inputValue", "searchValue", "onSearch", "autoClearSearchValue", "onSelect", "onDeselect", "dropdownMatchSelectWidth", "filterOption", "filterSort", "optionFilterProp", "optionLabelProp", "options", "optionRender", "children", "defaultActiveFirstOption", "menuItemSelectedIcon", "virtual", "direction", "listHeight", "listItemHeight", "labelRender", "value", "defaultValue", "labelInValue", "onChange", "maxCount"], fH = ["inputValue"];
function hH(e) {
  return !e || wt(e) !== "object";
}
var GT = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.id, r = e.mode, i = e.prefixCls, o = i === void 0 ? "rc-select" : i, s = e.backfill, a = e.fieldNames, l = e.inputValue, u = e.searchValue, c = e.onSearch, d = e.autoClearSearchValue, f = d === void 0 ? !0 : d, h = e.onSelect, p = e.onDeselect, g = e.dropdownMatchSelectWidth, m = g === void 0 ? !0 : g, v = e.filterOption, b = e.filterSort, x = e.optionFilterProp, w = e.optionLabelProp, C = e.options, y = e.optionRender, S = e.children, A = e.defaultActiveFirstOption, $ = e.menuItemSelectedIcon, M = e.virtual, _ = e.direction, T = e.listHeight, D = T === void 0 ? 200 : T, E = e.listItemHeight, R = E === void 0 ? 20 : E, I = e.labelRender, k = e.value, P = e.defaultValue, L = e.labelInValue, N = e.onChange, F = e.maxCount, B = Rt(e, dH), j = UT(n), z = Mp(r), H = !!(!C && S), W = O.useMemo(function() {
    return v === void 0 && r === "combobox" ? !1 : v;
  }, [v, r]), G = O.useMemo(
    function() {
      return jT(a, H);
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [
      // We stringify fieldNames to avoid unnecessary re-renders.
      JSON.stringify(a),
      H
    ]
    /* eslint-enable react-hooks/exhaustive-deps */
  ), K = Un("", {
    value: u !== void 0 ? u : l,
    postState: function(Je) {
      return Je || "";
    }
  }), Y = ae(K, 2), X = Y[0], Z = Y[1], Q = lH(C, S, G, x, w), ne = Q.valueOptions, q = Q.labelOptions, te = Q.options, fe = O.useCallback(function(He) {
    var Je = i1(He);
    return Je.map(function(Qe) {
      var lt, pt, vt, ee, be;
      if (hH(Qe))
        lt = Qe;
      else {
        var Ee;
        vt = Qe.key, pt = Qe.label, lt = (Ee = Qe.value) !== null && Ee !== void 0 ? Ee : vt;
      }
      var ye = ne.get(lt);
      if (ye) {
        var Ke;
        if (pt === void 0 && (pt = ye == null ? void 0 : ye[w || G.label]), vt === void 0 && (vt = (Ke = ye == null ? void 0 : ye.key) !== null && Ke !== void 0 ? Ke : lt), ee = ye == null ? void 0 : ye.disabled, be = ye == null ? void 0 : ye.title, process.env.NODE_ENV !== "production" && !w) {
          var et = ye == null ? void 0 : ye[G.label];
          et !== void 0 && !/* @__PURE__ */ O.isValidElement(et) && !/* @__PURE__ */ O.isValidElement(pt) && et !== pt && $t(!1, "`label` of `value` is not same as `label` in Select options.");
        }
      }
      return {
        label: pt,
        value: lt,
        key: vt,
        disabled: ee,
        title: be
      };
    });
  }, [G, w, ne]), Se = Un(P, {
    value: k
  }), de = ae(Se, 2), ce = de[0], pe = de[1], Oe = O.useMemo(function() {
    var He, Je = z && ce === null ? [] : ce, Qe = fe(Je);
    return r === "combobox" && hz((He = Qe[0]) === null || He === void 0 ? void 0 : He.value) ? [] : Qe;
  }, [ce, fe, r, z]), Re = tH(Oe, ne), De = ae(Re, 2), Me = De[0], Ue = De[1], oe = O.useMemo(function() {
    if (!r && Me.length === 1) {
      var He = Me[0];
      if (He.value === null && (He.label === null || He.label === void 0))
        return [];
    }
    return Me.map(function(Je) {
      var Qe;
      return ie(ie({}, Je), {}, {
        label: (Qe = typeof I == "function" ? I(Je) : Je.label) !== null && Qe !== void 0 ? Qe : Je.value
      });
    });
  }, [r, Me, I]), Ce = O.useMemo(function() {
    return new Set(Me.map(function(He) {
      return He.value;
    }));
  }, [Me]);
  O.useEffect(function() {
    if (r === "combobox") {
      var He, Je = (He = Me[0]) === null || He === void 0 ? void 0 : He.value;
      Z(fz(Je) ? String(Je) : "");
    }
  }, [Me]);
  var ge = iE(function(He, Je) {
    var Qe = Je ?? He;
    return re(re({}, G.value, He), G.label, Qe);
  }), ve = O.useMemo(function() {
    if (r !== "tags")
      return te;
    var He = _e(te), Je = function(lt) {
      return ne.has(lt);
    };
    return _e(Me).sort(function(Qe, lt) {
      return Qe.value < lt.value ? -1 : 1;
    }).forEach(function(Qe) {
      var lt = Qe.value;
      Je(lt) || He.push(ge(lt, Qe.label));
    }), He;
  }, [ge, te, ne, Me, r]), me = nH(ve, G, X, W, x), Fe = O.useMemo(function() {
    return r !== "tags" || !X || me.some(function(He) {
      return He[x || "value"] === X;
    }) || me.some(function(He) {
      return He[G.value] === X;
    }) ? me : [ge(X)].concat(_e(me));
  }, [ge, x, r, me, X, G]), Be = O.useMemo(function() {
    return b ? _e(Fe).sort(function(He, Je) {
      return b(He, Je);
    }) : Fe;
  }, [Fe, b]), qe = O.useMemo(function() {
    return Mz(Be, {
      fieldNames: G,
      childrenAsData: H
    });
  }, [Be, G, H]), Ve = function(Je) {
    var Qe = fe(Je);
    if (pe(Qe), N && // Trigger event only when value changed
    (Qe.length !== Me.length || Qe.some(function(vt, ee) {
      var be;
      return ((be = Me[ee]) === null || be === void 0 ? void 0 : be.value) !== (vt == null ? void 0 : vt.value);
    }))) {
      var lt = L ? Qe : Qe.map(function(vt) {
        return vt.value;
      }), pt = Qe.map(function(vt) {
        return Ob(Ue(vt.value));
      });
      N(
        // Value
        z ? lt : lt[0],
        // Option
        z ? pt : pt[0]
      );
    }
  }, We = O.useState(null), Ge = ae(We, 2), $e = Ge[0], ze = Ge[1], at = O.useState(0), xt = ae(at, 2), jt = xt[0], Lt = xt[1], At = A !== void 0 ? A : r !== "combobox", Et = O.useCallback(function(He, Je) {
    var Qe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, lt = Qe.source, pt = lt === void 0 ? "keyboard" : lt;
    Lt(Je), s && r === "combobox" && He !== null && pt === "keyboard" && ze(String(He));
  }, [s, r]), nt = function(Je, Qe, lt) {
    var pt = function() {
      var tt, dt = Ue(Je);
      return [L ? {
        label: dt == null ? void 0 : dt[G.label],
        value: Je,
        key: (tt = dt == null ? void 0 : dt.key) !== null && tt !== void 0 ? tt : Je
      } : Je, Ob(dt)];
    };
    if (Qe && h) {
      var vt = pt(), ee = ae(vt, 2), be = ee[0], Ee = ee[1];
      h(be, Ee);
    } else if (!Qe && p && lt !== "clear") {
      var ye = pt(), Ke = ae(ye, 2), et = Ke[0], Ie = Ke[1];
      p(et, Ie);
    }
  }, it = iE(function(He, Je) {
    var Qe, lt = z ? Je.selected : !0;
    lt ? Qe = z ? [].concat(_e(Me), [He]) : [He] : Qe = Me.filter(function(pt) {
      return pt.value !== He;
    }), Ve(Qe), nt(He, lt), r === "combobox" ? ze("") : (!Mp || f) && (Z(""), ze(""));
  }), je = function(Je, Qe) {
    Ve(Je);
    var lt = Qe.type, pt = Qe.values;
    (lt === "remove" || lt === "clear") && pt.forEach(function(vt) {
      nt(vt.value, !1, lt);
    });
  }, Le = function(Je, Qe) {
    if (Z(Je), ze(null), Qe.source === "submit") {
      var lt = (Je || "").trim();
      if (lt) {
        var pt = Array.from(new Set([].concat(_e(Ce), [lt])));
        Ve(pt), nt(lt, !0), Z("");
      }
      return;
    }
    Qe.source !== "blur" && (r === "combobox" && Ve(Je), c == null || c(Je));
  }, ot = function(Je) {
    var Qe = Je;
    r !== "tags" && (Qe = Je.map(function(pt) {
      var vt = q.get(pt);
      return vt == null ? void 0 : vt.value;
    }).filter(function(pt) {
      return pt !== void 0;
    }));
    var lt = Array.from(new Set([].concat(_e(Ce), _e(Qe))));
    Ve(lt), lt.forEach(function(pt) {
      nt(pt, !0);
    });
  }, yt = O.useMemo(function() {
    var He = M !== !1 && m !== !1;
    return ie(ie({}, Q), {}, {
      flattenOptions: qe,
      onActiveValue: Et,
      defaultActiveFirstOption: At,
      onSelect: it,
      menuItemSelectedIcon: $,
      rawValues: Ce,
      fieldNames: G,
      virtual: He,
      direction: _,
      listHeight: D,
      listItemHeight: R,
      childrenAsData: H,
      maxCount: F,
      optionRender: y
    });
  }, [F, Q, qe, Et, At, it, $, Ce, G, M, m, _, D, R, H, y]);
  return process.env.NODE_ENV !== "production" && (cH(e), uH(te, G)), /* @__PURE__ */ O.createElement(o1.Provider, {
    value: yt
  }, /* @__PURE__ */ O.createElement(s1, we({}, B, {
    // >>> MISC
    id: j,
    prefixCls: o,
    ref: t,
    omitDomProps: fH,
    mode: r,
    displayValues: oe,
    onDisplayValuesChange: je,
    direction: _,
    searchValue: X,
    onSearch: Le,
    autoClearSearchValue: f,
    onSearchSplit: ot,
    dropdownMatchSelectWidth: m,
    OptionList: WT,
    emptyOptions: !qe.length,
    activeValue: $e,
    activeDescendantId: "".concat(j, "_list_").concat(jt)
  })));
});
process.env.NODE_ENV !== "production" && (GT.displayName = "Select");
var u1 = GT;
u1.Option = l1;
u1.OptGroup = a1;
function $d(e, t, n) {
  return se({
    [`${e}-status-success`]: t === "success",
    [`${e}-status-warning`]: t === "warning",
    [`${e}-status-error`]: t === "error",
    [`${e}-status-validating`]: t === "validating",
    [`${e}-has-feedback`]: n
  });
}
const wf = (e, t) => t || e, KT = () => {
  const [, e] = Sr(), n = new ir(e.colorBgBase).toHsl().l < 0.5 ? {
    opacity: 0.65
  } : {};
  return /* @__PURE__ */ O.createElement("svg", {
    style: n,
    width: "184",
    height: "152",
    viewBox: "0 0 184 152",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ O.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ O.createElement("g", {
    transform: "translate(24 31.67)"
  }, /* @__PURE__ */ O.createElement("ellipse", {
    fillOpacity: ".8",
    fill: "#F5F5F7",
    cx: "67.797",
    cy: "106.89",
    rx: "67.797",
    ry: "12.668"
  }), /* @__PURE__ */ O.createElement("path", {
    d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
    fill: "#AEB8C2"
  }), /* @__PURE__ */ O.createElement("path", {
    d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
    fill: "url(#linearGradient-1)",
    transform: "translate(13.56)"
  }), /* @__PURE__ */ O.createElement("path", {
    d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
    fill: "#F5F5F7"
  }), /* @__PURE__ */ O.createElement("path", {
    d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
    fill: "#DCE0E6"
  })), /* @__PURE__ */ O.createElement("path", {
    d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
    fill: "#DCE0E6"
  }), /* @__PURE__ */ O.createElement("g", {
    transform: "translate(149.65 15.383)",
    fill: "#FFF"
  }, /* @__PURE__ */ O.createElement("ellipse", {
    cx: "20.654",
    cy: "3.167",
    rx: "2.849",
    ry: "2.815"
  }), /* @__PURE__ */ O.createElement("path", {
    d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
  }))));
};
process.env.NODE_ENV !== "production" && (KT.displayName = "EmptyImage");
const XT = () => {
  const [, e] = Sr(), {
    colorFill: t,
    colorFillTertiary: n,
    colorFillQuaternary: r,
    colorBgContainer: i
  } = e, {
    borderColor: o,
    shadowColor: s,
    contentColor: a
  } = mt(() => ({
    borderColor: new ir(t).onBackground(i).toHexShortString(),
    shadowColor: new ir(n).onBackground(i).toHexShortString(),
    contentColor: new ir(r).onBackground(i).toHexShortString()
  }), [t, n, r, i]);
  return /* @__PURE__ */ O.createElement("svg", {
    width: "64",
    height: "41",
    viewBox: "0 0 64 41",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ O.createElement("g", {
    transform: "translate(0 1)",
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ O.createElement("ellipse", {
    fill: s,
    cx: "32",
    cy: "33",
    rx: "32",
    ry: "7"
  }), /* @__PURE__ */ O.createElement("g", {
    fillRule: "nonzero",
    stroke: o
  }, /* @__PURE__ */ O.createElement("path", {
    d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
  }), /* @__PURE__ */ O.createElement("path", {
    d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
    fill: a
  }))));
};
process.env.NODE_ENV !== "production" && (XT.displayName = "SimpleImage");
const pH = (e) => {
  const {
    componentCls: t,
    margin: n,
    marginXS: r,
    marginXL: i,
    fontSize: o,
    lineHeight: s
  } = e;
  return {
    [t]: {
      marginInline: r,
      fontSize: o,
      lineHeight: s,
      textAlign: "center",
      //  &-image hashId
      [`${t}-image`]: {
        height: e.emptyImgHeight,
        marginBottom: r,
        opacity: e.opacityImage,
        img: {
          height: "100%"
        },
        svg: {
          maxWidth: "100%",
          height: "100%",
          margin: "auto"
        }
      },
      [`${t}-description`]: {
        color: e.colorText
      },
      //  &-footer hashId
      [`${t}-footer`]: {
        marginTop: n
      },
      "&-normal": {
        marginBlock: i,
        color: e.colorTextDescription,
        [`${t}-description`]: {
          color: e.colorTextDescription
        },
        [`${t}-image`]: {
          height: e.emptyImgHeightMD
        }
      },
      "&-small": {
        marginBlock: r,
        color: e.colorTextDescription,
        [`${t}-image`]: {
          height: e.emptyImgHeightSM
        }
      }
    }
  };
}, gH = $n("Empty", (e) => {
  const {
    componentCls: t,
    controlHeightLG: n,
    calc: r
  } = e, i = Jt(e, {
    emptyImgCls: `${t}-img`,
    emptyImgHeight: r(n).mul(2.5).equal(),
    emptyImgHeightMD: n,
    emptyImgHeightSM: r(n).mul(0.875).equal()
  });
  return [pH(i)];
});
var mH = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const YT = /* @__PURE__ */ O.createElement(KT, null), qT = /* @__PURE__ */ O.createElement(XT, null), Us = (e) => {
  var {
    className: t,
    rootClassName: n,
    prefixCls: r,
    image: i = YT,
    description: o,
    children: s,
    imageStyle: a,
    style: l
  } = e, u = mH(e, ["className", "rootClassName", "prefixCls", "image", "description", "children", "imageStyle", "style"]);
  const {
    getPrefixCls: c,
    direction: d,
    empty: f
  } = O.useContext(rt), h = c("empty", r), [p, g, m] = gH(h), [v] = ml("Empty"), b = typeof o < "u" ? o : v == null ? void 0 : v.description, x = typeof b == "string" ? b : "empty";
  let w = null;
  return typeof i == "string" ? w = /* @__PURE__ */ O.createElement("img", {
    alt: x,
    src: i
  }) : w = i, p(/* @__PURE__ */ O.createElement("div", Object.assign({
    className: se(g, m, h, f == null ? void 0 : f.className, {
      [`${h}-normal`]: i === qT,
      [`${h}-rtl`]: d === "rtl"
    }, t, n),
    style: Object.assign(Object.assign({}, f == null ? void 0 : f.style), l)
  }, u), /* @__PURE__ */ O.createElement("div", {
    className: `${h}-image`,
    style: a
  }, w), b && /* @__PURE__ */ O.createElement("div", {
    className: `${h}-description`
  }, b), s && /* @__PURE__ */ O.createElement("div", {
    className: `${h}-footer`
  }, s)));
};
Us.PRESENTED_IMAGE_DEFAULT = YT;
Us.PRESENTED_IMAGE_SIMPLE = qT;
process.env.NODE_ENV !== "production" && (Us.displayName = "Empty");
const d1 = (e) => {
  const {
    componentName: t
  } = e, {
    getPrefixCls: n
  } = Yt(rt), r = n("empty");
  switch (t) {
    case "Table":
    case "List":
      return /* @__PURE__ */ U.createElement(Us, {
        image: Us.PRESENTED_IMAGE_SIMPLE
      });
    case "Select":
    case "TreeSelect":
    case "Cascader":
    case "Transfer":
    case "Mentions":
      return /* @__PURE__ */ U.createElement(Us, {
        image: Us.PRESENTED_IMAGE_SIMPLE,
        className: `${r}-small`
      });
    default:
      return /* @__PURE__ */ U.createElement(Us, null);
  }
}, vH = ["outlined", "borderless", "filled"], Ug = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
  const n = Yt(rT);
  let r;
  typeof e < "u" ? r = e : t === !1 ? r = "borderless" : r = n ?? "outlined";
  const i = vH.includes(r);
  return [r, i];
}, bH = (e) => {
  const n = {
    overflow: {
      adjustX: !0,
      adjustY: !0,
      shiftY: !0
    },
    htmlRegion: e === "scroll" ? "scroll" : "visible",
    dynamicInset: !0
  };
  return {
    bottomLeft: Object.assign(Object.assign({}, n), {
      points: ["tl", "bl"],
      offset: [0, 4]
    }),
    bottomRight: Object.assign(Object.assign({}, n), {
      points: ["tr", "br"],
      offset: [0, 4]
    }),
    topLeft: Object.assign(Object.assign({}, n), {
      points: ["bl", "tl"],
      offset: [0, -4]
    }),
    topRight: Object.assign(Object.assign({}, n), {
      points: ["br", "tr"],
      offset: [0, -4]
    })
  };
};
function QT(e, t) {
  return e || bH(t);
}
const oE = (e) => {
  const {
    optionHeight: t,
    optionFontSize: n,
    optionLineHeight: r,
    optionPadding: i
  } = e;
  return {
    position: "relative",
    display: "block",
    minHeight: t,
    padding: i,
    color: e.colorText,
    fontWeight: "normal",
    fontSize: n,
    lineHeight: r,
    boxSizing: "border-box"
  };
}, yH = (e) => {
  const {
    antCls: t,
    componentCls: n
  } = e, r = `${n}-item`, i = `&${t}-slide-up-enter${t}-slide-up-enter-active`, o = `&${t}-slide-up-appear${t}-slide-up-appear-active`, s = `&${t}-slide-up-leave${t}-slide-up-leave-active`, a = `${n}-dropdown-placement-`;
  return [
    {
      [`${n}-dropdown`]: Object.assign(Object.assign({}, Gn(e)), {
        position: "absolute",
        top: -9999,
        zIndex: e.zIndexPopup,
        boxSizing: "border-box",
        padding: e.paddingXXS,
        overflow: "hidden",
        fontSize: e.fontSize,
        // Fix select render lag of long text in chrome
        // https://github.com/ant-design/ant-design/issues/11456
        // https://github.com/ant-design/ant-design/issues/11843
        fontVariant: "initial",
        backgroundColor: e.colorBgElevated,
        borderRadius: e.borderRadiusLG,
        outline: "none",
        boxShadow: e.boxShadowSecondary,
        [`
          ${i}${a}bottomLeft,
          ${o}${a}bottomLeft
        `]: {
          animationName: Xw
        },
        [`
          ${i}${a}topLeft,
          ${o}${a}topLeft,
          ${i}${a}topRight,
          ${o}${a}topRight
        `]: {
          animationName: qw
        },
        [`${s}${a}bottomLeft`]: {
          animationName: Yw
        },
        [`
          ${s}${a}topLeft,
          ${s}${a}topRight
        `]: {
          animationName: Qw
        },
        "&-hidden": {
          display: "none"
        },
        [`${r}`]: Object.assign(Object.assign({}, oE(e)), {
          cursor: "pointer",
          transition: `background ${e.motionDurationSlow} ease`,
          borderRadius: e.borderRadiusSM,
          // =========== Group ============
          "&-group": {
            color: e.colorTextDescription,
            fontSize: e.fontSizeSM,
            cursor: "default"
          },
          // =========== Option ===========
          "&-option": {
            display: "flex",
            "&-content": Object.assign({
              flex: "auto"
            }, la),
            "&-state": {
              flex: "none",
              display: "flex",
              alignItems: "center"
            },
            [`&-active:not(${r}-option-disabled)`]: {
              backgroundColor: e.optionActiveBg
            },
            [`&-selected:not(${r}-option-disabled)`]: {
              color: e.optionSelectedColor,
              fontWeight: e.optionSelectedFontWeight,
              backgroundColor: e.optionSelectedBg,
              [`${r}-option-state`]: {
                color: e.colorPrimary
              },
              [`&:has(+ ${r}-option-selected:not(${r}-option-disabled))`]: {
                borderEndStartRadius: 0,
                borderEndEndRadius: 0,
                [`& + ${r}-option-selected:not(${r}-option-disabled)`]: {
                  borderStartStartRadius: 0,
                  borderStartEndRadius: 0
                }
              }
            },
            "&-disabled": {
              [`&${r}-option-selected`]: {
                backgroundColor: e.colorBgContainerDisabled
              },
              color: e.colorTextDisabled,
              cursor: "not-allowed"
            },
            "&-grouped": {
              paddingInlineStart: e.calc(e.controlPaddingHorizontal).mul(2).equal()
            }
          },
          "&-empty": Object.assign(Object.assign({}, oE(e)), {
            color: e.colorTextDisabled
          })
        }),
        // =========================== RTL ===========================
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Follow code may reuse in other components
    ua(e, "slide-up"),
    ua(e, "slide-down"),
    Tp(e, "move-up"),
    Tp(e, "move-down")
  ];
}, Ip = 2, wH = (e) => {
  const {
    multipleSelectItemHeight: t,
    paddingXXS: n,
    lineWidth: r
  } = e, i = e.max(e.calc(n).sub(r).equal(), 0), o = e.max(e.calc(i).sub(Ip).equal(), 0);
  return {
    basePadding: i,
    containerPadding: o,
    itemHeight: le(t),
    itemLineHeight: le(e.calc(t).sub(e.calc(e.lineWidth).mul(2)).equal())
  };
}, CH = (e) => {
  const {
    multipleSelectItemHeight: t,
    selectHeight: n,
    lineWidth: r
  } = e;
  return e.calc(n).sub(t).div(2).sub(r).equal();
}, SH = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    borderRadiusSM: r,
    motionDurationSlow: i,
    paddingXS: o,
    multipleItemColorDisabled: s,
    multipleItemBorderColorDisabled: a,
    colorIcon: l,
    colorIconHover: u
  } = e;
  return {
    /**
     * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
     * may update to redesign with its align logic.
     */
    // =========================== Overflow ===========================
    [`${t}-selection-overflow`]: {
      position: "relative",
      display: "flex",
      flex: "auto",
      flexWrap: "wrap",
      maxWidth: "100%",
      "&-item": {
        flex: "none",
        alignSelf: "center",
        maxWidth: "100%",
        display: "inline-flex"
      },
      // ======================== Selections ==========================
      [`${t}-selection-item`]: {
        display: "flex",
        alignSelf: "center",
        flex: "none",
        boxSizing: "border-box",
        maxWidth: "100%",
        marginBlock: Ip,
        borderRadius: r,
        cursor: "default",
        transition: `font-size ${i}, line-height ${i}, height ${i}`,
        marginInlineEnd: e.calc(Ip).mul(2).equal(),
        paddingInlineStart: o,
        paddingInlineEnd: e.calc(o).div(2).equal(),
        [`${t}-disabled&`]: {
          color: s,
          borderColor: a,
          cursor: "not-allowed"
        },
        // It's ok not to do this, but 24px makes bottom narrow in view should adjust
        "&-content": {
          display: "inline-block",
          marginInlineEnd: e.calc(o).div(2).equal(),
          overflow: "hidden",
          whiteSpace: "pre",
          // fix whitespace wrapping. custom tags display all whitespace within.
          textOverflow: "ellipsis"
        },
        "&-remove": Object.assign(Object.assign({}, Rg()), {
          display: "inline-flex",
          alignItems: "center",
          color: l,
          fontWeight: "bold",
          fontSize: 10,
          lineHeight: "inherit",
          cursor: "pointer",
          [`> ${n}`]: {
            verticalAlign: "-0.2em"
          },
          "&:hover": {
            color: u
          }
        })
      }
    }
  };
}, xH = (e, t) => {
  const {
    componentCls: n
  } = e, r = `${n}-selection-overflow`, i = e.multipleSelectItemHeight, o = CH(e), s = t ? `${n}-${t}` : "", a = wH(e);
  return {
    [`${n}-multiple${s}`]: Object.assign(Object.assign({}, SH(e)), {
      // ========================= Selector =========================
      [`${n}-selector`]: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        height: "100%",
        // Multiple is little different that horizontal is follow the vertical
        paddingInline: a.basePadding,
        paddingBlock: a.containerPadding,
        borderRadius: e.borderRadius,
        [`${n}-disabled&`]: {
          background: e.multipleSelectorBgDisabled,
          cursor: "not-allowed"
        },
        "&:after": {
          display: "inline-block",
          width: 0,
          margin: `${le(Ip)} 0`,
          lineHeight: le(i),
          visibility: "hidden",
          content: '"\\a0"'
        }
      },
      // ======================== Selections ========================
      [`${n}-selection-item`]: {
        height: a.itemHeight,
        lineHeight: le(a.itemLineHeight)
      },
      // ========================== Input ==========================
      [`${r}-item + ${r}-item`]: {
        [`${n}-selection-search`]: {
          marginInlineStart: 0
        }
      },
      // https://github.com/ant-design/ant-design/issues/44754
      [`${r}-item-suffix`]: {
        height: "100%"
      },
      [`${n}-selection-search`]: {
        display: "inline-flex",
        position: "relative",
        maxWidth: "100%",
        marginInlineStart: e.calc(e.inputPaddingHorizontalBase).sub(o).equal(),
        "\n          &-input,\n          &-mirror\n        ": {
          height: i,
          fontFamily: e.fontFamily,
          lineHeight: le(i),
          transition: `all ${e.motionDurationSlow}`
        },
        "&-input": {
          width: "100%",
          minWidth: 4.1
          // fix search cursor missing
        },
        "&-mirror": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          insetInlineEnd: "auto",
          zIndex: 999,
          whiteSpace: "pre",
          // fix whitespace wrapping caused width calculation bug
          visibility: "hidden"
        }
      },
      // ======================= Placeholder =======================
      [`${n}-selection-placeholder`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: e.inputPaddingHorizontalBase,
        insetInlineEnd: e.inputPaddingHorizontalBase,
        transform: "translateY(-50%)",
        transition: `all ${e.motionDurationSlow}`
      }
    })
  };
};
function ov(e, t) {
  const {
    componentCls: n
  } = e, r = t ? `${n}-${t}` : "", i = {
    [`${n}-multiple${r}`]: {
      fontSize: e.fontSize,
      // ========================= Selector =========================
      [`${n}-selector`]: {
        [`${n}-show-search&`]: {
          cursor: "text"
        }
      },
      [`
        &${n}-show-arrow ${n}-selector,
        &${n}-allow-clear ${n}-selector
      `]: {
        paddingInlineEnd: e.calc(e.fontSizeIcon).add(e.controlPaddingHorizontal).equal()
      }
    }
  };
  return [xH(e, t), i];
}
const EH = (e) => {
  const {
    componentCls: t
  } = e, n = Jt(e, {
    selectHeight: e.controlHeightSM,
    multipleSelectItemHeight: e.multipleItemHeightSM,
    borderRadius: e.borderRadiusSM,
    borderRadiusSM: e.borderRadiusXS
  }), r = Jt(e, {
    fontSize: e.fontSizeLG,
    selectHeight: e.controlHeightLG,
    multipleSelectItemHeight: e.multipleItemHeightLG,
    borderRadius: e.borderRadiusLG,
    borderRadiusSM: e.borderRadius
  });
  return [
    ov(e),
    // ======================== Small ========================
    ov(n, "sm"),
    // Padding
    {
      [`${t}-multiple${t}-sm`]: {
        [`${t}-selection-placeholder`]: {
          insetInline: e.calc(e.controlPaddingHorizontalSM).sub(e.lineWidth).equal()
        },
        // https://github.com/ant-design/ant-design/issues/29559
        [`${t}-selection-search`]: {
          marginInlineStart: 2
          // Magic Number
        }
      }
    },
    // ======================== Large ========================
    ov(r, "lg")
  ];
};
function sv(e, t) {
  const {
    componentCls: n,
    inputPaddingHorizontalBase: r,
    borderRadius: i
  } = e, o = e.calc(e.controlHeight).sub(e.calc(e.lineWidth).mul(2)).equal(), s = t ? `${n}-${t}` : "";
  return {
    [`${n}-single${s}`]: {
      fontSize: e.fontSize,
      height: e.controlHeight,
      // ========================= Selector =========================
      [`${n}-selector`]: Object.assign(Object.assign({}, Gn(e, !0)), {
        display: "flex",
        borderRadius: i,
        [`${n}-selection-search`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: r,
          insetInlineEnd: r,
          bottom: 0,
          "&-input": {
            width: "100%",
            WebkitAppearance: "textfield"
          }
        },
        [`
          ${n}-selection-item,
          ${n}-selection-placeholder
        `]: {
          padding: 0,
          lineHeight: le(o),
          transition: `all ${e.motionDurationSlow}, visibility 0s`,
          alignSelf: "center"
        },
        [`${n}-selection-placeholder`]: {
          transition: "none",
          pointerEvents: "none"
        },
        // For common baseline align
        [[
          "&:after",
          /* For '' value baseline align */
          `${n}-selection-item:empty:after`,
          /* For undefined value baseline align */
          `${n}-selection-placeholder:empty:after`
        ].join(",")]: {
          display: "inline-block",
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        }
      }),
      [`
        &${n}-show-arrow ${n}-selection-item,
        &${n}-show-arrow ${n}-selection-placeholder
      `]: {
        paddingInlineEnd: e.showArrowPaddingInlineEnd
      },
      // Opacity selection if open
      [`&${n}-open ${n}-selection-item`]: {
        color: e.colorTextPlaceholder
      },
      // ========================== Input ==========================
      // We only change the style of non-customize input which is only support by `combobox` mode.
      // Not customize
      [`&:not(${n}-customize-input)`]: {
        [`${n}-selector`]: {
          width: "100%",
          height: "100%",
          padding: `0 ${le(r)}`,
          [`${n}-selection-search-input`]: {
            height: o
          },
          "&:after": {
            lineHeight: le(o)
          }
        }
      },
      [`&${n}-customize-input`]: {
        [`${n}-selector`]: {
          "&:after": {
            display: "none"
          },
          [`${n}-selection-search`]: {
            position: "static",
            width: "100%"
          },
          [`${n}-selection-placeholder`]: {
            position: "absolute",
            insetInlineStart: 0,
            insetInlineEnd: 0,
            padding: `0 ${le(r)}`,
            "&:after": {
              display: "none"
            }
          }
        }
      }
    }
  };
}
function $H(e) {
  const {
    componentCls: t
  } = e, n = e.calc(e.controlPaddingHorizontalSM).sub(e.lineWidth).equal();
  return [
    sv(e),
    // ======================== Small ========================
    // Shared
    sv(Jt(e, {
      controlHeight: e.controlHeightSM,
      borderRadius: e.borderRadiusSM
    }), "sm"),
    // padding
    {
      [`${t}-single${t}-sm`]: {
        [`&:not(${t}-customize-input)`]: {
          [`${t}-selection-search`]: {
            insetInlineStart: n,
            insetInlineEnd: n
          },
          [`${t}-selector`]: {
            padding: `0 ${le(n)}`
          },
          // With arrow should provides `padding-right` to show the arrow
          [`&${t}-show-arrow ${t}-selection-search`]: {
            insetInlineEnd: e.calc(n).add(e.calc(e.fontSize).mul(1.5)).equal()
          },
          [`
            &${t}-show-arrow ${t}-selection-item,
            &${t}-show-arrow ${t}-selection-placeholder
          `]: {
            paddingInlineEnd: e.calc(e.fontSize).mul(1.5).equal()
          }
        }
      }
    },
    // ======================== Large ========================
    // Shared
    sv(Jt(e, {
      controlHeight: e.singleItemHeightLG,
      fontSize: e.fontSizeLG,
      borderRadius: e.borderRadiusLG
    }), "lg")
  ];
}
const OH = (e) => {
  const {
    fontSize: t,
    lineHeight: n,
    controlHeight: r,
    controlHeightSM: i,
    controlHeightLG: o,
    paddingXXS: s,
    controlPaddingHorizontal: a,
    zIndexPopupBase: l,
    colorText: u,
    fontWeightStrong: c,
    controlItemBgActive: d,
    controlItemBgHover: f,
    colorBgContainer: h,
    colorFillSecondary: p,
    colorBgContainerDisabled: g,
    colorTextDisabled: m
  } = e, v = r - s * 2, b = i - s * 2, x = o - s * 2;
  return {
    zIndexPopup: l + 50,
    optionSelectedColor: u,
    optionSelectedFontWeight: c,
    optionSelectedBg: d,
    optionActiveBg: f,
    optionPadding: `${(r - t * n) / 2}px ${a}px`,
    optionFontSize: t,
    optionLineHeight: n,
    optionHeight: r,
    selectorBg: h,
    clearBg: h,
    singleItemHeightLG: o,
    multipleItemBg: p,
    multipleItemBorderColor: "transparent",
    multipleItemHeight: v,
    multipleItemHeightSM: b,
    multipleItemHeightLG: x,
    multipleSelectorBgDisabled: g,
    multipleItemColorDisabled: m,
    multipleItemBorderColorDisabled: "transparent",
    showArrowPaddingInlineEnd: Math.ceil(e.fontSize * 1.25)
  };
}, ZT = (e, t) => {
  const {
    componentCls: n,
    antCls: r,
    controlOutlineWidth: i
  } = e;
  return {
    [`&:not(${n}-customize-input) ${n}-selector`]: {
      border: `${le(e.lineWidth)} ${e.lineType} ${t.borderColor}`,
      background: e.selectorBg
    },
    [`&:not(${n}-disabled):not(${n}-customize-input):not(${r}-pagination-size-changer)`]: {
      [`&:hover ${n}-selector`]: {
        borderColor: t.hoverBorderHover
      },
      [`${n}-focused& ${n}-selector`]: {
        borderColor: t.activeBorderColor,
        boxShadow: `0 0 0 ${le(i)} ${t.activeShadowColor}`,
        outline: 0
      }
    }
  };
}, sE = (e, t) => ({
  [`&${e.componentCls}-status-${t.status}`]: Object.assign({}, ZT(e, t))
}), AH = (e) => ({
  "&-outlined": Object.assign(Object.assign(Object.assign(Object.assign({}, ZT(e, {
    borderColor: e.colorBorder,
    hoverBorderHover: e.colorPrimaryHover,
    activeBorderColor: e.colorPrimary,
    activeShadowColor: e.controlOutline
  })), sE(e, {
    status: "error",
    borderColor: e.colorError,
    hoverBorderHover: e.colorErrorHover,
    activeBorderColor: e.colorError,
    activeShadowColor: e.colorErrorOutline
  })), sE(e, {
    status: "warning",
    borderColor: e.colorWarning,
    hoverBorderHover: e.colorWarningHover,
    activeBorderColor: e.colorWarning,
    activeShadowColor: e.colorWarningOutline
  })), {
    [`&${e.componentCls}-disabled`]: {
      [`&:not(${e.componentCls}-customize-input) ${e.componentCls}-selector`]: {
        background: e.colorBgContainerDisabled,
        color: e.colorTextDisabled
      }
    },
    [`&${e.componentCls}-multiple ${e.componentCls}-selection-item`]: {
      background: e.multipleItemBg,
      border: `${le(e.lineWidth)} ${e.lineType} ${e.multipleItemBorderColor}`
    }
  })
}), JT = (e, t) => {
  const {
    componentCls: n,
    antCls: r
  } = e;
  return {
    [`&:not(${n}-customize-input) ${n}-selector`]: {
      background: t.bg,
      border: `${le(e.lineWidth)} ${e.lineType} transparent`,
      color: t.color
    },
    [`&:not(${n}-disabled):not(${n}-customize-input):not(${r}-pagination-size-changer)`]: {
      [`&:hover ${n}-selector`]: {
        background: t.hoverBg
      },
      [`${n}-focused& ${n}-selector`]: {
        background: e.selectorBg,
        borderColor: t.activeBorderColor,
        outline: 0
      }
    }
  };
}, aE = (e, t) => ({
  [`&${e.componentCls}-status-${t.status}`]: Object.assign({}, JT(e, t))
}), DH = (e) => ({
  "&-filled": Object.assign(Object.assign(Object.assign(Object.assign({}, JT(e, {
    bg: e.colorFillTertiary,
    hoverBg: e.colorFillSecondary,
    activeBorderColor: e.colorPrimary,
    color: e.colorText
  })), aE(e, {
    status: "error",
    bg: e.colorErrorBg,
    hoverBg: e.colorErrorBgHover,
    activeBorderColor: e.colorError,
    color: e.colorError
  })), aE(e, {
    status: "warning",
    bg: e.colorWarningBg,
    hoverBg: e.colorWarningBgHover,
    activeBorderColor: e.colorWarning,
    color: e.colorWarning
  })), {
    [`&${e.componentCls}-disabled`]: {
      [`&:not(${e.componentCls}-customize-input) ${e.componentCls}-selector`]: {
        borderColor: e.colorBorder,
        background: e.colorBgContainerDisabled,
        color: e.colorTextDisabled
      }
    },
    [`&${e.componentCls}-multiple ${e.componentCls}-selection-item`]: {
      background: e.colorBgContainer,
      border: `${le(e.lineWidth)} ${e.lineType} ${e.colorSplit}`
    }
  })
}), _H = (e) => ({
  "&-borderless": {
    [`${e.componentCls}-selector`]: {
      background: "transparent",
      borderColor: "transparent"
    },
    [`&${e.componentCls}-disabled`]: {
      [`&:not(${e.componentCls}-customize-input) ${e.componentCls}-selector`]: {
        color: e.colorTextDisabled
      }
    },
    [`&${e.componentCls}-multiple ${e.componentCls}-selection-item`]: {
      background: e.multipleItemBg,
      border: `${le(e.lineWidth)} ${e.lineType} ${e.multipleItemBorderColor}`
    }
  }
}), TH = (e) => ({
  [e.componentCls]: Object.assign(Object.assign(Object.assign({}, AH(e)), DH(e)), _H(e))
}), RH = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    position: "relative",
    transition: `all ${e.motionDurationMid} ${e.motionEaseInOut}`,
    input: {
      cursor: "pointer"
    },
    [`${t}-show-search&`]: {
      cursor: "text",
      input: {
        cursor: "auto",
        color: "inherit",
        height: "100%"
      }
    },
    [`${t}-disabled&`]: {
      cursor: "not-allowed",
      input: {
        cursor: "not-allowed"
      }
    }
  };
}, MH = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-selection-search-input`]: {
      margin: 0,
      padding: 0,
      background: "transparent",
      border: "none",
      outline: "none",
      appearance: "none",
      fontFamily: "inherit",
      "&::-webkit-search-cancel-button": {
        display: "none",
        "-webkit-appearance": "none"
      }
    }
  };
}, IH = (e) => {
  const {
    antCls: t,
    componentCls: n,
    inputPaddingHorizontalBase: r,
    iconCls: i
  } = e;
  return {
    [n]: Object.assign(Object.assign({}, Gn(e)), {
      position: "relative",
      display: "inline-block",
      cursor: "pointer",
      [`&:not(${n}-customize-input) ${n}-selector`]: Object.assign(Object.assign({}, RH(e)), MH(e)),
      // ======================== Selection ========================
      [`${n}-selection-item`]: Object.assign(Object.assign({
        flex: 1,
        fontWeight: "normal",
        position: "relative",
        userSelect: "none"
      }, la), {
        // https://github.com/ant-design/ant-design/issues/40421
        [`> ${t}-typography`]: {
          display: "inline"
        }
      }),
      // ======================= Placeholder =======================
      [`${n}-selection-placeholder`]: Object.assign(Object.assign({}, la), {
        flex: 1,
        color: e.colorTextPlaceholder,
        pointerEvents: "none"
      }),
      // ========================== Arrow ==========================
      [`${n}-arrow`]: Object.assign(Object.assign({}, Rg()), {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: r,
        height: e.fontSizeIcon,
        marginTop: e.calc(e.fontSizeIcon).mul(-1).div(2).equal(),
        color: e.colorTextQuaternary,
        fontSize: e.fontSizeIcon,
        lineHeight: 1,
        textAlign: "center",
        pointerEvents: "none",
        display: "flex",
        alignItems: "center",
        transition: `opacity ${e.motionDurationSlow} ease`,
        [i]: {
          verticalAlign: "top",
          transition: `transform ${e.motionDurationSlow}`,
          "> svg": {
            verticalAlign: "top"
          },
          [`&:not(${n}-suffix)`]: {
            pointerEvents: "auto"
          }
        },
        [`${n}-disabled &`]: {
          cursor: "not-allowed"
        },
        "> *:not(:last-child)": {
          marginInlineEnd: 8
          // FIXME: magic
        }
      }),
      // ========================== Clear ==========================
      [`${n}-clear`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: r,
        zIndex: 1,
        display: "inline-block",
        width: e.fontSizeIcon,
        height: e.fontSizeIcon,
        marginTop: e.calc(e.fontSizeIcon).mul(-1).div(2).equal(),
        color: e.colorTextQuaternary,
        fontSize: e.fontSizeIcon,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        cursor: "pointer",
        opacity: 0,
        transition: `color ${e.motionDurationMid} ease, opacity ${e.motionDurationSlow} ease`,
        textRendering: "auto",
        "&:before": {
          display: "block"
        },
        "&:hover": {
          color: e.colorTextTertiary
        }
      },
      "&:hover": {
        [`${n}-clear`]: {
          opacity: 1
        },
        // Should use the following selector, but since `:has` has poor compatibility,
        // we use `:not(:last-child)` instead, which may cause some problems in some cases.
        // [`${componentCls}-arrow:has(+ ${componentCls}-clear)`]: {
        [`${n}-arrow:not(:last-child)`]: {
          opacity: 0
        }
      }
    }),
    // ========================= Feedback ==========================
    [`${n}-has-feedback`]: {
      [`${n}-clear`]: {
        insetInlineEnd: e.calc(r).add(e.fontSize).add(e.paddingXS).equal()
      }
    }
  };
}, kH = (e) => {
  const {
    componentCls: t
  } = e;
  return [
    {
      [t]: {
        // ==================== In Form ====================
        [`&${t}-in-form-item`]: {
          width: "100%"
        }
      }
    },
    // =====================================================
    // ==                       LTR                       ==
    // =====================================================
    // Base
    IH(e),
    // Single
    $H(e),
    // Multiple
    EH(e),
    // Dropdown
    yH(e),
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${t}-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    jg(e, {
      borderElCls: `${t}-selector`,
      focusElCls: `${t}-focused`
    })
  ];
}, eR = $n("Select", (e, t) => {
  let {
    rootPrefixCls: n
  } = t;
  const r = Jt(e, {
    rootPrefixCls: n,
    inputPaddingHorizontalBase: e.calc(e.paddingSM).sub(1).equal(),
    multipleSelectItemHeight: e.multipleItemHeight,
    selectHeight: e.controlHeight
  });
  return [kH(r), TH(r)];
}, OH, {
  unitless: {
    optionLineHeight: !0,
    optionSelectedFontWeight: !0
  }
});
var PH = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, name: "check", theme: "outlined" }, NH = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: PH
  }));
}, f1 = /* @__PURE__ */ O.forwardRef(NH);
process.env.NODE_ENV !== "production" && (f1.displayName = "CheckOutlined");
var LH = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, name: "down", theme: "outlined" }, FH = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: LH
  }));
}, Cf = /* @__PURE__ */ O.forwardRef(FH);
process.env.NODE_ENV !== "production" && (Cf.displayName = "DownOutlined");
var BH = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, name: "search", theme: "outlined" }, jH = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: BH
  }));
}, h1 = /* @__PURE__ */ O.forwardRef(jH);
process.env.NODE_ENV !== "production" && (h1.displayName = "SearchOutlined");
function tR(e) {
  let {
    suffixIcon: t,
    clearIcon: n,
    menuItemSelectedIcon: r,
    removeIcon: i,
    loading: o,
    multiple: s,
    hasFeedback: a,
    prefixCls: l,
    showSuffixIcon: u,
    feedbackIcon: c,
    showArrow: d,
    componentName: f
  } = e;
  process.env.NODE_ENV !== "production" && Zt(f).deprecated(!n, "clearIcon", "allowClear={{ clearIcon: React.ReactNode }}");
  const h = n ?? /* @__PURE__ */ O.createElement(bl, null), p = (b) => t === null && !a && !d ? null : /* @__PURE__ */ O.createElement(O.Fragment, null, u !== !1 && b, a && c);
  let g = null;
  if (t !== void 0)
    g = p(t);
  else if (o)
    g = p(/* @__PURE__ */ O.createElement(wl, {
      spin: !0
    }));
  else {
    const b = `${l}-suffix`;
    g = (x) => {
      let {
        open: w,
        showSearch: C
      } = x;
      return p(w && C ? /* @__PURE__ */ O.createElement(h1, {
        className: b
      }) : /* @__PURE__ */ O.createElement(Cf, {
        className: b
      }));
    };
  }
  let m = null;
  r !== void 0 ? m = r : s ? m = /* @__PURE__ */ O.createElement(f1, null) : m = null;
  let v = null;
  return i !== void 0 ? v = i : v = /* @__PURE__ */ O.createElement(To, null), {
    clearIcon: h,
    suffixIcon: g,
    itemIcon: m,
    removeIcon: v
  };
}
function nR(e, t) {
  return t !== void 0 ? t : e !== null;
}
var zH = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const rR = "SECRET_COMBOBOX_MODE_DO_NOT_USE", iR = (e, t) => {
  var n;
  const {
    prefixCls: r,
    bordered: i,
    className: o,
    rootClassName: s,
    getPopupContainer: a,
    popupClassName: l,
    dropdownClassName: u,
    listHeight: c = 256,
    placement: d,
    listItemHeight: f,
    size: h,
    disabled: p,
    notFoundContent: g,
    status: m,
    builtinPlacements: v,
    dropdownMatchSelectWidth: b,
    popupMatchSelectWidth: x,
    direction: w,
    style: C,
    allowClear: y,
    variant: S,
    dropdownStyle: A,
    transitionName: $,
    tagRender: M,
    maxCount: _
  } = e, T = zH(e, ["prefixCls", "bordered", "className", "rootClassName", "getPopupContainer", "popupClassName", "dropdownClassName", "listHeight", "placement", "listItemHeight", "size", "disabled", "notFoundContent", "status", "builtinPlacements", "dropdownMatchSelectWidth", "popupMatchSelectWidth", "direction", "style", "allowClear", "variant", "dropdownStyle", "transitionName", "tagRender", "maxCount"]), {
    getPopupContainer: D,
    getPrefixCls: E,
    renderEmpty: R,
    direction: I,
    virtual: k,
    popupMatchSelectWidth: P,
    popupOverflow: L,
    select: N
  } = O.useContext(rt), [, F] = Sr(), B = f ?? (F == null ? void 0 : F.controlHeight), j = E("select", r), z = E(), H = w ?? I, {
    compactSize: W,
    compactItemClassnames: G
  } = Jc(j, H), [K, Y] = Ug(S, i), X = Kn(j), [Z, Q, ne] = eR(j, X), q = O.useMemo(() => {
    const {
      mode: $e
    } = e;
    if ($e !== "combobox")
      return $e === rR ? "combobox" : $e;
  }, [e.mode]), te = q === "multiple" || q === "tags", fe = nR(e.suffixIcon, e.showArrow), Se = (n = x ?? b) !== null && n !== void 0 ? n : P, {
    status: de,
    hasFeedback: ce,
    isFormItemInput: pe,
    feedbackIcon: Oe
  } = O.useContext(Yr), Re = wf(de, m);
  let De;
  g !== void 0 ? De = g : q === "combobox" ? De = null : De = (R == null ? void 0 : R("Select")) || /* @__PURE__ */ O.createElement(d1, {
    componentName: "Select"
  });
  const {
    suffixIcon: Me,
    itemIcon: Ue,
    removeIcon: oe,
    clearIcon: Ce
  } = tR(Object.assign(Object.assign({}, T), {
    multiple: te,
    hasFeedback: ce,
    feedbackIcon: Oe,
    showSuffixIcon: fe,
    prefixCls: j,
    componentName: "Select"
  })), ge = y === !0 ? {
    clearIcon: Ce
  } : y, ve = zn(T, ["suffixIcon", "itemIcon"]), me = se(l || u, {
    [`${j}-dropdown-${H}`]: H === "rtl"
  }, s, ne, X, Q), Fe = so(($e) => {
    var ze;
    return (ze = h ?? W) !== null && ze !== void 0 ? ze : $e;
  }), Be = O.useContext(Ko), qe = p ?? Be, Ve = se({
    [`${j}-lg`]: Fe === "large",
    [`${j}-sm`]: Fe === "small",
    [`${j}-rtl`]: H === "rtl",
    [`${j}-${K}`]: Y,
    [`${j}-in-form-item`]: pe
  }, $d(j, Re, ce), G, N == null ? void 0 : N.className, o, s, ne, X, Q), We = O.useMemo(() => d !== void 0 ? d : H === "rtl" ? "bottomRight" : "bottomLeft", [d, H]);
  if (process.env.NODE_ENV !== "production") {
    const $e = Zt("Select");
    $e.deprecated(!u, "dropdownClassName", "popupClassName"), $e.deprecated(b === void 0, "dropdownMatchSelectWidth", "popupMatchSelectWidth"), process.env.NODE_ENV !== "production" && $e(!("showArrow" in e), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null."), $e.deprecated(!("bordered" in e), "bordered", "variant"), process.env.NODE_ENV !== "production" && $e(!(typeof _ < "u" && !te), "usage", "`maxCount` only works with mode `multiple` or `tags`");
  }
  const [Ge] = Zc("SelectLike", A == null ? void 0 : A.zIndex);
  return Z(/* @__PURE__ */ O.createElement(u1, Object.assign({
    ref: t,
    virtual: k,
    showSearch: N == null ? void 0 : N.showSearch
  }, ve, {
    style: Object.assign(Object.assign({}, N == null ? void 0 : N.style), C),
    dropdownMatchSelectWidth: Se,
    transitionName: Xo(z, "slide-up", $),
    builtinPlacements: QT(v, L),
    listHeight: c,
    listItemHeight: B,
    mode: q,
    prefixCls: j,
    placement: We,
    direction: H,
    suffixIcon: Me,
    menuItemSelectedIcon: Ue,
    removeIcon: oe,
    allowClear: ge,
    notFoundContent: De,
    className: Ve,
    getPopupContainer: a || D,
    dropdownClassName: me,
    disabled: qe,
    dropdownStyle: Object.assign(Object.assign({}, A), {
      zIndex: Ge
    }),
    maxCount: te ? _ : void 0,
    tagRender: te ? M : void 0
  })));
};
process.env.NODE_ENV !== "production" && (iR.displayName = "Select");
const Sl = /* @__PURE__ */ O.forwardRef(iR), HH = t1(Sl);
Sl.SECRET_COMBOBOX_MODE_DO_NOT_USE = rR;
Sl.Option = l1;
Sl.OptGroup = a1;
Sl._InternalPanelDoNotUseOrYouWillBeFired = HH;
process.env.NODE_ENV !== "production" && (Sl.displayName = "Select");
const Rc = ["xxl", "xl", "lg", "md", "sm", "xs"], VH = (e) => ({
  xs: `(max-width: ${e.screenXSMax}px)`,
  sm: `(min-width: ${e.screenSM}px)`,
  md: `(min-width: ${e.screenMD}px)`,
  lg: `(min-width: ${e.screenLG}px)`,
  xl: `(min-width: ${e.screenXL}px)`,
  xxl: `(min-width: ${e.screenXXL}px)`
}), WH = (e) => {
  const t = e, n = [].concat(Rc).reverse();
  return n.forEach((r, i) => {
    const o = r.toUpperCase(), s = `screen${o}Min`, a = `screen${o}`;
    if (!(t[s] <= t[a]))
      throw new Error(`${s}<=${a} fails : !(${t[s]}<=${t[a]})`);
    if (i < n.length - 1) {
      const l = `screen${o}Max`;
      if (!(t[a] <= t[l]))
        throw new Error(`${a}<=${l} fails : !(${t[a]}<=${t[l]})`);
      const c = `screen${n[i + 1].toUpperCase()}Min`;
      if (!(t[l] <= t[c]))
        throw new Error(`${l}<=${c} fails : !(${t[l]}<=${t[c]})`);
    }
  }), e;
};
function oR() {
  const [, e] = Sr(), t = VH(WH(e));
  return U.useMemo(() => {
    const n = /* @__PURE__ */ new Map();
    let r = -1, i = {};
    return {
      matchHandlers: {},
      dispatch(o) {
        return i = o, n.forEach((s) => s(i)), n.size >= 1;
      },
      subscribe(o) {
        return n.size || this.register(), r += 1, n.set(r, o), o(i), r;
      },
      unsubscribe(o) {
        n.delete(o), n.size || this.unregister();
      },
      unregister() {
        Object.keys(t).forEach((o) => {
          const s = t[o], a = this.matchHandlers[s];
          a == null || a.mql.removeListener(a == null ? void 0 : a.listener);
        }), n.clear();
      },
      register() {
        Object.keys(t).forEach((o) => {
          const s = t[o], a = (u) => {
            let {
              matches: c
            } = u;
            this.dispatch(Object.assign(Object.assign({}, i), {
              [o]: c
            }));
          }, l = window.matchMedia(s);
          l.addListener(a), this.matchHandlers[s] = {
            mql: l,
            listener: a
          }, a(l);
        });
      },
      responsiveMap: t
    };
  }, [e]);
}
function UH() {
  const [, e] = O.useReducer((t) => t + 1, 0);
  return e;
}
function GH() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
  const t = he({}), n = UH(), r = oR();
  return sn(() => {
    const i = r.subscribe((o) => {
      t.current = o, e && n();
    });
    return () => r.unsubscribe(i);
  }, []), t.current;
}
const Db = /* @__PURE__ */ O.createContext({}), KH = (e) => {
  const {
    antCls: t,
    componentCls: n,
    iconCls: r,
    avatarBg: i,
    avatarColor: o,
    containerSize: s,
    containerSizeLG: a,
    containerSizeSM: l,
    textFontSize: u,
    textFontSizeLG: c,
    textFontSizeSM: d,
    borderRadius: f,
    borderRadiusLG: h,
    borderRadiusSM: p,
    lineWidth: g,
    lineType: m
  } = e, v = (b, x, w) => ({
    width: b,
    height: b,
    borderRadius: "50%",
    [`&${n}-square`]: {
      borderRadius: w
    },
    [`&${n}-icon`]: {
      fontSize: x,
      [`> ${r}`]: {
        margin: 0
      }
    }
  });
  return {
    [n]: Object.assign(Object.assign(Object.assign(Object.assign({}, Gn(e)), {
      position: "relative",
      display: "inline-flex",
      justifyContent: "center",
      alignItems: "center",
      overflow: "hidden",
      color: o,
      whiteSpace: "nowrap",
      textAlign: "center",
      verticalAlign: "middle",
      background: i,
      border: `${le(g)} ${m} transparent`,
      "&-image": {
        background: "transparent"
      },
      [`${t}-image-img`]: {
        display: "block"
      }
    }), v(s, u, f)), {
      "&-lg": Object.assign({}, v(a, c, h)),
      "&-sm": Object.assign({}, v(l, d, p)),
      "> img": {
        display: "block",
        width: "100%",
        height: "100%",
        objectFit: "cover"
      }
    })
  };
}, XH = (e) => {
  const {
    componentCls: t,
    groupBorderColor: n,
    groupOverlapping: r,
    groupSpace: i
  } = e;
  return {
    [`${t}-group`]: {
      display: "inline-flex",
      [`${t}`]: {
        borderColor: n
      },
      "> *:not(:first-child)": {
        marginInlineStart: r
      }
    },
    [`${t}-group-popover`]: {
      [`${t} + ${t}`]: {
        marginInlineStart: i
      }
    }
  };
}, YH = (e) => {
  const {
    controlHeight: t,
    controlHeightLG: n,
    controlHeightSM: r,
    fontSize: i,
    fontSizeLG: o,
    fontSizeXL: s,
    fontSizeHeading3: a,
    marginXS: l,
    marginXXS: u,
    colorBorderBg: c
  } = e;
  return {
    containerSize: t,
    containerSizeLG: n,
    containerSizeSM: r,
    textFontSize: Math.round((o + s) / 2),
    textFontSizeLG: a,
    textFontSizeSM: i,
    groupSpace: u,
    groupOverlapping: -l,
    groupBorderColor: c
  };
}, sR = $n("Avatar", (e) => {
  const {
    colorTextLightSolid: t,
    colorTextPlaceholder: n
  } = e, r = Jt(e, {
    avatarBg: n,
    avatarColor: t
  });
  return [KH(r), XH(r)];
}, YH);
var qH = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const QH = (e, t) => {
  const [n, r] = O.useState(1), [i, o] = O.useState(!1), [s, a] = O.useState(!0), l = O.useRef(null), u = O.useRef(null), c = xi(t, l), {
    getPrefixCls: d,
    avatar: f
  } = O.useContext(rt), h = O.useContext(Db), p = () => {
    if (!u.current || !l.current)
      return;
    const K = u.current.offsetWidth, Y = l.current.offsetWidth;
    if (K !== 0 && Y !== 0) {
      const {
        gap: X = 4
      } = e;
      X * 2 < Y && r(Y - X * 2 < K ? (Y - X * 2) / K : 1);
    }
  };
  O.useEffect(() => {
    o(!0);
  }, []), O.useEffect(() => {
    a(!0), r(1);
  }, [e.src]), O.useEffect(p, [e.gap]);
  const g = () => {
    const {
      onError: K
    } = e;
    (K == null ? void 0 : K()) !== !1 && a(!1);
  }, {
    prefixCls: m,
    shape: v,
    size: b,
    src: x,
    srcSet: w,
    icon: C,
    className: y,
    rootClassName: S,
    alt: A,
    draggable: $,
    children: M,
    crossOrigin: _
  } = e, T = qH(e, ["prefixCls", "shape", "size", "src", "srcSet", "icon", "className", "rootClassName", "alt", "draggable", "children", "crossOrigin"]), D = so((K) => {
    var Y, X;
    return (X = (Y = b ?? (h == null ? void 0 : h.size)) !== null && Y !== void 0 ? Y : K) !== null && X !== void 0 ? X : "default";
  }), E = Object.keys(typeof D == "object" ? D || {} : {}).some((K) => ["xs", "sm", "md", "lg", "xl", "xxl"].includes(K)), R = GH(E), I = O.useMemo(() => {
    if (typeof D != "object")
      return {};
    const K = Rc.find((X) => R[X]), Y = D[K];
    return Y ? {
      width: Y,
      height: Y,
      fontSize: Y && (C || M) ? Y / 2 : 18
    } : {};
  }, [R, D]);
  if (process.env.NODE_ENV !== "production") {
    const K = Zt("Avatar");
    process.env.NODE_ENV !== "production" && K(!(typeof C == "string" && C.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${C}\` at https://ant.design/components/icon`);
  }
  const k = d("avatar", m), P = Kn(k), [L, N, F] = sR(k, P), B = se({
    [`${k}-lg`]: D === "large",
    [`${k}-sm`]: D === "small"
  }), j = /* @__PURE__ */ O.isValidElement(x), z = v || (h == null ? void 0 : h.shape) || "circle", H = se(k, B, f == null ? void 0 : f.className, `${k}-${z}`, {
    [`${k}-image`]: j || x && s,
    [`${k}-icon`]: !!C
  }, F, P, y, S, N), W = typeof D == "number" ? {
    width: D,
    height: D,
    fontSize: C ? D / 2 : 18
  } : {};
  let G;
  if (typeof x == "string" && s)
    G = /* @__PURE__ */ O.createElement("img", {
      src: x,
      draggable: $,
      srcSet: w,
      onError: g,
      alt: A,
      crossOrigin: _
    });
  else if (j)
    G = x;
  else if (C)
    G = C;
  else if (i || n !== 1) {
    const K = `scale(${n})`, Y = {
      msTransform: K,
      WebkitTransform: K,
      transform: K
    };
    G = /* @__PURE__ */ O.createElement(Ci, {
      onResize: p
    }, /* @__PURE__ */ O.createElement("span", {
      className: `${k}-string`,
      ref: u,
      style: Object.assign({}, Y)
    }, M));
  } else
    G = /* @__PURE__ */ O.createElement("span", {
      className: `${k}-string`,
      style: {
        opacity: 0
      },
      ref: u
    }, M);
  return delete T.onError, delete T.gap, L(/* @__PURE__ */ O.createElement("span", Object.assign({}, T, {
    style: Object.assign(Object.assign(Object.assign(Object.assign({}, W), I), f == null ? void 0 : f.style), T.style),
    className: H,
    ref: c
  }), G));
}, p1 = /* @__PURE__ */ O.forwardRef(QH);
process.env.NODE_ENV !== "production" && (p1.displayName = "Avatar");
const Mc = (e) => e ? typeof e == "function" ? e() : e : null;
function g1(e) {
  var t = e.children, n = e.prefixCls, r = e.id, i = e.overlayInnerStyle, o = e.className, s = e.style;
  return /* @__PURE__ */ O.createElement("div", {
    className: se("".concat(n, "-content"), o),
    style: s
  }, /* @__PURE__ */ O.createElement("div", {
    className: "".concat(n, "-inner"),
    id: r,
    role: "tooltip",
    style: i
  }, typeof t == "function" ? t() : t));
}
var Fl = {
  shiftX: 64,
  adjustY: 1
}, Bl = {
  adjustX: 1,
  shiftY: !0
}, Gi = [0, 0], ZH = {
  left: {
    points: ["cr", "cl"],
    overflow: Bl,
    offset: [-4, 0],
    targetOffset: Gi
  },
  right: {
    points: ["cl", "cr"],
    overflow: Bl,
    offset: [4, 0],
    targetOffset: Gi
  },
  top: {
    points: ["bc", "tc"],
    overflow: Fl,
    offset: [0, -4],
    targetOffset: Gi
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: Fl,
    offset: [0, 4],
    targetOffset: Gi
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: Fl,
    offset: [0, -4],
    targetOffset: Gi
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: Bl,
    offset: [-4, 0],
    targetOffset: Gi
  },
  topRight: {
    points: ["br", "tr"],
    overflow: Fl,
    offset: [0, -4],
    targetOffset: Gi
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: Bl,
    offset: [4, 0],
    targetOffset: Gi
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: Fl,
    offset: [0, 4],
    targetOffset: Gi
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: Bl,
    offset: [4, 0],
    targetOffset: Gi
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: Fl,
    offset: [0, 4],
    targetOffset: Gi
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: Bl,
    offset: [-4, 0],
    targetOffset: Gi
  }
}, JH = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"], eV = function(t, n) {
  var r = t.overlayClassName, i = t.trigger, o = i === void 0 ? ["hover"] : i, s = t.mouseEnterDelay, a = s === void 0 ? 0 : s, l = t.mouseLeaveDelay, u = l === void 0 ? 0.1 : l, c = t.overlayStyle, d = t.prefixCls, f = d === void 0 ? "rc-tooltip" : d, h = t.children, p = t.onVisibleChange, g = t.afterVisibleChange, m = t.transitionName, v = t.animation, b = t.motion, x = t.placement, w = x === void 0 ? "right" : x, C = t.align, y = C === void 0 ? {} : C, S = t.destroyTooltipOnHide, A = S === void 0 ? !1 : S, $ = t.defaultVisible, M = t.getTooltipContainer, _ = t.overlayInnerStyle;
  t.arrowContent;
  var T = t.overlay, D = t.id, E = t.showArrow, R = E === void 0 ? !0 : E, I = Rt(t, JH), k = he(null);
  fl(n, function() {
    return k.current;
  });
  var P = ie({}, I);
  "visible" in t && (P.popupVisible = t.visible);
  var L = function() {
    return /* @__PURE__ */ O.createElement(g1, {
      key: "content",
      prefixCls: f,
      id: D,
      overlayInnerStyle: _
    }, T);
  };
  return /* @__PURE__ */ O.createElement(Wg, we({
    popupClassName: r,
    prefixCls: f,
    popup: L,
    action: o,
    builtinPlacements: ZH,
    popupPlacement: w,
    ref: k,
    popupAlign: y,
    getPopupContainer: M,
    onPopupVisibleChange: p,
    afterPopupVisibleChange: g,
    popupTransitionName: m,
    popupAnimation: v,
    popupMotion: b,
    defaultPopupVisible: $,
    autoDestroy: A,
    mouseLeaveDelay: u,
    popupStyle: c,
    mouseEnterDelay: a,
    arrow: R
  }, P), h);
};
const tV = /* @__PURE__ */ li(eV);
function m1(e) {
  const {
    sizePopupArrow: t,
    borderRadiusXS: n,
    borderRadiusOuter: r
  } = e, i = t / 2, o = 0, s = i, a = r * 1 / Math.sqrt(2), l = i - r * (1 - 1 / Math.sqrt(2)), u = i - n * (1 / Math.sqrt(2)), c = r * (Math.sqrt(2) - 1) + n * (1 / Math.sqrt(2)), d = 2 * i - u, f = c, h = 2 * i - a, p = l, g = 2 * i - o, m = s, v = i * Math.sqrt(2) + r * (Math.sqrt(2) - 2), b = r * (Math.sqrt(2) - 1), x = `polygon(${b}px 100%, 50% ${b}px, ${2 * i - b}px 100%, ${b}px 100%)`, w = `path('M ${o} ${s} A ${r} ${r} 0 0 0 ${a} ${l} L ${u} ${c} A ${n} ${n} 0 0 1 ${d} ${f} L ${h} ${p} A ${r} ${r} 0 0 0 ${g} ${m} Z')`;
  return {
    arrowShadowWidth: v,
    arrowPath: w,
    arrowPolygon: x
  };
}
const nV = (e, t, n) => {
  const {
    sizePopupArrow: r,
    arrowPolygon: i,
    arrowPath: o,
    arrowShadowWidth: s,
    borderRadiusXS: a,
    calc: l
  } = e;
  return {
    pointerEvents: "none",
    width: r,
    height: r,
    overflow: "hidden",
    "&::before": {
      position: "absolute",
      bottom: 0,
      insetInlineStart: 0,
      width: r,
      height: l(r).div(2).equal(),
      background: t,
      clipPath: {
        _multi_value_: !0,
        value: [i, o]
      },
      content: '""'
    },
    "&::after": {
      content: '""',
      position: "absolute",
      width: s,
      height: s,
      bottom: 0,
      insetInline: 0,
      margin: "auto",
      borderRadius: {
        _skip_check_: !0,
        value: `0 0 ${le(a)} 0`
      },
      transform: "translateY(50%) rotate(-135deg)",
      boxShadow: n,
      zIndex: 0,
      background: "transparent"
    }
  };
}, aR = 8;
function Gg(e) {
  const {
    contentRadius: t,
    limitVerticalRadius: n
  } = e, r = t > 12 ? t + 2 : 12;
  return {
    arrowOffsetHorizontal: r,
    arrowOffsetVertical: n ? aR : r
  };
}
function Jf(e, t) {
  return e ? t : {};
}
function v1(e, t, n) {
  const {
    componentCls: r,
    boxShadowPopoverArrow: i,
    arrowOffsetVertical: o,
    arrowOffsetHorizontal: s
  } = e, {
    arrowDistance: a = 0,
    arrowPlacement: l = {
      left: !0,
      right: !0,
      top: !0,
      bottom: !0
    }
  } = n || {};
  return {
    [r]: Object.assign(Object.assign(Object.assign(Object.assign({
      // ============================ Basic ============================
      [`${r}-arrow`]: [Object.assign(Object.assign({
        position: "absolute",
        zIndex: 1,
        display: "block"
      }, nV(e, t, i)), {
        "&:before": {
          background: t
        }
      })]
    }, Jf(!!l.top, {
      [[`&-placement-top > ${r}-arrow`, `&-placement-topLeft > ${r}-arrow`, `&-placement-topRight > ${r}-arrow`].join(",")]: {
        bottom: a,
        transform: "translateY(100%) rotate(180deg)"
      },
      [`&-placement-top > ${r}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(100%) rotate(180deg)"
      },
      [`&-placement-topLeft > ${r}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: s
        }
      },
      [`&-placement-topRight > ${r}-arrow`]: {
        right: {
          _skip_check_: !0,
          value: s
        }
      }
    })), Jf(!!l.bottom, {
      [[`&-placement-bottom > ${r}-arrow`, `&-placement-bottomLeft > ${r}-arrow`, `&-placement-bottomRight > ${r}-arrow`].join(",")]: {
        top: a,
        transform: "translateY(-100%)"
      },
      [`&-placement-bottom > ${r}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(-100%)"
      },
      [`&-placement-bottomLeft > ${r}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: s
        }
      },
      [`&-placement-bottomRight > ${r}-arrow`]: {
        right: {
          _skip_check_: !0,
          value: s
        }
      }
    })), Jf(!!l.left, {
      [[`&-placement-left > ${r}-arrow`, `&-placement-leftTop > ${r}-arrow`, `&-placement-leftBottom > ${r}-arrow`].join(",")]: {
        right: {
          _skip_check_: !0,
          value: a
        },
        transform: "translateX(100%) rotate(90deg)"
      },
      [`&-placement-left > ${r}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(100%) rotate(90deg)"
      },
      [`&-placement-leftTop > ${r}-arrow`]: {
        top: o
      },
      [`&-placement-leftBottom > ${r}-arrow`]: {
        bottom: o
      }
    })), Jf(!!l.right, {
      [[`&-placement-right > ${r}-arrow`, `&-placement-rightTop > ${r}-arrow`, `&-placement-rightBottom > ${r}-arrow`].join(",")]: {
        left: {
          _skip_check_: !0,
          value: a
        },
        transform: "translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-right > ${r}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-rightTop > ${r}-arrow`]: {
        top: o
      },
      [`&-placement-rightBottom > ${r}-arrow`]: {
        bottom: o
      }
    }))
  };
}
function rV(e, t, n, r) {
  if (r === !1)
    return {
      adjustX: !1,
      adjustY: !1
    };
  const i = r && typeof r == "object" ? r : {}, o = {};
  switch (e) {
    case "top":
    case "bottom":
      o.shiftX = t.arrowOffsetHorizontal * 2 + n, o.shiftY = !0, o.adjustY = !0;
      break;
    case "left":
    case "right":
      o.shiftY = t.arrowOffsetVertical * 2 + n, o.shiftX = !0, o.adjustX = !0;
      break;
  }
  const s = Object.assign(Object.assign({}, o), i);
  return s.shiftX || (s.adjustX = !0), s.shiftY || (s.adjustY = !0), s;
}
const lE = {
  left: {
    points: ["cr", "cl"]
  },
  right: {
    points: ["cl", "cr"]
  },
  top: {
    points: ["bc", "tc"]
  },
  bottom: {
    points: ["tc", "bc"]
  },
  topLeft: {
    points: ["bl", "tl"]
  },
  leftTop: {
    points: ["tr", "tl"]
  },
  topRight: {
    points: ["br", "tr"]
  },
  rightTop: {
    points: ["tl", "tr"]
  },
  bottomRight: {
    points: ["tr", "br"]
  },
  rightBottom: {
    points: ["bl", "br"]
  },
  bottomLeft: {
    points: ["tl", "bl"]
  },
  leftBottom: {
    points: ["br", "bl"]
  }
}, iV = {
  topLeft: {
    points: ["bl", "tc"]
  },
  leftTop: {
    points: ["tr", "cl"]
  },
  topRight: {
    points: ["br", "tc"]
  },
  rightTop: {
    points: ["tl", "cr"]
  },
  bottomRight: {
    points: ["tr", "bc"]
  },
  rightBottom: {
    points: ["bl", "cr"]
  },
  bottomLeft: {
    points: ["tl", "bc"]
  },
  leftBottom: {
    points: ["br", "cl"]
  }
}, oV = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
function lR(e) {
  const {
    arrowWidth: t,
    autoAdjustOverflow: n,
    arrowPointAtCenter: r,
    offset: i,
    borderRadius: o,
    visibleFirst: s
  } = e, a = t / 2, l = {};
  return Object.keys(lE).forEach((u) => {
    const c = r && iV[u] || lE[u], d = Object.assign(Object.assign({}, c), {
      offset: [0, 0],
      dynamicInset: !0
    });
    switch (l[u] = d, oV.has(u) && (d.autoArrow = !1), u) {
      case "top":
      case "topLeft":
      case "topRight":
        d.offset[1] = -a - i;
        break;
      case "bottom":
      case "bottomLeft":
      case "bottomRight":
        d.offset[1] = a + i;
        break;
      case "left":
      case "leftTop":
      case "leftBottom":
        d.offset[0] = -a - i;
        break;
      case "right":
      case "rightTop":
      case "rightBottom":
        d.offset[0] = a + i;
        break;
    }
    const f = Gg({
      contentRadius: o,
      limitVerticalRadius: !0
    });
    if (r)
      switch (u) {
        case "topLeft":
        case "bottomLeft":
          d.offset[0] = -f.arrowOffsetHorizontal - a;
          break;
        case "topRight":
        case "bottomRight":
          d.offset[0] = f.arrowOffsetHorizontal + a;
          break;
        case "leftTop":
        case "rightTop":
          d.offset[1] = -f.arrowOffsetHorizontal - a;
          break;
        case "leftBottom":
        case "rightBottom":
          d.offset[1] = f.arrowOffsetHorizontal + a;
          break;
      }
    d.overflow = rV(u, f, t, n), s && (d.htmlRegion = "visibleFirst");
  }), l;
}
const sV = (e) => {
  const {
    componentCls: t,
    // ant-tooltip
    tooltipMaxWidth: n,
    tooltipColor: r,
    tooltipBg: i,
    tooltipBorderRadius: o,
    zIndexPopup: s,
    controlHeight: a,
    boxShadowSecondary: l,
    paddingSM: u,
    paddingXS: c
  } = e;
  return [
    {
      [t]: Object.assign(Object.assign(Object.assign(Object.assign({}, Gn(e)), {
        position: "absolute",
        zIndex: s,
        display: "block",
        width: "max-content",
        maxWidth: n,
        visibility: "visible",
        transformOrigin: "var(--arrow-x, 50%) var(--arrow-y, 50%)",
        "&-hidden": {
          display: "none"
        },
        "--antd-arrow-background-color": i,
        // Wrapper for the tooltip content
        [`${t}-inner`]: {
          minWidth: a,
          minHeight: a,
          padding: `${le(e.calc(u).div(2).equal())} ${le(c)}`,
          color: r,
          textAlign: "start",
          textDecoration: "none",
          wordWrap: "break-word",
          backgroundColor: i,
          borderRadius: o,
          boxShadow: l,
          boxSizing: "border-box"
        },
        // Limit left and right placement radius
        [["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(",")]: {
          [`${t}-inner`]: {
            borderRadius: e.min(o, aR)
          }
        },
        [`${t}-content`]: {
          position: "relative"
        }
      }), Y3(e, (d, f) => {
        let {
          darkColor: h
        } = f;
        return {
          [`&${t}-${d}`]: {
            [`${t}-inner`]: {
              backgroundColor: h
            },
            [`${t}-arrow`]: {
              "--antd-arrow-background-color": h
            }
          }
        };
      })), {
        // RTL
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Arrow Style
    v1(e, "var(--antd-arrow-background-color)"),
    // Pure Render
    {
      [`${t}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: e.sizePopupArrow
      }
    }
  ];
}, aV = (e) => Object.assign(Object.assign({
  zIndexPopup: e.zIndexPopupBase + 70
}, Gg({
  contentRadius: e.borderRadius,
  limitVerticalRadius: !0
})), m1(Jt(e, {
  borderRadiusOuter: Math.min(e.borderRadiusOuter, 4)
}))), cR = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return $n("Tooltip", (r) => {
    const {
      borderRadius: i,
      colorTextLightSolid: o,
      colorBgSpotlight: s
    } = r, a = Jt(r, {
      // default variables
      tooltipMaxWidth: 250,
      tooltipColor: o,
      tooltipBorderRadius: i,
      tooltipBg: s
    });
    return [sV(a), vf(r, "zoom-big-fast")];
  }, aV, {
    resetStyle: !1,
    // Popover use Tooltip as internal component. We do not need to handle this.
    injectStyle: t
  })(e);
}, lV = yd.map((e) => `${e}-inverse`);
function cV(e) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) ? [].concat(_e(lV), _e(yd)).includes(e) : yd.includes(e);
}
function uR(e, t) {
  const n = cV(t), r = se({
    [`${e}-${t}`]: t && n
  }), i = {}, o = {};
  return t && !n && (i.background = t, o["--antd-arrow-background-color"] = t), {
    className: r,
    overlayStyle: i,
    arrowStyle: o
  };
}
const uV = (e) => {
  const {
    prefixCls: t,
    className: n,
    placement: r = "top",
    title: i,
    color: o,
    overlayInnerStyle: s
  } = e, {
    getPrefixCls: a
  } = O.useContext(rt), l = a("tooltip", t), [u, c, d] = cR(l), f = uR(l, o), h = f.arrowStyle, p = Object.assign(Object.assign({}, s), f.overlayStyle), g = se(c, d, l, `${l}-pure`, `${l}-placement-${r}`, n, f.className);
  return u(/* @__PURE__ */ O.createElement("div", {
    className: g,
    style: h
  }, /* @__PURE__ */ O.createElement("div", {
    className: `${l}-arrow`
  }), /* @__PURE__ */ O.createElement(g1, Object.assign({}, e, {
    className: c,
    prefixCls: l,
    overlayInnerStyle: p
  }), i)));
};
var dV = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const fV = /* @__PURE__ */ O.forwardRef((e, t) => {
  var n, r;
  const {
    prefixCls: i,
    openClassName: o,
    getTooltipContainer: s,
    overlayClassName: a,
    color: l,
    overlayInnerStyle: u,
    children: c,
    afterOpenChange: d,
    afterVisibleChange: f,
    destroyTooltipOnHide: h,
    arrow: p = !0,
    title: g,
    overlay: m,
    builtinPlacements: v,
    arrowPointAtCenter: b = !1,
    autoAdjustOverflow: x = !0
  } = e, w = !!p, [, C] = Sr(), {
    getPopupContainer: y,
    getPrefixCls: S,
    direction: A
  } = O.useContext(rt), $ = Zt("Tooltip"), M = O.useRef(null), _ = () => {
    var De;
    (De = M.current) === null || De === void 0 || De.forceAlign();
  };
  O.useImperativeHandle(t, () => ({
    forceAlign: _,
    forcePopupAlign: () => {
      $.deprecated(!1, "forcePopupAlign", "forceAlign"), _();
    }
  })), process.env.NODE_ENV !== "production" && ([["visible", "open"], ["defaultVisible", "defaultOpen"], ["onVisibleChange", "onOpenChange"], ["afterVisibleChange", "afterOpenChange"], ["arrowPointAtCenter", "arrow={{ pointAtCenter: true }}"]].forEach((De) => {
    let [Me, Ue] = De;
    $.deprecated(!(Me in e), Me, Ue);
  }), process.env.NODE_ENV !== "production" && $(!h || typeof h == "boolean", "usage", "`destroyTooltipOnHide` no need config `keepParent` anymore. Please use `boolean` value directly."), process.env.NODE_ENV !== "production" && $(!p || typeof p == "boolean" || !("arrowPointAtCenter" in p), "deprecated", "`arrowPointAtCenter` in `arrow` is deprecated. Please use `pointAtCenter` instead."));
  const [T, D] = Un(!1, {
    value: (n = e.open) !== null && n !== void 0 ? n : e.visible,
    defaultValue: (r = e.defaultOpen) !== null && r !== void 0 ? r : e.defaultVisible
  }), E = !g && !m && g !== 0, R = (De) => {
    var Me, Ue;
    D(E ? !1 : De), E || ((Me = e.onOpenChange) === null || Me === void 0 || Me.call(e, De), (Ue = e.onVisibleChange) === null || Ue === void 0 || Ue.call(e, De));
  }, I = O.useMemo(() => {
    var De, Me;
    let Ue = b;
    return typeof p == "object" && (Ue = (Me = (De = p.pointAtCenter) !== null && De !== void 0 ? De : p.arrowPointAtCenter) !== null && Me !== void 0 ? Me : b), v || lR({
      arrowPointAtCenter: Ue,
      autoAdjustOverflow: x,
      arrowWidth: w ? C.sizePopupArrow : 0,
      borderRadius: C.borderRadius,
      offset: C.marginXXS,
      visibleFirst: !0
    });
  }, [b, p, v, C]), k = O.useMemo(() => g === 0 ? g : m || g || "", [m, g]), P = /* @__PURE__ */ O.createElement(wd, null, typeof k == "function" ? k() : k), {
    getPopupContainer: L,
    placement: N = "top",
    mouseEnterDelay: F = 0.1,
    mouseLeaveDelay: B = 0.1,
    overlayStyle: j,
    rootClassName: z
  } = e, H = dV(e, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName"]), W = S("tooltip", i), G = S(), K = e["data-popover-inject"];
  let Y = T;
  !("open" in e) && !("visible" in e) && E && (Y = !1);
  const X = /* @__PURE__ */ O.isValidElement(c) && !C_(c) ? c : /* @__PURE__ */ O.createElement("span", null, c), Z = X.props, Q = !Z.className || typeof Z.className == "string" ? se(Z.className, o || `${W}-open`) : Z.className, [ne, q, te] = cR(W, !K), fe = uR(W, l), Se = fe.arrowStyle, de = Object.assign(Object.assign({}, u), fe.overlayStyle), ce = se(a, {
    [`${W}-rtl`]: A === "rtl"
  }, fe.className, z, q, te), [pe, Oe] = Zc("Tooltip", H.zIndex), Re = /* @__PURE__ */ O.createElement(tV, Object.assign({}, H, {
    zIndex: pe,
    showArrow: w,
    placement: N,
    mouseEnterDelay: F,
    mouseLeaveDelay: B,
    prefixCls: W,
    overlayClassName: ce,
    overlayStyle: Object.assign(Object.assign({}, Se), j),
    getTooltipContainer: L || s || y,
    ref: M,
    builtinPlacements: I,
    overlay: P,
    visible: Y,
    onVisibleChange: R,
    afterVisibleChange: d ?? f,
    overlayInnerStyle: de,
    arrowContent: /* @__PURE__ */ O.createElement("span", {
      className: `${W}-arrow-content`
    }),
    motion: {
      motionName: Xo(G, "zoom-big-fast", e.transitionName),
      motionDeadline: 1e3
    },
    destroyTooltipOnHide: !!h
  }), Y ? oi(X, {
    className: Q
  }) : X);
  return ne(/* @__PURE__ */ O.createElement(hf.Provider, {
    value: Oe
  }, Re));
}), lr = fV;
process.env.NODE_ENV !== "production" && (lr.displayName = "Tooltip");
lr._InternalPanelDoNotUseOrYouWillBeFired = uV;
const hV = (e) => {
  const {
    componentCls: t,
    popoverColor: n,
    titleMinWidth: r,
    fontWeightStrong: i,
    innerPadding: o,
    boxShadowSecondary: s,
    colorTextHeading: a,
    borderRadiusLG: l,
    zIndexPopup: u,
    titleMarginBottom: c,
    colorBgElevated: d,
    popoverBg: f,
    titleBorderBottom: h,
    innerContentPadding: p,
    titlePadding: g
  } = e;
  return [
    {
      [t]: Object.assign(Object.assign({}, Gn(e)), {
        position: "absolute",
        top: 0,
        // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
        left: {
          _skip_check_: !0,
          value: 0
        },
        zIndex: u,
        fontWeight: "normal",
        whiteSpace: "normal",
        textAlign: "start",
        cursor: "auto",
        userSelect: "text",
        transformOrigin: "var(--arrow-x, 50%) var(--arrow-y, 50%)",
        "--antd-arrow-background-color": d,
        "&-rtl": {
          direction: "rtl"
        },
        "&-hidden": {
          display: "none"
        },
        [`${t}-content`]: {
          position: "relative"
        },
        [`${t}-inner`]: {
          backgroundColor: f,
          backgroundClip: "padding-box",
          borderRadius: l,
          boxShadow: s,
          padding: o
        },
        [`${t}-title`]: {
          minWidth: r,
          marginBottom: c,
          color: a,
          fontWeight: i,
          borderBottom: h,
          padding: g
        },
        [`${t}-inner-content`]: {
          color: n,
          padding: p
        }
      })
    },
    // Arrow Style
    v1(e, "var(--antd-arrow-background-color)"),
    // Pure Render
    {
      [`${t}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: e.sizePopupArrow,
        display: "inline-block",
        [`${t}-content`]: {
          display: "inline-block"
        }
      }
    }
  ];
}, pV = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: yd.map((n) => {
      const r = e[`${n}6`];
      return {
        [`&${t}-${n}`]: {
          "--antd-arrow-background-color": r,
          [`${t}-inner`]: {
            backgroundColor: r
          },
          [`${t}-arrow`]: {
            background: "transparent"
          }
        }
      };
    })
  };
}, gV = (e) => {
  const {
    lineWidth: t,
    controlHeight: n,
    fontHeight: r,
    padding: i,
    wireframe: o,
    zIndexPopupBase: s,
    borderRadiusLG: a,
    marginXS: l,
    lineType: u,
    colorSplit: c,
    paddingSM: d
  } = e, f = n - r, h = f / 2, p = f / 2 - t, g = i;
  return Object.assign(Object.assign(Object.assign({
    titleMinWidth: 177,
    zIndexPopup: s + 30
  }, m1(e)), Gg({
    contentRadius: a,
    limitVerticalRadius: !0
  })), {
    // internal
    innerPadding: o ? 0 : 12,
    titleMarginBottom: o ? 0 : l,
    titlePadding: o ? `${h}px ${g}px ${p}px` : 0,
    titleBorderBottom: o ? `${t}px ${u} ${c}` : "none",
    innerContentPadding: o ? `${d}px ${g}px` : 0
  });
}, dR = $n("Popover", (e) => {
  const {
    colorBgElevated: t,
    colorText: n
  } = e, r = Jt(e, {
    popoverBg: t,
    popoverColor: n
  });
  return [hV(r), pV(r), vf(r, "zoom-big")];
}, gV, {
  resetStyle: !1,
  deprecatedTokens: [["width", "titleMinWidth"], ["minWidth", "titleMinWidth"]]
});
var mV = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const vV = (e, t, n) => !t && !n ? null : /* @__PURE__ */ O.createElement(O.Fragment, null, t && /* @__PURE__ */ O.createElement("div", {
  className: `${e}-title`
}, Mc(t)), /* @__PURE__ */ O.createElement("div", {
  className: `${e}-inner-content`
}, Mc(n))), bV = (e) => {
  const {
    hashId: t,
    prefixCls: n,
    className: r,
    style: i,
    placement: o = "top",
    title: s,
    content: a,
    children: l
  } = e;
  return /* @__PURE__ */ O.createElement("div", {
    className: se(t, n, `${n}-pure`, `${n}-placement-${o}`, r),
    style: i
  }, /* @__PURE__ */ O.createElement("div", {
    className: `${n}-arrow`
  }), /* @__PURE__ */ O.createElement(g1, Object.assign({}, e, {
    className: t,
    prefixCls: n
  }), l || vV(n, s, a)));
}, fR = (e) => {
  const {
    prefixCls: t,
    className: n
  } = e, r = mV(e, ["prefixCls", "className"]), {
    getPrefixCls: i
  } = O.useContext(rt), o = i("popover", t), [s, a, l] = dR(o);
  return s(/* @__PURE__ */ O.createElement(bV, Object.assign({}, r, {
    prefixCls: o,
    hashId: a,
    className: se(n, l)
  })));
};
var yV = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const wV = (e) => {
  let {
    title: t,
    content: n,
    prefixCls: r
  } = e;
  return /* @__PURE__ */ O.createElement(O.Fragment, null, t && /* @__PURE__ */ O.createElement("div", {
    className: `${r}-title`
  }, Mc(t)), /* @__PURE__ */ O.createElement("div", {
    className: `${r}-inner-content`
  }, Mc(n)));
}, CV = /* @__PURE__ */ O.forwardRef((e, t) => {
  var n;
  const {
    prefixCls: r,
    title: i,
    content: o,
    overlayClassName: s,
    placement: a = "top",
    trigger: l = "hover",
    children: u,
    mouseEnterDelay: c = 0.1,
    mouseLeaveDelay: d = 0.1,
    onOpenChange: f,
    overlayStyle: h = {}
  } = e, p = yV(e, ["prefixCls", "title", "content", "overlayClassName", "placement", "trigger", "children", "mouseEnterDelay", "mouseLeaveDelay", "onOpenChange", "overlayStyle"]), {
    getPrefixCls: g
  } = O.useContext(rt), m = g("popover", r), [v, b, x] = dR(m), w = g(), C = se(s, b, x), [y, S] = Un(!1, {
    value: (n = e.open) !== null && n !== void 0 ? n : e.visible
  }), A = (_, T) => {
    S(_, !0), f == null || f(_, T);
  }, $ = (_) => {
    _.keyCode === xe.ESC && A(!1, _);
  }, M = (_) => {
    A(_);
  };
  return v(/* @__PURE__ */ O.createElement(lr, Object.assign({
    placement: a,
    trigger: l,
    mouseEnterDelay: c,
    mouseLeaveDelay: d,
    overlayStyle: h
  }, p, {
    prefixCls: m,
    overlayClassName: C,
    ref: t,
    open: y,
    onOpenChange: M,
    overlay: i || o ? /* @__PURE__ */ O.createElement(wV, {
      prefixCls: m,
      title: i,
      content: o
    }) : null,
    transitionName: Xo(w, "zoom-big", p.transitionName),
    "data-popover-inject": !0
  }), oi(u, {
    onKeyDown: (_) => {
      var T, D;
      /* @__PURE__ */ O.isValidElement(u) && ((D = u == null ? void 0 : (T = u.props).onKeyDown) === null || D === void 0 || D.call(T, _)), $(_);
    }
  })));
}), Kg = CV;
Kg._InternalPanelDoNotUseOrYouWillBeFired = fR;
process.env.NODE_ENV !== "production" && (Kg.displayName = "Popover");
const cE = (e) => {
  const {
    size: t,
    shape: n
  } = O.useContext(Db), r = O.useMemo(() => ({
    size: e.size || t,
    shape: e.shape || n
  }), [e.size, e.shape, t, n]);
  return /* @__PURE__ */ O.createElement(Db.Provider, {
    value: r
  }, e.children);
}, SV = (e) => {
  const {
    getPrefixCls: t,
    direction: n
  } = O.useContext(rt), {
    prefixCls: r,
    className: i,
    rootClassName: o,
    style: s,
    maxCount: a,
    maxStyle: l,
    size: u,
    shape: c,
    maxPopoverPlacement: d = "top",
    maxPopoverTrigger: f = "hover",
    children: h
  } = e, p = t("avatar", r), g = `${p}-group`, m = Kn(p), [v, b, x] = sR(p, m), w = se(g, {
    [`${g}-rtl`]: n === "rtl"
  }, x, m, i, o, b), C = Xr(h).map((S, A) => oi(S, {
    key: `avatar-key-${A}`
  })), y = C.length;
  if (a && a < y) {
    const S = C.slice(0, a), A = C.slice(a, y);
    return S.push(/* @__PURE__ */ O.createElement(Kg, {
      key: "avatar-popover-key",
      content: A,
      trigger: f,
      placement: d,
      overlayClassName: `${g}-popover`,
      destroyTooltipOnHide: !0
    }, /* @__PURE__ */ O.createElement(p1, {
      style: l
    }, `+${y - a}`))), v(/* @__PURE__ */ O.createElement(cE, {
      shape: c,
      size: u
    }, /* @__PURE__ */ O.createElement("div", {
      className: w,
      style: s
    }, S)));
  }
  return v(/* @__PURE__ */ O.createElement(cE, {
    shape: c,
    size: u
  }, /* @__PURE__ */ O.createElement("div", {
    className: w,
    style: s
  }, C)));
}, hR = p1;
hR.Group = SV;
var xV = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, name: "right", theme: "outlined" }, EV = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: xV
  }));
}, Od = /* @__PURE__ */ O.forwardRef(EV);
process.env.NODE_ENV !== "production" && (Od.displayName = "RightOutlined");
var $V = xe.ESC, OV = xe.TAB;
function AV(e) {
  var t = e.visible, n = e.triggerRef, r = e.onVisibleChange, i = e.autoFocus, o = e.overlayRef, s = O.useRef(!1), a = function() {
    if (t) {
      var d, f;
      (d = n.current) === null || d === void 0 || (f = d.focus) === null || f === void 0 || f.call(d), r == null || r(!1);
    }
  }, l = function() {
    var d;
    return (d = o.current) !== null && d !== void 0 && d.focus ? (o.current.focus(), s.current = !0, !0) : !1;
  }, u = function(d) {
    switch (d.keyCode) {
      case $V:
        a();
        break;
      case OV: {
        var f = !1;
        s.current || (f = l()), f ? d.preventDefault() : a();
        break;
      }
    }
  };
  O.useEffect(function() {
    return t ? (window.addEventListener("keydown", u), i && rn(l, 3), function() {
      window.removeEventListener("keydown", u), s.current = !1;
    }) : function() {
      s.current = !1;
    };
  }, [t]);
}
var DV = /* @__PURE__ */ li(function(e, t) {
  var n = e.overlay, r = e.arrow, i = e.prefixCls, o = mt(function() {
    var a;
    return typeof n == "function" ? a = n() : a = n, a;
  }, [n]), s = xi(t, o == null ? void 0 : o.ref);
  return /* @__PURE__ */ U.createElement(U.Fragment, null, r && /* @__PURE__ */ U.createElement("div", {
    className: "".concat(i, "-arrow")
  }), /* @__PURE__ */ U.cloneElement(o, {
    ref: Ms(o) ? s : void 0
  }));
}), jl = {
  adjustX: 1,
  adjustY: 1
}, zl = [0, 0], _V = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: jl,
    offset: [0, -4],
    targetOffset: zl
  },
  top: {
    points: ["bc", "tc"],
    overflow: jl,
    offset: [0, -4],
    targetOffset: zl
  },
  topRight: {
    points: ["br", "tr"],
    overflow: jl,
    offset: [0, -4],
    targetOffset: zl
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: jl,
    offset: [0, 4],
    targetOffset: zl
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: jl,
    offset: [0, 4],
    targetOffset: zl
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: jl,
    offset: [0, 4],
    targetOffset: zl
  }
}, TV = ["arrow", "prefixCls", "transitionName", "animation", "align", "placement", "placements", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "visible", "trigger", "autoFocus", "overlay", "children", "onVisibleChange"];
function RV(e, t) {
  var n, r = e.arrow, i = r === void 0 ? !1 : r, o = e.prefixCls, s = o === void 0 ? "rc-dropdown" : o, a = e.transitionName, l = e.animation, u = e.align, c = e.placement, d = c === void 0 ? "bottomLeft" : c, f = e.placements, h = f === void 0 ? _V : f, p = e.getPopupContainer, g = e.showAction, m = e.hideAction, v = e.overlayClassName, b = e.overlayStyle, x = e.visible, w = e.trigger, C = w === void 0 ? ["hover"] : w, y = e.autoFocus, S = e.overlay, A = e.children, $ = e.onVisibleChange, M = Rt(e, TV), _ = U.useState(), T = ae(_, 2), D = T[0], E = T[1], R = "visible" in e ? x : D, I = U.useRef(null), k = U.useRef(null), P = U.useRef(null);
  U.useImperativeHandle(t, function() {
    return I.current;
  });
  var L = function(K) {
    E(K), $ == null || $(K);
  };
  AV({
    visible: R,
    triggerRef: P,
    onVisibleChange: L,
    autoFocus: y,
    overlayRef: k
  });
  var N = function(K) {
    var Y = e.onOverlayClick;
    E(!1), Y && Y(K);
  }, F = function() {
    return /* @__PURE__ */ U.createElement(DV, {
      ref: k,
      overlay: S,
      prefixCls: s,
      arrow: i
    });
  }, B = function() {
    return typeof S == "function" ? F : F();
  }, j = function() {
    var K = e.minOverlayWidthMatchTrigger, Y = e.alignPoint;
    return "minOverlayWidthMatchTrigger" in e ? K : !Y;
  }, z = function() {
    var K = e.openClassName;
    return K !== void 0 ? K : "".concat(s, "-open");
  }, H = /* @__PURE__ */ U.cloneElement(A, {
    className: se((n = A.props) === null || n === void 0 ? void 0 : n.className, R && z()),
    ref: Ms(A) ? xi(P, A.ref) : void 0
  }), W = m;
  return !W && C.indexOf("contextMenu") !== -1 && (W = ["click"]), /* @__PURE__ */ U.createElement(Wg, we({
    builtinPlacements: h
  }, M, {
    prefixCls: s,
    ref: I,
    popupClassName: se(v, re({}, "".concat(s, "-show-arrow"), i)),
    popupStyle: b,
    action: C,
    showAction: g,
    hideAction: W,
    popupPlacement: d,
    popupAlign: u,
    popupTransitionName: a,
    popupAnimation: l,
    popupVisible: R,
    stretch: j() ? "minWidth" : "",
    popup: B(),
    onPopupVisibleChange: L,
    onPopupClick: N,
    getPopupContainer: p
  }), H);
}
const pR = /* @__PURE__ */ U.forwardRef(RV);
var gR = /* @__PURE__ */ O.createContext(null);
function mR(e, t) {
  return e === void 0 ? null : "".concat(e, "-").concat(t);
}
function vR(e) {
  var t = O.useContext(gR);
  return mR(t, e);
}
var MV = ["children", "locked"], Eo = /* @__PURE__ */ O.createContext(null);
function IV(e, t) {
  var n = ie({}, e);
  return Object.keys(t).forEach(function(r) {
    var i = t[r];
    i !== void 0 && (n[r] = i);
  }), n;
}
function Ad(e) {
  var t = e.children, n = e.locked, r = Rt(e, MV), i = O.useContext(Eo), o = lf(function() {
    return IV(i, r);
  }, [i, r], function(s, a) {
    return !n && (s[0] !== a[0] || !pd(s[1], a[1], !0));
  });
  return /* @__PURE__ */ O.createElement(Eo.Provider, {
    value: o
  }, t);
}
var kV = [], bR = /* @__PURE__ */ O.createContext(null);
function Xg() {
  return O.useContext(bR);
}
var yR = /* @__PURE__ */ O.createContext(kV);
function tu(e) {
  var t = O.useContext(yR);
  return O.useMemo(function() {
    return e !== void 0 ? [].concat(_e(t), [e]) : t;
  }, [t, e]);
}
var wR = /* @__PURE__ */ O.createContext(null), b1 = /* @__PURE__ */ O.createContext({});
function uE(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  if (Fg(e)) {
    var n = e.nodeName.toLowerCase(), r = (
      // Focusable element
      ["input", "select", "textarea", "button"].includes(n) || // Editable element
      e.isContentEditable || // Anchor with href element
      n === "a" && !!e.getAttribute("href")
    ), i = e.getAttribute("tabindex"), o = Number(i), s = null;
    return i && !Number.isNaN(o) ? s = o : r && s === null && (s = 0), r && e.disabled && (s = null), s !== null && (s >= 0 || t && s < 0);
  }
  return !1;
}
function PV(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = _e(e.querySelectorAll("*")).filter(function(r) {
    return uE(r, t);
  });
  return uE(e, t) && n.unshift(e), n;
}
var _b = xe.LEFT, Tb = xe.RIGHT, Rb = xe.UP, tp = xe.DOWN, np = xe.ENTER, CR = xe.ESC, Cu = xe.HOME, Su = xe.END, dE = [Rb, tp, _b, Tb];
function NV(e, t, n, r) {
  var i, o = "prev", s = "next", a = "children", l = "parent";
  if (e === "inline" && r === np)
    return {
      inlineTrigger: !0
    };
  var u = re(re({}, Rb, o), tp, s), c = re(re(re(re({}, _b, n ? s : o), Tb, n ? o : s), tp, a), np, a), d = re(re(re(re(re(re({}, Rb, o), tp, s), np, a), CR, l), _b, n ? a : l), Tb, n ? l : a), f = {
    inline: u,
    horizontal: c,
    vertical: d,
    inlineSub: u,
    horizontalSub: d,
    verticalSub: d
  }, h = (i = f["".concat(e).concat(t ? "" : "Sub")]) === null || i === void 0 ? void 0 : i[r];
  switch (h) {
    case o:
      return {
        offset: -1,
        sibling: !0
      };
    case s:
      return {
        offset: 1,
        sibling: !0
      };
    case l:
      return {
        offset: -1,
        sibling: !1
      };
    case a:
      return {
        offset: 1,
        sibling: !1
      };
    default:
      return null;
  }
}
function LV(e) {
  for (var t = e; t; ) {
    if (t.getAttribute("data-menu-list"))
      return t;
    t = t.parentElement;
  }
  return null;
}
function FV(e, t) {
  for (var n = e || document.activeElement; n; ) {
    if (t.has(n))
      return n;
    n = n.parentElement;
  }
  return null;
}
function y1(e, t) {
  var n = PV(e, !0);
  return n.filter(function(r) {
    return t.has(r);
  });
}
function fE(e, t, n) {
  var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  if (!e)
    return null;
  var i = y1(e, t), o = i.length, s = i.findIndex(function(a) {
    return n === a;
  });
  return r < 0 ? s === -1 ? s = o - 1 : s -= 1 : r > 0 && (s += 1), s = (s + o) % o, i[s];
}
var Mb = function(t, n) {
  var r = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  return t.forEach(function(s) {
    var a = document.querySelector("[data-menu-id='".concat(mR(n, s), "']"));
    a && (r.add(a), o.set(a, s), i.set(s, a));
  }), {
    elements: r,
    key2element: i,
    element2key: o
  };
};
function BV(e, t, n, r, i, o, s, a, l, u) {
  var c = O.useRef(), d = O.useRef();
  d.current = t;
  var f = function() {
    rn.cancel(c.current);
  };
  return O.useEffect(function() {
    return function() {
      f();
    };
  }, []), function(h) {
    var p = h.which;
    if ([].concat(dE, [np, CR, Cu, Su]).includes(p)) {
      var g = o(), m = Mb(g, r), v = m, b = v.elements, x = v.key2element, w = v.element2key, C = x.get(t), y = FV(C, b), S = w.get(y), A = NV(e, s(S, !0).length === 1, n, p);
      if (!A && p !== Cu && p !== Su)
        return;
      (dE.includes(p) || [Cu, Su].includes(p)) && h.preventDefault();
      var $ = function(k) {
        if (k) {
          var P = k, L = k.querySelector("a");
          L != null && L.getAttribute("href") && (P = L);
          var N = w.get(k);
          a(N), f(), c.current = rn(function() {
            d.current === N && P.focus();
          });
        }
      };
      if ([Cu, Su].includes(p) || A.sibling || !y) {
        var M;
        !y || e === "inline" ? M = i.current : M = LV(y);
        var _, T = y1(M, b);
        p === Cu ? _ = T[0] : p === Su ? _ = T[T.length - 1] : _ = fE(M, b, y, A.offset), $(_);
      } else if (A.inlineTrigger)
        l(S);
      else if (A.offset > 0)
        l(S, !0), f(), c.current = rn(function() {
          m = Mb(g, r);
          var I = y.getAttribute("aria-controls"), k = document.getElementById(I), P = fE(k, m.elements);
          $(P);
        }, 5);
      else if (A.offset < 0) {
        var D = s(S, !0), E = D[D.length - 2], R = x.get(E);
        l(E, !1), $(R);
      }
    }
    u == null || u(h);
  };
}
function jV(e) {
  Promise.resolve().then(e);
}
var w1 = "__RC_UTIL_PATH_SPLIT__", hE = function(t) {
  return t.join(w1);
}, zV = function(t) {
  return t.split(w1);
}, Ib = "rc-menu-more";
function HV() {
  var e = O.useState({}), t = ae(e, 2), n = t[1], r = he(/* @__PURE__ */ new Map()), i = he(/* @__PURE__ */ new Map()), o = O.useState([]), s = ae(o, 2), a = s[0], l = s[1], u = he(0), c = he(!1), d = function() {
    c.current || n({});
  }, f = Kt(function(x, w) {
    process.env.NODE_ENV !== "production" && $t(!r.current.has(x), "Duplicated key '".concat(x, "' used in Menu by path [").concat(w.join(" > "), "]"));
    var C = hE(w);
    i.current.set(C, x), r.current.set(x, C), u.current += 1;
    var y = u.current;
    jV(function() {
      y === u.current && d();
    });
  }, []), h = Kt(function(x, w) {
    var C = hE(w);
    i.current.delete(C), r.current.delete(x);
  }, []), p = Kt(function(x) {
    l(x);
  }, []), g = Kt(function(x, w) {
    var C = r.current.get(x) || "", y = zV(C);
    return w && a.includes(y[0]) && y.unshift(Ib), y;
  }, [a]), m = Kt(function(x, w) {
    return x.some(function(C) {
      var y = g(C, !0);
      return y.includes(w);
    });
  }, [g]), v = function() {
    var w = _e(r.current.keys());
    return a.length && w.push(Ib), w;
  }, b = Kt(function(x) {
    var w = "".concat(r.current.get(x)).concat(w1), C = /* @__PURE__ */ new Set();
    return _e(i.current.keys()).forEach(function(y) {
      y.startsWith(w) && C.add(i.current.get(y));
    }), C;
  }, []);
  return O.useEffect(function() {
    return function() {
      c.current = !0;
    };
  }, []), {
    // Register
    registerPath: f,
    unregisterPath: h,
    refreshOverflowKeys: p,
    // Util
    isSubPathKey: m,
    getKeyPath: g,
    getKeys: v,
    getSubPathKeys: b
  };
}
function Nu(e) {
  var t = O.useRef(e);
  t.current = e;
  var n = O.useCallback(function() {
    for (var r, i = arguments.length, o = new Array(i), s = 0; s < i; s++)
      o[s] = arguments[s];
    return (r = t.current) === null || r === void 0 ? void 0 : r.call.apply(r, [t].concat(o));
  }, []);
  return e ? n : void 0;
}
var VV = Math.random().toFixed(5).toString().slice(2), pE = 0;
function WV(e) {
  var t = Un(e, {
    value: e
  }), n = ae(t, 2), r = n[0], i = n[1];
  return O.useEffect(function() {
    pE += 1;
    var o = process.env.NODE_ENV === "test" ? "test" : "".concat(VV, "-").concat(pE);
    i("rc-menu-uuid-".concat(o));
  }, []), r;
}
function SR(e, t, n, r) {
  var i = O.useContext(Eo), o = i.activeKey, s = i.onActive, a = i.onInactive, l = {
    active: o === e
  };
  return t || (l.onMouseEnter = function(u) {
    n == null || n({
      key: e,
      domEvent: u
    }), s(e);
  }, l.onMouseLeave = function(u) {
    r == null || r({
      key: e,
      domEvent: u
    }), a(e);
  }), l;
}
function xR(e) {
  var t = O.useContext(Eo), n = t.mode, r = t.rtl, i = t.inlineIndent;
  if (n !== "inline")
    return null;
  var o = e;
  return r ? {
    paddingRight: o * i
  } : {
    paddingLeft: o * i
  };
}
function ER(e) {
  var t = e.icon, n = e.props, r = e.children, i;
  return t === null || t === !1 ? null : (typeof t == "function" ? i = /* @__PURE__ */ O.createElement(t, ie({}, n)) : typeof t != "boolean" && (i = t), i || r || null);
}
var UV = ["item"];
function kp(e) {
  var t = e.item, n = Rt(e, UV);
  return Object.defineProperty(n, "item", {
    get: function() {
      return $t(!1, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future."), t;
    }
  }), n;
}
var GV = ["title", "attribute", "elementRef"], KV = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"], XV = ["active"], YV = /* @__PURE__ */ function(e) {
  pl(n, e);
  var t = cf(n);
  function n() {
    return ci(this, n), t.apply(this, arguments);
  }
  return ui(n, [{
    key: "render",
    value: function() {
      var i = this.props, o = i.title, s = i.attribute, a = i.elementRef, l = Rt(i, GV), u = zn(l, ["eventKey", "popupClassName", "popupOffset", "onTitleClick"]);
      return $t(!s, "`attribute` of Menu.Item is deprecated. Please pass attribute directly."), /* @__PURE__ */ O.createElement(Uo.Item, we({}, s, {
        title: typeof o == "string" ? o : void 0
      }, u, {
        ref: a
      }));
    }
  }]), n;
}(O.Component), qV = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.style, r = e.className, i = e.eventKey, o = e.warnKey, s = e.disabled, a = e.itemIcon, l = e.children, u = e.role, c = e.onMouseEnter, d = e.onMouseLeave, f = e.onClick, h = e.onKeyDown, p = e.onFocus, g = Rt(e, KV), m = vR(i), v = O.useContext(Eo), b = v.prefixCls, x = v.onItemClick, w = v.disabled, C = v.overflowDisabled, y = v.itemIcon, S = v.selectedKeys, A = v.onActive, $ = O.useContext(b1), M = $._internalRenderMenuItem, _ = "".concat(b, "-item"), T = O.useRef(), D = O.useRef(), E = w || s, R = ba(t, D), I = tu(i);
  process.env.NODE_ENV !== "production" && o && $t(!1, "MenuItem should not leave undefined `key`.");
  var k = function(X) {
    return {
      key: i,
      // Note: For legacy code is reversed which not like other antd component
      keyPath: _e(I).reverse(),
      item: T.current,
      domEvent: X
    };
  }, P = a || y, L = SR(i, E, c, d), N = L.active, F = Rt(L, XV), B = S.includes(i), j = xR(I.length), z = function(X) {
    if (!E) {
      var Z = k(X);
      f == null || f(kp(Z)), x(Z);
    }
  }, H = function(X) {
    if (h == null || h(X), X.which === xe.ENTER) {
      var Z = k(X);
      f == null || f(kp(Z)), x(Z);
    }
  }, W = function(X) {
    A(i), p == null || p(X);
  }, G = {};
  e.role === "option" && (G["aria-selected"] = B);
  var K = /* @__PURE__ */ O.createElement(YV, we({
    ref: T,
    elementRef: R,
    role: u === null ? "none" : u || "menuitem",
    tabIndex: s ? null : -1,
    "data-menu-id": C && m ? null : m
  }, g, F, G, {
    component: "li",
    "aria-disabled": s,
    style: ie(ie({}, j), n),
    className: se(_, re(re(re({}, "".concat(_, "-active"), N), "".concat(_, "-selected"), B), "".concat(_, "-disabled"), E), r),
    onClick: z,
    onKeyDown: H,
    onFocus: W
  }), l, /* @__PURE__ */ O.createElement(ER, {
    props: ie(ie({}, e), {}, {
      isSelected: B
    }),
    icon: P
  }));
  return M && (K = M(K, e, {
    selected: B
  })), K;
});
function QV(e, t) {
  var n = e.eventKey, r = Xg(), i = tu(n);
  return O.useEffect(function() {
    if (r)
      return r.registerPath(n, i), function() {
        r.unregisterPath(n, i);
      };
  }, [i]), r ? null : /* @__PURE__ */ O.createElement(qV, we({}, e, {
    ref: t
  }));
}
const Sf = /* @__PURE__ */ O.forwardRef(QV);
var ZV = ["className", "children"], JV = function(t, n) {
  var r = t.className, i = t.children, o = Rt(t, ZV), s = O.useContext(Eo), a = s.prefixCls, l = s.mode, u = s.rtl;
  return /* @__PURE__ */ O.createElement("ul", we({
    className: se(a, u && "".concat(a, "-rtl"), "".concat(a, "-sub"), "".concat(a, "-").concat(l === "inline" ? "inline" : "vertical"), r),
    role: "menu"
  }, o, {
    "data-menu-list": !0,
    ref: n
  }), i);
}, C1 = /* @__PURE__ */ O.forwardRef(JV);
C1.displayName = "SubMenuList";
function S1(e, t) {
  return Xr(e).map(function(n, r) {
    if (/* @__PURE__ */ O.isValidElement(n)) {
      var i, o, s = n.key, a = (i = (o = n.props) === null || o === void 0 ? void 0 : o.eventKey) !== null && i !== void 0 ? i : s, l = a == null;
      l && (a = "tmp_key-".concat([].concat(_e(t), [r]).join("-")));
      var u = {
        key: a,
        eventKey: a
      };
      return process.env.NODE_ENV !== "production" && l && (u.warnKey = !0), /* @__PURE__ */ O.cloneElement(n, u);
    }
    return n;
  });
}
var Wr = {
  adjustX: 1,
  adjustY: 1
}, e9 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: Wr
  },
  topRight: {
    points: ["br", "tr"],
    overflow: Wr
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: Wr
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: Wr
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: Wr
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: Wr
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: Wr
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: Wr
  }
}, t9 = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: Wr
  },
  topRight: {
    points: ["br", "tr"],
    overflow: Wr
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: Wr
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: Wr
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: Wr
  },
  rightBottom: {
    points: ["br", "bl"],
    overflow: Wr
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: Wr
  },
  leftBottom: {
    points: ["bl", "br"],
    overflow: Wr
  }
};
function $R(e, t, n) {
  if (t)
    return t;
  if (n)
    return n[e] || n.other;
}
var n9 = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
};
function r9(e) {
  var t = e.prefixCls, n = e.visible, r = e.children, i = e.popup, o = e.popupStyle, s = e.popupClassName, a = e.popupOffset, l = e.disabled, u = e.mode, c = e.onVisibleChange, d = O.useContext(Eo), f = d.getPopupContainer, h = d.rtl, p = d.subMenuOpenDelay, g = d.subMenuCloseDelay, m = d.builtinPlacements, v = d.triggerSubMenuAction, b = d.forceSubMenuRender, x = d.rootClassName, w = d.motion, C = d.defaultMotions, y = O.useState(!1), S = ae(y, 2), A = S[0], $ = S[1], M = ie(h ? ie({}, t9) : ie({}, e9), m), _ = n9[u], T = $R(u, w, C), D = O.useRef(T);
  u !== "inline" && (D.current = T);
  var E = ie(ie({}, D.current), {}, {
    leavedClassName: "".concat(t, "-hidden"),
    removeOnLeave: !1,
    motionAppear: !0
  }), R = O.useRef();
  return O.useEffect(function() {
    return R.current = rn(function() {
      $(n);
    }), function() {
      rn.cancel(R.current);
    };
  }, [n]), /* @__PURE__ */ O.createElement(Wg, {
    prefixCls: t,
    popupClassName: se("".concat(t, "-popup"), re({}, "".concat(t, "-rtl"), h), s, x),
    stretch: u === "horizontal" ? "minWidth" : null,
    getPopupContainer: f,
    builtinPlacements: M,
    popupPlacement: _,
    popupVisible: A,
    popup: i,
    popupStyle: o,
    popupAlign: a && {
      offset: a
    },
    action: l ? [] : [v],
    mouseEnterDelay: p,
    mouseLeaveDelay: g,
    onPopupVisibleChange: c,
    forceRender: b,
    popupMotion: E,
    fresh: !0
  }, r);
}
function i9(e) {
  var t = e.id, n = e.open, r = e.keyPath, i = e.children, o = "inline", s = O.useContext(Eo), a = s.prefixCls, l = s.forceSubMenuRender, u = s.motion, c = s.defaultMotions, d = s.mode, f = O.useRef(!1);
  f.current = d === o;
  var h = O.useState(!f.current), p = ae(h, 2), g = p[0], m = p[1], v = f.current ? n : !1;
  O.useEffect(function() {
    f.current && m(!1);
  }, [d]);
  var b = ie({}, $R(o, u, c));
  r.length > 1 && (b.motionAppear = !1);
  var x = b.onVisibleChanged;
  return b.onVisibleChanged = function(w) {
    return !f.current && !w && m(!0), x == null ? void 0 : x(w);
  }, g ? null : /* @__PURE__ */ O.createElement(Ad, {
    mode: o,
    locked: !f.current
  }, /* @__PURE__ */ O.createElement(qo, we({
    visible: v
  }, b, {
    forceRender: l,
    removeOnLeave: !1,
    leavedClassName: "".concat(a, "-hidden")
  }), function(w) {
    var C = w.className, y = w.style;
    return /* @__PURE__ */ O.createElement(C1, {
      id: t,
      className: C,
      style: y
    }, i);
  }));
}
var o9 = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "popupStyle", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"], s9 = ["active"], a9 = function(t) {
  var n = t.style, r = t.className, i = t.title, o = t.eventKey, s = t.warnKey, a = t.disabled, l = t.internalPopupClose, u = t.children, c = t.itemIcon, d = t.expandIcon, f = t.popupClassName, h = t.popupOffset, p = t.popupStyle, g = t.onClick, m = t.onMouseEnter, v = t.onMouseLeave, b = t.onTitleClick, x = t.onTitleMouseEnter, w = t.onTitleMouseLeave, C = Rt(t, o9), y = vR(o), S = O.useContext(Eo), A = S.prefixCls, $ = S.mode, M = S.openKeys, _ = S.disabled, T = S.overflowDisabled, D = S.activeKey, E = S.selectedKeys, R = S.itemIcon, I = S.expandIcon, k = S.onItemClick, P = S.onOpenChange, L = S.onActive, N = O.useContext(b1), F = N._internalRenderSubMenuItem, B = O.useContext(wR), j = B.isSubPathKey, z = tu(), H = "".concat(A, "-submenu"), W = _ || a, G = O.useRef(), K = O.useRef();
  process.env.NODE_ENV !== "production" && s && $t(!1, "SubMenu should not leave undefined `key`.");
  var Y = c ?? R, X = d ?? I, Z = M.includes(o), Q = !T && Z, ne = j(E, o), q = SR(o, W, x, w), te = q.active, fe = Rt(q, s9), Se = O.useState(!1), de = ae(Se, 2), ce = de[0], pe = de[1], Oe = function(Ge) {
    W || pe(Ge);
  }, Re = function(Ge) {
    Oe(!0), m == null || m({
      key: o,
      domEvent: Ge
    });
  }, De = function(Ge) {
    Oe(!1), v == null || v({
      key: o,
      domEvent: Ge
    });
  }, Me = O.useMemo(function() {
    return te || ($ !== "inline" ? ce || j([D], o) : !1);
  }, [$, te, D, ce, o, j]), Ue = xR(z.length), oe = function(Ge) {
    W || (b == null || b({
      key: o,
      domEvent: Ge
    }), $ === "inline" && P(o, !Z));
  }, Ce = Nu(function(We) {
    g == null || g(kp(We)), k(We);
  }), ge = function(Ge) {
    $ !== "inline" && P(o, Ge);
  }, ve = function() {
    L(o);
  }, me = y && "".concat(y, "-popup"), Fe = /* @__PURE__ */ O.createElement("div", we({
    role: "menuitem",
    style: Ue,
    className: "".concat(H, "-title"),
    tabIndex: W ? null : -1,
    ref: G,
    title: typeof i == "string" ? i : null,
    "data-menu-id": T && y ? null : y,
    "aria-expanded": Q,
    "aria-haspopup": !0,
    "aria-controls": me,
    "aria-disabled": W,
    onClick: oe,
    onFocus: ve
  }, fe), i, /* @__PURE__ */ O.createElement(ER, {
    icon: $ !== "horizontal" ? X : void 0,
    props: ie(ie({}, t), {}, {
      isOpen: Q,
      // [Legacy] Not sure why need this mark
      isSubMenu: !0
    })
  }, /* @__PURE__ */ O.createElement("i", {
    className: "".concat(H, "-arrow")
  }))), Be = O.useRef($);
  if ($ !== "inline" && z.length > 1 ? Be.current = "vertical" : Be.current = $, !T) {
    var qe = Be.current;
    Fe = /* @__PURE__ */ O.createElement(r9, {
      mode: qe,
      prefixCls: H,
      visible: !l && Q && $ !== "inline",
      popupClassName: f,
      popupOffset: h,
      popupStyle: p,
      popup: /* @__PURE__ */ O.createElement(
        Ad,
        {
          mode: qe === "horizontal" ? "vertical" : qe
        },
        /* @__PURE__ */ O.createElement(C1, {
          id: me,
          ref: K
        }, u)
      ),
      disabled: W,
      onVisibleChange: ge
    }, Fe);
  }
  var Ve = /* @__PURE__ */ O.createElement(Uo.Item, we({
    role: "none"
  }, C, {
    component: "li",
    style: n,
    className: se(H, "".concat(H, "-").concat($), r, re(re(re(re({}, "".concat(H, "-open"), Q), "".concat(H, "-active"), Me), "".concat(H, "-selected"), ne), "".concat(H, "-disabled"), W)),
    onMouseEnter: Re,
    onMouseLeave: De
  }), Fe, !T && /* @__PURE__ */ O.createElement(i9, {
    id: me,
    open: Q,
    keyPath: z
  }, u));
  return F && (Ve = F(Ve, t, {
    selected: ne,
    active: Me,
    open: Q,
    disabled: W
  })), /* @__PURE__ */ O.createElement(Ad, {
    onItemClick: Ce,
    mode: $ === "horizontal" ? "vertical" : $,
    itemIcon: Y,
    expandIcon: X
  }, Ve);
};
function Yg(e) {
  var t = e.eventKey, n = e.children, r = tu(t), i = S1(n, r), o = Xg();
  O.useEffect(function() {
    if (o)
      return o.registerPath(t, r), function() {
        o.unregisterPath(t, r);
      };
  }, [r]);
  var s;
  return o ? s = i : s = /* @__PURE__ */ O.createElement(a9, e, i), /* @__PURE__ */ O.createElement(yR.Provider, {
    value: r
  }, s);
}
var l9 = ["className", "title", "eventKey", "children"], c9 = ["children"], u9 = function(t) {
  var n = t.className, r = t.title;
  t.eventKey;
  var i = t.children, o = Rt(t, l9), s = O.useContext(Eo), a = s.prefixCls, l = "".concat(a, "-item-group");
  return /* @__PURE__ */ O.createElement("li", we({
    role: "presentation"
  }, o, {
    onClick: function(c) {
      return c.stopPropagation();
    },
    className: se(l, n)
  }), /* @__PURE__ */ O.createElement("div", {
    role: "presentation",
    className: "".concat(l, "-title"),
    title: typeof r == "string" ? r : void 0
  }, r), /* @__PURE__ */ O.createElement("ul", {
    role: "group",
    className: "".concat(l, "-list")
  }, i));
};
function qg(e) {
  var t = e.children, n = Rt(e, c9), r = tu(n.eventKey), i = S1(t, r), o = Xg();
  return o ? i : /* @__PURE__ */ O.createElement(u9, zn(n, ["warnKey"]), i);
}
function x1(e) {
  var t = e.className, n = e.style, r = O.useContext(Eo), i = r.prefixCls, o = Xg();
  return o ? null : /* @__PURE__ */ O.createElement("li", {
    role: "separator",
    className: se("".concat(i, "-item-divider"), t),
    style: n
  });
}
var d9 = ["label", "children", "key", "type"];
function kb(e) {
  return (e || []).map(function(t, n) {
    if (t && wt(t) === "object") {
      var r = t, i = r.label, o = r.children, s = r.key, a = r.type, l = Rt(r, d9), u = s ?? "tmp-".concat(n);
      return o || a === "group" ? a === "group" ? /* @__PURE__ */ O.createElement(qg, we({
        key: u
      }, l, {
        title: i
      }), kb(o)) : /* @__PURE__ */ O.createElement(Yg, we({
        key: u
      }, l, {
        title: i
      }), kb(o)) : a === "divider" ? /* @__PURE__ */ O.createElement(x1, we({
        key: u
      }, l)) : /* @__PURE__ */ O.createElement(Sf, we({
        key: u
      }, l), i);
    }
    return null;
  }).filter(function(t) {
    return t;
  });
}
function f9(e, t, n) {
  var r = e;
  return t && (r = kb(t)), S1(r, n);
}
var h9 = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem"], Hl = [], p9 = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n, r = e, i = r.prefixCls, o = i === void 0 ? "rc-menu" : i, s = r.rootClassName, a = r.style, l = r.className, u = r.tabIndex, c = u === void 0 ? 0 : u, d = r.items, f = r.children, h = r.direction, p = r.id, g = r.mode, m = g === void 0 ? "vertical" : g, v = r.inlineCollapsed, b = r.disabled, x = r.disabledOverflow, w = r.subMenuOpenDelay, C = w === void 0 ? 0.1 : w, y = r.subMenuCloseDelay, S = y === void 0 ? 0.1 : y, A = r.forceSubMenuRender, $ = r.defaultOpenKeys, M = r.openKeys, _ = r.activeKey, T = r.defaultActiveFirst, D = r.selectable, E = D === void 0 ? !0 : D, R = r.multiple, I = R === void 0 ? !1 : R, k = r.defaultSelectedKeys, P = r.selectedKeys, L = r.onSelect, N = r.onDeselect, F = r.inlineIndent, B = F === void 0 ? 24 : F, j = r.motion, z = r.defaultMotions, H = r.triggerSubMenuAction, W = H === void 0 ? "hover" : H, G = r.builtinPlacements, K = r.itemIcon, Y = r.expandIcon, X = r.overflowedIndicator, Z = X === void 0 ? "..." : X, Q = r.overflowedIndicatorPopupClassName, ne = r.getPopupContainer, q = r.onClick, te = r.onOpenChange, fe = r.onKeyDown, Se = r.openAnimation, de = r.openTransitionName, ce = r._internalRenderMenuItem, pe = r._internalRenderSubMenuItem, Oe = Rt(r, h9), Re = O.useMemo(function() {
    return f9(f, d, Hl);
  }, [f, d]), De = O.useState(!1), Me = ae(De, 2), Ue = Me[0], oe = Me[1], Ce = O.useRef(), ge = WV(p), ve = h === "rtl";
  process.env.NODE_ENV !== "production" && $t(!Se && !de, "`openAnimation` and `openTransitionName` is removed. Please use `motion` or `defaultMotion` instead.");
  var me = Un($, {
    value: M,
    postState: function(Ye) {
      return Ye || Hl;
    }
  }), Fe = ae(me, 2), Be = Fe[0], qe = Fe[1], Ve = function(Ye) {
    var Dt = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    function en() {
      qe(Ye), te == null || te(Ye);
    }
    Dt ? Cp(en) : en();
  }, We = O.useState(Be), Ge = ae(We, 2), $e = Ge[0], ze = Ge[1], at = O.useRef(!1), xt = O.useMemo(function() {
    return (m === "inline" || m === "vertical") && v ? ["vertical", v] : [m, !1];
  }, [m, v]), jt = ae(xt, 2), Lt = jt[0], At = jt[1], Et = Lt === "inline", nt = O.useState(Lt), it = ae(nt, 2), je = it[0], Le = it[1], ot = O.useState(At), yt = ae(ot, 2), He = yt[0], Je = yt[1];
  O.useEffect(function() {
    Le(Lt), Je(At), at.current && (Et ? qe($e) : Ve(Hl));
  }, [Lt, At]);
  var Qe = O.useState(0), lt = ae(Qe, 2), pt = lt[0], vt = lt[1], ee = pt >= Re.length - 1 || je !== "horizontal" || x;
  O.useEffect(function() {
    Et && ze(Be);
  }, [Be]), O.useEffect(function() {
    return at.current = !0, function() {
      at.current = !1;
    };
  }, []);
  var be = HV(), Ee = be.registerPath, ye = be.unregisterPath, Ke = be.refreshOverflowKeys, et = be.isSubPathKey, Ie = be.getKeyPath, Ae = be.getKeys, tt = be.getSubPathKeys, dt = O.useMemo(function() {
    return {
      registerPath: Ee,
      unregisterPath: ye
    };
  }, [Ee, ye]), Tt = O.useMemo(function() {
    return {
      isSubPathKey: et
    };
  }, [et]);
  O.useEffect(function() {
    Ke(ee ? Hl : Re.slice(pt + 1).map(function(Ze) {
      return Ze.key;
    }));
  }, [pt, ee]);
  var Ct = Un(_ || T && ((n = Re[0]) === null || n === void 0 ? void 0 : n.key), {
    value: _
  }), vn = ae(Ct, 2), Hn = vn[0], pn = vn[1], Qn = Nu(function(Ze) {
    pn(Ze);
  }), Fr = Nu(function() {
    pn(void 0);
  });
  fl(t, function() {
    return {
      list: Ce.current,
      focus: function(Ye) {
        var Dt, en = Ae(), zt = Mb(en, ge), xn = zt.elements, or = zt.key2element, $r = zt.element2key, mr = y1(Ce.current, xn), Jr = Hn ?? (mr[0] ? $r.get(mr[0]) : (Dt = Re.find(function(Jn) {
          return !Jn.props.disabled;
        })) === null || Dt === void 0 ? void 0 : Dt.key), Zn = or.get(Jr);
        if (Jr && Zn) {
          var vr;
          Zn == null || (vr = Zn.focus) === null || vr === void 0 || vr.call(Zn, Ye);
        }
      }
    };
  });
  var Qr = Un(k || [], {
    value: P,
    // Legacy convert key to array
    postState: function(Ye) {
      return Array.isArray(Ye) ? Ye : Ye == null ? Hl : [Ye];
    }
  }), Br = ae(Qr, 2), gr = Br[0], Er = Br[1], jr = function(Ye) {
    if (E) {
      var Dt = Ye.key, en = gr.includes(Dt), zt;
      I ? en ? zt = gr.filter(function(or) {
        return or !== Dt;
      }) : zt = [].concat(_e(gr), [Dt]) : zt = [Dt], Er(zt);
      var xn = ie(ie({}, Ye), {}, {
        selectedKeys: zt
      });
      en ? N == null || N(xn) : L == null || L(xn);
    }
    !I && Be.length && je !== "inline" && Ve(Hl);
  }, zr = Nu(function(Ze) {
    q == null || q(kp(Ze)), jr(Ze);
  }), zi = Nu(function(Ze, Ye) {
    var Dt = Be.filter(function(zt) {
      return zt !== Ze;
    });
    if (Ye)
      Dt.push(Ze);
    else if (je !== "inline") {
      var en = tt(Ze);
      Dt = Dt.filter(function(zt) {
        return !en.has(zt);
      });
    }
    pd(Be, Dt, !0) || Ve(Dt, !0);
  }), Mo = function(Ye, Dt) {
    var en = Dt ?? !Be.includes(Ye);
    zi(Ye, en);
  }, fi = BV(je, Hn, ve, ge, Ce, Ae, Ie, pn, Mo, fe);
  O.useEffect(function() {
    oe(!0);
  }, []);
  var Ei = O.useMemo(function() {
    return {
      _internalRenderMenuItem: ce,
      _internalRenderSubMenuItem: pe
    };
  }, [ce, pe]), Zr = je !== "horizontal" || x ? Re : (
    // Need wrap for overflow dropdown that do not response for open
    Re.map(function(Ze, Ye) {
      return (
        // Always wrap provider to avoid sub node re-mount
        /* @__PURE__ */ O.createElement(Ad, {
          key: Ze.key,
          overflowDisabled: Ye > pt
        }, Ze)
      );
    })
  ), hi = /* @__PURE__ */ O.createElement(Uo, we({
    id: p,
    ref: Ce,
    prefixCls: "".concat(o, "-overflow"),
    component: "ul",
    itemComponent: Sf,
    className: se(o, "".concat(o, "-root"), "".concat(o, "-").concat(je), l, re(re({}, "".concat(o, "-inline-collapsed"), He), "".concat(o, "-rtl"), ve), s),
    dir: h,
    style: a,
    role: "menu",
    tabIndex: c,
    data: Zr,
    renderRawItem: function(Ye) {
      return Ye;
    },
    renderRawRest: function(Ye) {
      var Dt = Ye.length, en = Dt ? Re.slice(-Dt) : null;
      return /* @__PURE__ */ O.createElement(Yg, {
        eventKey: Ib,
        title: Z,
        disabled: ee,
        internalPopupClose: Dt === 0,
        popupClassName: Q
      }, en);
    },
    maxCount: je !== "horizontal" || x ? Uo.INVALIDATE : Uo.RESPONSIVE,
    ssr: "full",
    "data-menu-list": !0,
    onVisibleChange: function(Ye) {
      vt(Ye);
    },
    onKeyDown: fi
  }, Oe));
  return /* @__PURE__ */ O.createElement(b1.Provider, {
    value: Ei
  }, /* @__PURE__ */ O.createElement(gR.Provider, {
    value: ge
  }, /* @__PURE__ */ O.createElement(Ad, {
    prefixCls: o,
    rootClassName: s,
    mode: je,
    openKeys: Be,
    rtl: ve,
    disabled: b,
    motion: Ue ? j : null,
    defaultMotions: Ue ? z : null,
    activeKey: Hn,
    onActive: Qn,
    onInactive: Fr,
    selectedKeys: gr,
    inlineIndent: B,
    subMenuOpenDelay: C,
    subMenuCloseDelay: S,
    forceSubMenuRender: A,
    builtinPlacements: G,
    triggerSubMenuAction: W,
    getPopupContainer: ne,
    itemIcon: K,
    expandIcon: Y,
    onItemClick: zr,
    onOpenChange: zi
  }, /* @__PURE__ */ O.createElement(wR.Provider, {
    value: Tt
  }, hi), /* @__PURE__ */ O.createElement("div", {
    style: {
      display: "none"
    },
    "aria-hidden": !0
  }, /* @__PURE__ */ O.createElement(bR.Provider, {
    value: dt
  }, Re)))));
}), nu = p9;
nu.Item = Sf;
nu.SubMenu = Yg;
nu.ItemGroup = qg;
nu.Divider = x1;
var g9 = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "bars", theme: "outlined" }, m9 = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: g9
  }));
}, OR = /* @__PURE__ */ O.forwardRef(m9);
process.env.NODE_ENV !== "production" && (OR.displayName = "BarsOutlined");
var v9 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, name: "left", theme: "outlined" }, b9 = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: v9
  }));
}, Pp = /* @__PURE__ */ O.forwardRef(b9);
process.env.NODE_ENV !== "production" && (Pp.displayName = "LeftOutlined");
const y9 = (e) => !isNaN(parseFloat(e)) && isFinite(e), w9 = /* @__PURE__ */ O.createContext({
  siderHook: {
    addSider: () => null,
    removeSider: () => null
  }
});
var C9 = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const gE = {
  xs: "479.98px",
  sm: "575.98px",
  md: "767.98px",
  lg: "991.98px",
  xl: "1199.98px",
  xxl: "1599.98px"
}, E1 = /* @__PURE__ */ O.createContext({}), S9 = /* @__PURE__ */ (() => {
  let e = 0;
  return function() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return e += 1, `${t}${e}`;
  };
})(), x9 = /* @__PURE__ */ O.forwardRef((e, t) => {
  const {
    prefixCls: n,
    className: r,
    trigger: i,
    children: o,
    defaultCollapsed: s = !1,
    theme: a = "dark",
    style: l = {},
    collapsible: u = !1,
    reverseArrow: c = !1,
    width: d = 200,
    collapsedWidth: f = 80,
    zeroWidthTriggerStyle: h,
    breakpoint: p,
    onCollapse: g,
    onBreakpoint: m
  } = e, v = C9(e, ["prefixCls", "className", "trigger", "children", "defaultCollapsed", "theme", "style", "collapsible", "reverseArrow", "width", "collapsedWidth", "zeroWidthTriggerStyle", "breakpoint", "onCollapse", "onBreakpoint"]), {
    siderHook: b
  } = Yt(w9), [x, w] = ht("collapsed" in e ? e.collapsed : s), [C, y] = ht(!1);
  Pe(() => {
    "collapsed" in e && w(e.collapsed);
  }, [e.collapsed]);
  const S = (D, E) => {
    "collapsed" in e || w(D), g == null || g(D, E);
  }, A = he();
  A.current = (D) => {
    y(D.matches), m == null || m(D.matches), x !== D.matches && S(D.matches, "responsive");
  }, Pe(() => {
    function D(R) {
      return A.current(R);
    }
    let E;
    if (typeof window < "u") {
      const {
        matchMedia: R
      } = window;
      if (R && p && p in gE) {
        E = R(`screen and (max-width: ${gE[p]})`);
        try {
          E.addEventListener("change", D);
        } catch {
          E.addListener(D);
        }
        D(E);
      }
    }
    return () => {
      try {
        E == null || E.removeEventListener("change", D);
      } catch {
        E == null || E.removeListener(D);
      }
    };
  }, [p]), Pe(() => {
    const D = S9("ant-sider-");
    return b.addSider(D), () => b.removeSider(D);
  }, []);
  const $ = () => {
    S(!x, "clickTrigger");
  }, {
    getPrefixCls: M
  } = Yt(rt), _ = () => {
    const D = M("layout-sider", n), E = zn(v, ["collapsed"]), R = x ? f : d, I = y9(R) ? `${R}px` : String(R), k = parseFloat(String(f || 0)) === 0 ? /* @__PURE__ */ O.createElement("span", {
      onClick: $,
      className: se(`${D}-zero-width-trigger`, `${D}-zero-width-trigger-${c ? "right" : "left"}`),
      style: h
    }, i || /* @__PURE__ */ O.createElement(OR, null)) : null, N = {
      expanded: c ? /* @__PURE__ */ O.createElement(Od, null) : /* @__PURE__ */ O.createElement(Pp, null),
      collapsed: c ? /* @__PURE__ */ O.createElement(Pp, null) : /* @__PURE__ */ O.createElement(Od, null)
    }[x ? "collapsed" : "expanded"], F = i !== null ? k || /* @__PURE__ */ O.createElement("div", {
      className: `${D}-trigger`,
      onClick: $,
      style: {
        width: I
      }
    }, i || N) : null, B = Object.assign(Object.assign({}, l), {
      flex: `0 0 ${I}`,
      maxWidth: I,
      minWidth: I,
      width: I
    }), j = se(D, `${D}-${a}`, {
      [`${D}-collapsed`]: !!x,
      [`${D}-has-trigger`]: u && i !== null && !k,
      [`${D}-below`]: !!C,
      [`${D}-zero-width`]: parseFloat(I) === 0
    }, r);
    return /* @__PURE__ */ O.createElement("aside", Object.assign({
      className: j
    }, E, {
      style: B,
      ref: t
    }), /* @__PURE__ */ O.createElement("div", {
      className: `${D}-children`
    }, o), u || C && k ? F : null);
  }, T = O.useMemo(() => ({
    siderCollapsed: x
  }), [x]);
  return /* @__PURE__ */ O.createElement(E1.Provider, {
    value: T
  }, _());
});
process.env.NODE_ENV !== "production" && (x9.displayName = "Sider");
var E9 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "ellipsis", theme: "outlined" }, $9 = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: E9
  }));
}, Qg = /* @__PURE__ */ O.forwardRef($9);
process.env.NODE_ENV !== "production" && (Qg.displayName = "EllipsisOutlined");
var O9 = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const AR = (e) => {
  const {
    prefixCls: t,
    className: n,
    dashed: r
  } = e, i = O9(e, ["prefixCls", "className", "dashed"]), {
    getPrefixCls: o
  } = O.useContext(rt), s = o("menu", t), a = se({
    [`${s}-item-divider-dashed`]: !!r
  }, n);
  return /* @__PURE__ */ O.createElement(x1, Object.assign({
    className: a
  }, i));
}, Np = /* @__PURE__ */ Yo({
  prefixCls: "",
  firstLevel: !0,
  inlineCollapsed: !1
}), DR = (e) => {
  var t;
  const {
    className: n,
    children: r,
    icon: i,
    title: o,
    danger: s
  } = e, {
    prefixCls: a,
    firstLevel: l,
    direction: u,
    disableMenuItemTitleTooltip: c,
    inlineCollapsed: d
  } = O.useContext(Np), f = (b) => {
    const x = /* @__PURE__ */ O.createElement("span", {
      className: `${a}-title-content`
    }, r);
    return (!i || /* @__PURE__ */ O.isValidElement(r) && r.type === "span") && r && b && l && typeof r == "string" ? /* @__PURE__ */ O.createElement("div", {
      className: `${a}-inline-collapsed-noicon`
    }, r.charAt(0)) : x;
  }, {
    siderCollapsed: h
  } = O.useContext(E1);
  let p = o;
  typeof o > "u" ? p = l ? r : "" : o === !1 && (p = "");
  const g = {
    title: p
  };
  !h && !d && (g.title = null, g.open = !1);
  const m = Xr(r).length;
  let v = /* @__PURE__ */ O.createElement(Sf, Object.assign({}, zn(e, ["title", "icon", "danger"]), {
    className: se({
      [`${a}-item-danger`]: s,
      [`${a}-item-only-child`]: (i ? m + 1 : m) === 1
    }, n),
    title: typeof o == "string" ? o : void 0
  }), oi(i, {
    className: se(/* @__PURE__ */ O.isValidElement(i) ? (t = i.props) === null || t === void 0 ? void 0 : t.className : "", `${a}-item-icon`)
  }), f(d));
  return c || (v = /* @__PURE__ */ O.createElement(lr, Object.assign({}, g, {
    placement: u === "rtl" ? "left" : "right",
    overlayClassName: `${a}-inline-collapsed-tooltip`
  }), v)), v;
}, _R = (e) => {
  var t;
  const {
    popupClassName: n,
    icon: r,
    title: i,
    theme: o
  } = e, s = O.useContext(Np), {
    prefixCls: a,
    inlineCollapsed: l,
    theme: u
  } = s, c = tu();
  let d;
  if (!r)
    d = l && !c.length && i && typeof i == "string" ? /* @__PURE__ */ O.createElement("div", {
      className: `${a}-inline-collapsed-noicon`
    }, i.charAt(0)) : /* @__PURE__ */ O.createElement("span", {
      className: `${a}-title-content`
    }, i);
  else {
    const p = /* @__PURE__ */ O.isValidElement(i) && i.type === "span";
    d = /* @__PURE__ */ O.createElement(O.Fragment, null, oi(r, {
      className: se(/* @__PURE__ */ O.isValidElement(r) ? (t = r.props) === null || t === void 0 ? void 0 : t.className : "", `${a}-item-icon`)
    }), p ? i : /* @__PURE__ */ O.createElement("span", {
      className: `${a}-title-content`
    }, i));
  }
  const f = O.useMemo(() => Object.assign(Object.assign({}, s), {
    firstLevel: !1
  }), [s]), [h] = Zc("Menu");
  return /* @__PURE__ */ O.createElement(Np.Provider, {
    value: f
  }, /* @__PURE__ */ O.createElement(Yg, Object.assign({}, zn(e, ["icon"]), {
    title: d,
    popupClassName: se(a, n, `${a}-${o || u}`),
    popupStyle: {
      zIndex: h
    }
  })));
};
var A9 = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
function Pb(e) {
  return (e || []).map((t, n) => {
    if (t && typeof t == "object") {
      const r = t, {
        label: i,
        children: o,
        key: s,
        type: a
      } = r, l = A9(r, ["label", "children", "key", "type"]), u = s ?? `tmp-${n}`;
      return o || a === "group" ? a === "group" ? /* @__PURE__ */ O.createElement(qg, Object.assign({
        key: u
      }, l, {
        title: i
      }), Pb(o)) : /* @__PURE__ */ O.createElement(_R, Object.assign({
        key: u
      }, l, {
        title: i
      }), Pb(o)) : a === "divider" ? /* @__PURE__ */ O.createElement(AR, Object.assign({
        key: u
      }, l)) : /* @__PURE__ */ O.createElement(DR, Object.assign({
        key: u
      }, l), i);
    }
    return null;
  }).filter((t) => t);
}
function D9(e) {
  return O.useMemo(() => e && Pb(e), [e]);
}
var _9 = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const Lp = /* @__PURE__ */ O.createContext(null), T9 = /* @__PURE__ */ O.forwardRef((e, t) => {
  const {
    children: n
  } = e, r = _9(e, ["children"]), i = O.useContext(Lp), o = O.useMemo(() => Object.assign(Object.assign({}, i), r), [
    i,
    r.prefixCls,
    // restProps.expandIcon, Not mark as deps since this is a ReactNode
    r.mode,
    r.selectable,
    r.rootClassName
    // restProps.validator, Not mark as deps since this is a function
  ]), s = bF(n), a = ba(t, s ? n.ref : null);
  return /* @__PURE__ */ O.createElement(Lp.Provider, {
    value: o
  }, /* @__PURE__ */ O.createElement(wd, null, s ? /* @__PURE__ */ O.cloneElement(n, {
    ref: a
  }) : n));
}), R9 = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n,
    horizontalLineHeight: r,
    colorSplit: i,
    lineWidth: o,
    lineType: s,
    itemPaddingInline: a
  } = e;
  return {
    [`${t}-horizontal`]: {
      lineHeight: r,
      border: 0,
      borderBottom: `${le(o)} ${s} ${i}`,
      boxShadow: "none",
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        content: '"\\20"'
      },
      // ======================= Item =======================
      [`${t}-item, ${t}-submenu`]: {
        position: "relative",
        display: "inline-block",
        verticalAlign: "bottom",
        paddingInline: a
      },
      [`> ${t}-item:hover,
        > ${t}-item-active,
        > ${t}-submenu ${t}-submenu-title:hover`]: {
        backgroundColor: "transparent"
      },
      [`${t}-item, ${t}-submenu-title`]: {
        transition: [`border-color ${n}`, `background ${n}`].join(",")
      },
      // ===================== Sub Menu =====================
      [`${t}-submenu-arrow`]: {
        display: "none"
      }
    }
  };
}, M9 = (e) => {
  let {
    componentCls: t,
    menuArrowOffset: n,
    calc: r
  } = e;
  return {
    [`${t}-rtl`]: {
      direction: "rtl"
    },
    [`${t}-submenu-rtl`]: {
      transformOrigin: "100% 0"
    },
    // Vertical Arrow
    [`${t}-rtl${t}-vertical,
    ${t}-submenu-rtl ${t}-vertical`]: {
      [`${t}-submenu-arrow`]: {
        "&::before": {
          transform: `rotate(-45deg) translateY(${le(r(n).mul(-1).equal())})`
        },
        "&::after": {
          transform: `rotate(45deg) translateY(${le(n)})`
        }
      }
    }
  };
}, mE = (e) => Object.assign({}, Mw(e)), vE = (e, t) => {
  const {
    componentCls: n,
    itemColor: r,
    itemSelectedColor: i,
    groupTitleColor: o,
    itemBg: s,
    subMenuItemBg: a,
    itemSelectedBg: l,
    activeBarHeight: u,
    activeBarWidth: c,
    activeBarBorderWidth: d,
    motionDurationSlow: f,
    motionEaseInOut: h,
    motionEaseOut: p,
    itemPaddingInline: g,
    motionDurationMid: m,
    itemHoverColor: v,
    lineType: b,
    colorSplit: x,
    // Disabled
    itemDisabledColor: w,
    // Danger
    dangerItemColor: C,
    dangerItemHoverColor: y,
    dangerItemSelectedColor: S,
    dangerItemActiveBg: A,
    dangerItemSelectedBg: $,
    // Bg
    popupBg: M,
    itemHoverBg: _,
    itemActiveBg: T,
    menuSubMenuBg: D,
    // Horizontal
    horizontalItemSelectedColor: E,
    horizontalItemSelectedBg: R,
    horizontalItemBorderRadius: I,
    horizontalItemHoverBg: k
  } = e;
  return {
    [`${n}-${t}, ${n}-${t} > ${n}`]: {
      color: r,
      background: s,
      [`&${n}-root:focus-visible`]: Object.assign({}, mE(e)),
      // ======================== Item ========================
      [`${n}-item-group-title`]: {
        color: o
      },
      [`${n}-submenu-selected`]: {
        [`> ${n}-submenu-title`]: {
          color: i
        }
      },
      [`${n}-item, ${n}-submenu-title`]: {
        color: r,
        [`&:not(${n}-item-disabled):focus-visible`]: Object.assign({}, mE(e))
      },
      // Disabled
      [`${n}-item-disabled, ${n}-submenu-disabled`]: {
        color: `${w} !important`
      },
      // Hover
      [`${n}-item:not(${n}-item-selected):not(${n}-submenu-selected)`]: {
        [`&:hover, > ${n}-submenu-title:hover`]: {
          color: v
        }
      },
      [`&:not(${n}-horizontal)`]: {
        [`${n}-item:not(${n}-item-selected)`]: {
          "&:hover": {
            backgroundColor: _
          },
          "&:active": {
            backgroundColor: T
          }
        },
        [`${n}-submenu-title`]: {
          "&:hover": {
            backgroundColor: _
          },
          "&:active": {
            backgroundColor: T
          }
        }
      },
      // Danger - only Item has
      [`${n}-item-danger`]: {
        color: C,
        [`&${n}-item:hover`]: {
          [`&:not(${n}-item-selected):not(${n}-submenu-selected)`]: {
            color: y
          }
        },
        [`&${n}-item:active`]: {
          background: A
        }
      },
      [`${n}-item a`]: {
        "&, &:hover": {
          color: "inherit"
        }
      },
      [`${n}-item-selected`]: {
        color: i,
        // Danger
        [`&${n}-item-danger`]: {
          color: S
        },
        "a, a:hover": {
          color: "inherit"
        }
      },
      [`& ${n}-item-selected`]: {
        backgroundColor: l,
        // Danger
        [`&${n}-item-danger`]: {
          backgroundColor: $
        }
      },
      [`&${n}-submenu > ${n}`]: {
        backgroundColor: D
      },
      // =====  =======
      // dark popupBg rest  darkPopupBg
      [`&${n}-popup > ${n}`]: {
        backgroundColor: M
      },
      [`&${n}-submenu-popup > ${n}`]: {
        backgroundColor: M
      },
      // =====  end =======
      // ====================== Horizontal ======================
      [`&${n}-horizontal`]: Object.assign(Object.assign({}, t === "dark" ? {
        borderBottom: 0
      } : {}), {
        [`> ${n}-item, > ${n}-submenu`]: {
          top: d,
          marginTop: e.calc(d).mul(-1).equal(),
          marginBottom: 0,
          borderRadius: I,
          "&::after": {
            position: "absolute",
            insetInline: g,
            bottom: 0,
            borderBottom: `${le(u)} solid transparent`,
            transition: `border-color ${f} ${h}`,
            content: '""'
          },
          "&:hover, &-active, &-open": {
            background: k,
            "&::after": {
              borderBottomWidth: u,
              borderBottomColor: E
            }
          },
          "&-selected": {
            color: E,
            backgroundColor: R,
            "&:hover": {
              backgroundColor: R
            },
            "&::after": {
              borderBottomWidth: u,
              borderBottomColor: E
            }
          }
        }
      }),
      // ================== Inline & Vertical ===================
      //
      [`&${n}-root`]: {
        [`&${n}-inline, &${n}-vertical`]: {
          borderInlineEnd: `${le(d)} ${b} ${x}`
        }
      },
      // ======================== Inline ========================
      [`&${n}-inline`]: {
        // Sub
        [`${n}-sub${n}-inline`]: {
          background: a
        },
        [`${n}-item`]: {
          position: "relative",
          "&::after": {
            position: "absolute",
            insetBlock: 0,
            insetInlineEnd: 0,
            borderInlineEnd: `${le(c)} solid ${i}`,
            transform: "scaleY(0.0001)",
            opacity: 0,
            transition: [`transform ${m} ${p}`, `opacity ${m} ${p}`].join(","),
            content: '""'
          },
          // Danger
          [`&${n}-item-danger`]: {
            "&::after": {
              borderInlineEndColor: S
            }
          }
        },
        [`${n}-selected, ${n}-item-selected`]: {
          "&::after": {
            transform: "scaleY(1)",
            opacity: 1,
            transition: [`transform ${m} ${h}`, `opacity ${m} ${h}`].join(",")
          }
        }
      }
    }
  };
}, bE = (e) => {
  const {
    componentCls: t,
    itemHeight: n,
    itemMarginInline: r,
    padding: i,
    menuArrowSize: o,
    marginXS: s,
    itemMarginBlock: a,
    itemWidth: l
  } = e, u = e.calc(o).add(i).add(s).equal();
  return {
    [`${t}-item`]: {
      position: "relative",
      overflow: "hidden"
    },
    [`${t}-item, ${t}-submenu-title`]: {
      height: n,
      lineHeight: le(n),
      paddingInline: i,
      overflow: "hidden",
      textOverflow: "ellipsis",
      marginInline: r,
      marginBlock: a,
      width: l
    },
    [`> ${t}-item,
            > ${t}-submenu > ${t}-submenu-title`]: {
      height: n,
      lineHeight: le(n)
    },
    [`${t}-item-group-list ${t}-submenu-title,
            ${t}-submenu-title`]: {
      paddingInlineEnd: u
    }
  };
}, I9 = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    itemHeight: r,
    colorTextLightSolid: i,
    dropdownWidth: o,
    controlHeightLG: s,
    motionDurationMid: a,
    motionEaseOut: l,
    paddingXL: u,
    itemMarginInline: c,
    fontSizeLG: d,
    motionDurationSlow: f,
    paddingXS: h,
    boxShadowSecondary: p,
    collapsedWidth: g,
    collapsedIconSize: m
  } = e, v = {
    height: r,
    lineHeight: le(r),
    listStylePosition: "inside",
    listStyleType: "disc"
  };
  return [
    {
      [t]: {
        "&-inline, &-vertical": Object.assign({
          [`&${t}-root`]: {
            boxShadow: "none"
          }
        }, bE(e))
      },
      [`${t}-submenu-popup`]: {
        [`${t}-vertical`]: Object.assign(Object.assign({}, bE(e)), {
          boxShadow: p
        })
      }
    },
    // Vertical only
    {
      [`${t}-submenu-popup ${t}-vertical${t}-sub`]: {
        minWidth: o,
        maxHeight: `calc(100vh - ${le(e.calc(s).mul(2.5).equal())})`,
        padding: "0",
        overflow: "hidden",
        borderInlineEnd: 0,
        // https://github.com/ant-design/ant-design/issues/22244
        // https://github.com/ant-design/ant-design/issues/26812
        "&:not([class*='-active'])": {
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    },
    // Inline Only
    {
      [`${t}-inline`]: {
        width: "100%",
        // Motion enhance for first level
        [`&${t}-root`]: {
          [`${t}-item, ${t}-submenu-title`]: {
            display: "flex",
            alignItems: "center",
            transition: [`border-color ${f}`, `background ${f}`, `padding ${a} ${l}`].join(","),
            [`> ${t}-title-content`]: {
              flex: "auto",
              minWidth: 0,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            "> *": {
              flex: "none"
            }
          }
        },
        // >>>>> Sub
        [`${t}-sub${t}-inline`]: {
          padding: 0,
          border: 0,
          borderRadius: 0,
          boxShadow: "none",
          [`& > ${t}-submenu > ${t}-submenu-title`]: v,
          [`& ${t}-item-group-title`]: {
            paddingInlineStart: u
          }
        },
        // >>>>> Item
        [`${t}-item`]: v
      }
    },
    // Inline Collapse Only
    {
      [`${t}-inline-collapsed`]: {
        width: g,
        [`&${t}-root`]: {
          [`${t}-item, ${t}-submenu ${t}-submenu-title`]: {
            [`> ${t}-inline-collapsed-noicon`]: {
              fontSize: d,
              textAlign: "center"
            }
          }
        },
        [`> ${t}-item,
          > ${t}-item-group > ${t}-item-group-list > ${t}-item,
          > ${t}-item-group > ${t}-item-group-list > ${t}-submenu > ${t}-submenu-title,
          > ${t}-submenu > ${t}-submenu-title`]: {
          insetInlineStart: 0,
          paddingInline: `calc(50% - ${le(e.calc(d).div(2).equal())} - ${le(c)})`,
          textOverflow: "clip",
          [`
            ${t}-submenu-arrow,
            ${t}-submenu-expand-icon
          `]: {
            opacity: 0
          },
          [`${t}-item-icon, ${n}`]: {
            margin: 0,
            fontSize: m,
            lineHeight: le(r),
            "+ span": {
              display: "inline-block",
              opacity: 0
            }
          }
        },
        [`${t}-item-icon, ${n}`]: {
          display: "inline-block"
        },
        "&-tooltip": {
          pointerEvents: "none",
          [`${t}-item-icon, ${n}`]: {
            display: "none"
          },
          "a, a:hover": {
            color: i
          }
        },
        [`${t}-item-group-title`]: Object.assign(Object.assign({}, la), {
          paddingInline: h
        })
      }
    }
  ];
}, yE = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n,
    motionDurationMid: r,
    motionEaseInOut: i,
    motionEaseOut: o,
    iconCls: s,
    iconSize: a,
    iconMarginInlineEnd: l
  } = e;
  return {
    // >>>>> Item
    [`${t}-item, ${t}-submenu-title`]: {
      position: "relative",
      display: "block",
      margin: 0,
      whiteSpace: "nowrap",
      cursor: "pointer",
      transition: [`border-color ${n}`, `background ${n}`, `padding ${n} ${i}`].join(","),
      [`${t}-item-icon, ${s}`]: {
        minWidth: a,
        fontSize: a,
        transition: [`font-size ${r} ${o}`, `margin ${n} ${i}`, `color ${n}`].join(","),
        "+ span": {
          marginInlineStart: l,
          opacity: 1,
          transition: [`opacity ${n} ${i}`, `margin ${n}`, `color ${n}`].join(",")
        }
      },
      [`${t}-item-icon`]: Object.assign({}, Rg()),
      [`&${t}-item-only-child`]: {
        [`> ${s}, > ${t}-item-icon`]: {
          marginInlineEnd: 0
        }
      }
    },
    // Disabled state sets text to gray and nukes hover/tab effects
    [`${t}-item-disabled, ${t}-submenu-disabled`]: {
      background: "none !important",
      cursor: "not-allowed",
      "&::after": {
        borderColor: "transparent !important"
      },
      a: {
        color: "inherit !important"
      },
      [`> ${t}-submenu-title`]: {
        color: "inherit !important",
        cursor: "not-allowed"
      }
    }
  };
}, wE = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n,
    motionEaseInOut: r,
    borderRadius: i,
    menuArrowSize: o,
    menuArrowOffset: s
  } = e;
  return {
    [`${t}-submenu`]: {
      "&-expand-icon, &-arrow": {
        position: "absolute",
        top: "50%",
        insetInlineEnd: e.margin,
        width: o,
        color: "currentcolor",
        transform: "translateY(-50%)",
        transition: `transform ${n} ${r}, opacity ${n}`
      },
      "&-arrow": {
        // 
        "&::before, &::after": {
          position: "absolute",
          width: e.calc(o).mul(0.6).equal(),
          height: e.calc(o).mul(0.15).equal(),
          backgroundColor: "currentcolor",
          borderRadius: i,
          transition: [`background ${n} ${r}`, `transform ${n} ${r}`, `top ${n} ${r}`, `color ${n} ${r}`].join(","),
          content: '""'
        },
        "&::before": {
          transform: `rotate(45deg) translateY(${le(e.calc(s).mul(-1).equal())})`
        },
        "&::after": {
          transform: `rotate(-45deg) translateY(${le(s)})`
        }
      }
    }
  };
}, k9 = (e) => {
  const {
    antCls: t,
    componentCls: n,
    fontSize: r,
    motionDurationSlow: i,
    motionDurationMid: o,
    motionEaseInOut: s,
    paddingXS: a,
    padding: l,
    colorSplit: u,
    lineWidth: c,
    zIndexPopup: d,
    borderRadiusLG: f,
    subMenuItemBorderRadius: h,
    menuArrowSize: p,
    menuArrowOffset: g,
    lineType: m,
    groupTitleLineHeight: v,
    groupTitleFontSize: b
  } = e;
  return [
    // Misc
    {
      "": {
        [`${n}`]: Object.assign(Object.assign({}, ca()), {
          // Hidden
          "&-hidden": {
            display: "none"
          }
        })
      },
      [`${n}-submenu-hidden`]: {
        display: "none"
      }
    },
    {
      [n]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, Gn(e)), ca()), {
        marginBottom: 0,
        paddingInlineStart: 0,
        // Override default ul/ol
        fontSize: r,
        lineHeight: 0,
        listStyle: "none",
        outline: "none",
        // Magic cubic here but smooth transition
        transition: `width ${i} cubic-bezier(0.2, 0, 0, 1) 0s`,
        "ul, ol": {
          margin: 0,
          padding: 0,
          listStyle: "none"
        },
        // Overflow ellipsis
        "&-overflow": {
          display: "flex",
          [`${n}-item`]: {
            flex: "none"
          }
        },
        [`${n}-item, ${n}-submenu, ${n}-submenu-title`]: {
          borderRadius: e.itemBorderRadius
        },
        [`${n}-item-group-title`]: {
          padding: `${le(a)} ${le(l)}`,
          fontSize: b,
          lineHeight: v,
          transition: `all ${i}`
        },
        [`&-horizontal ${n}-submenu`]: {
          transition: [`border-color ${i} ${s}`, `background ${i} ${s}`].join(",")
        },
        [`${n}-submenu, ${n}-submenu-inline`]: {
          transition: [`border-color ${i} ${s}`, `background ${i} ${s}`, `padding ${o} ${s}`].join(",")
        },
        [`${n}-submenu ${n}-sub`]: {
          cursor: "initial",
          transition: [`background ${i} ${s}`, `padding ${i} ${s}`].join(",")
        },
        [`${n}-title-content`]: {
          transition: `color ${i}`,
          // https://github.com/ant-design/ant-design/issues/41143
          [`> ${t}-typography-ellipsis-single-line`]: {
            display: "inline",
            verticalAlign: "unset"
          }
        },
        [`${n}-item a`]: {
          "&::before": {
            position: "absolute",
            inset: 0,
            backgroundColor: "transparent",
            content: '""'
          }
        },
        // Removed a Badge related style seems it's safe
        // https://github.com/ant-design/ant-design/issues/19809
        // >>>>> Divider
        [`${n}-item-divider`]: {
          overflow: "hidden",
          lineHeight: 0,
          borderColor: u,
          borderStyle: m,
          borderWidth: 0,
          borderTopWidth: c,
          marginBlock: c,
          padding: 0,
          "&-dashed": {
            borderStyle: "dashed"
          }
        }
      }), yE(e)), {
        [`${n}-item-group`]: {
          [`${n}-item-group-list`]: {
            margin: 0,
            padding: 0,
            [`${n}-item, ${n}-submenu-title`]: {
              paddingInline: `${le(e.calc(r).mul(2).equal())} ${le(l)}`
            }
          }
        },
        // ======================= Sub Menu =======================
        "&-submenu": {
          "&-popup": {
            position: "absolute",
            zIndex: d,
            borderRadius: f,
            boxShadow: "none",
            transformOrigin: "0 0",
            [`&${n}-submenu`]: {
              background: "transparent"
            },
            // https://github.com/ant-design/ant-design/issues/13955
            "&::before": {
              position: "absolute",
              inset: 0,
              zIndex: -1,
              width: "100%",
              height: "100%",
              opacity: 0,
              content: '""'
            },
            [`> ${n}`]: Object.assign(Object.assign(Object.assign({
              borderRadius: f
            }, yE(e)), wE(e)), {
              [`${n}-item, ${n}-submenu > ${n}-submenu-title`]: {
                borderRadius: h
              },
              [`${n}-submenu-title::after`]: {
                transition: `transform ${i} ${s}`
              }
            })
          },
          "\n          &-placement-leftTop,\n          &-placement-bottomRight,\n          ": {
            transformOrigin: "100% 0"
          },
          "\n          &-placement-leftBottom,\n          &-placement-topRight,\n          ": {
            transformOrigin: "100% 100%"
          },
          "\n          &-placement-rightBottom,\n          &-placement-topLeft,\n          ": {
            transformOrigin: "0 100%"
          },
          "\n          &-placement-bottomLeft,\n          &-placement-rightTop,\n          ": {
            transformOrigin: "0 0"
          },
          "\n          &-placement-leftTop,\n          &-placement-leftBottom\n          ": {
            paddingInlineEnd: e.paddingXS
          },
          "\n          &-placement-rightTop,\n          &-placement-rightBottom\n          ": {
            paddingInlineStart: e.paddingXS
          },
          "\n          &-placement-topRight,\n          &-placement-topLeft\n          ": {
            paddingBottom: e.paddingXS
          },
          "\n          &-placement-bottomRight,\n          &-placement-bottomLeft\n          ": {
            paddingTop: e.paddingXS
          }
        }
      }), wE(e)), {
        [`&-inline-collapsed ${n}-submenu-arrow,
        &-inline ${n}-submenu-arrow`]: {
          // 
          "&::before": {
            transform: `rotate(-45deg) translateX(${le(g)})`
          },
          "&::after": {
            transform: `rotate(45deg) translateX(${le(e.calc(g).mul(-1).equal())})`
          }
        },
        [`${n}-submenu-open${n}-submenu-inline > ${n}-submenu-title > ${n}-submenu-arrow`]: {
          // 
          transform: `translateY(${le(e.calc(p).mul(0.2).mul(-1).equal())})`,
          "&::after": {
            transform: `rotate(-45deg) translateX(${le(e.calc(g).mul(-1).equal())})`
          },
          "&::before": {
            transform: `rotate(45deg) translateX(${le(g)})`
          }
        }
      })
    },
    // Integration with header element so menu items have the same height
    {
      [`${t}-layout-header`]: {
        [n]: {
          lineHeight: "inherit"
        }
      }
    }
  ];
}, P9 = (e) => {
  var t, n, r;
  const {
    colorPrimary: i,
    colorError: o,
    colorTextDisabled: s,
    colorErrorBg: a,
    colorText: l,
    colorTextDescription: u,
    colorBgContainer: c,
    colorFillAlter: d,
    colorFillContent: f,
    lineWidth: h,
    lineWidthBold: p,
    controlItemBgActive: g,
    colorBgTextHover: m,
    controlHeightLG: v,
    lineHeight: b,
    colorBgElevated: x,
    marginXXS: w,
    padding: C,
    fontSize: y,
    controlHeightSM: S,
    fontSizeLG: A,
    colorTextLightSolid: $,
    colorErrorHover: M
  } = e, _ = (t = e.activeBarWidth) !== null && t !== void 0 ? t : 0, T = (n = e.activeBarBorderWidth) !== null && n !== void 0 ? n : h, D = (r = e.itemMarginInline) !== null && r !== void 0 ? r : e.marginXXS, E = new ir($).setAlpha(0.65).toRgbString();
  return {
    dropdownWidth: 160,
    zIndexPopup: e.zIndexPopupBase + 50,
    radiusItem: e.borderRadiusLG,
    itemBorderRadius: e.borderRadiusLG,
    radiusSubMenuItem: e.borderRadiusSM,
    subMenuItemBorderRadius: e.borderRadiusSM,
    colorItemText: l,
    itemColor: l,
    colorItemTextHover: l,
    itemHoverColor: l,
    colorItemTextHoverHorizontal: i,
    horizontalItemHoverColor: i,
    colorGroupTitle: u,
    groupTitleColor: u,
    colorItemTextSelected: i,
    itemSelectedColor: i,
    colorItemTextSelectedHorizontal: i,
    horizontalItemSelectedColor: i,
    colorItemBg: c,
    itemBg: c,
    colorItemBgHover: m,
    itemHoverBg: m,
    colorItemBgActive: f,
    itemActiveBg: g,
    colorSubItemBg: d,
    subMenuItemBg: d,
    colorItemBgSelected: g,
    itemSelectedBg: g,
    colorItemBgSelectedHorizontal: "transparent",
    horizontalItemSelectedBg: "transparent",
    colorActiveBarWidth: 0,
    activeBarWidth: _,
    colorActiveBarHeight: p,
    activeBarHeight: p,
    colorActiveBarBorderSize: h,
    activeBarBorderWidth: T,
    // Disabled
    colorItemTextDisabled: s,
    itemDisabledColor: s,
    // Danger
    colorDangerItemText: o,
    dangerItemColor: o,
    colorDangerItemTextHover: o,
    dangerItemHoverColor: o,
    colorDangerItemTextSelected: o,
    dangerItemSelectedColor: o,
    colorDangerItemBgActive: a,
    dangerItemActiveBg: a,
    colorDangerItemBgSelected: a,
    dangerItemSelectedBg: a,
    itemMarginInline: D,
    horizontalItemBorderRadius: 0,
    horizontalItemHoverBg: "transparent",
    itemHeight: v,
    groupTitleLineHeight: b,
    collapsedWidth: v * 2,
    popupBg: x,
    itemMarginBlock: w,
    itemPaddingInline: C,
    horizontalLineHeight: `${v * 1.15}px`,
    iconSize: y,
    iconMarginInlineEnd: S - y,
    collapsedIconSize: A,
    groupTitleFontSize: y,
    // Disabled
    darkItemDisabledColor: new ir($).setAlpha(0.25).toRgbString(),
    // Dark
    darkItemColor: E,
    darkDangerItemColor: o,
    darkItemBg: "#001529",
    darkPopupBg: "#001529",
    darkSubMenuItemBg: "#000c17",
    darkItemSelectedColor: $,
    darkItemSelectedBg: i,
    darkDangerItemSelectedBg: o,
    darkItemHoverBg: "transparent",
    darkGroupTitleColor: E,
    darkItemHoverColor: $,
    darkDangerItemHoverColor: M,
    darkDangerItemSelectedColor: $,
    darkDangerItemActiveBg: o,
    // internal
    itemWidth: _ ? `calc(100% + ${T}px)` : `calc(100% - ${D * 2}px)`
  };
}, N9 = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  return $n("Menu", (i) => {
    const {
      colorBgElevated: o,
      controlHeightLG: s,
      fontSize: a,
      darkItemColor: l,
      darkDangerItemColor: u,
      darkItemBg: c,
      darkSubMenuItemBg: d,
      darkItemSelectedColor: f,
      darkItemSelectedBg: h,
      darkDangerItemSelectedBg: p,
      darkItemHoverBg: g,
      darkGroupTitleColor: m,
      darkItemHoverColor: v,
      darkItemDisabledColor: b,
      darkDangerItemHoverColor: x,
      darkDangerItemSelectedColor: w,
      darkDangerItemActiveBg: C,
      popupBg: y,
      darkPopupBg: S
    } = i, A = i.calc(a).div(7).mul(5).equal(), $ = Jt(i, {
      menuArrowSize: A,
      menuHorizontalHeight: i.calc(s).mul(1.15).equal(),
      menuArrowOffset: i.calc(A).mul(0.25).equal(),
      menuSubMenuBg: o,
      calc: i.calc,
      popupBg: y
    }), M = Jt($, {
      itemColor: l,
      itemHoverColor: v,
      groupTitleColor: m,
      itemSelectedColor: f,
      itemBg: c,
      popupBg: S,
      subMenuItemBg: d,
      itemActiveBg: "transparent",
      itemSelectedBg: h,
      activeBarHeight: 0,
      activeBarBorderWidth: 0,
      itemHoverBg: g,
      // Disabled
      itemDisabledColor: b,
      // Danger
      dangerItemColor: u,
      dangerItemHoverColor: x,
      dangerItemSelectedColor: w,
      dangerItemActiveBg: C,
      dangerItemSelectedBg: p,
      menuSubMenuBg: d,
      // Horizontal
      horizontalItemSelectedColor: f,
      horizontalItemSelectedBg: h
    });
    return [
      // Basic
      k9($),
      // Horizontal
      R9($),
      // Hard code for some light style
      // Vertical
      I9($),
      // Hard code for some light style
      // Theme
      vE($, "light"),
      vE(M, "dark"),
      // RTL
      M9($),
      // Motion
      sT($),
      ua($, "slide-up"),
      ua($, "slide-down"),
      vf($, "zoom-big")
    ];
  }, P9, {
    deprecatedTokens: [["colorGroupTitle", "groupTitleColor"], ["radiusItem", "itemBorderRadius"], ["radiusSubMenuItem", "subMenuItemBorderRadius"], ["colorItemText", "itemColor"], ["colorItemTextHover", "itemHoverColor"], ["colorItemTextHoverHorizontal", "horizontalItemHoverColor"], ["colorItemTextSelected", "itemSelectedColor"], ["colorItemTextSelectedHorizontal", "horizontalItemSelectedColor"], ["colorItemTextDisabled", "itemDisabledColor"], ["colorDangerItemText", "dangerItemColor"], ["colorDangerItemTextHover", "dangerItemHoverColor"], ["colorDangerItemTextSelected", "dangerItemSelectedColor"], ["colorDangerItemBgActive", "dangerItemActiveBg"], ["colorDangerItemBgSelected", "dangerItemSelectedBg"], ["colorItemBg", "itemBg"], ["colorItemBgHover", "itemHoverBg"], ["colorSubItemBg", "subMenuItemBg"], ["colorItemBgActive", "itemActiveBg"], ["colorItemBgSelectedHorizontal", "horizontalItemSelectedBg"], ["colorActiveBarWidth", "activeBarWidth"], ["colorActiveBarHeight", "activeBarHeight"], ["colorActiveBarBorderSize", "activeBarBorderWidth"], ["colorItemBgSelected", "itemSelectedBg"]],
    // Dropdown will handle menu style self. We do not need to handle this.
    injectStyle: n,
    unitless: {
      groupTitleLineHeight: !0
    }
  })(e, t);
};
var L9 = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
function av(e) {
  return e === null || e === !1;
}
const F9 = /* @__PURE__ */ li((e, t) => {
  var n;
  const r = O.useContext(Lp), i = r || {}, {
    getPrefixCls: o,
    getPopupContainer: s,
    direction: a,
    menu: l
  } = O.useContext(rt), u = o(), {
    prefixCls: c,
    className: d,
    style: f,
    theme: h = "light",
    expandIcon: p,
    _internalDisableMenuItemTitleTooltip: g,
    inlineCollapsed: m,
    siderCollapsed: v,
    items: b,
    children: x,
    rootClassName: w,
    mode: C,
    selectable: y,
    onClick: S,
    overflowedIndicatorPopupClassName: A
  } = e, $ = L9(e, ["prefixCls", "className", "style", "theme", "expandIcon", "_internalDisableMenuItemTitleTooltip", "inlineCollapsed", "siderCollapsed", "items", "children", "rootClassName", "mode", "selectable", "onClick", "overflowedIndicatorPopupClassName"]), M = zn($, ["collapsedWidth"]), _ = D9(b) || x;
  if (process.env.NODE_ENV !== "production") {
    const H = Zt("Menu");
    process.env.NODE_ENV !== "production" && H(!("inlineCollapsed" in e && C !== "inline"), "usage", "`inlineCollapsed` should only be used when `mode` is inline."), process.env.NODE_ENV !== "production" && H(!(e.siderCollapsed !== void 0 && "inlineCollapsed" in e), "usage", "`inlineCollapsed` not control Menu under Sider. Should set `collapsed` on Sider instead."), H.deprecated("items" in e && !x, "children", "items");
  }
  (n = i.validator) === null || n === void 0 || n.call(i, {
    mode: C
  });
  const T = Nn(function() {
    var H;
    S == null || S.apply(void 0, arguments), (H = i.onClick) === null || H === void 0 || H.call(i);
  }), D = i.mode || C, E = y ?? i.selectable, R = O.useMemo(() => v !== void 0 ? v : m, [m, v]), I = {
    horizontal: {
      motionName: `${u}-slide-up`
    },
    inline: cb(u),
    other: {
      motionName: `${u}-zoom-big`
    }
  }, k = o("menu", c || i.prefixCls), P = Kn(k), [L, N, F] = N9(k, P, !r), B = se(`${k}-${h}`, l == null ? void 0 : l.className, d), j = O.useMemo(() => {
    var H, W;
    if (typeof p == "function" || av(p))
      return p || null;
    if (typeof i.expandIcon == "function" || av(i.expandIcon))
      return i.expandIcon || null;
    if (typeof (l == null ? void 0 : l.expandIcon) == "function" || av(l == null ? void 0 : l.expandIcon))
      return (l == null ? void 0 : l.expandIcon) || null;
    const G = (H = p ?? (i == null ? void 0 : i.expandIcon)) !== null && H !== void 0 ? H : l == null ? void 0 : l.expandIcon;
    return oi(G, {
      className: se(`${k}-submenu-expand-icon`, /* @__PURE__ */ O.isValidElement(G) ? (W = G.props) === null || W === void 0 ? void 0 : W.className : void 0)
    });
  }, [p, i == null ? void 0 : i.expandIcon, l == null ? void 0 : l.expandIcon, k]), z = O.useMemo(() => ({
    prefixCls: k,
    inlineCollapsed: R || !1,
    direction: a,
    firstLevel: !0,
    theme: h,
    mode: D,
    disableMenuItemTitleTooltip: g
  }), [k, R, a, g, h]);
  return L(/* @__PURE__ */ O.createElement(Lp.Provider, {
    value: null
  }, /* @__PURE__ */ O.createElement(Np.Provider, {
    value: z
  }, /* @__PURE__ */ O.createElement(nu, Object.assign({
    getPopupContainer: s,
    overflowedIndicator: /* @__PURE__ */ O.createElement(Qg, null),
    overflowedIndicatorPopupClassName: se(k, `${k}-${h}`, A),
    mode: D,
    selectable: E,
    onClick: T
  }, M, {
    inlineCollapsed: R,
    style: Object.assign(Object.assign({}, l == null ? void 0 : l.style), f),
    className: B,
    prefixCls: k,
    direction: a,
    defaultMotions: I,
    expandIcon: j,
    ref: t,
    rootClassName: se(w, N, i.rootClassName, F, P)
  }), _))));
}), ru = /* @__PURE__ */ li((e, t) => {
  const n = he(null), r = O.useContext(E1);
  return fl(t, () => ({
    menu: n.current,
    focus: (i) => {
      var o;
      (o = n.current) === null || o === void 0 || o.focus(i);
    }
  })), /* @__PURE__ */ O.createElement(F9, Object.assign({
    ref: n
  }, e, r));
});
ru.Item = DR;
ru.SubMenu = _R;
ru.Divider = AR;
ru.ItemGroup = qg;
process.env.NODE_ENV !== "production" && (ru.displayName = "Menu");
const B9 = (e) => {
  const {
    componentCls: t,
    menuCls: n,
    colorError: r,
    colorTextLightSolid: i
  } = e, o = `${n}-item`;
  return {
    [`${t}, ${t}-menu-submenu`]: {
      [`${n} ${o}`]: {
        [`&${o}-danger:not(${o}-disabled)`]: {
          color: r,
          "&:hover": {
            color: i,
            backgroundColor: r
          }
        }
      }
    }
  };
}, j9 = (e) => {
  const {
    componentCls: t,
    menuCls: n,
    zIndexPopup: r,
    dropdownArrowDistance: i,
    sizePopupArrow: o,
    antCls: s,
    iconCls: a,
    motionDurationMid: l,
    paddingBlock: u,
    fontSize: c,
    dropdownEdgeChildPadding: d,
    colorTextDisabled: f,
    fontSizeIcon: h,
    controlPaddingHorizontal: p,
    colorBgElevated: g
  } = e;
  return [
    {
      [t]: Object.assign(Object.assign({}, Gn(e)), {
        position: "absolute",
        top: -9999,
        left: {
          _skip_check_: !0,
          value: -9999
        },
        zIndex: r,
        display: "block",
        // A placeholder out of dropdown visible range to avoid close when user moving
        "&::before": {
          position: "absolute",
          insetBlock: e.calc(o).div(2).sub(i).equal(),
          // insetInlineStart: -7, // FIXME: Seems not work for hidden element
          zIndex: -9999,
          opacity: 1e-4,
          content: '""'
        },
        [`&-trigger${s}-btn`]: {
          [`& > ${a}-down, & > ${s}-btn-icon > ${a}-down`]: {
            fontSize: h
          }
        },
        [`${t}-wrap`]: {
          position: "relative",
          [`${s}-btn > ${a}-down`]: {
            fontSize: h
          },
          [`${a}-down::before`]: {
            transition: `transform ${l}`
          }
        },
        [`${t}-wrap-open`]: {
          [`${a}-down::before`]: {
            transform: "rotate(180deg)"
          }
        },
        "\n        &-hidden,\n        &-menu-hidden,\n        &-menu-submenu-hidden\n      ": {
          display: "none"
        },
        // =============================================================
        // ==                         Motion                          ==
        // =============================================================
        // When position is not enough for dropdown, the placement will revert.
        // We will handle this with revert motion name.
        [`&${s}-slide-down-enter${s}-slide-down-enter-active${t}-placement-bottomLeft,
          &${s}-slide-down-appear${s}-slide-down-appear-active${t}-placement-bottomLeft,
          &${s}-slide-down-enter${s}-slide-down-enter-active${t}-placement-bottom,
          &${s}-slide-down-appear${s}-slide-down-appear-active${t}-placement-bottom,
          &${s}-slide-down-enter${s}-slide-down-enter-active${t}-placement-bottomRight,
          &${s}-slide-down-appear${s}-slide-down-appear-active${t}-placement-bottomRight`]: {
          animationName: Xw
        },
        [`&${s}-slide-up-enter${s}-slide-up-enter-active${t}-placement-topLeft,
          &${s}-slide-up-appear${s}-slide-up-appear-active${t}-placement-topLeft,
          &${s}-slide-up-enter${s}-slide-up-enter-active${t}-placement-top,
          &${s}-slide-up-appear${s}-slide-up-appear-active${t}-placement-top,
          &${s}-slide-up-enter${s}-slide-up-enter-active${t}-placement-topRight,
          &${s}-slide-up-appear${s}-slide-up-appear-active${t}-placement-topRight`]: {
          animationName: qw
        },
        [`&${s}-slide-down-leave${s}-slide-down-leave-active${t}-placement-bottomLeft,
          &${s}-slide-down-leave${s}-slide-down-leave-active${t}-placement-bottom,
          &${s}-slide-down-leave${s}-slide-down-leave-active${t}-placement-bottomRight`]: {
          animationName: Yw
        },
        [`&${s}-slide-up-leave${s}-slide-up-leave-active${t}-placement-topLeft,
          &${s}-slide-up-leave${s}-slide-up-leave-active${t}-placement-top,
          &${s}-slide-up-leave${s}-slide-up-leave-active${t}-placement-topRight`]: {
          animationName: Qw
        }
      })
    },
    // =============================================================
    // ==                        Arrow style                      ==
    // =============================================================
    v1(e, g, {
      arrowPlacement: {
        top: !0,
        bottom: !0
      }
    }),
    {
      // =============================================================
      // ==                          Menu                           ==
      // =============================================================
      [`${t} ${n}`]: {
        position: "relative",
        margin: 0
      },
      [`${n}-submenu-popup`]: {
        position: "absolute",
        zIndex: r,
        background: "transparent",
        boxShadow: "none",
        transformOrigin: "0 0",
        "ul, li": {
          listStyle: "none",
          margin: 0
        }
      },
      [`${t}, ${t}-menu-submenu`]: {
        [n]: Object.assign(Object.assign({
          padding: d,
          listStyleType: "none",
          backgroundColor: g,
          backgroundClip: "padding-box",
          borderRadius: e.borderRadiusLG,
          outline: "none",
          boxShadow: e.boxShadowSecondary
        }, Za(e)), {
          "&:empty": {
            padding: 0,
            boxShadow: "none"
          },
          [`${n}-item-group-title`]: {
            padding: `${le(u)} ${le(p)}`,
            color: e.colorTextDescription,
            transition: `all ${l}`
          },
          // ======================= Item Content =======================
          [`${n}-item`]: {
            position: "relative",
            display: "flex",
            alignItems: "center"
          },
          [`${n}-item-icon`]: {
            minWidth: c,
            marginInlineEnd: e.marginXS,
            fontSize: e.fontSizeSM
          },
          [`${n}-title-content`]: {
            flex: "auto",
            "> a": {
              color: "inherit",
              transition: `all ${l}`,
              "&:hover": {
                color: "inherit"
              },
              "&::after": {
                position: "absolute",
                inset: 0,
                content: '""'
              }
            }
          },
          // =========================== Item ===========================
          [`${n}-item, ${n}-submenu-title`]: Object.assign(Object.assign({
            clear: "both",
            margin: 0,
            padding: `${le(u)} ${le(p)}`,
            color: e.colorText,
            fontWeight: "normal",
            fontSize: c,
            lineHeight: e.lineHeight,
            cursor: "pointer",
            transition: `all ${l}`,
            borderRadius: e.borderRadiusSM,
            "&:hover, &-active": {
              backgroundColor: e.controlItemBgHover
            }
          }, Za(e)), {
            "&-selected": {
              color: e.colorPrimary,
              backgroundColor: e.controlItemBgActive,
              "&:hover, &-active": {
                backgroundColor: e.controlItemBgActiveHover
              }
            },
            "&-disabled": {
              color: f,
              cursor: "not-allowed",
              "&:hover": {
                color: f,
                backgroundColor: g,
                cursor: "not-allowed"
              },
              a: {
                pointerEvents: "none"
              }
            },
            "&-divider": {
              height: 1,
              // By design
              margin: `${le(e.marginXXS)} 0`,
              overflow: "hidden",
              lineHeight: 0,
              backgroundColor: e.colorSplit
            },
            [`${t}-menu-submenu-expand-icon`]: {
              position: "absolute",
              insetInlineEnd: e.paddingXS,
              [`${t}-menu-submenu-arrow-icon`]: {
                marginInlineEnd: "0 !important",
                color: e.colorTextDescription,
                fontSize: h,
                fontStyle: "normal"
              }
            }
          }),
          [`${n}-item-group-list`]: {
            margin: `0 ${le(e.marginXS)}`,
            padding: 0,
            listStyle: "none"
          },
          [`${n}-submenu-title`]: {
            paddingInlineEnd: e.calc(p).add(e.fontSizeSM).equal()
          },
          [`${n}-submenu-vertical`]: {
            position: "relative"
          },
          [`${n}-submenu${n}-submenu-disabled ${t}-menu-submenu-title`]: {
            [`&, ${t}-menu-submenu-arrow-icon`]: {
              color: f,
              backgroundColor: g,
              cursor: "not-allowed"
            }
          },
          // https://github.com/ant-design/ant-design/issues/19264
          [`${n}-submenu-selected ${t}-menu-submenu-title`]: {
            color: e.colorPrimary
          }
        })
      }
    },
    // Follow code may reuse in other components
    [ua(e, "slide-up"), ua(e, "slide-down"), Tp(e, "move-up"), Tp(e, "move-down"), vf(e, "zoom-big")]
  ];
}, z9 = (e) => Object.assign(Object.assign({
  zIndexPopup: e.zIndexPopupBase + 50,
  paddingBlock: (e.controlHeight - e.fontSize * e.lineHeight) / 2
}, Gg({
  contentRadius: e.borderRadiusLG,
  limitVerticalRadius: !0
})), m1(e)), H9 = $n("Dropdown", (e) => {
  const {
    marginXXS: t,
    sizePopupArrow: n,
    paddingXXS: r,
    componentCls: i
  } = e, o = Jt(e, {
    menuCls: `${i}-menu`,
    dropdownArrowDistance: e.calc(n).div(2).add(t).equal(),
    dropdownEdgeChildPadding: r
  });
  return [j9(o), B9(o)];
}, z9), xf = (e) => {
  const {
    menu: t,
    arrow: n,
    prefixCls: r,
    children: i,
    trigger: o,
    disabled: s,
    dropdownRender: a,
    getPopupContainer: l,
    overlayClassName: u,
    rootClassName: c,
    overlayStyle: d,
    open: f,
    onOpenChange: h,
    // Deprecated
    visible: p,
    onVisibleChange: g,
    mouseEnterDelay: m = 0.15,
    mouseLeaveDelay: v = 0.1,
    autoAdjustOverflow: b = !0,
    placement: x = "",
    overlay: w,
    transitionName: C
  } = e, {
    getPopupContainer: y,
    getPrefixCls: S,
    direction: A,
    dropdown: $
  } = O.useContext(rt), M = Zt("Dropdown");
  process.env.NODE_ENV !== "production" && ([["visible", "open"], ["onVisibleChange", "onOpenChange"]].forEach((ne) => {
    let [q, te] = ne;
    M.deprecated(!(q in e), q, te);
  }), M.deprecated(!("overlay" in e), "overlay", "menu"));
  const _ = O.useMemo(() => {
    const ne = S();
    return C !== void 0 ? C : x.includes("top") ? `${ne}-slide-down` : `${ne}-slide-up`;
  }, [S, x, C]), T = O.useMemo(() => x ? x.includes("Center") ? x.slice(0, x.indexOf("Center")) : x : A === "rtl" ? "bottomRight" : "bottomLeft", [x, A]);
  if (process.env.NODE_ENV !== "production") {
    if (x.includes("Center")) {
      const ne = x.slice(0, x.indexOf("Center"));
      process.env.NODE_ENV !== "production" && M(!x.includes("Center"), "deprecated", `You are using '${x}' placement in Dropdown, which is deprecated. Try to use '${ne}' instead.`);
    }
    [["visible", "open"], ["onVisibleChange", "onOpenChange"]].forEach((ne) => {
      let [q, te] = ne;
      M.deprecated(!(q in e), q, te);
    });
  }
  const D = S("dropdown", r), E = Kn(D), [R, I, k] = H9(D, E), [, P] = Sr(), L = O.Children.only(i), N = oi(L, {
    className: se(`${D}-trigger`, {
      [`${D}-rtl`]: A === "rtl"
    }, L.props.className),
    disabled: s
  }), F = s ? [] : o;
  let B;
  F && F.includes("contextMenu") && (B = !0);
  const [j, z] = Un(!1, {
    value: f ?? p
  }), H = Nn((ne) => {
    h == null || h(ne, {
      source: "trigger"
    }), g == null || g(ne), z(ne);
  }), W = se(u, c, I, k, E, $ == null ? void 0 : $.className, {
    [`${D}-rtl`]: A === "rtl"
  }), G = lR({
    arrowPointAtCenter: typeof n == "object" && n.pointAtCenter,
    autoAdjustOverflow: b,
    offset: P.marginXXS,
    arrowWidth: n ? P.sizePopupArrow : 0,
    borderRadius: P.borderRadius
  }), K = O.useCallback(() => {
    t != null && t.selectable && (t != null && t.multiple) || (h == null || h(!1, {
      source: "menu"
    }), z(!1));
  }, [t == null ? void 0 : t.selectable, t == null ? void 0 : t.multiple]), Y = () => {
    let ne;
    return t != null && t.items ? ne = /* @__PURE__ */ O.createElement(ru, Object.assign({}, t)) : typeof w == "function" ? ne = w() : ne = w, a && (ne = a(ne)), ne = O.Children.only(typeof ne == "string" ? /* @__PURE__ */ O.createElement("span", null, ne) : ne), /* @__PURE__ */ O.createElement(T9, {
      prefixCls: `${D}-menu`,
      rootClassName: se(k, E),
      expandIcon: /* @__PURE__ */ O.createElement("span", {
        className: `${D}-menu-submenu-arrow`
      }, /* @__PURE__ */ O.createElement(Od, {
        className: `${D}-menu-submenu-arrow-icon`
      })),
      mode: "vertical",
      selectable: !1,
      onClick: K,
      validator: (q) => {
        let {
          mode: te
        } = q;
        process.env.NODE_ENV !== "production" && M(!te || te === "vertical", "usage", `mode="${te}" is not supported for Dropdown's Menu.`);
      }
    }, ne);
  }, [X, Z] = Zc("Dropdown", d == null ? void 0 : d.zIndex);
  let Q = /* @__PURE__ */ O.createElement(pR, Object.assign({
    alignPoint: B
  }, zn(e, ["rootClassName"]), {
    mouseEnterDelay: m,
    mouseLeaveDelay: v,
    visible: j,
    builtinPlacements: G,
    arrow: !!n,
    overlayClassName: W,
    prefixCls: D,
    getPopupContainer: l || y,
    transitionName: _,
    trigger: F,
    overlay: Y,
    placement: T,
    onVisibleChange: H,
    overlayStyle: Object.assign(Object.assign(Object.assign({}, $ == null ? void 0 : $.style), d), {
      zIndex: X
    })
  }), N);
  return X && (Q = /* @__PURE__ */ O.createElement(hf.Provider, {
    value: Z
  }, Q)), R(Q);
};
function V9(e) {
  return Object.assign(Object.assign({}, e), {
    align: {
      overflow: {
        adjustX: !1,
        adjustY: !1
      }
    }
  });
}
const W9 = t1(xf, "dropdown", (e) => e, V9), U9 = (e) => /* @__PURE__ */ O.createElement(W9, Object.assign({}, e), /* @__PURE__ */ O.createElement("span", null));
xf._InternalPanelDoNotUseOrYouWillBeFired = U9;
process.env.NODE_ENV !== "production" && (xf.displayName = "Dropdown");
var G9 = ["prefixCls", "className", "style", "checked", "disabled", "defaultChecked", "type", "title", "onChange"], K9 = /* @__PURE__ */ li(function(e, t) {
  var n = e.prefixCls, r = n === void 0 ? "rc-checkbox" : n, i = e.className, o = e.style, s = e.checked, a = e.disabled, l = e.defaultChecked, u = l === void 0 ? !1 : l, c = e.type, d = c === void 0 ? "checkbox" : c, f = e.title, h = e.onChange, p = Rt(e, G9), g = he(null), m = Un(u, {
    value: s
  }), v = ae(m, 2), b = v[0], x = v[1];
  fl(t, function() {
    return {
      focus: function(S) {
        var A;
        (A = g.current) === null || A === void 0 || A.focus(S);
      },
      blur: function() {
        var S;
        (S = g.current) === null || S === void 0 || S.blur();
      },
      input: g.current
    };
  });
  var w = se(r, i, re(re({}, "".concat(r, "-checked"), b), "".concat(r, "-disabled"), a)), C = function(S) {
    a || ("checked" in e || x(S.target.checked), h == null || h({
      target: ie(ie({}, e), {}, {
        type: d,
        checked: S.target.checked
      }),
      stopPropagation: function() {
        S.stopPropagation();
      },
      preventDefault: function() {
        S.preventDefault();
      },
      nativeEvent: S.nativeEvent
    }));
  };
  return /* @__PURE__ */ O.createElement("span", {
    className: w,
    title: f,
    style: o
  }, /* @__PURE__ */ O.createElement("input", we({}, p, {
    className: "".concat(r, "-input"),
    ref: g,
    onChange: C,
    disabled: a,
    checked: !!b,
    type: d
  })), /* @__PURE__ */ O.createElement("span", {
    className: "".concat(r, "-inner")
  }));
});
function TR(e) {
  return Jt(e, {
    inputAffixPadding: e.paddingXXS
  });
}
const RR = (e) => {
  const {
    controlHeight: t,
    fontSize: n,
    lineHeight: r,
    lineWidth: i,
    controlHeightSM: o,
    controlHeightLG: s,
    fontSizeLG: a,
    lineHeightLG: l,
    paddingSM: u,
    controlPaddingHorizontalSM: c,
    controlPaddingHorizontal: d,
    colorFillAlter: f,
    colorPrimaryHover: h,
    colorPrimary: p,
    controlOutlineWidth: g,
    controlOutline: m,
    colorErrorOutline: v,
    colorWarningOutline: b,
    colorBgContainer: x
  } = e;
  return {
    paddingBlock: Math.max(Math.round((t - n * r) / 2 * 10) / 10 - i, 0),
    paddingBlockSM: Math.max(Math.round((o - n * r) / 2 * 10) / 10 - i, 0),
    paddingBlockLG: Math.ceil((s - a * l) / 2 * 10) / 10 - i,
    paddingInline: u - i,
    paddingInlineSM: c - i,
    paddingInlineLG: d - i,
    addonBg: f,
    activeBorderColor: p,
    hoverBorderColor: h,
    activeShadow: `0 0 0 ${g}px ${m}`,
    errorActiveShadow: `0 0 0 ${g}px ${v}`,
    warningActiveShadow: `0 0 0 ${g}px ${b}`,
    hoverBg: x,
    activeBg: x,
    inputFontSize: n,
    inputFontSizeLG: a,
    inputFontSizeSM: n
  };
}, X9 = (e) => ({
  borderColor: e.hoverBorderColor,
  backgroundColor: e.hoverBg
}), $1 = (e) => ({
  color: e.colorTextDisabled,
  backgroundColor: e.colorBgContainerDisabled,
  borderColor: e.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  "input[disabled]": {
    cursor: "not-allowed"
  },
  "&:hover:not([disabled])": Object.assign({}, X9(Jt(e, {
    hoverBorderColor: e.colorBorder,
    hoverBg: e.colorBgContainerDisabled
  })))
}), MR = (e, t) => ({
  background: e.colorBgContainer,
  borderWidth: e.lineWidth,
  borderStyle: e.lineType,
  borderColor: t.borderColor,
  "&:hover": {
    borderColor: t.hoverBorderColor,
    backgroundColor: e.hoverBg
  },
  "&:focus, &:focus-within": {
    borderColor: t.activeBorderColor,
    boxShadow: t.activeShadow,
    outline: 0,
    backgroundColor: e.activeBg
  }
}), CE = (e, t) => ({
  [`&${e.componentCls}-status-${t.status}:not(${e.componentCls}-disabled)`]: Object.assign(Object.assign({}, MR(e, t)), {
    [`${e.componentCls}-prefix, ${e.componentCls}-suffix`]: {
      color: t.affixColor
    }
  })
}), Y9 = (e, t) => ({
  "&-outlined": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, MR(e, {
    borderColor: e.colorBorder,
    hoverBorderColor: e.hoverBorderColor,
    activeBorderColor: e.activeBorderColor,
    activeShadow: e.activeShadow
  })), {
    [`&${e.componentCls}-disabled, &[disabled]`]: Object.assign({}, $1(e))
  }), CE(e, {
    status: "error",
    borderColor: e.colorError,
    hoverBorderColor: e.colorErrorBorderHover,
    activeBorderColor: e.colorError,
    activeShadow: e.errorActiveShadow,
    affixColor: e.colorError
  })), CE(e, {
    status: "warning",
    borderColor: e.colorWarning,
    hoverBorderColor: e.colorWarningBorderHover,
    activeBorderColor: e.colorWarning,
    activeShadow: e.warningActiveShadow,
    affixColor: e.colorWarning
  })), t)
}), SE = (e, t) => ({
  [`&${e.componentCls}-group-wrapper-status-${t.status}`]: {
    [`${e.componentCls}-group-addon`]: {
      borderColor: t.addonBorderColor,
      color: t.addonColor
    }
  }
}), q9 = (e) => ({
  "&-outlined": Object.assign(Object.assign(Object.assign({
    [`${e.componentCls}-group`]: {
      "&-addon": {
        background: e.addonBg,
        border: `${le(e.lineWidth)} ${e.lineType} ${e.colorBorder}`
      },
      "&-addon:first-child": {
        borderInlineEnd: 0
      },
      "&-addon:last-child": {
        borderInlineStart: 0
      }
    }
  }, SE(e, {
    status: "error",
    addonBorderColor: e.colorError,
    addonColor: e.colorErrorText
  })), SE(e, {
    status: "warning",
    addonBorderColor: e.colorWarning,
    addonColor: e.colorWarningText
  })), {
    [`&${e.componentCls}-group-wrapper-disabled`]: {
      [`${e.componentCls}-group-addon`]: Object.assign({}, $1(e))
    }
  })
}), Q9 = (e, t) => ({
  "&-borderless": Object.assign({
    background: "transparent",
    border: "none",
    "&:focus, &:focus-within": {
      outline: "none"
    },
    [`&${e.componentCls}-disabled, &[disabled]`]: {
      color: e.colorTextDisabled
    }
  }, t)
}), IR = (e, t) => ({
  background: t.bg,
  borderWidth: e.lineWidth,
  borderStyle: e.lineType,
  borderColor: "transparent",
  "input&, & input, textarea&, & textarea": {
    color: t == null ? void 0 : t.inputColor
  },
  "&:hover": {
    background: t.hoverBg
  },
  "&:focus, &:focus-within": {
    outline: 0,
    borderColor: t.activeBorderColor,
    backgroundColor: e.activeBg
  }
}), xE = (e, t) => ({
  [`&${e.componentCls}-status-${t.status}:not(${e.componentCls}-disabled)`]: Object.assign(Object.assign({}, IR(e, t)), {
    [`${e.componentCls}-prefix, ${e.componentCls}-suffix`]: {
      color: t.affixColor
    }
  })
}), Z9 = (e, t) => ({
  "&-filled": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, IR(e, {
    bg: e.colorFillTertiary,
    hoverBg: e.colorFillSecondary,
    activeBorderColor: e.colorPrimary
  })), {
    [`&${e.componentCls}-disabled, &[disabled]`]: Object.assign({}, $1(e))
  }), xE(e, {
    status: "error",
    bg: e.colorErrorBg,
    hoverBg: e.colorErrorBgHover,
    activeBorderColor: e.colorError,
    inputColor: e.colorErrorText,
    affixColor: e.colorError
  })), xE(e, {
    status: "warning",
    bg: e.colorWarningBg,
    hoverBg: e.colorWarningBgHover,
    activeBorderColor: e.colorWarning,
    inputColor: e.colorWarningText,
    affixColor: e.colorWarning
  })), t)
}), EE = (e, t) => ({
  [`&${e.componentCls}-group-wrapper-status-${t.status}`]: {
    [`${e.componentCls}-group-addon`]: {
      background: t.addonBg,
      color: t.addonColor
    }
  }
}), J9 = (e) => ({
  "&-filled": Object.assign(Object.assign(Object.assign({
    [`${e.componentCls}-group`]: {
      "&-addon": {
        background: e.colorFillTertiary
      },
      [`${e.componentCls}-filled:not(:focus):not(:focus-within)`]: {
        "&:not(:first-child)": {
          borderInlineStart: `${le(e.lineWidth)} ${e.lineType} ${e.colorSplit}`
        },
        "&:not(:last-child)": {
          borderInlineEnd: `${le(e.lineWidth)} ${e.lineType} ${e.colorSplit}`
        }
      }
    }
  }, EE(e, {
    status: "error",
    addonBg: e.colorErrorBg,
    addonColor: e.colorErrorText
  })), EE(e, {
    status: "warning",
    addonBg: e.colorWarningBg,
    addonColor: e.colorWarningText
  })), {
    [`&${e.componentCls}-group-wrapper-disabled`]: {
      [`${e.componentCls}-group`]: {
        "&-addon": {
          background: e.colorFillTertiary,
          color: e.colorTextDisabled
        },
        "&-addon:first-child": {
          borderInlineStart: `${le(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
          borderTop: `${le(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
          borderBottom: `${le(e.lineWidth)} ${e.lineType} ${e.colorBorder}`
        },
        "&-addon:last-child": {
          borderInlineEnd: `${le(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
          borderTop: `${le(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
          borderBottom: `${le(e.lineWidth)} ${e.lineType} ${e.colorBorder}`
        }
      }
    }
  })
}), e7 = (e) => ({
  // Firefox
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color: e,
    userSelect: "none"
    // https://github.com/ant-design/ant-design/pull/32639
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
}), kR = (e) => {
  const {
    paddingBlockLG: t,
    lineHeightLG: n,
    borderRadiusLG: r,
    paddingInlineLG: i
  } = e;
  return {
    padding: `${le(t)} ${le(i)}`,
    fontSize: e.inputFontSizeLG,
    lineHeight: n,
    borderRadius: r
  };
}, PR = (e) => ({
  padding: `${le(e.paddingBlockSM)} ${le(e.paddingInlineSM)}`,
  fontSize: e.inputFontSizeSM,
  borderRadius: e.borderRadiusSM
}), NR = (e) => Object.assign(Object.assign({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${le(e.paddingBlock)} ${le(e.paddingInline)}`,
  color: e.colorText,
  fontSize: e.inputFontSize,
  lineHeight: e.lineHeight,
  borderRadius: e.borderRadius,
  transition: `all ${e.motionDurationMid}`
}, e7(e.colorTextPlaceholder)), {
  // Reset height for `textarea`s
  "textarea&": {
    maxWidth: "100%",
    // prevent textarea resize from coming out of its container
    height: "auto",
    minHeight: e.controlHeight,
    lineHeight: e.lineHeight,
    verticalAlign: "bottom",
    transition: `all ${e.motionDurationSlow}, height 0s`,
    resize: "vertical"
  },
  // Size
  "&-lg": Object.assign({}, kR(e)),
  "&-sm": Object.assign({}, PR(e)),
  // RTL
  "&-rtl": {
    direction: "rtl"
  },
  "&-textarea-rtl": {
    direction: "rtl"
  }
}), t7 = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e;
  return {
    position: "relative",
    display: "table",
    width: "100%",
    borderCollapse: "separate",
    borderSpacing: 0,
    // Undo padding and float of grid classes
    "&[class*='col-']": {
      paddingInlineEnd: e.paddingXS,
      "&:last-child": {
        paddingInlineEnd: 0
      }
    },
    // Sizing options
    [`&-lg ${t}, &-lg > ${t}-group-addon`]: Object.assign({}, kR(e)),
    [`&-sm ${t}, &-sm > ${t}-group-addon`]: Object.assign({}, PR(e)),
    // Fix https://github.com/ant-design/ant-design/issues/5754
    [`&-lg ${n}-select-single ${n}-select-selector`]: {
      height: e.controlHeightLG
    },
    [`&-sm ${n}-select-single ${n}-select-selector`]: {
      height: e.controlHeightSM
    },
    [`> ${t}`]: {
      display: "table-cell",
      "&:not(:first-child):not(:last-child)": {
        borderRadius: 0
      }
    },
    [`${t}-group`]: {
      "&-addon, &-wrap": {
        display: "table-cell",
        width: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      "&-wrap > *": {
        display: "block !important"
      },
      "&-addon": {
        position: "relative",
        padding: `0 ${le(e.paddingInline)}`,
        color: e.colorText,
        fontWeight: "normal",
        fontSize: e.inputFontSize,
        textAlign: "center",
        borderRadius: e.borderRadius,
        transition: `all ${e.motionDurationSlow}`,
        lineHeight: 1,
        // Reset Select's style in addon
        [`${n}-select`]: {
          margin: `${le(e.calc(e.paddingBlock).add(1).mul(-1).equal())} ${le(e.calc(e.paddingInline).mul(-1).equal())}`,
          [`&${n}-select-single:not(${n}-select-customize-input):not(${n}-pagination-size-changer)`]: {
            [`${n}-select-selector`]: {
              backgroundColor: "inherit",
              border: `${le(e.lineWidth)} ${e.lineType} transparent`,
              boxShadow: "none"
            }
          },
          "&-open, &-focused": {
            [`${n}-select-selector`]: {
              color: e.colorPrimary
            }
          }
        },
        // https://github.com/ant-design/ant-design/issues/31333
        [`${n}-cascader-picker`]: {
          margin: `-9px ${le(e.calc(e.paddingInline).mul(-1).equal())}`,
          backgroundColor: "transparent",
          [`${n}-cascader-input`]: {
            textAlign: "start",
            border: 0,
            boxShadow: "none"
          }
        }
      }
    },
    [`${t}`]: {
      width: "100%",
      marginBottom: 0,
      textAlign: "inherit",
      "&:focus": {
        zIndex: 1,
        // Fix https://gw.alipayobjects.com/zos/rmsportal/DHNpoqfMXSfrSnlZvhsJ.png
        borderInlineEndWidth: 1
      },
      "&:hover": {
        zIndex: 1,
        borderInlineEndWidth: 1,
        [`${t}-search-with-button &`]: {
          zIndex: 0
        }
      }
    },
    // Reset rounded corners
    [`> ${t}:first-child, ${t}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      // Reset Select's style in addon
      [`${n}-select ${n}-select-selector`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${t}-affix-wrapper`]: {
      [`&:not(:first-child) ${t}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${t}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${t}:last-child, ${t}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      // Reset Select's style in addon
      [`${n}-select ${n}-select-selector`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${t}-affix-wrapper`]: {
      "&:not(:last-child)": {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${t}-search &`]: {
          borderStartStartRadius: e.borderRadius,
          borderEndStartRadius: e.borderRadius
        }
      },
      [`&:not(:first-child), ${t}-search &:not(:first-child)`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${t}-group-compact`]: Object.assign(Object.assign({
      display: "block"
    }, ca()), {
      [`${t}-group-addon, ${t}-group-wrap, > ${t}`]: {
        "&:not(:first-child):not(:last-child)": {
          borderInlineEndWidth: e.lineWidth,
          "&:hover": {
            zIndex: 1
          },
          "&:focus": {
            zIndex: 1
          }
        }
      },
      "& > *": {
        display: "inline-block",
        float: "none",
        verticalAlign: "top",
        // https://github.com/ant-design/ant-design-pro/issues/139
        borderRadius: 0
      },
      [`
        & > ${t}-affix-wrapper,
        & > ${t}-number-affix-wrapper,
        & > ${n}-picker-range
      `]: {
        display: "inline-flex"
      },
      "& > *:not(:last-child)": {
        marginInlineEnd: e.calc(e.lineWidth).mul(-1).equal(),
        borderInlineEndWidth: e.lineWidth
      },
      // Undo float for .ant-input-group .ant-input
      [`${t}`]: {
        float: "none"
      },
      // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
      [`& > ${n}-select > ${n}-select-selector,
      & > ${n}-select-auto-complete ${t},
      & > ${n}-cascader-picker ${t},
      & > ${t}-group-wrapper ${t}`]: {
        borderInlineEndWidth: e.lineWidth,
        borderRadius: 0,
        "&:hover": {
          zIndex: 1
        },
        "&:focus": {
          zIndex: 1
        }
      },
      [`& > ${n}-select-focused`]: {
        zIndex: 1
      },
      // update z-index for arrow icon
      [`& > ${n}-select > ${n}-select-arrow`]: {
        zIndex: 1
        // https://github.com/ant-design/ant-design/issues/20371
      },
      [`& > *:first-child,
      & > ${n}-select:first-child > ${n}-select-selector,
      & > ${n}-select-auto-complete:first-child ${t},
      & > ${n}-cascader-picker:first-child ${t}`]: {
        borderStartStartRadius: e.borderRadius,
        borderEndStartRadius: e.borderRadius
      },
      [`& > *:last-child,
      & > ${n}-select:last-child > ${n}-select-selector,
      & > ${n}-cascader-picker:last-child ${t},
      & > ${n}-cascader-picker-focused:last-child ${t}`]: {
        borderInlineEndWidth: e.lineWidth,
        borderStartEndRadius: e.borderRadius,
        borderEndEndRadius: e.borderRadius
      },
      // https://github.com/ant-design/ant-design/issues/12493
      [`& > ${n}-select-auto-complete ${t}`]: {
        verticalAlign: "top"
      },
      [`${t}-group-wrapper + ${t}-group-wrapper`]: {
        marginInlineStart: e.calc(e.lineWidth).mul(-1).equal(),
        [`${t}-affix-wrapper`]: {
          borderRadius: 0
        }
      },
      [`${t}-group-wrapper:not(:last-child)`]: {
        [`&${t}-search > ${t}-group`]: {
          [`& > ${t}-group-addon > ${t}-search-button`]: {
            borderRadius: 0
          },
          [`& > ${t}`]: {
            borderStartStartRadius: e.borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            borderEndStartRadius: e.borderRadius
          }
        }
      }
    })
  };
}, n7 = (e) => {
  const {
    componentCls: t,
    controlHeightSM: n,
    lineWidth: r,
    calc: i
  } = e, s = i(n).sub(i(r).mul(2)).sub(16).div(2).equal();
  return {
    [t]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, Gn(e)), NR(e)), Y9(e)), Z9(e)), Q9(e)), {
      '&[type="color"]': {
        height: e.controlHeight,
        [`&${t}-lg`]: {
          height: e.controlHeightLG
        },
        [`&${t}-sm`]: {
          height: n,
          paddingTop: s,
          paddingBottom: s
        }
      },
      '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
        "-webkit-appearance": "none"
      }
    })
  };
}, r7 = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // ========================= Input =========================
    [`${t}-clear-icon`]: {
      margin: 0,
      color: e.colorTextQuaternary,
      fontSize: e.fontSizeIcon,
      verticalAlign: -1,
      // https://github.com/ant-design/ant-design/pull/18151
      // https://codesandbox.io/s/wizardly-sun-u10br
      cursor: "pointer",
      transition: `color ${e.motionDurationSlow}`,
      "&:hover": {
        color: e.colorTextTertiary
      },
      "&:active": {
        color: e.colorText
      },
      "&-hidden": {
        visibility: "hidden"
      },
      "&-has-suffix": {
        margin: `0 ${le(e.inputAffixPadding)}`
      }
    }
  };
}, i7 = (e) => {
  const {
    componentCls: t,
    inputAffixPadding: n,
    colorTextDescription: r,
    motionDurationSlow: i,
    colorIcon: o,
    colorIconHover: s,
    iconCls: a
  } = e;
  return {
    [`${t}-affix-wrapper`]: Object.assign(Object.assign(Object.assign(Object.assign({}, NR(e)), {
      display: "inline-flex",
      [`&:not(${t}-disabled):hover`]: {
        zIndex: 1,
        [`${t}-search-with-button &`]: {
          zIndex: 0
        }
      },
      "&-focused, &:focus": {
        zIndex: 1
      },
      [`> input${t}`]: {
        padding: 0,
        fontSize: "inherit",
        border: "none",
        borderRadius: 0,
        outline: "none",
        background: "transparent",
        color: "inherit",
        "&::-ms-reveal": {
          display: "none"
        },
        "&:focus": {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        display: "inline-block",
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${t}`]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          "> *:not(:last-child)": {
            marginInlineEnd: e.paddingXS
          }
        },
        "&-show-count-suffix": {
          color: r
        },
        "&-show-count-has-suffix": {
          marginInlineEnd: e.paddingXXS
        },
        "&-prefix": {
          marginInlineEnd: n
        },
        "&-suffix": {
          marginInlineStart: n
        }
      }
    }), r7(e)), {
      // password
      [`${a}${t}-password-icon`]: {
        color: o,
        cursor: "pointer",
        transition: `all ${i}`,
        "&:hover": {
          color: s
        }
      }
    })
  };
}, o7 = (e) => {
  const {
    componentCls: t,
    borderRadiusLG: n,
    borderRadiusSM: r
  } = e;
  return {
    [`${t}-group`]: Object.assign(Object.assign(Object.assign({}, Gn(e)), t7(e)), {
      "&-rtl": {
        direction: "rtl"
      },
      "&-wrapper": Object.assign(Object.assign(Object.assign({
        display: "inline-block",
        width: "100%",
        textAlign: "start",
        verticalAlign: "top",
        "&-rtl": {
          direction: "rtl"
        },
        // Size
        "&-lg": {
          [`${t}-group-addon`]: {
            borderRadius: n,
            fontSize: e.inputFontSizeLG
          }
        },
        "&-sm": {
          [`${t}-group-addon`]: {
            borderRadius: r
          }
        }
      }, q9(e)), J9(e)), {
        // '&-disabled': {
        //   [`${componentCls}-group-addon`]: {
        //     ...genDisabledStyle(token),
        //   },
        // },
        // Fix the issue of using icons in Space Compact mode
        // https://github.com/ant-design/ant-design/issues/42122
        [`&:not(${t}-compact-first-item):not(${t}-compact-last-item)${t}-compact-item`]: {
          [`${t}, ${t}-group-addon`]: {
            borderRadius: 0
          }
        },
        [`&:not(${t}-compact-last-item)${t}-compact-first-item`]: {
          [`${t}, ${t}-group-addon`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`&:not(${t}-compact-first-item)${t}-compact-last-item`]: {
          [`${t}, ${t}-group-addon`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        // Fix the issue of input use show-count param in space compact mode
        // https://github.com/ant-design/ant-design/issues/46872
        [`&:not(${t}-compact-last-item)${t}-compact-item`]: {
          [`${t}-affix-wrapper`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        }
      })
    })
  };
}, s7 = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e, r = `${t}-search`;
  return {
    [r]: {
      [`${t}`]: {
        "&:hover, &:focus": {
          borderColor: e.colorPrimaryHover,
          [`+ ${t}-group-addon ${r}-button:not(${n}-btn-primary)`]: {
            borderInlineStartColor: e.colorPrimaryHover
          }
        }
      },
      [`${t}-affix-wrapper`]: {
        borderRadius: 0
      },
      // fix slight height diff in Firefox:
      // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
      [`${t}-lg`]: {
        lineHeight: e.calc(e.lineHeightLG).sub(2e-4).equal({
          unit: !1
        })
      },
      [`> ${t}-group`]: {
        [`> ${t}-group-addon:last-child`]: {
          insetInlineStart: -1,
          padding: 0,
          border: 0,
          [`${r}-button`]: {
            // Fix https://github.com/ant-design/ant-design/issues/47150
            marginInlineEnd: -1,
            paddingTop: 0,
            paddingBottom: 0,
            borderStartStartRadius: 0,
            borderStartEndRadius: e.borderRadius,
            borderEndEndRadius: e.borderRadius,
            borderEndStartRadius: 0,
            boxShadow: "none"
          },
          [`${r}-button:not(${n}-btn-primary)`]: {
            color: e.colorTextDescription,
            "&:hover": {
              color: e.colorPrimaryHover
            },
            "&:active": {
              color: e.colorPrimaryActive
            },
            [`&${n}-btn-loading::before`]: {
              insetInlineStart: 0,
              insetInlineEnd: 0,
              insetBlockStart: 0,
              insetBlockEnd: 0
            }
          }
        }
      },
      [`${r}-button`]: {
        height: e.controlHeight,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`&-large ${r}-button`]: {
        height: e.controlHeightLG
      },
      [`&-small ${r}-button`]: {
        height: e.controlHeightSM
      },
      "&-rtl": {
        direction: "rtl"
      },
      // ===================== Compact Item Customized Styles =====================
      [`&${t}-compact-item`]: {
        [`&:not(${t}-compact-last-item)`]: {
          [`${t}-group-addon`]: {
            [`${t}-search-button`]: {
              marginInlineEnd: e.calc(e.lineWidth).mul(-1).equal(),
              borderRadius: 0
            }
          }
        },
        [`&:not(${t}-compact-first-item)`]: {
          [`${t},${t}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`> ${t}-group-addon ${t}-search-button,
        > ${t},
        ${t}-affix-wrapper`]: {
          "&:hover,&:focus,&:active": {
            zIndex: 2
          }
        },
        [`> ${t}-affix-wrapper-focused`]: {
          zIndex: 2
        }
      }
    }
  };
}, a7 = (e) => {
  const {
    componentCls: t,
    paddingLG: n
  } = e, r = `${t}-textarea`;
  return {
    [r]: {
      position: "relative",
      "&-show-count": {
        // https://github.com/ant-design/ant-design/issues/33049
        [`> ${t}`]: {
          height: "100%"
        },
        [`${t}-data-count`]: {
          position: "absolute",
          bottom: e.calc(e.fontSize).mul(e.lineHeight).mul(-1).equal(),
          insetInlineEnd: 0,
          color: e.colorTextDescription,
          whiteSpace: "nowrap",
          pointerEvents: "none"
        }
      },
      "&-allow-clear": {
        [`> ${t}`]: {
          paddingInlineEnd: n
        }
      },
      [`&-affix-wrapper${r}-has-feedback`]: {
        [`${t}`]: {
          paddingInlineEnd: n
        }
      },
      [`&-affix-wrapper${t}-affix-wrapper`]: {
        padding: 0,
        [`> textarea${t}`]: {
          fontSize: "inherit",
          border: "none",
          outline: "none",
          background: "transparent",
          "&:focus": {
            boxShadow: "none !important"
          }
        },
        [`${t}-suffix`]: {
          margin: 0,
          "> *:not(:last-child)": {
            marginInline: 0
          },
          // Clear Icon
          [`${t}-clear-icon`]: {
            position: "absolute",
            insetInlineEnd: e.paddingXS,
            insetBlockStart: e.paddingXS
          },
          // Feedback Icon
          [`${r}-suffix`]: {
            position: "absolute",
            top: 0,
            insetInlineEnd: e.paddingInline,
            bottom: 0,
            zIndex: 1,
            display: "inline-flex",
            alignItems: "center",
            margin: "auto",
            pointerEvents: "none"
          }
        }
      }
    }
  };
}, l7 = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-out-of-range`]: {
      [`&, & input, & textarea, ${t}-show-count-suffix, ${t}-data-count`]: {
        color: e.colorError
      }
    }
  };
}, O1 = $n("Input", (e) => {
  const t = Jt(e, TR(e));
  return [
    n7(t),
    a7(t),
    i7(t),
    o7(t),
    s7(t),
    l7(t),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    jg(t)
  ];
}, RR), Zg = (e) => {
  const {
    prefixCls: t,
    className: n,
    style: r,
    size: i,
    shape: o
  } = e, s = se({
    [`${t}-lg`]: i === "large",
    [`${t}-sm`]: i === "small"
  }), a = se({
    [`${t}-circle`]: o === "circle",
    [`${t}-square`]: o === "square",
    [`${t}-round`]: o === "round"
  }), l = O.useMemo(() => typeof i == "number" ? {
    width: i,
    height: i,
    lineHeight: `${i}px`
  } : {}, [i]);
  return /* @__PURE__ */ O.createElement("span", {
    className: se(t, s, a, n),
    style: Object.assign(Object.assign({}, l), r)
  });
}, c7 = new Gt("ant-skeleton-loading", {
  "0%": {
    backgroundPosition: "100% 50%"
  },
  "100%": {
    backgroundPosition: "0 50%"
  }
}), Jg = (e) => ({
  height: e,
  lineHeight: le(e)
}), fc = (e) => Object.assign({
  width: e
}, Jg(e)), u7 = (e) => ({
  background: e.skeletonLoadingBackground,
  backgroundSize: "400% 100%",
  animationName: c7,
  animationDuration: e.skeletonLoadingMotionDuration,
  animationTimingFunction: "ease",
  animationIterationCount: "infinite"
}), lv = (e, t) => Object.assign({
  width: t(e).mul(5).equal(),
  minWidth: t(e).mul(5).equal()
}, Jg(e)), d7 = (e) => {
  const {
    skeletonAvatarCls: t,
    gradientFromColor: n,
    controlHeight: r,
    controlHeightLG: i,
    controlHeightSM: o
  } = e;
  return {
    [`${t}`]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: n
    }, fc(r)),
    [`${t}${t}-circle`]: {
      borderRadius: "50%"
    },
    [`${t}${t}-lg`]: Object.assign({}, fc(i)),
    [`${t}${t}-sm`]: Object.assign({}, fc(o))
  };
}, f7 = (e) => {
  const {
    controlHeight: t,
    borderRadiusSM: n,
    skeletonInputCls: r,
    controlHeightLG: i,
    controlHeightSM: o,
    gradientFromColor: s,
    calc: a
  } = e;
  return {
    [`${r}`]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: s,
      borderRadius: n
    }, lv(t, a)),
    [`${r}-lg`]: Object.assign({}, lv(i, a)),
    [`${r}-sm`]: Object.assign({}, lv(o, a))
  };
}, $E = (e) => Object.assign({
  width: e
}, Jg(e)), h7 = (e) => {
  const {
    skeletonImageCls: t,
    imageSizeBase: n,
    gradientFromColor: r,
    borderRadiusSM: i,
    calc: o
  } = e;
  return {
    [`${t}`]: Object.assign(Object.assign({
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      verticalAlign: "top",
      background: r,
      borderRadius: i
    }, $E(o(n).mul(2).equal())), {
      [`${t}-path`]: {
        fill: "#bfbfbf"
      },
      [`${t}-svg`]: Object.assign(Object.assign({}, $E(n)), {
        maxWidth: o(n).mul(4).equal(),
        maxHeight: o(n).mul(4).equal()
      }),
      [`${t}-svg${t}-svg-circle`]: {
        borderRadius: "50%"
      }
    }),
    [`${t}${t}-circle`]: {
      borderRadius: "50%"
    }
  };
}, cv = (e, t, n) => {
  const {
    skeletonButtonCls: r
  } = e;
  return {
    [`${n}${r}-circle`]: {
      width: t,
      minWidth: t,
      borderRadius: "50%"
    },
    [`${n}${r}-round`]: {
      borderRadius: t
    }
  };
}, uv = (e, t) => Object.assign({
  width: t(e).mul(2).equal(),
  minWidth: t(e).mul(2).equal()
}, Jg(e)), p7 = (e) => {
  const {
    borderRadiusSM: t,
    skeletonButtonCls: n,
    controlHeight: r,
    controlHeightLG: i,
    controlHeightSM: o,
    gradientFromColor: s,
    calc: a
  } = e;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
    [`${n}`]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: s,
      borderRadius: t,
      width: a(r).mul(2).equal(),
      minWidth: a(r).mul(2).equal()
    }, uv(r, a))
  }, cv(e, r, n)), {
    [`${n}-lg`]: Object.assign({}, uv(i, a))
  }), cv(e, i, `${n}-lg`)), {
    [`${n}-sm`]: Object.assign({}, uv(o, a))
  }), cv(e, o, `${n}-sm`));
}, g7 = (e) => {
  const {
    componentCls: t,
    skeletonAvatarCls: n,
    skeletonTitleCls: r,
    skeletonParagraphCls: i,
    skeletonButtonCls: o,
    skeletonInputCls: s,
    skeletonImageCls: a,
    controlHeight: l,
    controlHeightLG: u,
    controlHeightSM: c,
    gradientFromColor: d,
    padding: f,
    marginSM: h,
    borderRadius: p,
    titleHeight: g,
    blockRadius: m,
    paragraphLiHeight: v,
    controlHeightXS: b,
    paragraphMarginTop: x
  } = e;
  return {
    [`${t}`]: {
      display: "table",
      width: "100%",
      [`${t}-header`]: {
        display: "table-cell",
        paddingInlineEnd: f,
        verticalAlign: "top",
        // Avatar
        [`${n}`]: Object.assign({
          display: "inline-block",
          verticalAlign: "top",
          background: d
        }, fc(l)),
        [`${n}-circle`]: {
          borderRadius: "50%"
        },
        [`${n}-lg`]: Object.assign({}, fc(u)),
        [`${n}-sm`]: Object.assign({}, fc(c))
      },
      [`${t}-content`]: {
        display: "table-cell",
        width: "100%",
        verticalAlign: "top",
        // Title
        [`${r}`]: {
          width: "100%",
          height: g,
          background: d,
          borderRadius: m,
          [`+ ${i}`]: {
            marginBlockStart: c
          }
        },
        // paragraph
        [`${i}`]: {
          padding: 0,
          "> li": {
            width: "100%",
            height: v,
            listStyle: "none",
            background: d,
            borderRadius: m,
            "+ li": {
              marginBlockStart: b
            }
          }
        },
        [`${i}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
          width: "61%"
        }
      },
      [`&-round ${t}-content`]: {
        [`${r}, ${i} > li`]: {
          borderRadius: p
        }
      }
    },
    [`${t}-with-avatar ${t}-content`]: {
      // Title
      [`${r}`]: {
        marginBlockStart: h,
        [`+ ${i}`]: {
          marginBlockStart: x
        }
      }
    },
    // Skeleton element
    [`${t}${t}-element`]: Object.assign(Object.assign(Object.assign(Object.assign({
      display: "inline-block",
      width: "auto"
    }, p7(e)), d7(e)), f7(e)), h7(e)),
    // Skeleton Block Button, Input
    [`${t}${t}-block`]: {
      width: "100%",
      [`${o}`]: {
        width: "100%"
      },
      [`${s}`]: {
        width: "100%"
      }
    },
    // With active animation
    [`${t}${t}-active`]: {
      [`
        ${r},
        ${i} > li,
        ${n},
        ${o},
        ${s},
        ${a}
      `]: Object.assign({}, u7(e))
    }
  };
}, m7 = (e) => {
  const {
    colorFillContent: t,
    colorFill: n
  } = e, r = t, i = n;
  return {
    color: r,
    colorGradientEnd: i,
    gradientFromColor: r,
    gradientToColor: i,
    titleHeight: e.controlHeight / 2,
    blockRadius: e.borderRadiusSM,
    paragraphMarginTop: e.marginLG + e.marginXXS,
    paragraphLiHeight: e.controlHeight / 2
  };
}, iu = $n("Skeleton", (e) => {
  const {
    componentCls: t,
    calc: n
  } = e, r = Jt(e, {
    skeletonAvatarCls: `${t}-avatar`,
    skeletonTitleCls: `${t}-title`,
    skeletonParagraphCls: `${t}-paragraph`,
    skeletonButtonCls: `${t}-button`,
    skeletonInputCls: `${t}-input`,
    skeletonImageCls: `${t}-image`,
    imageSizeBase: n(e.controlHeight).mul(1.5).equal(),
    borderRadius: 100,
    // Large number to make capsule shape
    skeletonLoadingBackground: `linear-gradient(90deg, ${e.gradientFromColor} 25%, ${e.gradientToColor} 37%, ${e.gradientFromColor} 63%)`,
    skeletonLoadingMotionDuration: "1.4s"
  });
  return [g7(r)];
}, m7, {
  deprecatedTokens: [["color", "gradientFromColor"], ["colorGradientEnd", "gradientToColor"]]
}), v7 = (e) => {
  const {
    prefixCls: t,
    className: n,
    rootClassName: r,
    active: i,
    shape: o = "circle",
    size: s = "default"
  } = e, {
    getPrefixCls: a
  } = O.useContext(rt), l = a("skeleton", t), [u, c, d] = iu(l), f = zn(e, ["prefixCls", "className"]), h = se(l, `${l}-element`, {
    [`${l}-active`]: i
  }, n, r, c, d);
  return u(/* @__PURE__ */ O.createElement("div", {
    className: h
  }, /* @__PURE__ */ O.createElement(Zg, Object.assign({
    prefixCls: `${l}-avatar`,
    shape: o,
    size: s
  }, f))));
}, b7 = (e) => {
  const {
    prefixCls: t,
    className: n,
    rootClassName: r,
    active: i,
    block: o = !1,
    size: s = "default"
  } = e, {
    getPrefixCls: a
  } = O.useContext(rt), l = a("skeleton", t), [u, c, d] = iu(l), f = zn(e, ["prefixCls"]), h = se(l, `${l}-element`, {
    [`${l}-active`]: i,
    [`${l}-block`]: o
  }, n, r, c, d);
  return u(/* @__PURE__ */ O.createElement("div", {
    className: h
  }, /* @__PURE__ */ O.createElement(Zg, Object.assign({
    prefixCls: `${l}-button`,
    size: s
  }, f))));
}, y7 = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z", w7 = (e) => {
  const {
    prefixCls: t,
    className: n,
    rootClassName: r,
    style: i,
    active: o
  } = e, {
    getPrefixCls: s
  } = O.useContext(rt), a = s("skeleton", t), [l, u, c] = iu(a), d = se(a, `${a}-element`, {
    [`${a}-active`]: o
  }, n, r, u, c);
  return l(/* @__PURE__ */ O.createElement("div", {
    className: d
  }, /* @__PURE__ */ O.createElement("div", {
    className: se(`${a}-image`, n),
    style: i
  }, /* @__PURE__ */ O.createElement("svg", {
    viewBox: "0 0 1098 1024",
    xmlns: "http://www.w3.org/2000/svg",
    className: `${a}-image-svg`
  }, /* @__PURE__ */ O.createElement("path", {
    d: y7,
    className: `${a}-image-path`
  })))));
}, C7 = (e) => {
  const {
    prefixCls: t,
    className: n,
    rootClassName: r,
    active: i,
    block: o,
    size: s = "default"
  } = e, {
    getPrefixCls: a
  } = O.useContext(rt), l = a("skeleton", t), [u, c, d] = iu(l), f = zn(e, ["prefixCls"]), h = se(l, `${l}-element`, {
    [`${l}-active`]: i,
    [`${l}-block`]: o
  }, n, r, c, d);
  return u(/* @__PURE__ */ O.createElement("div", {
    className: h
  }, /* @__PURE__ */ O.createElement(Zg, Object.assign({
    prefixCls: `${l}-input`,
    size: s
  }, f))));
};
var S7 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M888 792H200V168c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v688c0 4.4 3.6 8 8 8h752c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM288 604a64 64 0 10128 0 64 64 0 10-128 0zm118-224a48 48 0 1096 0 48 48 0 10-96 0zm158 228a96 96 0 10192 0 96 96 0 10-192 0zm148-314a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "dot-chart", theme: "outlined" }, x7 = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: S7
  }));
}, LR = /* @__PURE__ */ O.forwardRef(x7);
process.env.NODE_ENV !== "production" && (LR.displayName = "DotChartOutlined");
const E7 = (e) => {
  const {
    prefixCls: t,
    className: n,
    rootClassName: r,
    style: i,
    active: o,
    children: s
  } = e, {
    getPrefixCls: a
  } = O.useContext(rt), l = a("skeleton", t), [u, c, d] = iu(l), f = se(l, `${l}-element`, {
    [`${l}-active`]: o
  }, c, n, r, d), h = s ?? /* @__PURE__ */ O.createElement(LR, null);
  return u(/* @__PURE__ */ O.createElement("div", {
    className: f
  }, /* @__PURE__ */ O.createElement("div", {
    className: se(`${l}-image`, n),
    style: i
  }, h)));
}, $7 = (e, t) => {
  const {
    width: n,
    rows: r = 2
  } = t;
  if (Array.isArray(n))
    return n[e];
  if (r - 1 === e)
    return n;
}, O7 = (e) => {
  const {
    prefixCls: t,
    className: n,
    style: r,
    rows: i
  } = e, o = _e(Array(i)).map((s, a) => (
    // eslint-disable-next-line react/no-array-index-key
    /* @__PURE__ */ O.createElement("li", {
      key: a,
      style: {
        width: $7(a, e)
      }
    })
  ));
  return /* @__PURE__ */ O.createElement("ul", {
    className: se(t, n),
    style: r
  }, o);
}, A7 = (e) => {
  let {
    prefixCls: t,
    className: n,
    width: r,
    style: i
  } = e;
  return /* @__PURE__ */ O.createElement("h3", {
    className: se(t, n),
    style: Object.assign({
      width: r
    }, i)
  });
};
function dv(e) {
  return e && typeof e == "object" ? e : {};
}
function D7(e, t) {
  return e && !t ? {
    size: "large",
    shape: "square"
  } : {
    size: "large",
    shape: "circle"
  };
}
function _7(e, t) {
  return !e && t ? {
    width: "38%"
  } : e && t ? {
    width: "50%"
  } : {};
}
function T7(e, t) {
  const n = {};
  return (!e || !t) && (n.width = "61%"), !e && t ? n.rows = 3 : n.rows = 2, n;
}
const xl = (e) => {
  const {
    prefixCls: t,
    loading: n,
    className: r,
    rootClassName: i,
    style: o,
    children: s,
    avatar: a = !1,
    title: l = !0,
    paragraph: u = !0,
    active: c,
    round: d
  } = e, {
    getPrefixCls: f,
    direction: h,
    skeleton: p
  } = O.useContext(rt), g = f("skeleton", t), [m, v, b] = iu(g);
  if (n || !("loading" in e)) {
    const x = !!a, w = !!l, C = !!u;
    let y;
    if (x) {
      const $ = Object.assign(Object.assign({
        prefixCls: `${g}-avatar`
      }, D7(w, C)), dv(a));
      y = /* @__PURE__ */ O.createElement("div", {
        className: `${g}-header`
      }, /* @__PURE__ */ O.createElement(Zg, Object.assign({}, $)));
    }
    let S;
    if (w || C) {
      let $;
      if (w) {
        const _ = Object.assign(Object.assign({
          prefixCls: `${g}-title`
        }, _7(x, C)), dv(l));
        $ = /* @__PURE__ */ O.createElement(A7, Object.assign({}, _));
      }
      let M;
      if (C) {
        const _ = Object.assign(Object.assign({
          prefixCls: `${g}-paragraph`
        }, T7(x, w)), dv(u));
        M = /* @__PURE__ */ O.createElement(O7, Object.assign({}, _));
      }
      S = /* @__PURE__ */ O.createElement("div", {
        className: `${g}-content`
      }, $, M);
    }
    const A = se(g, {
      [`${g}-with-avatar`]: x,
      [`${g}-active`]: c,
      [`${g}-rtl`]: h === "rtl",
      [`${g}-round`]: d
    }, p == null ? void 0 : p.className, r, i, v, b);
    return m(/* @__PURE__ */ O.createElement("div", {
      className: A,
      style: Object.assign(Object.assign({}, p == null ? void 0 : p.style), o)
    }, y, S));
  }
  return s ?? null;
};
xl.Button = b7;
xl.Avatar = v7;
xl.Input = C7;
xl.Image = w7;
xl.Node = E7;
process.env.NODE_ENV !== "production" && (xl.displayName = "Skeleton");
var R7 = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { tag: "path", attrs: { d: "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" } }] }, name: "plus", theme: "outlined" }, M7 = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: R7
  }));
}, ou = /* @__PURE__ */ O.forwardRef(M7);
process.env.NODE_ENV !== "production" && (ou.displayName = "PlusOutlined");
const em = /* @__PURE__ */ Yo(null);
var I7 = function(t) {
  var n = t.activeTabOffset, r = t.horizontal, i = t.rtl, o = t.indicator, s = o === void 0 ? {} : o, a = s.size, l = s.align, u = l === void 0 ? "center" : l, c = ht(), d = ae(c, 2), f = d[0], h = d[1], p = he(), g = U.useCallback(function(v) {
    return typeof a == "function" ? a(v) : typeof a == "number" ? a : v;
  }, [a]);
  function m() {
    rn.cancel(p.current);
  }
  return Pe(function() {
    var v = {};
    if (n)
      if (r) {
        v.width = g(n.width);
        var b = i ? "right" : "left";
        u === "start" && (v[b] = n[b]), u === "center" && (v[b] = n[b] + n.width / 2, v.transform = i ? "translateX(50%)" : "translateX(-50%)"), u === "end" && (v[b] = n[b] + n.width, v.transform = "translateX(-100%)");
      } else
        v.height = g(n.height), u === "start" && (v.top = n.top), u === "center" && (v.top = n.top + n.height / 2, v.transform = "translateY(-50%)"), u === "end" && (v.top = n.top + n.height, v.transform = "translateY(-100%)");
    return m(), p.current = rn(function() {
      h(v);
    }), m;
  }, [n, r, i, u, g]), {
    style: f
  };
}, OE = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function k7(e, t, n) {
  return mt(function() {
    for (var r, i = /* @__PURE__ */ new Map(), o = t.get((r = e[0]) === null || r === void 0 ? void 0 : r.key) || OE, s = o.left + o.width, a = 0; a < e.length; a += 1) {
      var l = e[a].key, u = t.get(l);
      if (!u) {
        var c;
        u = t.get((c = e[a - 1]) === null || c === void 0 ? void 0 : c.key) || OE;
      }
      var d = i.get(l) || ie({}, u);
      d.right = s - d.left - d.width, i.set(l, d);
    }
    return i;
  }, [e.map(function(r) {
    return r.key;
  }).join("_"), t, n]);
}
function AE(e, t) {
  var n = O.useRef(e), r = O.useState({}), i = ae(r, 2), o = i[1];
  function s(a) {
    var l = typeof a == "function" ? a(n.current) : a;
    l !== n.current && t(l, n.current), n.current = l, o({});
  }
  return [n.current, s];
}
var P7 = 0.1, DE = 0.01, rp = 20, _E = Math.pow(0.995, rp);
function N7(e, t) {
  var n = ht(), r = ae(n, 2), i = r[0], o = r[1], s = ht(0), a = ae(s, 2), l = a[0], u = a[1], c = ht(0), d = ae(c, 2), f = d[0], h = d[1], p = ht(), g = ae(p, 2), m = g[0], v = g[1], b = he();
  function x($) {
    var M = $.touches[0], _ = M.screenX, T = M.screenY;
    o({
      x: _,
      y: T
    }), window.clearInterval(b.current);
  }
  function w($) {
    if (i) {
      $.preventDefault();
      var M = $.touches[0], _ = M.screenX, T = M.screenY;
      o({
        x: _,
        y: T
      });
      var D = _ - i.x, E = T - i.y;
      t(D, E);
      var R = Date.now();
      u(R), h(R - l), v({
        x: D,
        y: E
      });
    }
  }
  function C() {
    if (i && (o(null), v(null), m)) {
      var $ = m.x / f, M = m.y / f, _ = Math.abs($), T = Math.abs(M);
      if (Math.max(_, T) < P7)
        return;
      var D = $, E = M;
      b.current = window.setInterval(function() {
        if (Math.abs(D) < DE && Math.abs(E) < DE) {
          window.clearInterval(b.current);
          return;
        }
        D *= _E, E *= _E, t(D * rp, E * rp);
      }, rp);
    }
  }
  var y = he();
  function S($) {
    var M = $.deltaX, _ = $.deltaY, T = 0, D = Math.abs(M), E = Math.abs(_);
    D === E ? T = y.current === "x" ? M : _ : D > E ? (T = M, y.current = "x") : (T = _, y.current = "y"), t(-T, -T) && $.preventDefault();
  }
  var A = he(null);
  A.current = {
    onTouchStart: x,
    onTouchMove: w,
    onTouchEnd: C,
    onWheel: S
  }, O.useEffect(function() {
    function $(D) {
      A.current.onTouchStart(D);
    }
    function M(D) {
      A.current.onTouchMove(D);
    }
    function _(D) {
      A.current.onTouchEnd(D);
    }
    function T(D) {
      A.current.onWheel(D);
    }
    return document.addEventListener("touchmove", M, {
      passive: !1
    }), document.addEventListener("touchend", _, {
      passive: !1
    }), e.current.addEventListener("touchstart", $, {
      passive: !1
    }), e.current.addEventListener("wheel", T), function() {
      document.removeEventListener("touchmove", M), document.removeEventListener("touchend", _);
    };
  }, []);
}
function FR(e) {
  var t = ht(0), n = ae(t, 2), r = n[0], i = n[1], o = he(0), s = he();
  return s.current = e, U0(function() {
    var a;
    (a = s.current) === null || a === void 0 || a.call(s);
  }, [r]), function() {
    o.current === r && (o.current += 1, i(o.current));
  };
}
function L7(e) {
  var t = he([]), n = ht({}), r = ae(n, 2), i = r[1], o = he(typeof e == "function" ? e() : e), s = FR(function() {
    var l = o.current;
    t.current.forEach(function(u) {
      l = u(l);
    }), t.current = [], o.current = l, i({});
  });
  function a(l) {
    t.current.push(l), s();
  }
  return [o.current, a];
}
var TE = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
};
function F7(e, t, n, r, i, o, s) {
  var a = s.tabs, l = s.tabPosition, u = s.rtl, c, d, f;
  return ["top", "bottom"].includes(l) ? (c = "width", d = u ? "right" : "left", f = Math.abs(n)) : (c = "height", d = "top", f = -n), mt(function() {
    if (!a.length)
      return [0, 0];
    for (var h = a.length, p = h, g = 0; g < h; g += 1) {
      var m = e.get(a[g].key) || TE;
      if (m[d] + m[c] > f + t) {
        p = g - 1;
        break;
      }
    }
    for (var v = 0, b = h - 1; b >= 0; b -= 1) {
      var x = e.get(a[b].key) || TE;
      if (x[d] < f) {
        v = b + 1;
        break;
      }
    }
    return v >= p ? [0, 0] : [v, p];
  }, [e, t, r, i, o, f, l, a.map(function(h) {
    return h.key;
  }).join("_"), u]);
}
function RE(e) {
  var t;
  return e instanceof Map ? (t = {}, e.forEach(function(n, r) {
    t[r] = n;
  })) : t = e, JSON.stringify(t);
}
var B7 = "TABS_DQ";
function BR(e) {
  return String(e).replace(/"/g, B7);
}
function jR(e, t, n, r) {
  return (
    // Only editable tabs can be removed
    !(!n || // Tabs cannot be removed when disabled
    r || // closable is false
    e === !1 || // If closable is undefined, the remove button should be hidden when closeIcon is null or false
    e === void 0 && (t === !1 || t === null))
  );
}
var zR = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.prefixCls, r = e.editable, i = e.locale, o = e.style;
  return !r || r.showAdd === !1 ? null : /* @__PURE__ */ O.createElement("button", {
    ref: t,
    type: "button",
    className: "".concat(n, "-nav-add"),
    style: o,
    "aria-label": (i == null ? void 0 : i.addAriaLabel) || "Add tab",
    onClick: function(a) {
      r.onEdit("add", {
        event: a
      });
    }
  }, r.addIcon || "+");
}), Nb = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.position, r = e.prefixCls, i = e.extra;
  if (!i)
    return null;
  var o, s = {};
  return wt(i) === "object" && !/* @__PURE__ */ O.isValidElement(i) ? s = i : s.right = i, n === "right" && (o = s.right), n === "left" && (o = s.left), o ? /* @__PURE__ */ O.createElement("div", {
    className: "".concat(r, "-extra-content"),
    ref: t
  }, o) : null;
});
process.env.NODE_ENV !== "production" && (Nb.displayName = "ExtraContent");
var j7 = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.prefixCls, r = e.id, i = e.tabs, o = e.locale, s = e.mobile, a = e.moreIcon, l = a === void 0 ? "More" : a, u = e.moreTransitionName, c = e.style, d = e.className, f = e.editable, h = e.tabBarGutter, p = e.rtl, g = e.removeAriaLabel, m = e.onTabClick, v = e.getPopupContainer, b = e.popupClassName, x = ht(!1), w = ae(x, 2), C = w[0], y = w[1], S = ht(null), A = ae(S, 2), $ = A[0], M = A[1], _ = "".concat(r, "-more-popup"), T = "".concat(n, "-dropdown"), D = $ !== null ? "".concat(_, "-").concat($) : null, E = o == null ? void 0 : o.dropdownAriaLabel;
  function R(B, j) {
    B.preventDefault(), B.stopPropagation(), f.onEdit("remove", {
      key: j,
      event: B
    });
  }
  var I = /* @__PURE__ */ O.createElement(nu, {
    onClick: function(j) {
      var z = j.key, H = j.domEvent;
      m(z, H), y(!1);
    },
    prefixCls: "".concat(T, "-menu"),
    id: _,
    tabIndex: -1,
    role: "listbox",
    "aria-activedescendant": D,
    selectedKeys: [$],
    "aria-label": E !== void 0 ? E : "expanded dropdown"
  }, i.map(function(B) {
    var j = B.closable, z = B.disabled, H = B.closeIcon, W = B.key, G = B.label, K = jR(j, H, f, z);
    return /* @__PURE__ */ O.createElement(Sf, {
      key: W,
      id: "".concat(_, "-").concat(W),
      role: "option",
      "aria-controls": r && "".concat(r, "-panel-").concat(W),
      disabled: z
    }, /* @__PURE__ */ O.createElement("span", null, G), K && /* @__PURE__ */ O.createElement("button", {
      type: "button",
      "aria-label": g || "remove",
      tabIndex: 0,
      className: "".concat(T, "-menu-item-remove"),
      onClick: function(X) {
        X.stopPropagation(), R(X, W);
      }
    }, H || f.removeIcon || ""));
  }));
  function k(B) {
    for (var j = i.filter(function(K) {
      return !K.disabled;
    }), z = j.findIndex(function(K) {
      return K.key === $;
    }) || 0, H = j.length, W = 0; W < H; W += 1) {
      z = (z + B + H) % H;
      var G = j[z];
      if (!G.disabled) {
        M(G.key);
        return;
      }
    }
  }
  function P(B) {
    var j = B.which;
    if (!C) {
      [xe.DOWN, xe.SPACE, xe.ENTER].includes(j) && (y(!0), B.preventDefault());
      return;
    }
    switch (j) {
      case xe.UP:
        k(-1), B.preventDefault();
        break;
      case xe.DOWN:
        k(1), B.preventDefault();
        break;
      case xe.ESC:
        y(!1);
        break;
      case xe.SPACE:
      case xe.ENTER:
        $ !== null && m($, B);
        break;
    }
  }
  Pe(function() {
    var B = document.getElementById(D);
    B && B.scrollIntoView && B.scrollIntoView(!1);
  }, [$]), Pe(function() {
    C || M(null);
  }, [C]);
  var L = re({}, p ? "marginRight" : "marginLeft", h);
  i.length || (L.visibility = "hidden", L.order = 1);
  var N = se(re({}, "".concat(T, "-rtl"), p)), F = s ? null : /* @__PURE__ */ O.createElement(pR, {
    prefixCls: T,
    overlay: I,
    trigger: ["hover"],
    visible: i.length ? C : !1,
    transitionName: u,
    onVisibleChange: y,
    overlayClassName: se(N, b),
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    getPopupContainer: v
  }, /* @__PURE__ */ O.createElement("button", {
    type: "button",
    className: "".concat(n, "-nav-more"),
    style: L,
    tabIndex: -1,
    "aria-hidden": "true",
    "aria-haspopup": "listbox",
    "aria-controls": _,
    id: "".concat(r, "-more"),
    "aria-expanded": C,
    onKeyDown: P
  }, l));
  return /* @__PURE__ */ O.createElement("div", {
    className: se("".concat(n, "-nav-operations"), d),
    style: c,
    ref: t
  }, F, /* @__PURE__ */ O.createElement(zR, {
    prefixCls: n,
    locale: o,
    editable: f
  }));
});
const z7 = /* @__PURE__ */ O.memo(j7, function(e, t) {
  return (
    // https://github.com/ant-design/ant-design/issues/32544
    // We'd better remove syntactic sugar in `rc-menu` since this has perf issue
    t.tabMoving
  );
});
var H7 = function(t) {
  var n = t.prefixCls, r = t.id, i = t.active, o = t.tab, s = o.key, a = o.label, l = o.disabled, u = o.closeIcon, c = o.icon, d = t.closable, f = t.renderWrapper, h = t.removeAriaLabel, p = t.editable, g = t.onClick, m = t.onFocus, v = t.style, b = "".concat(n, "-tab"), x = jR(d, u, p, l);
  function w(A) {
    l || g(A);
  }
  function C(A) {
    A.preventDefault(), A.stopPropagation(), p.onEdit("remove", {
      key: s,
      event: A
    });
  }
  var y = O.useMemo(function() {
    return c && typeof a == "string" ? /* @__PURE__ */ O.createElement("span", null, a) : a;
  }, [a, c]), S = /* @__PURE__ */ O.createElement("div", {
    key: s,
    "data-node-key": BR(s),
    className: se(b, re(re(re({}, "".concat(b, "-with-remove"), x), "".concat(b, "-active"), i), "".concat(b, "-disabled"), l)),
    style: v,
    onClick: w
  }, /* @__PURE__ */ O.createElement("div", {
    role: "tab",
    "aria-selected": i,
    id: r && "".concat(r, "-tab-").concat(s),
    className: "".concat(b, "-btn"),
    "aria-controls": r && "".concat(r, "-panel-").concat(s),
    "aria-disabled": l,
    tabIndex: l ? null : 0,
    onClick: function($) {
      $.stopPropagation(), w($);
    },
    onKeyDown: function($) {
      [xe.SPACE, xe.ENTER].includes($.which) && ($.preventDefault(), w($));
    },
    onFocus: m
  }, c && /* @__PURE__ */ O.createElement("span", {
    className: "".concat(b, "-icon")
  }, c), a && y), x && /* @__PURE__ */ O.createElement("button", {
    type: "button",
    "aria-label": h || "remove",
    tabIndex: 0,
    className: "".concat(b, "-remove"),
    onClick: function($) {
      $.stopPropagation(), C($);
    }
  }, u || p.removeIcon || ""));
  return f ? f(S) : S;
}, V7 = function(t, n) {
  var r = t.offsetWidth, i = t.offsetHeight, o = t.offsetTop, s = t.offsetLeft, a = t.getBoundingClientRect(), l = a.width, u = a.height, c = a.x, d = a.y;
  return Math.abs(l - r) < 1 ? [l, u, c - n.x, d - n.y] : [r, i, s, o];
}, Vl = function(t) {
  var n = t.current || {}, r = n.offsetWidth, i = r === void 0 ? 0 : r, o = n.offsetHeight, s = o === void 0 ? 0 : o;
  if (t.current) {
    var a = t.current.getBoundingClientRect(), l = a.width, u = a.height;
    if (Math.abs(l - i) < 1)
      return [l, u];
  }
  return [i, s];
}, eh = function(t, n) {
  return t[n ? 0 : 1];
}, ME = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.className, r = e.style, i = e.id, o = e.animated, s = e.activeKey, a = e.rtl, l = e.extra, u = e.editable, c = e.locale, d = e.tabPosition, f = e.tabBarGutter, h = e.children, p = e.onTabClick, g = e.onTabScroll, m = e.indicator, v = O.useContext(em), b = v.prefixCls, x = v.tabs, w = he(null), C = he(null), y = he(null), S = he(null), A = he(null), $ = he(null), M = he(null), _ = d === "top" || d === "bottom", T = AE(0, function(Ee, ye) {
    _ && g && g({
      direction: Ee > ye ? "left" : "right"
    });
  }), D = ae(T, 2), E = D[0], R = D[1], I = AE(0, function(Ee, ye) {
    !_ && g && g({
      direction: Ee > ye ? "top" : "bottom"
    });
  }), k = ae(I, 2), P = k[0], L = k[1], N = ht([0, 0]), F = ae(N, 2), B = F[0], j = F[1], z = ht([0, 0]), H = ae(z, 2), W = H[0], G = H[1], K = ht([0, 0]), Y = ae(K, 2), X = Y[0], Z = Y[1], Q = ht([0, 0]), ne = ae(Q, 2), q = ne[0], te = ne[1], fe = L7(/* @__PURE__ */ new Map()), Se = ae(fe, 2), de = Se[0], ce = Se[1], pe = k7(x, de, W[0]), Oe = eh(B, _), Re = eh(W, _), De = eh(X, _), Me = eh(q, _), Ue = Oe < Re + De, oe = Ue ? Oe - Me : Oe - De, Ce = "".concat(b, "-nav-operations-hidden"), ge = 0, ve = 0;
  _ && a ? (ge = 0, ve = Math.max(0, Re - oe)) : (ge = Math.min(0, oe - Re), ve = 0);
  function me(Ee) {
    return Ee < ge ? ge : Ee > ve ? ve : Ee;
  }
  var Fe = he(null), Be = ht(), qe = ae(Be, 2), Ve = qe[0], We = qe[1];
  function Ge() {
    We(Date.now());
  }
  function $e() {
    Fe.current && clearTimeout(Fe.current);
  }
  N7(S, function(Ee, ye) {
    function Ke(et, Ie) {
      et(function(Ae) {
        var tt = me(Ae + Ie);
        return tt;
      });
    }
    return Ue ? (_ ? Ke(R, Ee) : Ke(L, ye), $e(), Ge(), !0) : !1;
  }), Pe(function() {
    return $e(), Ve && (Fe.current = setTimeout(function() {
      We(0);
    }, 100)), $e;
  }, [Ve]);
  var ze = F7(
    pe,
    // Container
    oe,
    // Transform
    _ ? E : P,
    // Tabs
    Re,
    // Add
    De,
    // Operation
    Me,
    ie(ie({}, e), {}, {
      tabs: x
    })
  ), at = ae(ze, 2), xt = at[0], jt = at[1], Lt = Nn(function() {
    var Ee = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : s, ye = pe.get(Ee) || {
      width: 0,
      height: 0,
      left: 0,
      right: 0,
      top: 0
    };
    if (_) {
      var Ke = E;
      a ? ye.right < E ? Ke = ye.right : ye.right + ye.width > E + oe && (Ke = ye.right + ye.width - oe) : ye.left < -E ? Ke = -ye.left : ye.left + ye.width > -E + oe && (Ke = -(ye.left + ye.width - oe)), L(0), R(me(Ke));
    } else {
      var et = P;
      ye.top < -P ? et = -ye.top : ye.top + ye.height > -P + oe && (et = -(ye.top + ye.height - oe)), R(0), L(me(et));
    }
  }), At = {};
  d === "top" || d === "bottom" ? At[a ? "marginRight" : "marginLeft"] = f : At.marginTop = f;
  var Et = x.map(function(Ee, ye) {
    var Ke = Ee.key;
    return /* @__PURE__ */ O.createElement(H7, {
      id: i,
      prefixCls: b,
      key: Ke,
      tab: Ee,
      style: ye === 0 ? void 0 : At,
      closable: Ee.closable,
      editable: u,
      active: Ke === s,
      renderWrapper: h,
      removeAriaLabel: c == null ? void 0 : c.removeAriaLabel,
      onClick: function(Ie) {
        p(Ke, Ie);
      },
      onFocus: function() {
        Lt(Ke), Ge(), S.current && (a || (S.current.scrollLeft = 0), S.current.scrollTop = 0);
      }
    });
  }), nt = function() {
    return ce(function() {
      var ye, Ke = /* @__PURE__ */ new Map(), et = (ye = A.current) === null || ye === void 0 ? void 0 : ye.getBoundingClientRect();
      return x.forEach(function(Ie) {
        var Ae, tt = Ie.key, dt = (Ae = A.current) === null || Ae === void 0 ? void 0 : Ae.querySelector('[data-node-key="'.concat(BR(tt), '"]'));
        if (dt) {
          var Tt = V7(dt, et), Ct = ae(Tt, 4), vn = Ct[0], Hn = Ct[1], pn = Ct[2], Qn = Ct[3];
          Ke.set(tt, {
            width: vn,
            height: Hn,
            left: pn,
            top: Qn
          });
        }
      }), Ke;
    });
  };
  Pe(function() {
    nt();
  }, [x.map(function(Ee) {
    return Ee.key;
  }).join("_")]);
  var it = FR(function() {
    var Ee = Vl(w), ye = Vl(C), Ke = Vl(y);
    j([Ee[0] - ye[0] - Ke[0], Ee[1] - ye[1] - Ke[1]]);
    var et = Vl(M);
    Z(et);
    var Ie = Vl($);
    te(Ie);
    var Ae = Vl(A);
    G([Ae[0] - et[0], Ae[1] - et[1]]), nt();
  }), je = x.slice(0, xt), Le = x.slice(jt + 1), ot = [].concat(_e(je), _e(Le)), yt = pe.get(s), He = I7({
    activeTabOffset: yt,
    horizontal: _,
    indicator: m,
    rtl: a
  }), Je = He.style;
  Pe(function() {
    Lt();
  }, [s, ge, ve, RE(yt), RE(pe), _]), Pe(function() {
    it();
  }, [a]);
  var Qe = !!ot.length, lt = "".concat(b, "-nav-wrap"), pt, vt, ee, be;
  return _ ? a ? (vt = E > 0, pt = E !== ve) : (pt = E < 0, vt = E !== ge) : (ee = P < 0, be = P !== ge), /* @__PURE__ */ O.createElement(Ci, {
    onResize: it
  }, /* @__PURE__ */ O.createElement("div", {
    ref: ba(t, w),
    role: "tablist",
    className: se("".concat(b, "-nav"), n),
    style: r,
    onKeyDown: function() {
      Ge();
    }
  }, /* @__PURE__ */ O.createElement(Nb, {
    ref: C,
    position: "left",
    extra: l,
    prefixCls: b
  }), /* @__PURE__ */ O.createElement(Ci, {
    onResize: it
  }, /* @__PURE__ */ O.createElement("div", {
    className: se(lt, re(re(re(re({}, "".concat(lt, "-ping-left"), pt), "".concat(lt, "-ping-right"), vt), "".concat(lt, "-ping-top"), ee), "".concat(lt, "-ping-bottom"), be)),
    ref: S
  }, /* @__PURE__ */ O.createElement(Ci, {
    onResize: it
  }, /* @__PURE__ */ O.createElement("div", {
    ref: A,
    className: "".concat(b, "-nav-list"),
    style: {
      transform: "translate(".concat(E, "px, ").concat(P, "px)"),
      transition: Ve ? "none" : void 0
    }
  }, Et, /* @__PURE__ */ O.createElement(zR, {
    ref: M,
    prefixCls: b,
    locale: c,
    editable: u,
    style: ie(ie({}, Et.length === 0 ? void 0 : At), {}, {
      visibility: Qe ? "hidden" : null
    })
  }), /* @__PURE__ */ O.createElement("div", {
    className: se("".concat(b, "-ink-bar"), re({}, "".concat(b, "-ink-bar-animated"), o.inkBar)),
    style: Je
  }))))), /* @__PURE__ */ O.createElement(z7, we({}, e, {
    removeAriaLabel: c == null ? void 0 : c.removeAriaLabel,
    ref: $,
    prefixCls: b,
    tabs: ot,
    className: !Qe && Ce,
    tabMoving: !!Ve
  })), /* @__PURE__ */ O.createElement(Nb, {
    ref: y,
    position: "right",
    extra: l,
    prefixCls: b
  })));
}), A1 = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.prefixCls, r = e.className, i = e.style, o = e.id, s = e.active, a = e.tabKey, l = e.children;
  return /* @__PURE__ */ O.createElement("div", {
    id: o && "".concat(o, "-panel-").concat(a),
    role: "tabpanel",
    tabIndex: s ? 0 : -1,
    "aria-labelledby": o && "".concat(o, "-tab-").concat(a),
    "aria-hidden": !s,
    style: i,
    className: se(n, s && "".concat(n, "-active"), r),
    ref: t
  }, l);
});
process.env.NODE_ENV !== "production" && (A1.displayName = "TabPane");
var W7 = ["renderTabBar"], U7 = ["label", "key"], HR = function(t) {
  var n = t.renderTabBar, r = Rt(t, W7), i = O.useContext(em), o = i.tabs;
  if (n) {
    var s = ie(ie({}, r), {}, {
      // Legacy support. We do not use this actually
      panes: o.map(function(a) {
        var l = a.label, u = a.key, c = Rt(a, U7);
        return /* @__PURE__ */ O.createElement(A1, we({
          tab: l,
          key: u,
          tabKey: u
        }, c));
      })
    });
    return n(s, ME);
  }
  return /* @__PURE__ */ O.createElement(ME, r);
};
process.env.NODE_ENV !== "production" && (HR.displayName = "TabNavListWrapper");
var G7 = ["key", "forceRender", "style", "className", "destroyInactiveTabPane"], K7 = function(t) {
  var n = t.id, r = t.activeKey, i = t.animated, o = t.tabPosition, s = t.destroyInactiveTabPane, a = O.useContext(em), l = a.prefixCls, u = a.tabs, c = i.tabPane, d = "".concat(l, "-tabpane");
  return /* @__PURE__ */ O.createElement("div", {
    className: se("".concat(l, "-content-holder"))
  }, /* @__PURE__ */ O.createElement("div", {
    className: se("".concat(l, "-content"), "".concat(l, "-content-").concat(o), re({}, "".concat(l, "-content-animated"), c))
  }, u.map(function(f) {
    var h = f.key, p = f.forceRender, g = f.style, m = f.className, v = f.destroyInactiveTabPane, b = Rt(f, G7), x = h === r;
    return /* @__PURE__ */ O.createElement(qo, we({
      key: h,
      visible: x,
      forceRender: p,
      removeOnLeave: !!(s || v),
      leavedClassName: "".concat(d, "-hidden")
    }, i.tabPaneMotion), function(w, C) {
      var y = w.style, S = w.className;
      return /* @__PURE__ */ O.createElement(A1, we({}, b, {
        prefixCls: d,
        id: n,
        tabKey: h,
        animated: c,
        active: x,
        style: ie(ie({}, g), y),
        className: se(m, S),
        ref: C
      }));
    });
  })));
};
function X7() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    inkBar: !0,
    tabPane: !1
  }, t;
  return e === !1 ? t = {
    inkBar: !1,
    tabPane: !1
  } : e === !0 ? t = {
    inkBar: !0,
    tabPane: !1
  } : t = ie({
    inkBar: !0
  }, wt(e) === "object" ? e : {}), t.tabPaneMotion && t.tabPane === void 0 && (t.tabPane = !0), !t.tabPaneMotion && t.tabPane && (process.env.NODE_ENV !== "production" && $t(!1, "`animated.tabPane` is true but `animated.tabPaneMotion` is not provided. Motion will not work."), t.tabPane = !1), t;
}
var Y7 = ["id", "prefixCls", "className", "items", "direction", "activeKey", "defaultActiveKey", "editable", "animated", "tabPosition", "tabBarGutter", "tabBarStyle", "tabBarExtraContent", "locale", "moreIcon", "moreTransitionName", "destroyInactiveTabPane", "renderTabBar", "onChange", "onTabClick", "onTabScroll", "getPopupContainer", "popupClassName", "indicator"], IE = 0, VR = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.id, r = e.prefixCls, i = r === void 0 ? "rc-tabs" : r, o = e.className, s = e.items, a = e.direction, l = e.activeKey, u = e.defaultActiveKey, c = e.editable, d = e.animated, f = e.tabPosition, h = f === void 0 ? "top" : f, p = e.tabBarGutter, g = e.tabBarStyle, m = e.tabBarExtraContent, v = e.locale, b = e.moreIcon, x = e.moreTransitionName, w = e.destroyInactiveTabPane, C = e.renderTabBar, y = e.onChange, S = e.onTabClick, A = e.onTabScroll, $ = e.getPopupContainer, M = e.popupClassName, _ = e.indicator, T = Rt(e, Y7), D = O.useMemo(function() {
    return (s || []).filter(function(te) {
      return te && wt(te) === "object" && "key" in te;
    });
  }, [s]), E = a === "rtl", R = X7(d), I = ht(!1), k = ae(I, 2), P = k[0], L = k[1];
  Pe(function() {
    L(n1());
  }, []);
  var N = Un(function() {
    var te;
    return (te = D[0]) === null || te === void 0 ? void 0 : te.key;
  }, {
    value: l,
    defaultValue: u
  }), F = ae(N, 2), B = F[0], j = F[1], z = ht(function() {
    return D.findIndex(function(te) {
      return te.key === B;
    });
  }), H = ae(z, 2), W = H[0], G = H[1];
  Pe(function() {
    var te = D.findIndex(function(Se) {
      return Se.key === B;
    });
    if (te === -1) {
      var fe;
      te = Math.max(0, Math.min(W, D.length - 1)), j((fe = D[te]) === null || fe === void 0 ? void 0 : fe.key);
    }
    G(te);
  }, [D.map(function(te) {
    return te.key;
  }).join("_"), B, W]);
  var K = Un(null, {
    value: n
  }), Y = ae(K, 2), X = Y[0], Z = Y[1];
  Pe(function() {
    n || (Z("rc-tabs-".concat(process.env.NODE_ENV === "test" ? "test" : IE)), IE += 1);
  }, []);
  function Q(te, fe) {
    S == null || S(te, fe);
    var Se = te !== B;
    j(te), Se && (y == null || y(te));
  }
  var ne = {
    id: X,
    activeKey: B,
    animated: R,
    tabPosition: h,
    rtl: E,
    mobile: P
  }, q = ie(ie({}, ne), {}, {
    editable: c,
    locale: v,
    moreIcon: b,
    moreTransitionName: x,
    tabBarGutter: p,
    onTabClick: Q,
    onTabScroll: A,
    extra: m,
    style: g,
    panes: null,
    getPopupContainer: $,
    popupClassName: M,
    indicator: _
  });
  return /* @__PURE__ */ O.createElement(em.Provider, {
    value: {
      tabs: D,
      prefixCls: i
    }
  }, /* @__PURE__ */ O.createElement("div", we({
    ref: t,
    id: n,
    className: se(i, "".concat(i, "-").concat(h), re(re(re({}, "".concat(i, "-mobile"), P), "".concat(i, "-editable"), c), "".concat(i, "-rtl"), E), o)
  }, T), /* @__PURE__ */ O.createElement(HR, we({}, q, {
    renderTabBar: C
  })), /* @__PURE__ */ O.createElement(K7, we({
    destroyInactiveTabPane: w
  }, ne, {
    animated: R
  }))));
});
process.env.NODE_ENV !== "production" && (VR.displayName = "Tabs");
const q7 = {
  motionAppear: !1,
  motionEnter: !0,
  motionLeave: !0
};
function Q7(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    inkBar: !0,
    tabPane: !1
  }, n;
  return t === !1 ? n = {
    inkBar: !1,
    tabPane: !1
  } : t === !0 ? n = {
    inkBar: !0,
    tabPane: !0
  } : n = Object.assign({
    inkBar: !0
  }, typeof t == "object" ? t : {}), n.tabPane && (n.tabPaneMotion = Object.assign(Object.assign({}, q7), {
    motionName: Xo(e, "switch")
  })), n;
}
var Z7 = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
function J7(e) {
  return e.filter((t) => t);
}
function eW(e, t) {
  if (process.env.NODE_ENV !== "production" && Zt("Tabs").deprecated(!t, "Tabs.TabPane", "items"), e)
    return e;
  const n = Xr(t).map((r) => {
    if (/* @__PURE__ */ O.isValidElement(r)) {
      const {
        key: i,
        props: o
      } = r, s = o || {}, {
        tab: a
      } = s, l = Z7(s, ["tab"]);
      return Object.assign(Object.assign({
        key: String(i)
      }, l), {
        label: a
      });
    }
    return null;
  });
  return J7(n);
}
const tW = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n
  } = e;
  return [
    {
      [t]: {
        [`${t}-switch`]: {
          "&-appear, &-enter": {
            transition: "none",
            "&-start": {
              opacity: 0
            },
            "&-active": {
              opacity: 1,
              transition: `opacity ${n}`
            }
          },
          "&-leave": {
            position: "absolute",
            transition: "none",
            inset: 0,
            "&-start": {
              opacity: 1
            },
            "&-active": {
              opacity: 0,
              transition: `opacity ${n}`
            }
          }
        }
      }
    },
    // Follow code may reuse in other components
    [ua(e, "slide-up"), ua(e, "slide-down")]
  ];
}, nW = (e) => {
  const {
    componentCls: t,
    tabsCardPadding: n,
    cardBg: r,
    cardGutter: i,
    colorBorderSecondary: o,
    itemSelectedColor: s
  } = e;
  return {
    [`${t}-card`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-tab`]: {
          margin: 0,
          padding: n,
          background: r,
          border: `${le(e.lineWidth)} ${e.lineType} ${o}`,
          transition: `all ${e.motionDurationSlow} ${e.motionEaseInOut}`
        },
        [`${t}-tab-active`]: {
          color: s,
          background: e.colorBgContainer
        },
        [`${t}-ink-bar`]: {
          visibility: "hidden"
        }
      },
      // ========================== Top & Bottom ==========================
      [`&${t}-top, &${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginLeft: {
              _skip_check_: !0,
              value: le(i)
            }
          }
        }
      },
      [`&${t}-top`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: `${le(e.borderRadiusLG)} ${le(e.borderRadiusLG)} 0 0`
          },
          [`${t}-tab-active`]: {
            borderBottomColor: e.colorBgContainer
          }
        }
      },
      [`&${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: `0 0 ${le(e.borderRadiusLG)} ${le(e.borderRadiusLG)}`
          },
          [`${t}-tab-active`]: {
            borderTopColor: e.colorBgContainer
          }
        }
      },
      // ========================== Left & Right ==========================
      [`&${t}-left, &${t}-right`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginTop: le(i)
          }
        }
      },
      [`&${t}-left`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `${le(e.borderRadiusLG)} 0 0 ${le(e.borderRadiusLG)}`
            }
          },
          [`${t}-tab-active`]: {
            borderRightColor: {
              _skip_check_: !0,
              value: e.colorBgContainer
            }
          }
        }
      },
      [`&${t}-right`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `0 ${le(e.borderRadiusLG)} ${le(e.borderRadiusLG)} 0`
            }
          },
          [`${t}-tab-active`]: {
            borderLeftColor: {
              _skip_check_: !0,
              value: e.colorBgContainer
            }
          }
        }
      }
    }
  };
}, rW = (e) => {
  const {
    componentCls: t,
    itemHoverColor: n,
    dropdownEdgeChildVerticalPadding: r
  } = e;
  return {
    [`${t}-dropdown`]: Object.assign(Object.assign({}, Gn(e)), {
      position: "absolute",
      top: -9999,
      left: {
        _skip_check_: !0,
        value: -9999
      },
      zIndex: e.zIndexPopup,
      display: "block",
      "&-hidden": {
        display: "none"
      },
      [`${t}-dropdown-menu`]: {
        maxHeight: e.tabsDropdownHeight,
        margin: 0,
        padding: `${le(r)} 0`,
        overflowX: "hidden",
        overflowY: "auto",
        textAlign: {
          _skip_check_: !0,
          value: "left"
        },
        listStyleType: "none",
        backgroundColor: e.colorBgContainer,
        backgroundClip: "padding-box",
        borderRadius: e.borderRadiusLG,
        outline: "none",
        boxShadow: e.boxShadowSecondary,
        "&-item": Object.assign(Object.assign({}, la), {
          display: "flex",
          alignItems: "center",
          minWidth: e.tabsDropdownWidth,
          margin: 0,
          padding: `${le(e.paddingXXS)} ${le(e.paddingSM)}`,
          color: e.colorText,
          fontWeight: "normal",
          fontSize: e.fontSize,
          lineHeight: e.lineHeight,
          cursor: "pointer",
          transition: `all ${e.motionDurationSlow}`,
          "> span": {
            flex: 1,
            whiteSpace: "nowrap"
          },
          "&-remove": {
            flex: "none",
            marginLeft: {
              _skip_check_: !0,
              value: e.marginSM
            },
            color: e.colorTextDescription,
            fontSize: e.fontSizeSM,
            background: "transparent",
            border: 0,
            cursor: "pointer",
            "&:hover": {
              color: n
            }
          },
          "&:hover": {
            background: e.controlItemBgHover
          },
          "&-disabled": {
            "&, &:hover": {
              color: e.colorTextDisabled,
              background: "transparent",
              cursor: "not-allowed"
            }
          }
        })
      }
    })
  };
}, iW = (e) => {
  const {
    componentCls: t,
    margin: n,
    colorBorderSecondary: r,
    horizontalMargin: i,
    verticalItemPadding: o,
    verticalItemMargin: s,
    calc: a
  } = e;
  return {
    // ========================== Top & Bottom ==========================
    [`${t}-top, ${t}-bottom`]: {
      flexDirection: "column",
      [`> ${t}-nav, > div > ${t}-nav`]: {
        margin: i,
        "&::before": {
          position: "absolute",
          right: {
            _skip_check_: !0,
            value: 0
          },
          left: {
            _skip_check_: !0,
            value: 0
          },
          borderBottom: `${le(e.lineWidth)} ${e.lineType} ${r}`,
          content: "''"
        },
        [`${t}-ink-bar`]: {
          height: e.lineWidthBold,
          "&-animated": {
            transition: `width ${e.motionDurationSlow}, left ${e.motionDurationSlow},
            right ${e.motionDurationSlow}`
          }
        },
        [`${t}-nav-wrap`]: {
          "&::before, &::after": {
            top: 0,
            bottom: 0,
            width: e.controlHeight
          },
          "&::before": {
            left: {
              _skip_check_: !0,
              value: 0
            },
            boxShadow: e.boxShadowTabsOverflowLeft
          },
          "&::after": {
            right: {
              _skip_check_: !0,
              value: 0
            },
            boxShadow: e.boxShadowTabsOverflowRight
          },
          [`&${t}-nav-wrap-ping-left::before`]: {
            opacity: 1
          },
          [`&${t}-nav-wrap-ping-right::after`]: {
            opacity: 1
          }
        }
      }
    },
    [`${t}-top`]: {
      [`> ${t}-nav,
        > div > ${t}-nav`]: {
        "&::before": {
          bottom: 0
        },
        [`${t}-ink-bar`]: {
          bottom: 0
        }
      }
    },
    [`${t}-bottom`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        order: 1,
        marginTop: n,
        marginBottom: 0,
        "&::before": {
          top: 0
        },
        [`${t}-ink-bar`]: {
          top: 0
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        order: 0
      }
    },
    // ========================== Left & Right ==========================
    [`${t}-left, ${t}-right`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        flexDirection: "column",
        minWidth: a(e.controlHeight).mul(1.25).equal(),
        // >>>>>>>>>>> Tab
        [`${t}-tab`]: {
          padding: o,
          textAlign: "center"
        },
        [`${t}-tab + ${t}-tab`]: {
          margin: s
        },
        // >>>>>>>>>>> Nav
        [`${t}-nav-wrap`]: {
          flexDirection: "column",
          "&::before, &::after": {
            right: {
              _skip_check_: !0,
              value: 0
            },
            left: {
              _skip_check_: !0,
              value: 0
            },
            height: e.controlHeight
          },
          "&::before": {
            top: 0,
            boxShadow: e.boxShadowTabsOverflowTop
          },
          "&::after": {
            bottom: 0,
            boxShadow: e.boxShadowTabsOverflowBottom
          },
          [`&${t}-nav-wrap-ping-top::before`]: {
            opacity: 1
          },
          [`&${t}-nav-wrap-ping-bottom::after`]: {
            opacity: 1
          }
        },
        // >>>>>>>>>>> Ink Bar
        [`${t}-ink-bar`]: {
          width: e.lineWidthBold,
          "&-animated": {
            transition: `height ${e.motionDurationSlow}, top ${e.motionDurationSlow}`
          }
        },
        [`${t}-nav-list, ${t}-nav-operations`]: {
          flex: "1 0 auto",
          // fix safari scroll problem
          flexDirection: "column"
        }
      }
    },
    [`${t}-left`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-ink-bar`]: {
          right: {
            _skip_check_: !0,
            value: 0
          }
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        marginLeft: {
          _skip_check_: !0,
          value: le(a(e.lineWidth).mul(-1).equal())
        },
        borderLeft: {
          _skip_check_: !0,
          value: `${le(e.lineWidth)} ${e.lineType} ${e.colorBorder}`
        },
        [`> ${t}-content > ${t}-tabpane`]: {
          paddingLeft: {
            _skip_check_: !0,
            value: e.paddingLG
          }
        }
      }
    },
    [`${t}-right`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        order: 1,
        [`${t}-ink-bar`]: {
          left: {
            _skip_check_: !0,
            value: 0
          }
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        order: 0,
        marginRight: {
          _skip_check_: !0,
          value: a(e.lineWidth).mul(-1).equal()
        },
        borderRight: {
          _skip_check_: !0,
          value: `${le(e.lineWidth)} ${e.lineType} ${e.colorBorder}`
        },
        [`> ${t}-content > ${t}-tabpane`]: {
          paddingRight: {
            _skip_check_: !0,
            value: e.paddingLG
          }
        }
      }
    }
  };
}, oW = (e) => {
  const {
    componentCls: t,
    cardPaddingSM: n,
    cardPaddingLG: r,
    horizontalItemPaddingSM: i,
    horizontalItemPaddingLG: o
  } = e;
  return {
    [t]: {
      "&-small": {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: i,
            fontSize: e.titleFontSizeSM
          }
        }
      },
      "&-large": {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: o,
            fontSize: e.titleFontSizeLG
          }
        }
      }
    },
    [`${t}-card`]: {
      [`&${t}-small`]: {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: n
          }
        },
        [`&${t}-bottom`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: `0 0 ${le(e.borderRadius)} ${le(e.borderRadius)}`
          }
        },
        [`&${t}-top`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: `${le(e.borderRadius)} ${le(e.borderRadius)} 0 0`
          }
        },
        [`&${t}-right`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `0 ${le(e.borderRadius)} ${le(e.borderRadius)} 0`
            }
          }
        },
        [`&${t}-left`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `${le(e.borderRadius)} 0 0 ${le(e.borderRadius)}`
            }
          }
        }
      },
      [`&${t}-large`]: {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: r
          }
        }
      }
    }
  };
}, sW = (e) => {
  const {
    componentCls: t,
    itemActiveColor: n,
    itemHoverColor: r,
    iconCls: i,
    tabsHorizontalItemMargin: o,
    horizontalItemPadding: s,
    itemSelectedColor: a,
    itemColor: l
  } = e, u = `${t}-tab`;
  return {
    [u]: {
      position: "relative",
      WebkitTouchCallout: "none",
      WebkitTapHighlightColor: "transparent",
      display: "inline-flex",
      alignItems: "center",
      padding: s,
      fontSize: e.titleFontSize,
      background: "transparent",
      border: 0,
      outline: "none",
      cursor: "pointer",
      color: l,
      "&-btn, &-remove": Object.assign({
        "&:focus:not(:focus-visible), &:active": {
          color: n
        }
      }, Za(e)),
      "&-btn": {
        outline: "none",
        transition: `all ${e.motionDurationSlow}`,
        [`${u}-icon:not(:last-child)`]: {
          marginInlineEnd: e.marginSM
        }
      },
      "&-remove": {
        flex: "none",
        marginRight: {
          _skip_check_: !0,
          value: e.calc(e.marginXXS).mul(-1).equal()
        },
        marginLeft: {
          _skip_check_: !0,
          value: e.marginXS
        },
        color: e.colorTextDescription,
        fontSize: e.fontSizeSM,
        background: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        transition: `all ${e.motionDurationSlow}`,
        "&:hover": {
          color: e.colorTextHeading
        }
      },
      "&:hover": {
        color: r
      },
      [`&${u}-active ${u}-btn`]: {
        color: a,
        textShadow: e.tabsActiveTextShadow
      },
      [`&${u}-disabled`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed"
      },
      [`&${u}-disabled ${u}-btn, &${u}-disabled ${t}-remove`]: {
        "&:focus, &:active": {
          color: e.colorTextDisabled
        }
      },
      [`& ${u}-remove ${i}`]: {
        margin: 0
      },
      [`${i}:not(:last-child)`]: {
        marginRight: {
          _skip_check_: !0,
          value: e.marginSM
        }
      }
    },
    [`${u} + ${u}`]: {
      margin: {
        _skip_check_: !0,
        value: o
      }
    }
  };
}, aW = (e) => {
  const {
    componentCls: t,
    tabsHorizontalItemMarginRTL: n,
    iconCls: r,
    cardGutter: i,
    calc: o
  } = e;
  return {
    [`${t}-rtl`]: {
      direction: "rtl",
      [`${t}-nav`]: {
        [`${t}-tab`]: {
          margin: {
            _skip_check_: !0,
            value: n
          },
          [`${t}-tab:last-of-type`]: {
            marginLeft: {
              _skip_check_: !0,
              value: 0
            }
          },
          [r]: {
            marginRight: {
              _skip_check_: !0,
              value: 0
            },
            marginLeft: {
              _skip_check_: !0,
              value: le(e.marginSM)
            }
          },
          [`${t}-tab-remove`]: {
            marginRight: {
              _skip_check_: !0,
              value: le(e.marginXS)
            },
            marginLeft: {
              _skip_check_: !0,
              value: le(o(e.marginXXS).mul(-1).equal())
            },
            [r]: {
              margin: 0
            }
          }
        }
      },
      [`&${t}-left`]: {
        [`> ${t}-nav`]: {
          order: 1
        },
        [`> ${t}-content-holder`]: {
          order: 0
        }
      },
      [`&${t}-right`]: {
        [`> ${t}-nav`]: {
          order: 0
        },
        [`> ${t}-content-holder`]: {
          order: 1
        }
      },
      // ====================== Card ======================
      [`&${t}-card${t}-top, &${t}-card${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginRight: {
              _skip_check_: !0,
              value: i
            },
            marginLeft: {
              _skip_check_: !0,
              value: 0
            }
          }
        }
      }
    },
    [`${t}-dropdown-rtl`]: {
      direction: "rtl"
    },
    [`${t}-menu-item`]: {
      [`${t}-dropdown-rtl`]: {
        textAlign: {
          _skip_check_: !0,
          value: "right"
        }
      }
    }
  };
}, lW = (e) => {
  const {
    componentCls: t,
    tabsCardPadding: n,
    cardHeight: r,
    cardGutter: i,
    itemHoverColor: o,
    itemActiveColor: s,
    colorBorderSecondary: a
  } = e;
  return {
    [t]: Object.assign(Object.assign(Object.assign(Object.assign({}, Gn(e)), {
      display: "flex",
      // ========================== Navigation ==========================
      [`> ${t}-nav, > div > ${t}-nav`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        alignItems: "center",
        [`${t}-nav-wrap`]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          alignSelf: "stretch",
          overflow: "hidden",
          whiteSpace: "nowrap",
          transform: "translate(0)",
          // Fix chrome render bug
          // >>>>> Ping shadow
          "&::before, &::after": {
            position: "absolute",
            zIndex: 1,
            opacity: 0,
            transition: `opacity ${e.motionDurationSlow}`,
            content: "''",
            pointerEvents: "none"
          }
        },
        [`${t}-nav-list`]: {
          position: "relative",
          display: "flex",
          transition: `opacity ${e.motionDurationSlow}`
        },
        // >>>>>>>> Operations
        [`${t}-nav-operations`]: {
          display: "flex",
          alignSelf: "stretch"
        },
        [`${t}-nav-operations-hidden`]: {
          position: "absolute",
          visibility: "hidden",
          pointerEvents: "none"
        },
        [`${t}-nav-more`]: {
          position: "relative",
          padding: n,
          background: "transparent",
          border: 0,
          color: e.colorText,
          "&::after": {
            position: "absolute",
            right: {
              _skip_check_: !0,
              value: 0
            },
            bottom: 0,
            left: {
              _skip_check_: !0,
              value: 0
            },
            height: e.calc(e.controlHeightLG).div(8).equal(),
            transform: "translateY(100%)",
            content: "''"
          }
        },
        [`${t}-nav-add`]: Object.assign({
          minWidth: r,
          minHeight: r,
          marginLeft: {
            _skip_check_: !0,
            value: i
          },
          padding: `0 ${le(e.paddingXS)}`,
          background: "transparent",
          border: `${le(e.lineWidth)} ${e.lineType} ${a}`,
          borderRadius: `${le(e.borderRadiusLG)} ${le(e.borderRadiusLG)} 0 0`,
          outline: "none",
          cursor: "pointer",
          color: e.colorText,
          transition: `all ${e.motionDurationSlow} ${e.motionEaseInOut}`,
          "&:hover": {
            color: o
          },
          "&:active, &:focus:not(:focus-visible)": {
            color: s
          }
        }, Za(e))
      },
      [`${t}-extra-content`]: {
        flex: "none"
      },
      // ============================ InkBar ============================
      [`${t}-ink-bar`]: {
        position: "absolute",
        background: e.inkBarColor,
        pointerEvents: "none"
      }
    }), sW(e)), {
      // =========================== TabPanes ===========================
      [`${t}-content`]: {
        position: "relative",
        width: "100%"
      },
      [`${t}-content-holder`]: {
        flex: "auto",
        minWidth: 0,
        minHeight: 0
      },
      [`${t}-tabpane`]: {
        outline: "none",
        "&-hidden": {
          display: "none"
        }
      }
    }),
    [`${t}-centered`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-nav-wrap`]: {
          [`&:not([class*='${t}-nav-wrap-ping'])`]: {
            justifyContent: "center"
          }
        }
      }
    }
  };
}, cW = (e) => {
  const t = e.controlHeightLG;
  return {
    zIndexPopup: e.zIndexPopupBase + 50,
    cardBg: e.colorFillAlter,
    cardHeight: t,
    // Initialize with empty string, because cardPadding will be calculated with cardHeight by default.
    cardPadding: `${(t - Math.round(e.fontSize * e.lineHeight)) / 2 - e.lineWidth}px ${e.padding}px`,
    cardPaddingSM: `${e.paddingXXS * 1.5}px ${e.padding}px`,
    cardPaddingLG: `${e.paddingXS}px ${e.padding}px ${e.paddingXXS * 1.5}px`,
    titleFontSize: e.fontSize,
    titleFontSizeLG: e.fontSizeLG,
    titleFontSizeSM: e.fontSize,
    inkBarColor: e.colorPrimary,
    horizontalMargin: `0 0 ${e.margin}px 0`,
    horizontalItemGutter: 32,
    // Fixed Value
    // Initialize with empty string, because horizontalItemMargin will be calculated with horizontalItemGutter by default.
    horizontalItemMargin: "",
    horizontalItemMarginRTL: "",
    horizontalItemPadding: `${e.paddingSM}px 0`,
    horizontalItemPaddingSM: `${e.paddingXS}px 0`,
    horizontalItemPaddingLG: `${e.padding}px 0`,
    verticalItemPadding: `${e.paddingXS}px ${e.paddingLG}px`,
    verticalItemMargin: `${e.margin}px 0 0 0`,
    itemColor: e.colorText,
    itemSelectedColor: e.colorPrimary,
    itemHoverColor: e.colorPrimaryHover,
    itemActiveColor: e.colorPrimaryActive,
    cardGutter: e.marginXXS / 2
  };
}, uW = $n("Tabs", (e) => {
  const t = Jt(e, {
    // `cardPadding` is empty by default, so we could calculate with dynamic `cardHeight`
    tabsCardPadding: e.cardPadding,
    dropdownEdgeChildVerticalPadding: e.paddingXXS,
    tabsActiveTextShadow: "0 0 0.25px currentcolor",
    tabsDropdownHeight: 200,
    tabsDropdownWidth: 120,
    tabsHorizontalItemMargin: `0 0 0 ${le(e.horizontalItemGutter)}`,
    tabsHorizontalItemMarginRTL: `0 0 0 ${le(e.horizontalItemGutter)}`
  });
  return [oW(t), aW(t), iW(t), rW(t), nW(t), lW(t), tW(t)];
}, cW), WR = () => null;
process.env.NODE_ENV !== "production" && (WR.displayName = "DeprecatedTabPane");
var dW = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const tm = (e) => {
  var t, n, r, i, o, s, a, l;
  const {
    type: u,
    className: c,
    rootClassName: d,
    size: f,
    onEdit: h,
    hideAdd: p,
    centered: g,
    addIcon: m,
    removeIcon: v,
    moreIcon: b,
    popupClassName: x,
    children: w,
    items: C,
    animated: y,
    style: S,
    indicatorSize: A,
    indicator: $
  } = e, M = dW(e, ["type", "className", "rootClassName", "size", "onEdit", "hideAdd", "centered", "addIcon", "removeIcon", "moreIcon", "popupClassName", "children", "items", "animated", "style", "indicatorSize", "indicator"]), {
    prefixCls: _
  } = M, {
    direction: T,
    tabs: D,
    getPrefixCls: E,
    getPopupContainer: R
  } = O.useContext(rt), I = E("tabs", _), k = Kn(I), [P, L, N] = uW(I, k);
  let F;
  u === "editable-card" && (F = {
    onEdit: (K, Y) => {
      let {
        key: X,
        event: Z
      } = Y;
      h == null || h(K === "add" ? Z : X, K);
    },
    removeIcon: (t = v ?? (D == null ? void 0 : D.removeIcon)) !== null && t !== void 0 ? t : /* @__PURE__ */ O.createElement(To, null),
    addIcon: (m ?? (D == null ? void 0 : D.addIcon)) || /* @__PURE__ */ O.createElement(ou, null),
    showAdd: p !== !0
  });
  const B = E();
  if (process.env.NODE_ENV !== "production") {
    const K = Zt("Tabs");
    process.env.NODE_ENV !== "production" && K(!("onPrevClick" in e) && !("onNextClick" in e), "breaking", "`onPrevClick` and `onNextClick` has been removed. Please use `onTabScroll` instead."), process.env.NODE_ENV !== "production" && K(!(A || D != null && D.indicatorSize), "deprecated", "`indicatorSize` has been deprecated. Please use `indicator={{ size: ... }}` instead.");
  }
  const j = so(f), z = eW(C, w), H = Q7(I, y), W = Object.assign(Object.assign({}, D == null ? void 0 : D.style), S), G = {
    align: (n = $ == null ? void 0 : $.align) !== null && n !== void 0 ? n : (r = D == null ? void 0 : D.indicator) === null || r === void 0 ? void 0 : r.align,
    size: (a = (o = (i = $ == null ? void 0 : $.size) !== null && i !== void 0 ? i : A) !== null && o !== void 0 ? o : (s = D == null ? void 0 : D.indicator) === null || s === void 0 ? void 0 : s.size) !== null && a !== void 0 ? a : D == null ? void 0 : D.indicatorSize
  };
  return P(/* @__PURE__ */ O.createElement(VR, Object.assign({
    direction: T,
    getPopupContainer: R,
    moreTransitionName: `${B}-slide-up`
  }, M, {
    items: z,
    className: se({
      [`${I}-${j}`]: j,
      [`${I}-card`]: ["card", "editable-card"].includes(u),
      [`${I}-editable-card`]: u === "editable-card",
      [`${I}-centered`]: g
    }, D == null ? void 0 : D.className, c, d, L, N, k),
    popupClassName: se(x, L, N, k),
    style: W,
    editable: F,
    moreIcon: (l = b ?? (D == null ? void 0 : D.moreIcon)) !== null && l !== void 0 ? l : /* @__PURE__ */ O.createElement(Qg, null),
    prefixCls: I,
    animated: H,
    indicator: G
  })));
};
tm.TabPane = WR;
process.env.NODE_ENV !== "production" && (tm.displayName = "Tabs");
var fW = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const UR = (e) => {
  var {
    prefixCls: t,
    className: n,
    hoverable: r = !0
  } = e, i = fW(e, ["prefixCls", "className", "hoverable"]);
  const {
    getPrefixCls: o
  } = O.useContext(rt), s = o("card", t), a = se(`${s}-grid`, n, {
    [`${s}-grid-hoverable`]: r
  });
  return /* @__PURE__ */ O.createElement("div", Object.assign({}, i, {
    className: a
  }));
}, hW = (e) => {
  const {
    antCls: t,
    componentCls: n,
    headerHeight: r,
    cardPaddingBase: i,
    tabsMarginBottom: o
  } = e;
  return Object.assign(Object.assign({
    display: "flex",
    justifyContent: "center",
    flexDirection: "column",
    minHeight: r,
    marginBottom: -1,
    padding: `0 ${le(i)}`,
    color: e.colorTextHeading,
    fontWeight: e.fontWeightStrong,
    fontSize: e.headerFontSize,
    background: e.headerBg,
    borderBottom: `${le(e.lineWidth)} ${e.lineType} ${e.colorBorderSecondary}`,
    borderRadius: `${le(e.borderRadiusLG)} ${le(e.borderRadiusLG)} 0 0`
  }, ca()), {
    "&-wrapper": {
      width: "100%",
      display: "flex",
      alignItems: "center"
    },
    "&-title": Object.assign(Object.assign({
      display: "inline-block",
      flex: 1
    }, la), {
      [`
          > ${n}-typography,
          > ${n}-typography-edit-content
        `]: {
        insetInlineStart: 0,
        marginTop: 0,
        marginBottom: 0
      }
    }),
    [`${t}-tabs-top`]: {
      clear: "both",
      marginBottom: o,
      color: e.colorText,
      fontWeight: "normal",
      fontSize: e.fontSize,
      "&-bar": {
        borderBottom: `${le(e.lineWidth)} ${e.lineType} ${e.colorBorderSecondary}`
      }
    }
  });
}, pW = (e) => {
  const {
    cardPaddingBase: t,
    colorBorderSecondary: n,
    cardShadow: r,
    lineWidth: i
  } = e;
  return {
    width: "33.33%",
    padding: t,
    border: 0,
    borderRadius: 0,
    boxShadow: `
      ${le(i)} 0 0 0 ${n},
      0 ${le(i)} 0 0 ${n},
      ${le(i)} ${le(i)} 0 0 ${n},
      ${le(i)} 0 0 0 ${n} inset,
      0 ${le(i)} 0 0 ${n} inset;
    `,
    transition: `all ${e.motionDurationMid}`,
    "&-hoverable:hover": {
      position: "relative",
      zIndex: 1,
      boxShadow: r
    }
  };
}, gW = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    actionsLiMargin: r,
    cardActionsIconSize: i,
    colorBorderSecondary: o,
    actionsBg: s
  } = e;
  return Object.assign(Object.assign({
    margin: 0,
    padding: 0,
    listStyle: "none",
    background: s,
    borderTop: `${le(e.lineWidth)} ${e.lineType} ${o}`,
    display: "flex",
    borderRadius: `0 0 ${le(e.borderRadiusLG)} ${le(e.borderRadiusLG)}`
  }, ca()), {
    "& > li": {
      margin: r,
      color: e.colorTextDescription,
      textAlign: "center",
      "> span": {
        position: "relative",
        display: "block",
        minWidth: e.calc(e.cardActionsIconSize).mul(2).equal(),
        fontSize: e.fontSize,
        lineHeight: e.lineHeight,
        cursor: "pointer",
        "&:hover": {
          color: e.colorPrimary,
          transition: `color ${e.motionDurationMid}`
        },
        [`a:not(${t}-btn), > ${n}`]: {
          display: "inline-block",
          width: "100%",
          color: e.colorTextDescription,
          lineHeight: le(e.fontHeight),
          transition: `color ${e.motionDurationMid}`,
          "&:hover": {
            color: e.colorPrimary
          }
        },
        [`> ${n}`]: {
          fontSize: i,
          lineHeight: le(e.calc(i).mul(e.lineHeight).equal())
        }
      },
      "&:not(:last-child)": {
        borderInlineEnd: `${le(e.lineWidth)} ${e.lineType} ${o}`
      }
    }
  });
}, mW = (e) => Object.assign(Object.assign({
  margin: `${le(e.calc(e.marginXXS).mul(-1).equal())} 0`,
  display: "flex"
}, ca()), {
  "&-avatar": {
    paddingInlineEnd: e.padding
  },
  "&-detail": {
    overflow: "hidden",
    flex: 1,
    "> div:not(:last-child)": {
      marginBottom: e.marginXS
    }
  },
  "&-title": Object.assign({
    color: e.colorTextHeading,
    fontWeight: e.fontWeightStrong,
    fontSize: e.fontSizeLG
  }, la),
  "&-description": {
    color: e.colorTextDescription
  }
}), vW = (e) => {
  const {
    componentCls: t,
    cardPaddingBase: n,
    colorFillAlter: r
  } = e;
  return {
    [`${t}-head`]: {
      padding: `0 ${le(n)}`,
      background: r,
      "&-title": {
        fontSize: e.fontSize
      }
    },
    [`${t}-body`]: {
      padding: `${le(e.padding)} ${le(n)}`
    }
  };
}, bW = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    overflow: "hidden",
    [`${t}-body`]: {
      userSelect: "none"
    }
  };
}, yW = (e) => {
  const {
    antCls: t,
    componentCls: n,
    cardShadow: r,
    cardHeadPadding: i,
    colorBorderSecondary: o,
    boxShadowTertiary: s,
    cardPaddingBase: a,
    extraColor: l
  } = e;
  return {
    [n]: Object.assign(Object.assign({}, Gn(e)), {
      position: "relative",
      background: e.colorBgContainer,
      borderRadius: e.borderRadiusLG,
      [`&:not(${n}-bordered)`]: {
        boxShadow: s
      },
      [`${n}-head`]: hW(e),
      [`${n}-extra`]: {
        // https://stackoverflow.com/a/22429853/3040605
        marginInlineStart: "auto",
        color: l,
        fontWeight: "normal",
        fontSize: e.fontSize
      },
      [`${n}-body`]: Object.assign({
        padding: a,
        borderRadius: ` 0 0 ${le(e.borderRadiusLG)} ${le(e.borderRadiusLG)}`
      }, ca()),
      [`${n}-grid`]: pW(e),
      [`${n}-cover`]: {
        "> *": {
          display: "block",
          width: "100%"
        },
        [`img, img + ${t}-image-mask`]: {
          borderRadius: `${le(e.borderRadiusLG)} ${le(e.borderRadiusLG)} 0 0`
        }
      },
      [`${n}-actions`]: gW(e),
      [`${n}-meta`]: mW(e)
    }),
    [`${n}-bordered`]: {
      border: `${le(e.lineWidth)} ${e.lineType} ${o}`,
      [`${n}-cover`]: {
        marginTop: -1,
        marginInlineStart: -1,
        marginInlineEnd: -1
      }
    },
    [`${n}-hoverable`]: {
      cursor: "pointer",
      transition: `box-shadow ${e.motionDurationMid}, border-color ${e.motionDurationMid}`,
      "&:hover": {
        borderColor: "transparent",
        boxShadow: r
      }
    },
    [`${n}-contain-grid`]: {
      borderRadius: `${le(e.borderRadiusLG)} ${le(e.borderRadiusLG)} 0 0 `,
      [`${n}-body`]: {
        display: "flex",
        flexWrap: "wrap"
      },
      [`&:not(${n}-loading) ${n}-body`]: {
        marginBlockStart: e.calc(e.lineWidth).mul(-1).equal(),
        marginInlineStart: e.calc(e.lineWidth).mul(-1).equal(),
        padding: 0
      }
    },
    [`${n}-contain-tabs`]: {
      [`> ${n}-head`]: {
        minHeight: 0,
        [`${n}-head-title, ${n}-extra`]: {
          paddingTop: i
        }
      }
    },
    [`${n}-type-inner`]: vW(e),
    [`${n}-loading`]: bW(e),
    [`${n}-rtl`]: {
      direction: "rtl"
    }
  };
}, wW = (e) => {
  const {
    componentCls: t,
    cardPaddingSM: n,
    headerHeightSM: r,
    headerFontSizeSM: i
  } = e;
  return {
    [`${t}-small`]: {
      [`> ${t}-head`]: {
        minHeight: r,
        padding: `0 ${le(n)}`,
        fontSize: i,
        [`> ${t}-head-wrapper`]: {
          [`> ${t}-extra`]: {
            fontSize: e.fontSize
          }
        }
      },
      [`> ${t}-body`]: {
        padding: n
      }
    },
    [`${t}-small${t}-contain-tabs`]: {
      [`> ${t}-head`]: {
        [`${t}-head-title, ${t}-extra`]: {
          paddingTop: 0,
          display: "flex",
          alignItems: "center"
        }
      }
    }
  };
}, CW = (e) => ({
  headerBg: "transparent",
  headerFontSize: e.fontSizeLG,
  headerFontSizeSM: e.fontSize,
  headerHeight: e.fontSizeLG * e.lineHeightLG + e.padding * 2,
  headerHeightSM: e.fontSize * e.lineHeight + e.paddingXS * 2,
  actionsBg: e.colorBgContainer,
  actionsLiMargin: `${e.paddingSM}px 0`,
  tabsMarginBottom: -e.padding - e.lineWidth,
  extraColor: e.colorText
}), SW = $n("Card", (e) => {
  const t = Jt(e, {
    cardShadow: e.boxShadowCard,
    cardHeadPadding: e.padding,
    cardPaddingBase: e.paddingLG,
    cardActionsIconSize: e.fontSize,
    cardPaddingSM: 12
    // Fixed padding.
  });
  return [
    // Style
    yW(t),
    // Size
    wW(t)
  ];
}, CW);
var kE = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const xW = (e) => {
  const {
    actionClasses: t,
    actions: n = [],
    actionStyle: r
  } = e;
  return /* @__PURE__ */ O.createElement("ul", {
    className: t,
    style: r
  }, n.map((i, o) => {
    const s = `action-${o}`;
    return /* @__PURE__ */ O.createElement("li", {
      style: {
        width: `${100 / n.length}%`
      },
      key: s
    }, /* @__PURE__ */ O.createElement("span", null, i));
  }));
}, EW = /* @__PURE__ */ O.forwardRef((e, t) => {
  const {
    prefixCls: n,
    className: r,
    rootClassName: i,
    style: o,
    extra: s,
    headStyle: a = {},
    bodyStyle: l = {},
    title: u,
    loading: c,
    bordered: d = !0,
    size: f,
    type: h,
    cover: p,
    actions: g,
    tabList: m,
    children: v,
    activeTabKey: b,
    defaultActiveTabKey: x,
    tabBarExtraContent: w,
    hoverable: C,
    tabProps: y = {},
    classNames: S,
    styles: A
  } = e, $ = kE(e, ["prefixCls", "className", "rootClassName", "style", "extra", "headStyle", "bodyStyle", "title", "loading", "bordered", "size", "type", "cover", "actions", "tabList", "children", "activeTabKey", "defaultActiveTabKey", "tabBarExtraContent", "hoverable", "tabProps", "classNames", "styles"]), {
    getPrefixCls: M,
    direction: _,
    card: T
  } = O.useContext(rt);
  if (process.env.NODE_ENV !== "production") {
    const de = Zt("Card");
    [["headStyle", "styles.header"], ["bodyStyle", "styles.body"]].forEach((ce) => {
      let [pe, Oe] = ce;
      de.deprecated(!(pe in e), pe, Oe);
    });
  }
  const D = (de) => {
    var ce;
    (ce = e.onTabChange) === null || ce === void 0 || ce.call(e, de);
  }, E = (de) => {
    var ce;
    return se((ce = T == null ? void 0 : T.classNames) === null || ce === void 0 ? void 0 : ce[de], S == null ? void 0 : S[de]);
  }, R = (de) => {
    var ce;
    return Object.assign(Object.assign({}, (ce = T == null ? void 0 : T.styles) === null || ce === void 0 ? void 0 : ce[de]), A == null ? void 0 : A[de]);
  }, I = O.useMemo(() => {
    let de = !1;
    return O.Children.forEach(v, (ce) => {
      ce && ce.type && ce.type === UR && (de = !0);
    }), de;
  }, [v]), k = M("card", n), [P, L, N] = SW(k), F = /* @__PURE__ */ O.createElement(xl, {
    loading: !0,
    active: !0,
    paragraph: {
      rows: 4
    },
    title: !1
  }, v), B = b !== void 0, j = Object.assign(Object.assign({}, y), {
    [B ? "activeKey" : "defaultActiveKey"]: B ? b : x,
    tabBarExtraContent: w
  });
  let z;
  const H = so(f), W = !H || H === "default" ? "large" : H, G = m ? /* @__PURE__ */ O.createElement(tm, Object.assign({
    size: W
  }, j, {
    className: `${k}-head-tabs`,
    onChange: D,
    items: m.map((de) => {
      var {
        tab: ce
      } = de, pe = kE(de, ["tab"]);
      return Object.assign({
        label: ce
      }, pe);
    })
  })) : null;
  if (u || s || G) {
    const de = se(`${k}-head`, E("header")), ce = se(`${k}-head-title`, E("title")), pe = se(`${k}-extra`, E("extra")), Oe = Object.assign(Object.assign({}, a), R("header"));
    z = /* @__PURE__ */ O.createElement("div", {
      className: de,
      style: Oe
    }, /* @__PURE__ */ O.createElement("div", {
      className: `${k}-head-wrapper`
    }, u && /* @__PURE__ */ O.createElement("div", {
      className: ce,
      style: R("title")
    }, u), s && /* @__PURE__ */ O.createElement("div", {
      className: pe,
      style: R("extra")
    }, s)), G);
  }
  const K = se(`${k}-cover`, E("cover")), Y = p ? /* @__PURE__ */ O.createElement("div", {
    className: K,
    style: R("cover")
  }, p) : null, X = se(`${k}-body`, E("body")), Z = Object.assign(Object.assign({}, l), R("body")), Q = /* @__PURE__ */ O.createElement("div", {
    className: X,
    style: Z
  }, c ? F : v), ne = se(`${k}-actions`, E("actions")), q = g && g.length ? /* @__PURE__ */ O.createElement(xW, {
    actionClasses: ne,
    actionStyle: R("actions"),
    actions: g
  }) : null, te = zn($, ["onTabChange"]), fe = se(k, T == null ? void 0 : T.className, {
    [`${k}-loading`]: c,
    [`${k}-bordered`]: d,
    [`${k}-hoverable`]: C,
    [`${k}-contain-grid`]: I,
    [`${k}-contain-tabs`]: m && m.length,
    [`${k}-${H}`]: H,
    [`${k}-type-${h}`]: !!h,
    [`${k}-rtl`]: _ === "rtl"
  }, r, i, L, N), Se = Object.assign(Object.assign({}, T == null ? void 0 : T.style), o);
  return P(/* @__PURE__ */ O.createElement("div", Object.assign({
    ref: t
  }, te, {
    className: fe,
    style: Se
  }), z, Y, Q, q));
});
var $W = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const OW = (e) => {
  const {
    prefixCls: t,
    className: n,
    avatar: r,
    title: i,
    description: o
  } = e, s = $W(e, ["prefixCls", "className", "avatar", "title", "description"]), {
    getPrefixCls: a
  } = O.useContext(rt), l = a("card", t), u = se(`${l}-meta`, n), c = r ? /* @__PURE__ */ O.createElement("div", {
    className: `${l}-meta-avatar`
  }, r) : null, d = i ? /* @__PURE__ */ O.createElement("div", {
    className: `${l}-meta-title`
  }, i) : null, f = o ? /* @__PURE__ */ O.createElement("div", {
    className: `${l}-meta-description`
  }, o) : null, h = d || f ? /* @__PURE__ */ O.createElement("div", {
    className: `${l}-meta-detail`
  }, d, f) : null;
  return /* @__PURE__ */ O.createElement("div", Object.assign({}, s, {
    className: u
  }), c, h);
}, nm = EW;
nm.Grid = UR;
nm.Meta = OW;
process.env.NODE_ENV !== "production" && (nm.displayName = "Card");
function AW(e, t, n) {
  var r = n || {}, i = r.noTrailing, o = i === void 0 ? !1 : i, s = r.noLeading, a = s === void 0 ? !1 : s, l = r.debounceMode, u = l === void 0 ? void 0 : l, c, d = !1, f = 0;
  function h() {
    c && clearTimeout(c);
  }
  function p(m) {
    var v = m || {}, b = v.upcomingOnly, x = b === void 0 ? !1 : b;
    h(), d = !x;
  }
  function g() {
    for (var m = arguments.length, v = new Array(m), b = 0; b < m; b++)
      v[b] = arguments[b];
    var x = this, w = Date.now() - f;
    if (d)
      return;
    function C() {
      f = Date.now(), t.apply(x, v);
    }
    function y() {
      c = void 0;
    }
    !a && u && !c && C(), h(), u === void 0 && w > e ? a ? (f = Date.now(), o || (c = setTimeout(u ? y : C, e))) : C() : o !== !0 && (c = setTimeout(u ? y : C, u === void 0 ? e - w : e));
  }
  return g.cancel = p, g;
}
function DW(e, t, n) {
  var r = {}, i = r.atBegin, o = i === void 0 ? !1 : i;
  return AW(e, t, {
    debounceMode: o !== !1
  });
}
var su = /* @__PURE__ */ O.createContext(null), hc = "__rc_cascader_search_mark__", _W = function(t, n, r) {
  var i = r.label;
  return n.some(function(o) {
    return String(o[i]).toLowerCase().includes(t.toLowerCase());
  });
}, TW = function(t, n, r, i) {
  return n.map(function(o) {
    return o[i.label];
  }).join(" / ");
};
const RW = function(e, t, n, r, i, o) {
  var s = i.filter, a = s === void 0 ? _W : s, l = i.render, u = l === void 0 ? TW : l, c = i.limit, d = c === void 0 ? 50 : c, f = i.sort;
  return O.useMemo(function() {
    var h = [];
    if (!e)
      return [];
    function p(g, m) {
      var v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      g.forEach(function(b) {
        if (!(!f && d !== !1 && d > 0 && h.length >= d)) {
          var x = [].concat(_e(m), [b]), w = b[n.children], C = v || b.disabled;
          if (
            // If is leaf option
            (!w || w.length === 0 || // If is changeOnSelect
            o) && a(e, x, {
              label: n.label
            })
          ) {
            var y;
            h.push(ie(ie({}, b), {}, (y = {
              disabled: C
            }, re(y, n.label, u(e, x, r, n)), re(y, hc, x), re(y, n.children, void 0), y)));
          }
          w && p(b[n.children], x, C);
        }
      });
    }
    return p(t, []), f && h.sort(function(g, m) {
      return f(g[hc], m[hc], e, n);
    }), d !== !1 && d > 0 ? h.slice(0, d) : h;
  }, [e, t, n, r, u, o, a, f, d]);
};
var D1 = "__RC_CASCADER_SPLIT__", GR = "SHOW_PARENT", KR = "SHOW_CHILD";
function wo(e) {
  return e.join(D1);
}
function Ic(e) {
  return e.map(wo);
}
function MW(e) {
  return e.split(D1);
}
function XR(e) {
  var t = e || {}, n = t.label, r = t.value, i = t.children, o = r || "value";
  return {
    label: n || "label",
    value: o,
    key: o,
    children: i || "children"
  };
}
function Lu(e, t) {
  var n, r;
  return (n = e.isLeaf) !== null && n !== void 0 ? n : !((r = e[t.children]) !== null && r !== void 0 && r.length);
}
function IW(e) {
  var t = e.parentElement;
  if (t) {
    var n = e.offsetTop - t.offsetTop;
    n - t.scrollTop < 0 ? t.scrollTo({
      top: n
    }) : n + e.offsetHeight - t.scrollTop > t.offsetHeight && t.scrollTo({
      top: n + e.offsetHeight - t.offsetHeight
    });
  }
}
function YR(e, t) {
  return e.map(function(n) {
    var r;
    return (r = n[hc]) === null || r === void 0 ? void 0 : r.map(function(i) {
      return i[t.value];
    });
  });
}
function kW(e) {
  return Array.isArray(e) && Array.isArray(e[0]);
}
function Fp(e) {
  return e ? kW(e) ? e : (e.length === 0 ? [] : [e]).map(function(t) {
    return Array.isArray(t) ? t : [t];
  }) : [];
}
function qR(e, t, n) {
  var r = new Set(e), i = t();
  return e.filter(function(o) {
    var s = i[o], a = s ? s.parent : null, l = s ? s.children : null;
    return s && s.node.disabled ? !0 : n === KR ? !(l && l.some(function(u) {
      return u.key && r.has(u.key);
    })) : !(a && !a.node.disabled && r.has(a.key));
  });
}
function kc(e, t, n) {
  for (var r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, i = t, o = [], s = function() {
    var u, c, d, f = e[a], h = (u = i) === null || u === void 0 ? void 0 : u.findIndex(function(g) {
      var m = g[n.value];
      return r ? String(m) === String(f) : m === f;
    }), p = h !== -1 ? (c = i) === null || c === void 0 ? void 0 : c[h] : null;
    o.push({
      value: (d = p == null ? void 0 : p[n.value]) !== null && d !== void 0 ? d : f,
      index: h,
      option: p
    }), i = p == null ? void 0 : p[n.children];
  }, a = 0; a < e.length; a += 1)
    s();
  return o;
}
const PW = function(e, t, n, r, i) {
  return O.useMemo(function() {
    var o = i || // Default displayRender
    function(s) {
      var a = r ? s.slice(-1) : s, l = " / ";
      return a.every(function(u) {
        return ["string", "number"].includes(wt(u));
      }) ? a.join(l) : a.reduce(function(u, c, d) {
        var f = /* @__PURE__ */ O.isValidElement(c) ? /* @__PURE__ */ O.cloneElement(c, {
          key: d
        }) : c;
        return d === 0 ? [f] : [].concat(_e(u), [l, f]);
      }, []);
    };
    return e.map(function(s) {
      var a, l = kc(s, t, n), u = o(l.map(function(d) {
        var f, h = d.option, p = d.value;
        return (f = h == null ? void 0 : h[n.label]) !== null && f !== void 0 ? f : p;
      }), l.map(function(d) {
        var f = d.option;
        return f;
      })), c = wo(s);
      return {
        label: u,
        value: c,
        key: c,
        valueCells: s,
        disabled: (a = l[l.length - 1]) === null || a === void 0 || (a = a.option) === null || a === void 0 ? void 0 : a.disabled
      };
    });
  }, [e, t, n, i, r]);
};
function QR(e, t) {
  return O.useCallback(function(n) {
    var r = [], i = [];
    return n.forEach(function(o) {
      var s = kc(o, e, t);
      s.every(function(a) {
        return a.option;
      }) ? i.push(o) : r.push(o);
    }), [i, r];
  }, [e, t]);
}
function NW(e, t) {
  return e[t];
}
function LW(e, t) {
  return "".concat(e, "-").concat(t);
}
function ZR(e, t) {
  return e ?? t;
}
function FW(e) {
  var t = e || {}, n = t.title, r = t._title, i = t.key, o = t.children, s = n || "title";
  return {
    title: s,
    _title: r || [s],
    key: i || "key",
    children: o || "children"
  };
}
function BW(e, t, n) {
  var r = {};
  wt(n) === "object" ? r = n : r = {
    externalGetKey: n
  }, r = r || {};
  var i = r, o = i.childrenPropName, s = i.externalGetKey, a = i.fieldNames, l = FW(a), u = l.key, c = l.children, d = o || c, f;
  s ? typeof s == "string" ? f = function(g) {
    return g[s];
  } : typeof s == "function" && (f = function(g) {
    return s(g);
  }) : f = function(g, m) {
    return ZR(g[u], m);
  };
  function h(p, g, m, v) {
    var b = p ? p[d] : e, x = p ? LW(m.pos, g) : "0", w = p ? [].concat(_e(v), [p]) : [];
    if (p) {
      var C = f(p, x), y = {
        node: p,
        index: g,
        pos: x,
        key: C,
        parentPos: m.node ? m.pos : null,
        level: m.level + 1,
        nodes: w
      };
      t(y);
    }
    b && b.forEach(function(S, A) {
      h(S, A, {
        node: p,
        pos: x,
        level: m ? m.level + 1 : -1
      }, w);
    });
  }
  h(null);
}
function jW(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = t.initWrapper, r = t.processEntity, i = t.onProcessFinished, o = t.externalGetKey, s = t.childrenPropName, a = t.fieldNames, l = arguments.length > 2 ? arguments[2] : void 0, u = o || l, c = {}, d = {}, f = {
    posEntities: c,
    keyEntities: d
  };
  return n && (f = n(f) || f), BW(e, function(h) {
    var p = h.node, g = h.index, m = h.pos, v = h.key, b = h.parentPos, x = h.level, w = h.nodes, C = {
      node: p,
      nodes: w,
      index: g,
      key: v,
      pos: m,
      level: x
    }, y = ZR(v, m);
    c[m] = C, d[y] = C, C.parent = c[b], C.parent && (C.parent.children = C.parent.children || [], C.parent.children.push(C)), r && r(C, f);
  }, {
    externalGetKey: u,
    childrenPropName: s,
    fieldNames: a
  }), i && i(f), f;
}
const zW = function(e, t) {
  var n = O.useRef({
    options: null,
    info: null
  }), r = O.useCallback(function() {
    return n.current.options !== e && (n.current.options = e, n.current.info = jW(e, {
      fieldNames: t,
      initWrapper: function(o) {
        return ie(ie({}, o), {}, {
          pathKeyEntities: {}
        });
      },
      processEntity: function(o, s) {
        var a = o.nodes.map(function(l) {
          return l[t.value];
        }).join(D1);
        s.pathKeyEntities[a] = o, o.key = a;
      }
    })), n.current.info.pathKeyEntities;
  }, [t, e]);
  return r;
};
function JR(e, t) {
  var n = O.useMemo(function() {
    return t || [];
  }, [t]), r = zW(n, e), i = O.useCallback(function(o) {
    var s = r();
    return o.map(function(a) {
      var l = s[a].nodes;
      return l.map(function(u) {
        return u[e.value];
      });
    });
  }, [r, e]);
  return [n, r, i];
}
function HW(e) {
  return O.useMemo(function() {
    if (!e)
      return [!1, {}];
    var t = {
      matchInputWidth: !0,
      limit: 50
    };
    return e && wt(e) === "object" && (t = ie(ie({}, t), e)), t.limit <= 0 && (delete t.limit, process.env.NODE_ENV !== "production" && $t(!1, "'limit' of showSearch should be positive number or false.")), [!0, t];
  }, [e]);
}
function eM(e, t) {
  var n = /* @__PURE__ */ new Set();
  return e.forEach(function(r) {
    t.has(r) || n.add(r);
  }), n;
}
function VW(e) {
  var t = e || {}, n = t.disabled, r = t.disableCheckbox, i = t.checkable;
  return !!(n || r) || i === !1;
}
function WW(e, t, n, r) {
  for (var i = new Set(e), o = /* @__PURE__ */ new Set(), s = 0; s <= n; s += 1) {
    var a = t.get(s) || /* @__PURE__ */ new Set();
    a.forEach(function(d) {
      var f = d.key, h = d.node, p = d.children, g = p === void 0 ? [] : p;
      i.has(f) && !r(h) && g.filter(function(m) {
        return !r(m.node);
      }).forEach(function(m) {
        i.add(m.key);
      });
    });
  }
  for (var l = /* @__PURE__ */ new Set(), u = n; u >= 0; u -= 1) {
    var c = t.get(u) || /* @__PURE__ */ new Set();
    c.forEach(function(d) {
      var f = d.parent, h = d.node;
      if (!(r(h) || !d.parent || l.has(d.parent.key))) {
        if (r(d.parent.node)) {
          l.add(f.key);
          return;
        }
        var p = !0, g = !1;
        (f.children || []).filter(function(m) {
          return !r(m.node);
        }).forEach(function(m) {
          var v = m.key, b = i.has(v);
          p && !b && (p = !1), !g && (b || o.has(v)) && (g = !0);
        }), p && i.add(f.key), g && o.add(f.key), l.add(f.key);
      }
    });
  }
  return {
    checkedKeys: Array.from(i),
    halfCheckedKeys: Array.from(eM(o, i))
  };
}
function UW(e, t, n, r, i) {
  for (var o = new Set(e), s = new Set(t), a = 0; a <= r; a += 1) {
    var l = n.get(a) || /* @__PURE__ */ new Set();
    l.forEach(function(f) {
      var h = f.key, p = f.node, g = f.children, m = g === void 0 ? [] : g;
      !o.has(h) && !s.has(h) && !i(p) && m.filter(function(v) {
        return !i(v.node);
      }).forEach(function(v) {
        o.delete(v.key);
      });
    });
  }
  s = /* @__PURE__ */ new Set();
  for (var u = /* @__PURE__ */ new Set(), c = r; c >= 0; c -= 1) {
    var d = n.get(c) || /* @__PURE__ */ new Set();
    d.forEach(function(f) {
      var h = f.parent, p = f.node;
      if (!(i(p) || !f.parent || u.has(f.parent.key))) {
        if (i(f.parent.node)) {
          u.add(h.key);
          return;
        }
        var g = !0, m = !1;
        (h.children || []).filter(function(v) {
          return !i(v.node);
        }).forEach(function(v) {
          var b = v.key, x = o.has(b);
          g && !x && (g = !1), !m && (x || s.has(b)) && (m = !0);
        }), g || o.delete(h.key), m && s.add(h.key), u.add(h.key);
      }
    });
  }
  return {
    checkedKeys: Array.from(o),
    halfCheckedKeys: Array.from(eM(s, o))
  };
}
function Lb(e, t, n, r) {
  var i = [], o;
  o = VW;
  var s = new Set(e.filter(function(c) {
    var d = !!NW(n, c);
    return d || i.push(c), d;
  })), a = /* @__PURE__ */ new Map(), l = 0;
  Object.keys(n).forEach(function(c) {
    var d = n[c], f = d.level, h = a.get(f);
    h || (h = /* @__PURE__ */ new Set(), a.set(f, h)), h.add(d), l = Math.max(l, f);
  }), $t(!i.length, "Tree missing follow keys: ".concat(i.slice(0, 100).map(function(c) {
    return "'".concat(c, "'");
  }).join(", ")));
  var u;
  return t === !0 ? u = WW(s, a, l, o) : u = UW(s, t.halfCheckedKeys, a, l, o), u;
}
function tM(e, t, n, r, i, o, s, a) {
  return function(l) {
    if (!e)
      t(l);
    else {
      var u = wo(l), c = Ic(n), d = Ic(r), f = c.includes(u), h = i.some(function(y) {
        return wo(y) === u;
      }), p = n, g = i;
      if (h && !f)
        g = i.filter(function(y) {
          return wo(y) !== u;
        });
      else {
        var m = f ? c.filter(function(y) {
          return y !== u;
        }) : [].concat(_e(c), [u]), v = o(), b;
        if (f) {
          var x = Lb(m, {
            checked: !1,
            halfCheckedKeys: d
          }, v);
          b = x.checkedKeys;
        } else {
          var w = Lb(m, !0, v);
          b = w.checkedKeys;
        }
        var C = qR(b, o, a);
        p = s(C);
      }
      t([].concat(_e(g), _e(p)));
    }
  };
}
function nM(e, t, n, r, i) {
  return O.useMemo(function() {
    var o = i(t), s = ae(o, 2), a = s[0], l = s[1];
    if (!e || !t.length)
      return [a, [], l];
    var u = Ic(a), c = n(), d = Lb(u, !0, c), f = d.checkedKeys, h = d.halfCheckedKeys;
    return [r(f), r(h), l];
  }, [e, t, n, r, i]);
}
var rM = /* @__PURE__ */ O.memo(function(e) {
  var t = e.children;
  return t;
}, function(e, t) {
  return !t.open;
});
process.env.NODE_ENV !== "production" && (rM.displayName = "CacheContent");
function GW(e) {
  var t, n = e.prefixCls, r = e.checked, i = e.halfChecked, o = e.disabled, s = e.onClick, a = e.disableCheckbox, l = O.useContext(su), u = l.checkable, c = typeof u != "boolean" ? u : null;
  return /* @__PURE__ */ O.createElement("span", {
    className: se("".concat(n), (t = {}, re(t, "".concat(n, "-checked"), r), re(t, "".concat(n, "-indeterminate"), !r && i), re(t, "".concat(n, "-disabled"), o || a), t)),
    onClick: s
  }, c);
}
var iM = "__cascader_fix_label__";
function KW(e) {
  var t = e.prefixCls, n = e.multiple, r = e.options, i = e.activeValue, o = e.prevValuePath, s = e.onToggleOpen, a = e.onSelect, l = e.onActive, u = e.checkedSet, c = e.halfCheckedSet, d = e.loadingKeys, f = e.isSelectable, h = e.searchValue, p = "".concat(t, "-menu"), g = "".concat(t, "-menu-item"), m = O.useContext(su), v = m.fieldNames, b = m.changeOnSelect, x = m.expandTrigger, w = m.expandIcon, C = m.loadingIcon, y = m.dropdownMenuColumnStyle, S = m.optionRender, A = x === "hover", $ = O.useMemo(function() {
    return r.map(function(M) {
      var _, T = M.disabled, D = M.disableCheckbox, E = M[hc], R = (_ = M[iM]) !== null && _ !== void 0 ? _ : M[v.label], I = M[v.value], k = Lu(M, v), P = E ? E.map(function(j) {
        return j[v.value];
      }) : [].concat(_e(o), [I]), L = wo(P), N = d.includes(L), F = u.has(L), B = c.has(L);
      return {
        disabled: T,
        label: R,
        value: I,
        isLeaf: k,
        isLoading: N,
        checked: F,
        halfChecked: B,
        option: M,
        disableCheckbox: D,
        fullPath: P,
        fullPathKey: L
      };
    });
  }, [r, u, v, c, d, o]);
  return /* @__PURE__ */ O.createElement("ul", {
    className: p,
    role: "menu"
  }, $.map(function(M) {
    var _, T = M.disabled, D = M.label, E = M.value, R = M.isLeaf, I = M.isLoading, k = M.checked, P = M.halfChecked, L = M.option, N = M.fullPath, F = M.fullPathKey, B = M.disableCheckbox, j = function() {
      if (!(T || h)) {
        var G = _e(N);
        A && R && G.pop(), l(G);
      }
    }, z = function() {
      f(L) && a(N, R);
    }, H;
    return typeof L.title == "string" ? H = L.title : typeof D == "string" && (H = D), /* @__PURE__ */ O.createElement("li", {
      key: F,
      className: se(g, (_ = {}, re(_, "".concat(g, "-expand"), !R), re(_, "".concat(g, "-active"), i === E || i === F), re(_, "".concat(g, "-disabled"), T), re(_, "".concat(g, "-loading"), I), _)),
      style: y,
      role: "menuitemcheckbox",
      title: H,
      "aria-checked": k,
      "data-path-key": F,
      onClick: function() {
        j(), !B && (!n || R) && z();
      },
      onDoubleClick: function() {
        b && s(!1);
      },
      onMouseEnter: function() {
        A && j();
      },
      onMouseDown: function(G) {
        G.preventDefault();
      }
    }, n && /* @__PURE__ */ O.createElement(GW, {
      prefixCls: "".concat(t, "-checkbox"),
      checked: k,
      halfChecked: P,
      disabled: T || B,
      disableCheckbox: B,
      onClick: function(G) {
        B || (G.stopPropagation(), z());
      }
    }), /* @__PURE__ */ O.createElement("div", {
      className: "".concat(g, "-content")
    }, S ? S(L) : D), !I && w && !R && /* @__PURE__ */ O.createElement("div", {
      className: "".concat(g, "-expand-icon")
    }, w), I && C && /* @__PURE__ */ O.createElement("div", {
      className: "".concat(g, "-loading-icon")
    }, C));
  }));
}
const XW = function(e, t) {
  var n = O.useContext(su), r = n.values, i = r[0], o = O.useState([]), s = ae(o, 2), a = s[0], l = s[1];
  return O.useEffect(
    function() {
      e || l(i || []);
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [t, i]
    /* eslint-enable react-hooks/exhaustive-deps */
  ), [a, l];
}, YW = function(e, t, n, r, i, o, s) {
  var a = s.direction, l = s.searchValue, u = s.toggleOpen, c = s.open, d = a === "rtl", f = O.useMemo(function() {
    for (var y = -1, S = t, A = [], $ = [], M = r.length, _ = YR(t, n), T = function(k) {
      var P = S.findIndex(function(L, N) {
        return (_[N] ? wo(_[N]) : L[n.value]) === r[k];
      });
      if (P === -1)
        return 1;
      y = P, A.push(y), $.push(r[k]), S = S[y][n.children];
    }, D = 0; D < M && S && !T(D); D += 1)
      ;
    for (var E = t, R = 0; R < A.length - 1; R += 1)
      E = E[A[R]][n.children];
    return [$, y, E, _];
  }, [r, n, t]), h = ae(f, 4), p = h[0], g = h[1], m = h[2], v = h[3], b = function(S) {
    i(S);
  }, x = function(S) {
    var A = m.length, $ = g;
    $ === -1 && S < 0 && ($ = A);
    for (var M = 0; M < A; M += 1) {
      $ = ($ + S + A) % A;
      var _ = m[$];
      if (_ && !_.disabled) {
        var T = p.slice(0, -1).concat(v[$] ? wo(v[$]) : _[n.value]);
        b(T);
        return;
      }
    }
  }, w = function() {
    if (p.length > 1) {
      var S = p.slice(0, -1);
      b(S);
    } else
      u(!1);
  }, C = function() {
    var S, A = ((S = m[g]) === null || S === void 0 ? void 0 : S[n.children]) || [], $ = A.find(function(_) {
      return !_.disabled;
    });
    if ($) {
      var M = [].concat(_e(p), [$[n.value]]);
      b(M);
    }
  };
  O.useImperativeHandle(e, function() {
    return {
      // scrollTo: treeRef.current?.scrollTo,
      onKeyDown: function(S) {
        var A = S.which;
        switch (A) {
          case xe.UP:
          case xe.DOWN: {
            var $ = 0;
            A === xe.UP ? $ = -1 : A === xe.DOWN && ($ = 1), $ !== 0 && x($);
            break;
          }
          case xe.LEFT: {
            if (l)
              break;
            d ? C() : w();
            break;
          }
          case xe.RIGHT: {
            if (l)
              break;
            d ? w() : C();
            break;
          }
          case xe.BACKSPACE: {
            l || w();
            break;
          }
          case xe.ENTER: {
            if (p.length) {
              var M = m[g], _ = (M == null ? void 0 : M[hc]) || [];
              _.length ? o(_.map(function(T) {
                return T[n.value];
              }), _[_.length - 1]) : o(p, m[g]);
            }
            break;
          }
          case xe.ESC:
            u(!1), c && S.stopPropagation();
        }
      },
      onKeyUp: function() {
      }
    };
  });
};
var _1 = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n, r, i, o = e.prefixCls, s = e.multiple, a = e.searchValue, l = e.toggleOpen, u = e.notFoundContent, c = e.direction, d = e.open, f = O.useRef(), h = c === "rtl", p = O.useContext(su), g = p.options, m = p.values, v = p.halfValues, b = p.fieldNames, x = p.changeOnSelect, w = p.onSelect, C = p.searchOptions, y = p.dropdownPrefixCls, S = p.loadData, A = p.expandTrigger, $ = y || o, M = O.useState([]), _ = ae(M, 2), T = _[0], D = _[1], E = function(ne) {
    if (!(!S || a)) {
      var q = kc(ne, g, b), te = q.map(function(de) {
        var ce = de.option;
        return ce;
      }), fe = te[te.length - 1];
      if (fe && !Lu(fe, b)) {
        var Se = wo(ne);
        D(function(de) {
          return [].concat(_e(de), [Se]);
        }), S(te);
      }
    }
  };
  O.useEffect(function() {
    T.length && T.forEach(function(Q) {
      var ne = MW(Q), q = kc(ne, g, b, !0).map(function(fe) {
        var Se = fe.option;
        return Se;
      }), te = q[q.length - 1];
      (!te || te[b.children] || Lu(te, b)) && D(function(fe) {
        return fe.filter(function(Se) {
          return Se !== Q;
        });
      });
    });
  }, [g, T, b]);
  var R = O.useMemo(function() {
    return new Set(Ic(m));
  }, [m]), I = O.useMemo(function() {
    return new Set(Ic(v));
  }, [v]), k = XW(s, d), P = ae(k, 2), L = P[0], N = P[1], F = function(ne) {
    N(ne), E(ne);
  }, B = function(ne) {
    var q = ne.disabled, te = Lu(ne, b);
    return !q && (te || x || s);
  }, j = function(ne, q) {
    var te = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    w(ne), !s && (q || x && (A === "hover" || te)) && l(!1);
  }, z = O.useMemo(function() {
    return a ? C : g;
  }, [a, C, g]), H = O.useMemo(function() {
    for (var Q = [{
      options: z
    }], ne = z, q = YR(ne, b), te = function() {
      var de = L[fe], ce = ne.find(function(Oe, Re) {
        return (q[Re] ? wo(q[Re]) : Oe[b.value]) === de;
      }), pe = ce == null ? void 0 : ce[b.children];
      if (!(pe != null && pe.length))
        return 1;
      ne = pe, Q.push({
        options: pe
      });
    }, fe = 0; fe < L.length && !te(); fe += 1)
      ;
    return Q;
  }, [z, L, b]), W = function(ne, q) {
    B(q) && j(ne, Lu(q, b), !0);
  };
  YW(t, z, b, L, F, W, {
    direction: c,
    searchValue: a,
    toggleOpen: l,
    open: d
  }), O.useEffect(function() {
    for (var Q = 0; Q < L.length; Q += 1) {
      var ne, q = L.slice(0, Q + 1), te = wo(q), fe = (ne = f.current) === null || ne === void 0 ? void 0 : ne.querySelector(
        'li[data-path-key="'.concat(te.replace(/\\{0,2}"/g, '\\"'), '"]')
        // matches unescaped double quotes
      );
      fe && IW(fe);
    }
  }, [L]);
  var G = !((n = H[0]) !== null && n !== void 0 && (n = n.options) !== null && n !== void 0 && n.length), K = [(r = {}, re(r, b.value, "__EMPTY__"), re(r, iM, u), re(r, "disabled", !0), r)], Y = ie(ie({}, e), {}, {
    multiple: !G && s,
    onSelect: j,
    onActive: F,
    onToggleOpen: l,
    checkedSet: R,
    halfCheckedSet: I,
    loadingKeys: T,
    isSelectable: B
  }), X = G ? [{
    options: K
  }] : H, Z = X.map(function(Q, ne) {
    var q = L.slice(0, ne), te = L[ne];
    return /* @__PURE__ */ O.createElement(KW, we({
      key: ne
    }, Y, {
      searchValue: a,
      prefixCls: $,
      options: Q.options,
      prevValuePath: q,
      activeValue: te
    }));
  });
  return /* @__PURE__ */ O.createElement(rM, {
    open: d
  }, /* @__PURE__ */ O.createElement("div", {
    className: se("".concat($, "-menus"), (i = {}, re(i, "".concat($, "-menu-empty"), G), re(i, "".concat($, "-rtl"), h), i)),
    ref: f
  }, Z));
});
process.env.NODE_ENV !== "production" && (_1.displayName = "RawOptionList");
var qW = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = _T();
  return /* @__PURE__ */ O.createElement(_1, we({}, e, n, {
    ref: t
  }));
});
function QW() {
}
function oM(e) {
  var t, n = e, r = n.prefixCls, i = r === void 0 ? "rc-cascader" : r, o = n.style, s = n.className, a = n.options, l = n.checkable, u = n.defaultValue, c = n.value, d = n.fieldNames, f = n.changeOnSelect, h = n.onChange, p = n.showCheckedStrategy, g = n.loadData, m = n.expandTrigger, v = n.expandIcon, b = v === void 0 ? ">" : v, x = n.loadingIcon, w = n.direction, C = n.notFoundContent, y = C === void 0 ? "Not Found" : C, S = !!l, A = Un(u, {
    value: c,
    postState: Fp
  }), $ = ae(A, 2), M = $[0], _ = $[1], T = O.useMemo(
    function() {
      return XR(d);
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [JSON.stringify(d)]
    /* eslint-enable react-hooks/exhaustive-deps */
  ), D = JR(T, a), E = ae(D, 3), R = E[0], I = E[1], k = E[2], P = QR(R, T), L = nM(S, M, I, k, P), N = ae(L, 3), F = N[0], B = N[1], j = N[2], z = Nn(function(X) {
    if (_(X), h) {
      var Z = Fp(X), Q = Z.map(function(te) {
        return kc(te, R, T).map(function(fe) {
          return fe.option;
        });
      }), ne = S ? Z : Z[0], q = S ? Q : Q[0];
      h(ne, q);
    }
  }), H = tM(S, z, F, B, j, I, k, p), W = Nn(function(X) {
    H(X);
  }), G = O.useMemo(function() {
    return {
      options: R,
      fieldNames: T,
      values: F,
      halfValues: B,
      changeOnSelect: f,
      onSelect: W,
      checkable: l,
      searchOptions: [],
      dropdownPrefixCls: null,
      loadData: g,
      expandTrigger: m,
      expandIcon: b,
      loadingIcon: x,
      dropdownMenuColumnStyle: null
    };
  }, [R, T, F, B, f, W, l, g, m, b, x]), K = "".concat(i, "-panel"), Y = !R.length;
  return /* @__PURE__ */ O.createElement(su.Provider, {
    value: G
  }, /* @__PURE__ */ O.createElement("div", {
    className: se(K, (t = {}, re(t, "".concat(K, "-rtl"), w === "rtl"), re(t, "".concat(K, "-empty"), Y), t), s),
    style: o
  }, Y ? y : /* @__PURE__ */ O.createElement(_1, {
    prefixCls: i,
    searchValue: null,
    multiple: S,
    toggleOpen: QW,
    open: !0,
    direction: w
  })));
}
function ZW(e) {
  var t = e.onPopupVisibleChange, n = e.popupVisible, r = e.popupClassName, i = e.popupPlacement;
  $t(!t, "`onPopupVisibleChange` is deprecated. Please use `onDropdownVisibleChange` instead."), $t(n === void 0, "`popupVisible` is deprecated. Please use `open` instead."), $t(r === void 0, "`popupClassName` is deprecated. Please use `dropdownClassName` instead."), $t(i === void 0, "`popupPlacement` is deprecated. Please use `placement` instead.");
}
function JW(e, t) {
  if (e) {
    var n = function r(i) {
      for (var o = 0; o < i.length; o++) {
        var s = i[o];
        if (s[t == null ? void 0 : t.value] === null)
          return $t(!1, "`value` in Cascader options should not be `null`."), !0;
        if (Array.isArray(s[t == null ? void 0 : t.children]) && r(s[t == null ? void 0 : t.children]))
          return !0;
      }
    };
    n(e);
  }
}
var eU = ["id", "prefixCls", "fieldNames", "defaultValue", "value", "changeOnSelect", "onChange", "displayRender", "checkable", "autoClearSearchValue", "searchValue", "onSearch", "showSearch", "expandTrigger", "options", "dropdownPrefixCls", "loadData", "popupVisible", "open", "popupClassName", "dropdownClassName", "dropdownMenuColumnStyle", "dropdownStyle", "popupPlacement", "placement", "onDropdownVisibleChange", "onPopupVisibleChange", "expandIcon", "loadingIcon", "children", "dropdownMatchSelectWidth", "showCheckedStrategy", "optionRender"], au = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e.id, r = e.prefixCls, i = r === void 0 ? "rc-cascader" : r, o = e.fieldNames, s = e.defaultValue, a = e.value, l = e.changeOnSelect, u = e.onChange, c = e.displayRender, d = e.checkable, f = e.autoClearSearchValue, h = f === void 0 ? !0 : f, p = e.searchValue, g = e.onSearch, m = e.showSearch, v = e.expandTrigger, b = e.options, x = e.dropdownPrefixCls, w = e.loadData, C = e.popupVisible, y = e.open, S = e.popupClassName, A = e.dropdownClassName, $ = e.dropdownMenuColumnStyle, M = e.dropdownStyle, _ = e.popupPlacement, T = e.placement, D = e.onDropdownVisibleChange, E = e.onPopupVisibleChange, R = e.expandIcon, I = R === void 0 ? ">" : R, k = e.loadingIcon, P = e.children, L = e.dropdownMatchSelectWidth, N = L === void 0 ? !1 : L, F = e.showCheckedStrategy, B = F === void 0 ? GR : F, j = e.optionRender, z = Rt(e, eU), H = UT(n), W = !!d, G = Un(s, {
    value: a,
    postState: Fp
  }), K = ae(G, 2), Y = K[0], X = K[1], Z = O.useMemo(
    function() {
      return XR(o);
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [JSON.stringify(o)]
    /* eslint-enable react-hooks/exhaustive-deps */
  ), Q = JR(Z, b), ne = ae(Q, 3), q = ne[0], te = ne[1], fe = ne[2], Se = Un("", {
    value: p,
    postState: function(je) {
      return je || "";
    }
  }), de = ae(Se, 2), ce = de[0], pe = de[1], Oe = function(je, Le) {
    pe(je), Le.source !== "blur" && g && g(je);
  }, Re = HW(m), De = ae(Re, 2), Me = De[0], Ue = De[1], oe = RW(ce, q, Z, x || i, Ue, l), Ce = QR(q, Z), ge = nM(W, Y, te, fe, Ce), ve = ae(ge, 3), me = ve[0], Fe = ve[1], Be = ve[2], qe = O.useMemo(function() {
    var it = Ic(me), je = qR(it, te, B);
    return [].concat(_e(Be), _e(fe(je)));
  }, [me, te, fe, Be, B]), Ve = PW(qe, q, Z, W, c), We = Nn(function(it) {
    if (X(it), u) {
      var je = Fp(it), Le = je.map(function(He) {
        return kc(He, q, Z).map(function(Je) {
          return Je.option;
        });
      }), ot = W ? je : je[0], yt = W ? Le : Le[0];
      u(ot, yt);
    }
  }), Ge = tM(W, We, me, Fe, Be, te, fe, B), $e = Nn(function(it) {
    (!W || h) && pe(""), Ge(it);
  }), ze = function(je, Le) {
    if (Le.type === "clear") {
      We([]);
      return;
    }
    var ot = Le.values[0], yt = ot.valueCells;
    $e(yt);
  }, at = y !== void 0 ? y : C, xt = A || S, jt = T || _, Lt = function(je) {
    D == null || D(je), E == null || E(je);
  };
  process.env.NODE_ENV !== "production" && (ZW(e), JW(q, Z));
  var At = O.useMemo(function() {
    return {
      options: q,
      fieldNames: Z,
      values: me,
      halfValues: Fe,
      changeOnSelect: l,
      onSelect: $e,
      checkable: d,
      searchOptions: oe,
      dropdownPrefixCls: x,
      loadData: w,
      expandTrigger: v,
      expandIcon: I,
      loadingIcon: k,
      dropdownMenuColumnStyle: $,
      optionRender: j
    };
  }, [q, Z, me, Fe, l, $e, d, oe, x, w, v, I, k, $, j]), Et = !(ce ? oe : q).length, nt = (
    // Search to match width
    ce && Ue.matchInputWidth || // Empty keep the width
    Et ? {} : {
      minWidth: "auto"
    }
  );
  return /* @__PURE__ */ O.createElement(su.Provider, {
    value: At
  }, /* @__PURE__ */ O.createElement(s1, we({}, z, {
    // MISC
    ref: t,
    id: H,
    prefixCls: i,
    autoClearSearchValue: h,
    dropdownMatchSelectWidth: N,
    dropdownStyle: ie(ie({}, nt), M),
    displayValues: Ve,
    onDisplayValuesChange: ze,
    mode: W ? "multiple" : void 0,
    searchValue: ce,
    onSearch: Oe,
    showSearch: Me,
    OptionList: qW,
    emptyOptions: Et,
    open: at,
    dropdownClassName: xt,
    placement: jt,
    onDropdownVisibleChange: Lt,
    getRawInputElement: function() {
      return P;
    }
  })));
});
process.env.NODE_ENV !== "production" && (au.displayName = "Cascader");
au.SHOW_PARENT = GR;
au.SHOW_CHILD = KR;
au.Panel = oM;
function sM(e, t) {
  const {
    getPrefixCls: n,
    direction: r,
    renderEmpty: i
  } = O.useContext(rt), o = t || r, s = n("select", e), a = n("cascader", e);
  return [s, a, o, i];
}
function aM(e, t) {
  return O.useMemo(() => t ? /* @__PURE__ */ O.createElement("span", {
    className: `${e}-checkbox-inner`
  }) : !1, [t]);
}
function lM(e, t, n) {
  let r = n;
  n || (r = t ? /* @__PURE__ */ O.createElement(Pp, null) : /* @__PURE__ */ O.createElement(Od, null));
  const i = /* @__PURE__ */ O.createElement("span", {
    className: `${e}-menu-item-loading-icon`
  }, /* @__PURE__ */ O.createElement(wl, {
    spin: !0
  }));
  return [r, i];
}
const tU = (e) => {
  const {
    checkboxCls: t
  } = e, n = `${t}-wrapper`;
  return [
    // ===================== Basic =====================
    {
      // Group
      [`${t}-group`]: Object.assign(Object.assign({}, Gn(e)), {
        display: "inline-flex",
        flexWrap: "wrap",
        columnGap: e.marginXS,
        // Group > Grid
        [`> ${e.antCls}-row`]: {
          flex: 1
        }
      }),
      // Wrapper
      [n]: Object.assign(Object.assign({}, Gn(e)), {
        display: "inline-flex",
        alignItems: "baseline",
        cursor: "pointer",
        // Fix checkbox & radio in flex align #30260
        "&:after": {
          display: "inline-block",
          width: 0,
          overflow: "hidden",
          content: "'\\a0'"
        },
        // Checkbox near checkbox
        [`& + ${n}`]: {
          marginInlineStart: 0
        },
        [`&${n}-in-form-item`]: {
          'input[type="checkbox"]': {
            width: 14,
            // FIXME: magic
            height: 14
            // FIXME: magic
          }
        }
      }),
      // Wrapper > Checkbox
      [t]: Object.assign(Object.assign({}, Gn(e)), {
        position: "relative",
        whiteSpace: "nowrap",
        lineHeight: 1,
        cursor: "pointer",
        borderRadius: e.borderRadiusSM,
        // To make alignment right when `controlHeight` is changed
        // Ref: https://github.com/ant-design/ant-design/issues/41564
        alignSelf: "center",
        // Wrapper > Checkbox > input
        [`${t}-input`]: {
          position: "absolute",
          // Since baseline align will get additional space offset,
          // we need to move input to top to make it align with text.
          // Ref: https://github.com/ant-design/ant-design/issues/38926#issuecomment-1486137799
          inset: 0,
          zIndex: 1,
          cursor: "pointer",
          opacity: 0,
          margin: 0,
          [`&:focus-visible + ${t}-inner`]: Object.assign({}, Mw(e))
        },
        // Wrapper > Checkbox > inner
        [`${t}-inner`]: {
          boxSizing: "border-box",
          display: "block",
          width: e.checkboxSize,
          height: e.checkboxSize,
          direction: "ltr",
          backgroundColor: e.colorBgContainer,
          border: `${le(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
          borderRadius: e.borderRadiusSM,
          borderCollapse: "separate",
          transition: `all ${e.motionDurationSlow}`,
          "&:after": {
            boxSizing: "border-box",
            position: "absolute",
            top: "50%",
            insetInlineStart: "25%",
            display: "table",
            width: e.calc(e.checkboxSize).div(14).mul(5).equal(),
            height: e.calc(e.checkboxSize).div(14).mul(8).equal(),
            border: `${le(e.lineWidthBold)} solid ${e.colorWhite}`,
            borderTop: 0,
            borderInlineStart: 0,
            transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
            opacity: 0,
            content: '""',
            transition: `all ${e.motionDurationFast} ${e.motionEaseInBack}, opacity ${e.motionDurationFast}`
          }
        },
        // Wrapper > Checkbox + Text
        "& + span": {
          paddingInlineStart: e.paddingXS,
          paddingInlineEnd: e.paddingXS
        }
      })
    },
    // ===================== Hover =====================
    {
      // Wrapper & Wrapper > Checkbox
      [`
        ${n}:not(${n}-disabled),
        ${t}:not(${t}-disabled)
      `]: {
        [`&:hover ${t}-inner`]: {
          borderColor: e.colorPrimary
        }
      },
      [`${n}:not(${n}-disabled)`]: {
        [`&:hover ${t}-checked:not(${t}-disabled) ${t}-inner`]: {
          backgroundColor: e.colorPrimaryHover,
          borderColor: "transparent"
        },
        [`&:hover ${t}-checked:not(${t}-disabled):after`]: {
          borderColor: e.colorPrimaryHover
        }
      }
    },
    // ==================== Checked ====================
    {
      // Wrapper > Checkbox
      [`${t}-checked`]: {
        [`${t}-inner`]: {
          backgroundColor: e.colorPrimary,
          borderColor: e.colorPrimary,
          "&:after": {
            opacity: 1,
            transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
            transition: `all ${e.motionDurationMid} ${e.motionEaseOutBack} ${e.motionDurationFast}`
          }
        }
      },
      [`
        ${n}-checked:not(${n}-disabled),
        ${t}-checked:not(${t}-disabled)
      `]: {
        [`&:hover ${t}-inner`]: {
          backgroundColor: e.colorPrimaryHover,
          borderColor: "transparent"
        }
      }
    },
    // ================= Indeterminate =================
    {
      [t]: {
        "&-indeterminate": {
          // Wrapper > Checkbox > inner
          [`${t}-inner`]: {
            backgroundColor: e.colorBgContainer,
            borderColor: e.colorBorder,
            "&:after": {
              top: "50%",
              insetInlineStart: "50%",
              width: e.calc(e.fontSizeLG).div(2).equal(),
              height: e.calc(e.fontSizeLG).div(2).equal(),
              backgroundColor: e.colorPrimary,
              border: 0,
              transform: "translate(-50%, -50%) scale(1)",
              opacity: 1,
              content: '""'
            }
          }
        }
      }
    },
    // ==================== Disable ====================
    {
      // Wrapper
      [`${n}-disabled`]: {
        cursor: "not-allowed"
      },
      // Wrapper > Checkbox
      [`${t}-disabled`]: {
        // Wrapper > Checkbox > input
        [`&, ${t}-input`]: {
          cursor: "not-allowed",
          // Disabled for native input to enable Tooltip event handler
          // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-1365075901
          pointerEvents: "none"
        },
        // Wrapper > Checkbox > inner
        [`${t}-inner`]: {
          background: e.colorBgContainerDisabled,
          borderColor: e.colorBorder,
          "&:after": {
            borderColor: e.colorTextDisabled
          }
        },
        "&:after": {
          display: "none"
        },
        "& + span": {
          color: e.colorTextDisabled
        },
        [`&${t}-indeterminate ${t}-inner::after`]: {
          background: e.colorTextDisabled
        }
      }
    }
  ];
};
function cM(e, t) {
  const n = Jt(t, {
    checkboxCls: `.${e}`,
    checkboxSize: t.controlInteractiveSize
  });
  return [tU(n)];
}
const uM = $n("Checkbox", (e, t) => {
  let {
    prefixCls: n
  } = t;
  return [cM(n, e)];
}), dM = (e) => {
  const {
    prefixCls: t,
    componentCls: n
  } = e, r = `${n}-menu-item`, i = `
  &${r}-expand ${r}-expand-icon,
  ${r}-loading-icon
`;
  return [
    // ==================== Checkbox ====================
    cM(`${t}-checkbox`, e),
    {
      [n]: {
        // ================== Checkbox ==================
        "&-checkbox": {
          top: 0,
          marginInlineEnd: e.paddingXS
        },
        // ==================== Menu ====================
        // >>> Menus
        "&-menus": {
          display: "flex",
          flexWrap: "nowrap",
          alignItems: "flex-start",
          [`&${n}-menu-empty`]: {
            [`${n}-menu`]: {
              width: "100%",
              height: "auto",
              [r]: {
                color: e.colorTextDisabled
              }
            }
          }
        },
        // >>> Menu
        "&-menu": {
          flexGrow: 1,
          flexShrink: 0,
          minWidth: e.controlItemWidth,
          height: e.dropdownHeight,
          margin: 0,
          padding: e.menuPadding,
          overflow: "auto",
          verticalAlign: "top",
          listStyle: "none",
          "-ms-overflow-style": "-ms-autohiding-scrollbar",
          // https://github.com/ant-design/ant-design/issues/11857
          "&:not(:last-child)": {
            borderInlineEnd: `${le(e.lineWidth)} ${e.lineType} ${e.colorSplit}`
          },
          "&-item": Object.assign(Object.assign({}, la), {
            display: "flex",
            flexWrap: "nowrap",
            alignItems: "center",
            padding: e.optionPadding,
            lineHeight: e.lineHeight,
            cursor: "pointer",
            transition: `all ${e.motionDurationMid}`,
            borderRadius: e.borderRadiusSM,
            "&:hover": {
              background: e.controlItemBgHover
            },
            "&-disabled": {
              color: e.colorTextDisabled,
              cursor: "not-allowed",
              "&:hover": {
                background: "transparent"
              },
              [i]: {
                color: e.colorTextDisabled
              }
            },
            [`&-active:not(${r}-disabled)`]: {
              "&, &:hover": {
                fontWeight: e.optionSelectedFontWeight,
                backgroundColor: e.optionSelectedBg
              }
            },
            "&-content": {
              flex: "auto"
            },
            [i]: {
              marginInlineStart: e.paddingXXS,
              color: e.colorTextDescription,
              fontSize: e.fontSizeIcon
            },
            "&-keyword": {
              color: e.colorHighlight
            }
          })
        }
      }
    }
  ];
}, nU = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e;
  return [
    // =====================================================
    // ==                     Control                     ==
    // =====================================================
    {
      [t]: {
        width: e.controlWidth
      }
    },
    // =====================================================
    // ==                      Popup                      ==
    // =====================================================
    {
      [`${t}-dropdown`]: [{
        [`&${n}-select-dropdown`]: {
          padding: 0
        }
      }, dM(e)]
    },
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${t}-dropdown-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    jg(e)
  ];
}, fM = (e) => {
  const t = Math.round((e.controlHeight - e.fontSize * e.lineHeight) / 2);
  return {
    controlWidth: 184,
    controlItemWidth: 111,
    dropdownHeight: 180,
    optionSelectedBg: e.controlItemBgActive,
    optionSelectedFontWeight: e.fontWeightStrong,
    optionPadding: `${t}px ${e.paddingSM}px`,
    menuPadding: e.paddingXXS
  };
}, hM = $n("Cascader", (e) => [nU(e)], fM), rU = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-panel`]: [dM(e), {
      display: "inline-flex",
      border: `${le(e.lineWidth)} ${e.lineType} ${e.colorSplit}`,
      borderRadius: e.borderRadiusLG,
      overflowX: "auto",
      maxWidth: "100%",
      [`${t}-menus`]: {
        alignItems: "stretch"
      },
      [`${t}-menu`]: {
        height: "auto"
      },
      "&-empty": {
        padding: e.paddingXXS
      }
    }]
  };
}, iU = Mg(["Cascader", "Panel"], (e) => rU(e), fM), oU = (e) => {
  const {
    prefixCls: t,
    className: n,
    multiple: r,
    rootClassName: i,
    notFoundContent: o,
    direction: s,
    expandIcon: a
  } = e, [l, u, c, d] = sM(t, s), f = Kn(u), [h, p, g] = hM(u, f);
  iU(u);
  const m = c === "rtl", [v, b] = lM(l, m, a), x = o || (d == null ? void 0 : d("Cascader")) || /* @__PURE__ */ O.createElement(d1, {
    componentName: "Cascader"
  }), w = aM(u, r);
  return h(/* @__PURE__ */ O.createElement(oM, Object.assign({}, e, {
    checkable: w,
    prefixCls: u,
    className: se(n, p, i, g, f),
    notFoundContent: x,
    direction: c,
    expandIcon: v,
    loadingIcon: b
  })));
};
var sU = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const {
  SHOW_CHILD: aU,
  SHOW_PARENT: lU
} = au;
function cU(e, t, n) {
  const r = e.toLowerCase().split(t).reduce((s, a, l) => l === 0 ? [a] : [].concat(_e(s), [t, a]), []), i = [];
  let o = 0;
  return r.forEach((s, a) => {
    const l = o + s.length;
    let u = e.slice(o, l);
    o = l, a % 2 === 1 && (u = // eslint-disable-next-line react/no-array-index-key
    /* @__PURE__ */ O.createElement("span", {
      className: `${n}-menu-item-keyword`,
      key: `separator-${a}`
    }, u)), i.push(u);
  }), i;
}
const uU = (e, t, n, r) => {
  const i = [], o = e.toLowerCase();
  return t.forEach((s, a) => {
    a !== 0 && i.push(" / ");
    let l = s[r.label];
    const u = typeof l;
    (u === "string" || u === "number") && (l = cU(String(l), o, n)), i.push(l);
  }), i;
}, ya = /* @__PURE__ */ O.forwardRef((e, t) => {
  var n;
  const {
    prefixCls: r,
    size: i,
    disabled: o,
    className: s,
    rootClassName: a,
    multiple: l,
    bordered: u = !0,
    transitionName: c,
    choiceTransitionName: d = "",
    popupClassName: f,
    dropdownClassName: h,
    expandIcon: p,
    placement: g,
    showSearch: m,
    allowClear: v = !0,
    notFoundContent: b,
    direction: x,
    getPopupContainer: w,
    status: C,
    showArrow: y,
    builtinPlacements: S,
    style: A,
    variant: $
  } = e, M = sU(e, ["prefixCls", "size", "disabled", "className", "rootClassName", "multiple", "bordered", "transitionName", "choiceTransitionName", "popupClassName", "dropdownClassName", "expandIcon", "placement", "showSearch", "allowClear", "notFoundContent", "direction", "getPopupContainer", "status", "showArrow", "builtinPlacements", "style", "variant"]), _ = zn(M, ["suffixIcon"]), {
    getPopupContainer: T,
    getPrefixCls: D,
    popupOverflow: E,
    cascader: R
  } = O.useContext(rt), {
    status: I,
    hasFeedback: k,
    isFormItemInput: P,
    feedbackIcon: L
  } = O.useContext(Yr), N = wf(I, C);
  if (process.env.NODE_ENV !== "production") {
    const Ve = Zt("Cascader");
    Ve.deprecated(!h, "dropdownClassName", "popupClassName"), process.env.NODE_ENV !== "production" && Ve(!("showArrow" in e), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null."), Ve.deprecated(!("bordered" in e), "bordered", "variant");
  }
  const [F, B, j, z] = sM(r, x), H = j === "rtl", W = D(), G = Kn(F), [K, Y, X] = eR(F, G), Z = Kn(B), [Q] = hM(B, Z), {
    compactSize: ne,
    compactItemClassnames: q
  } = Jc(F, x), [te, fe] = Ug($, u), Se = b || (z == null ? void 0 : z("Cascader")) || /* @__PURE__ */ O.createElement(d1, {
    componentName: "Cascader"
  }), de = se(f || h, `${B}-dropdown`, {
    [`${B}-dropdown-rtl`]: j === "rtl"
  }, a, G, Z, Y, X), ce = O.useMemo(() => {
    if (!m)
      return m;
    let Ve = {
      render: uU
    };
    return typeof m == "object" && (Ve = Object.assign(Object.assign({}, Ve), m)), Ve;
  }, [m]), pe = so((Ve) => {
    var We;
    return (We = i ?? ne) !== null && We !== void 0 ? We : Ve;
  }), Oe = O.useContext(Ko), Re = o ?? Oe, [De, Me] = lM(F, H, p), Ue = aM(B, l), oe = nR(e.suffixIcon, y), {
    suffixIcon: Ce,
    removeIcon: ge,
    clearIcon: ve
  } = tR(Object.assign(Object.assign({}, e), {
    hasFeedback: k,
    feedbackIcon: L,
    showSuffixIcon: oe,
    multiple: l,
    prefixCls: F,
    componentName: "Cascader"
  })), me = O.useMemo(() => g !== void 0 ? g : H ? "bottomRight" : "bottomLeft", [g, H]), Fe = v === !0 ? {
    clearIcon: ve
  } : v, [Be] = Zc("SelectLike", (n = _.dropdownStyle) === null || n === void 0 ? void 0 : n.zIndex), qe = /* @__PURE__ */ O.createElement(au, Object.assign({
    prefixCls: F,
    className: se(!r && B, {
      [`${F}-lg`]: pe === "large",
      [`${F}-sm`]: pe === "small",
      [`${F}-rtl`]: H,
      [`${F}-${te}`]: fe,
      [`${F}-in-form-item`]: P
    }, $d(F, N, k), q, R == null ? void 0 : R.className, s, a, G, Z, Y, X),
    disabled: Re,
    style: Object.assign(Object.assign({}, R == null ? void 0 : R.style), A)
  }, _, {
    builtinPlacements: QT(S, E),
    direction: j,
    placement: me,
    notFoundContent: Se,
    allowClear: Fe,
    showSearch: ce,
    expandIcon: De,
    suffixIcon: Ce,
    removeIcon: ge,
    loadingIcon: Me,
    checkable: Ue,
    dropdownClassName: de,
    dropdownPrefixCls: r || B,
    dropdownStyle: Object.assign(Object.assign({}, _.dropdownStyle), {
      zIndex: Be
    }),
    choiceTransitionName: Xo(W, "", d),
    transitionName: Xo(W, "slide-up", c),
    getPopupContainer: w || T,
    ref: t
  }));
  return Q(K(qe));
});
process.env.NODE_ENV !== "production" && (ya.displayName = "Cascader");
const dU = t1(ya);
ya.SHOW_PARENT = lU;
ya.SHOW_CHILD = aU;
ya.Panel = oU;
ya._InternalPanelDoNotUseOrYouWillBeFired = dU;
const pM = /* @__PURE__ */ U.createContext(null);
var fU = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const hU = (e, t) => {
  var n;
  const {
    prefixCls: r,
    className: i,
    rootClassName: o,
    children: s,
    indeterminate: a = !1,
    style: l,
    onMouseEnter: u,
    onMouseLeave: c,
    skipGroup: d = !1,
    disabled: f
  } = e, h = fU(e, ["prefixCls", "className", "rootClassName", "children", "indeterminate", "style", "onMouseEnter", "onMouseLeave", "skipGroup", "disabled"]), {
    getPrefixCls: p,
    direction: g,
    checkbox: m
  } = O.useContext(rt), v = O.useContext(pM), {
    isFormItemInput: b
  } = O.useContext(Yr), x = O.useContext(Ko), w = (n = (v == null ? void 0 : v.disabled) || f) !== null && n !== void 0 ? n : x, C = O.useRef(h.value);
  if (process.env.NODE_ENV !== "production") {
    const R = Zt("Checkbox");
    process.env.NODE_ENV !== "production" && R("checked" in h || !!v || !("value" in h), "usage", "`value` is not a valid prop, do you mean `checked`?");
  }
  O.useEffect(() => {
    v == null || v.registerValue(h.value);
  }, []), O.useEffect(() => {
    if (!d)
      return h.value !== C.current && (v == null || v.cancelValue(C.current), v == null || v.registerValue(h.value), C.current = h.value), () => v == null ? void 0 : v.cancelValue(h.value);
  }, [h.value]);
  const y = p("checkbox", r), S = Kn(y), [A, $, M] = uM(y, S), _ = Object.assign({}, h);
  v && !d && (_.onChange = function() {
    h.onChange && h.onChange.apply(h, arguments), v.toggleOption && v.toggleOption({
      label: s,
      value: h.value
    });
  }, _.name = v.name, _.checked = v.value.includes(h.value));
  const T = se(`${y}-wrapper`, {
    [`${y}-rtl`]: g === "rtl",
    [`${y}-wrapper-checked`]: _.checked,
    [`${y}-wrapper-disabled`]: w,
    [`${y}-wrapper-in-form-item`]: b
  }, m == null ? void 0 : m.className, i, o, M, S, $), D = se({
    [`${y}-indeterminate`]: a
  }, Lw, $), E = a ? "mixed" : void 0;
  return A(/* @__PURE__ */ O.createElement(Fw, {
    component: "Checkbox",
    disabled: w
  }, /* @__PURE__ */ O.createElement("label", {
    className: T,
    style: Object.assign(Object.assign({}, m == null ? void 0 : m.style), l),
    onMouseEnter: u,
    onMouseLeave: c
  }, /* @__PURE__ */ O.createElement(K9, Object.assign({
    "aria-checked": E
  }, _, {
    prefixCls: y,
    className: D,
    disabled: w,
    ref: t
  })), s !== void 0 && /* @__PURE__ */ O.createElement("span", null, s))));
}, T1 = /* @__PURE__ */ O.forwardRef(hU);
process.env.NODE_ENV !== "production" && (T1.displayName = "Checkbox");
var pU = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const gU = /* @__PURE__ */ O.forwardRef((e, t) => {
  const {
    defaultValue: n,
    children: r,
    options: i = [],
    prefixCls: o,
    className: s,
    rootClassName: a,
    style: l,
    onChange: u
  } = e, c = pU(e, ["defaultValue", "children", "options", "prefixCls", "className", "rootClassName", "style", "onChange"]), {
    getPrefixCls: d,
    direction: f
  } = O.useContext(rt), [h, p] = O.useState(c.value || n || []), [g, m] = O.useState([]);
  O.useEffect(() => {
    "value" in c && p(c.value || []);
  }, [c.value]);
  const v = O.useMemo(() => i.map((R) => typeof R == "string" || typeof R == "number" ? {
    label: R,
    value: R
  } : R), [i]), b = (R) => {
    m((I) => I.filter((k) => k !== R));
  }, x = (R) => {
    m((I) => [].concat(_e(I), [R]));
  }, w = (R) => {
    const I = h.indexOf(R.value), k = _e(h);
    I === -1 ? k.push(R.value) : k.splice(I, 1), "value" in c || p(k), u == null || u(k.filter((P) => g.includes(P)).sort((P, L) => {
      const N = v.findIndex((B) => B.value === P), F = v.findIndex((B) => B.value === L);
      return N - F;
    }));
  }, C = d("checkbox", o), y = `${C}-group`, S = Kn(C), [A, $, M] = uM(C, S), _ = zn(c, ["value", "disabled"]), T = i.length ? v.map((R) => /* @__PURE__ */ O.createElement(T1, {
    prefixCls: C,
    key: R.value.toString(),
    disabled: "disabled" in R ? R.disabled : c.disabled,
    value: R.value,
    checked: h.includes(R.value),
    onChange: R.onChange,
    className: `${y}-item`,
    style: R.style,
    title: R.title,
    id: R.id,
    required: R.required
  }, R.label)) : r, D = {
    toggleOption: w,
    value: h,
    disabled: c.disabled,
    name: c.name,
    // https://github.com/ant-design/ant-design/issues/16376
    registerValue: x,
    cancelValue: b
  }, E = se(y, {
    [`${y}-rtl`]: f === "rtl"
  }, s, a, M, S, $);
  return A(/* @__PURE__ */ O.createElement("div", Object.assign({
    className: E,
    style: l
  }, _, {
    ref: t
  }), /* @__PURE__ */ O.createElement(pM.Provider, {
    value: D
  }, T)));
}), rm = T1;
rm.Group = gU;
rm.__ANT_CHECKBOX = !0;
process.env.NODE_ENV !== "production" && (rm.displayName = "Checkbox");
const gM = /* @__PURE__ */ Yo({}), mU = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // Grid system
    [t]: {
      display: "flex",
      flexFlow: "row wrap",
      minWidth: 0,
      "&::before, &::after": {
        display: "flex"
      },
      "&-no-wrap": {
        flexWrap: "nowrap"
      },
      // The origin of the X-axis
      "&-start": {
        justifyContent: "flex-start"
      },
      // The center of the X-axis
      "&-center": {
        justifyContent: "center"
      },
      // The opposite of the X-axis
      "&-end": {
        justifyContent: "flex-end"
      },
      "&-space-between": {
        justifyContent: "space-between"
      },
      "&-space-around": {
        justifyContent: "space-around"
      },
      "&-space-evenly": {
        justifyContent: "space-evenly"
      },
      // Align at the top
      "&-top": {
        alignItems: "flex-start"
      },
      // Align at the center
      "&-middle": {
        alignItems: "center"
      },
      "&-bottom": {
        alignItems: "flex-end"
      }
    }
  };
}, vU = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // Grid system
    [t]: {
      position: "relative",
      maxWidth: "100%",
      // Prevent columns from collapsing when empty
      minHeight: 1
    }
  };
}, bU = (e, t) => {
  const {
    prefixCls: n,
    componentCls: r,
    gridColumns: i
  } = e, o = {};
  for (let s = i; s >= 0; s--)
    s === 0 ? (o[`${r}${t}-${s}`] = {
      display: "none"
    }, o[`${r}-push-${s}`] = {
      insetInlineStart: "auto"
    }, o[`${r}-pull-${s}`] = {
      insetInlineEnd: "auto"
    }, o[`${r}${t}-push-${s}`] = {
      insetInlineStart: "auto"
    }, o[`${r}${t}-pull-${s}`] = {
      insetInlineEnd: "auto"
    }, o[`${r}${t}-offset-${s}`] = {
      marginInlineStart: 0
    }, o[`${r}${t}-order-${s}`] = {
      order: 0
    }) : (o[`${r}${t}-${s}`] = [
      // https://github.com/ant-design/ant-design/issues/44456
      // Form set `display: flex` on Col which will override `display: block`.
      // Let's get it from css variable to support override.
      {
        "--ant-display": "block",
        // Fallback to display if variable not support
        display: "block"
      },
      {
        display: "var(--ant-display)",
        flex: `0 0 ${s / i * 100}%`,
        maxWidth: `${s / i * 100}%`
      }
    ], o[`${r}${t}-push-${s}`] = {
      insetInlineStart: `${s / i * 100}%`
    }, o[`${r}${t}-pull-${s}`] = {
      insetInlineEnd: `${s / i * 100}%`
    }, o[`${r}${t}-offset-${s}`] = {
      marginInlineStart: `${s / i * 100}%`
    }, o[`${r}${t}-order-${s}`] = {
      order: s
    });
  return o[`${r}${t}-flex`] = {
    flex: `var(--${n}${t}-flex)`
  }, o;
}, Fb = (e, t) => bU(e, t), yU = (e, t, n) => ({
  [`@media (min-width: ${le(t)})`]: Object.assign({}, Fb(e, n))
}), wU = () => ({}), CU = () => ({}), SU = $n("Grid", mU, wU), xU = $n("Grid", (e) => {
  const t = Jt(e, {
    gridColumns: 24
    // Row is divided into 24 parts in Grid
  }), n = {
    "-sm": t.screenSMMin,
    "-md": t.screenMDMin,
    "-lg": t.screenLGMin,
    "-xl": t.screenXLMin,
    "-xxl": t.screenXXLMin
  };
  return [vU(t), Fb(t, ""), Fb(t, "-xs"), Object.keys(n).map((r) => yU(t, n[r], r)).reduce((r, i) => Object.assign(Object.assign({}, r), i), {})];
}, CU);
var EU = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
function PE(e) {
  return typeof e == "number" ? `${e} ${e} auto` : /^\d+(\.\d+)?(px|em|rem|%)$/.test(e) ? `0 0 ${e}` : e;
}
const $U = ["xs", "sm", "md", "lg", "xl", "xxl"], R1 = /* @__PURE__ */ O.forwardRef((e, t) => {
  const {
    getPrefixCls: n,
    direction: r
  } = O.useContext(rt), {
    gutter: i,
    wrap: o
  } = O.useContext(gM), {
    prefixCls: s,
    span: a,
    order: l,
    offset: u,
    push: c,
    pull: d,
    className: f,
    children: h,
    flex: p,
    style: g
  } = e, m = EU(e, ["prefixCls", "span", "order", "offset", "push", "pull", "className", "children", "flex", "style"]), v = n("col", s), [b, x, w] = xU(v), C = {};
  let y = {};
  $U.forEach(($) => {
    let M = {};
    const _ = e[$];
    typeof _ == "number" ? M.span = _ : typeof _ == "object" && (M = _ || {}), delete m[$], y = Object.assign(Object.assign({}, y), {
      [`${v}-${$}-${M.span}`]: M.span !== void 0,
      [`${v}-${$}-order-${M.order}`]: M.order || M.order === 0,
      [`${v}-${$}-offset-${M.offset}`]: M.offset || M.offset === 0,
      [`${v}-${$}-push-${M.push}`]: M.push || M.push === 0,
      [`${v}-${$}-pull-${M.pull}`]: M.pull || M.pull === 0,
      [`${v}-rtl`]: r === "rtl"
    }), M.flex && (y[`${v}-${$}-flex`] = !0, C[`--${v}-${$}-flex`] = PE(M.flex));
  });
  const S = se(v, {
    [`${v}-${a}`]: a !== void 0,
    [`${v}-order-${l}`]: l,
    [`${v}-offset-${u}`]: u,
    [`${v}-push-${c}`]: c,
    [`${v}-pull-${d}`]: d
  }, f, y, x, w), A = {};
  if (i && i[0] > 0) {
    const $ = i[0] / 2;
    A.paddingLeft = $, A.paddingRight = $;
  }
  return p && (A.flex = PE(p), o === !1 && !A.minWidth && (A.minWidth = 0)), b(/* @__PURE__ */ O.createElement("div", Object.assign({}, m, {
    style: Object.assign(Object.assign(Object.assign({}, A), g), C),
    className: S,
    ref: t
  }), h));
});
process.env.NODE_ENV !== "production" && (R1.displayName = "Col");
var OU = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
function NE(e, t) {
  const [n, r] = O.useState(typeof e == "string" ? e : ""), i = () => {
    if (typeof e == "string" && r(e), typeof e == "object")
      for (let o = 0; o < Rc.length; o++) {
        const s = Rc[o];
        if (!t[s])
          continue;
        const a = e[s];
        if (a !== void 0) {
          r(a);
          return;
        }
      }
  };
  return O.useEffect(() => {
    i();
  }, [JSON.stringify(e), t]), n;
}
const mM = /* @__PURE__ */ O.forwardRef((e, t) => {
  const {
    prefixCls: n,
    justify: r,
    align: i,
    className: o,
    style: s,
    children: a,
    gutter: l = 0,
    wrap: u
  } = e, c = OU(e, ["prefixCls", "justify", "align", "className", "style", "children", "gutter", "wrap"]), {
    getPrefixCls: d,
    direction: f
  } = O.useContext(rt), [h, p] = O.useState({
    xs: !0,
    sm: !0,
    md: !0,
    lg: !0,
    xl: !0,
    xxl: !0
  }), [g, m] = O.useState({
    xs: !1,
    sm: !1,
    md: !1,
    lg: !1,
    xl: !1,
    xxl: !1
  }), v = NE(i, g), b = NE(r, g), x = O.useRef(l), w = oR();
  O.useEffect(() => {
    const k = w.subscribe((P) => {
      m(P);
      const L = x.current || 0;
      (!Array.isArray(L) && typeof L == "object" || Array.isArray(L) && (typeof L[0] == "object" || typeof L[1] == "object")) && p(P);
    });
    return () => w.unsubscribe(k);
  }, []);
  const C = () => {
    const k = [void 0, void 0];
    return (Array.isArray(l) ? l : [l, void 0]).forEach((L, N) => {
      if (typeof L == "object")
        for (let F = 0; F < Rc.length; F++) {
          const B = Rc[F];
          if (h[B] && L[B] !== void 0) {
            k[N] = L[B];
            break;
          }
        }
      else
        k[N] = L;
    }), k;
  }, y = d("row", n), [S, A, $] = SU(y), M = C(), _ = se(y, {
    [`${y}-no-wrap`]: u === !1,
    [`${y}-${b}`]: b,
    [`${y}-${v}`]: v,
    [`${y}-rtl`]: f === "rtl"
  }, o, A, $), T = {}, D = M[0] != null && M[0] > 0 ? M[0] / -2 : void 0;
  D && (T.marginLeft = D, T.marginRight = D);
  const [E, R] = M;
  T.rowGap = R;
  const I = O.useMemo(() => ({
    gutter: [E, R],
    wrap: u
  }), [E, R, u]);
  return S(/* @__PURE__ */ O.createElement(gM.Provider, {
    value: I
  }, /* @__PURE__ */ O.createElement("div", Object.assign({}, c, {
    className: _,
    style: Object.assign(Object.assign({}, T), s),
    ref: t
  }), a)));
});
process.env.NODE_ENV !== "production" && (mM.displayName = "Row");
const AU = (e) => {
  const {
    componentCls: t,
    sizePaddingEdgeHorizontal: n,
    colorSplit: r,
    lineWidth: i,
    textPaddingInline: o,
    orientationMargin: s,
    verticalMarginInline: a
  } = e;
  return {
    [t]: Object.assign(Object.assign({}, Gn(e)), {
      borderBlockStart: `${le(i)} solid ${r}`,
      // vertical
      "&-vertical": {
        position: "relative",
        top: "-0.06em",
        display: "inline-block",
        height: "0.9em",
        marginInline: a,
        marginBlock: 0,
        verticalAlign: "middle",
        borderTop: 0,
        borderInlineStart: `${le(i)} solid ${r}`
      },
      "&-horizontal": {
        display: "flex",
        clear: "both",
        width: "100%",
        minWidth: "100%",
        // Fix https://github.com/ant-design/ant-design/issues/10914
        margin: `${le(e.dividerHorizontalGutterMargin)} 0`
      },
      [`&-horizontal${t}-with-text`]: {
        display: "flex",
        alignItems: "center",
        margin: `${le(e.dividerHorizontalWithTextGutterMargin)} 0`,
        color: e.colorTextHeading,
        fontWeight: 500,
        fontSize: e.fontSizeLG,
        whiteSpace: "nowrap",
        textAlign: "center",
        borderBlockStart: `0 ${r}`,
        "&::before, &::after": {
          position: "relative",
          width: "50%",
          borderBlockStart: `${le(i)} solid transparent`,
          // Chrome not accept `inherit` in `border-top`
          borderBlockStartColor: "inherit",
          borderBlockEnd: 0,
          transform: "translateY(50%)",
          content: "''"
        }
      },
      [`&-horizontal${t}-with-text-left`]: {
        "&::before": {
          width: `calc(${s} * 100%)`
        },
        "&::after": {
          width: `calc(100% - ${s} * 100%)`
        }
      },
      [`&-horizontal${t}-with-text-right`]: {
        "&::before": {
          width: `calc(100% - ${s} * 100%)`
        },
        "&::after": {
          width: `calc(${s} * 100%)`
        }
      },
      [`${t}-inner-text`]: {
        display: "inline-block",
        paddingBlock: 0,
        paddingInline: o
      },
      "&-dashed": {
        background: "none",
        borderColor: r,
        borderStyle: "dashed",
        borderWidth: `${le(i)} 0 0`
      },
      [`&-horizontal${t}-with-text${t}-dashed`]: {
        "&::before, &::after": {
          borderStyle: "dashed none none"
        }
      },
      [`&-vertical${t}-dashed`]: {
        borderInlineStartWidth: i,
        borderInlineEnd: 0,
        borderBlockStart: 0,
        borderBlockEnd: 0
      },
      [`&-plain${t}-with-text`]: {
        color: e.colorText,
        fontWeight: "normal",
        fontSize: e.fontSize
      },
      [`&-horizontal${t}-with-text-left${t}-no-default-orientation-margin-left`]: {
        "&::before": {
          width: 0
        },
        "&::after": {
          width: "100%"
        },
        [`${t}-inner-text`]: {
          paddingInlineStart: n
        }
      },
      [`&-horizontal${t}-with-text-right${t}-no-default-orientation-margin-right`]: {
        "&::before": {
          width: "100%"
        },
        "&::after": {
          width: 0
        },
        [`${t}-inner-text`]: {
          paddingInlineEnd: n
        }
      }
    })
  };
}, DU = (e) => ({
  textPaddingInline: "1em",
  orientationMargin: 0.05,
  verticalMarginInline: e.marginXS
}), _U = $n("Divider", (e) => {
  const t = Jt(e, {
    dividerHorizontalWithTextGutterMargin: e.margin,
    dividerHorizontalGutterMargin: e.marginLG,
    sizePaddingEdgeHorizontal: 0
  });
  return [AU(t)];
}, DU, {
  unitless: {
    orientationMargin: !0
  }
});
var TU = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const ip = (e) => {
  const {
    getPrefixCls: t,
    direction: n,
    divider: r
  } = O.useContext(rt), {
    prefixCls: i,
    type: o = "horizontal",
    orientation: s = "center",
    orientationMargin: a,
    className: l,
    rootClassName: u,
    children: c,
    dashed: d,
    plain: f,
    style: h
  } = e, p = TU(e, ["prefixCls", "type", "orientation", "orientationMargin", "className", "rootClassName", "children", "dashed", "plain", "style"]), g = t("divider", i), [m, v, b] = _U(g), x = s.length > 0 ? `-${s}` : s, w = !!c, C = s === "left" && a != null, y = s === "right" && a != null, S = se(g, r == null ? void 0 : r.className, v, b, `${g}-${o}`, {
    [`${g}-with-text`]: w,
    [`${g}-with-text${x}`]: w,
    [`${g}-dashed`]: !!d,
    [`${g}-plain`]: !!f,
    [`${g}-rtl`]: n === "rtl",
    [`${g}-no-default-orientation-margin-left`]: C,
    [`${g}-no-default-orientation-margin-right`]: y
  }, l, u), A = O.useMemo(() => typeof a == "number" ? a : /^\d+$/.test(a) ? Number(a) : a, [a]), $ = Object.assign(Object.assign({}, C && {
    marginLeft: A
  }), y && {
    marginRight: A
  });
  if (process.env.NODE_ENV !== "production") {
    const M = Zt("Divider");
    process.env.NODE_ENV !== "production" && M(!c || o !== "vertical", "usage", "`children` not working in `vertical` mode.");
  }
  return m(/* @__PURE__ */ O.createElement("div", Object.assign({
    className: S,
    style: Object.assign(Object.assign({}, r == null ? void 0 : r.style), h)
  }, p, {
    role: "separator"
  }), c && o !== "vertical" && /* @__PURE__ */ O.createElement("span", {
    className: `${g}-inner-text`,
    style: $
  }, c)));
};
process.env.NODE_ENV !== "production" && (ip.displayName = "Divider");
function RU(e) {
  return !!(e.addonBefore || e.addonAfter);
}
function MU(e) {
  return !!(e.prefix || e.suffix || e.allowClear);
}
function LE(e, t, n) {
  var r = t.cloneNode(!0), i = Object.create(e, {
    target: {
      value: r
    },
    currentTarget: {
      value: r
    }
  });
  return r.value = n, typeof t.selectionStart == "number" && typeof t.selectionEnd == "number" && (r.selectionStart = t.selectionStart, r.selectionEnd = t.selectionEnd), i;
}
function Bp(e, t, n, r) {
  if (n) {
    var i = t;
    if (t.type === "click") {
      i = LE(t, e, ""), n(i);
      return;
    }
    if (e.type !== "file" && r !== void 0) {
      i = LE(t, e, r), n(i);
      return;
    }
    n(i);
  }
}
function IU(e, t) {
  if (e) {
    e.focus(t);
    var n = t || {}, r = n.cursor;
    if (r) {
      var i = e.value.length;
      switch (r) {
        case "start":
          e.setSelectionRange(0, 0);
          break;
        case "end":
          e.setSelectionRange(i, i);
          break;
        default:
          e.setSelectionRange(0, i);
      }
    }
  }
}
var vM = function(t) {
  var n, r, i = t.inputElement, o = t.children, s = t.prefixCls, a = t.prefix, l = t.suffix, u = t.addonBefore, c = t.addonAfter, d = t.className, f = t.style, h = t.disabled, p = t.readOnly, g = t.focused, m = t.triggerFocus, v = t.allowClear, b = t.value, x = t.handleReset, w = t.hidden, C = t.classes, y = t.classNames, S = t.dataAttrs, A = t.styles, $ = t.components, M = o ?? i, _ = ($ == null ? void 0 : $.affixWrapper) || "span", T = ($ == null ? void 0 : $.groupWrapper) || "span", D = ($ == null ? void 0 : $.wrapper) || "span", E = ($ == null ? void 0 : $.groupAddon) || "span", R = he(null), I = function(q) {
    var te;
    (te = R.current) !== null && te !== void 0 && te.contains(q.target) && (m == null || m());
  }, k = MU(t), P = /* @__PURE__ */ M0(M, {
    value: b,
    className: se(M.props.className, !k && (y == null ? void 0 : y.variant)) || null
  });
  if (k) {
    var L, N = null;
    if (v) {
      var F, B = !h && !p && b, j = "".concat(s, "-clear-icon"), z = wt(v) === "object" && v !== null && v !== void 0 && v.clearIcon ? v.clearIcon : "";
      N = /* @__PURE__ */ U.createElement("span", {
        onClick: x,
        onMouseDown: function(q) {
          return q.preventDefault();
        },
        className: se(j, (F = {}, re(F, "".concat(j, "-hidden"), !B), re(F, "".concat(j, "-has-suffix"), !!l), F)),
        role: "button",
        tabIndex: -1
      }, z);
    }
    var H = "".concat(s, "-affix-wrapper"), W = se(H, (L = {}, re(L, "".concat(s, "-disabled"), h), re(L, "".concat(H, "-disabled"), h), re(L, "".concat(H, "-focused"), g), re(L, "".concat(H, "-readonly"), p), re(L, "".concat(H, "-input-with-clear-btn"), l && v && b), L), C == null ? void 0 : C.affixWrapper, y == null ? void 0 : y.affixWrapper, y == null ? void 0 : y.variant), G = (l || v) && /* @__PURE__ */ U.createElement("span", {
      className: se("".concat(s, "-suffix"), y == null ? void 0 : y.suffix),
      style: A == null ? void 0 : A.suffix
    }, N, l);
    P = /* @__PURE__ */ U.createElement(_, we({
      className: W,
      style: A == null ? void 0 : A.affixWrapper,
      onClick: I
    }, S == null ? void 0 : S.affixWrapper, {
      ref: R
    }), a && /* @__PURE__ */ U.createElement("span", {
      className: se("".concat(s, "-prefix"), y == null ? void 0 : y.prefix),
      style: A == null ? void 0 : A.prefix
    }, a), P, G);
  }
  if (RU(t)) {
    var K = "".concat(s, "-group"), Y = "".concat(K, "-addon"), X = "".concat(K, "-wrapper"), Z = se("".concat(s, "-wrapper"), K, C == null ? void 0 : C.wrapper, y == null ? void 0 : y.wrapper), Q = se(X, re({}, "".concat(X, "-disabled"), h), C == null ? void 0 : C.group, y == null ? void 0 : y.groupWrapper);
    P = /* @__PURE__ */ U.createElement(T, {
      className: Q
    }, /* @__PURE__ */ U.createElement(D, {
      className: Z
    }, u && /* @__PURE__ */ U.createElement(E, {
      className: Y
    }, u), P, c && /* @__PURE__ */ U.createElement(E, {
      className: Y
    }, c)));
  }
  return /* @__PURE__ */ U.cloneElement(P, {
    className: se((n = P.props) === null || n === void 0 ? void 0 : n.className, d) || null,
    style: ie(ie({}, (r = P.props) === null || r === void 0 ? void 0 : r.style), f),
    hidden: w
  });
}, kU = ["show"];
function bM(e, t) {
  return O.useMemo(function() {
    var n = {};
    t && (n.show = wt(t) === "object" && t.formatter ? t.formatter : !!t), n = ie(ie({}, n), e);
    var r = n, i = r.show, o = Rt(r, kU);
    return ie(ie({}, o), {}, {
      show: !!i,
      showFormatter: typeof i == "function" ? i : void 0,
      strategy: o.strategy || function(s) {
        return s.length;
      }
    });
  }, [e, t]);
}
var PU = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "count", "type", "classes", "classNames", "styles", "onCompositionStart", "onCompositionEnd"], NU = /* @__PURE__ */ li(function(e, t) {
  var n = e.autoComplete, r = e.onChange, i = e.onFocus, o = e.onBlur, s = e.onPressEnter, a = e.onKeyDown, l = e.prefixCls, u = l === void 0 ? "rc-input" : l, c = e.disabled, d = e.htmlSize, f = e.className, h = e.maxLength, p = e.suffix, g = e.showCount, m = e.count, v = e.type, b = v === void 0 ? "text" : v, x = e.classes, w = e.classNames, C = e.styles, y = e.onCompositionStart, S = e.onCompositionEnd, A = Rt(e, PU), $ = ht(!1), M = ae($, 2), _ = M[0], T = M[1], D = he(!1), E = he(null), R = function(pe) {
    E.current && IU(E.current, pe);
  }, I = Un(e.defaultValue, {
    value: e.value
  }), k = ae(I, 2), P = k[0], L = k[1], N = P == null ? "" : String(P), F = ht(null), B = ae(F, 2), j = B[0], z = B[1], H = bM(m, g), W = H.max || h, G = H.strategy(N), K = !!W && G > W;
  fl(t, function() {
    return {
      focus: R,
      blur: function() {
        var pe;
        (pe = E.current) === null || pe === void 0 || pe.blur();
      },
      setSelectionRange: function(pe, Oe, Re) {
        var De;
        (De = E.current) === null || De === void 0 || De.setSelectionRange(pe, Oe, Re);
      },
      select: function() {
        var pe;
        (pe = E.current) === null || pe === void 0 || pe.select();
      },
      input: E.current
    };
  }), Pe(function() {
    T(function(ce) {
      return ce && c ? !1 : ce;
    });
  }, [c]);
  var Y = function(pe, Oe, Re) {
    var De = Oe;
    if (!D.current && H.exceedFormatter && H.max && H.strategy(Oe) > H.max) {
      if (De = H.exceedFormatter(Oe, {
        max: H.max
      }), Oe !== De) {
        var Me, Ue;
        z([((Me = E.current) === null || Me === void 0 ? void 0 : Me.selectionStart) || 0, ((Ue = E.current) === null || Ue === void 0 ? void 0 : Ue.selectionEnd) || 0]);
      }
    } else if (Re.source === "compositionEnd")
      return;
    L(De), E.current && Bp(E.current, pe, r, De);
  };
  Pe(function() {
    if (j) {
      var ce;
      (ce = E.current) === null || ce === void 0 || ce.setSelectionRange.apply(ce, _e(j));
    }
  }, [j]);
  var X = function(pe) {
    Y(pe, pe.target.value, {
      source: "change"
    });
  }, Z = function(pe) {
    D.current = !1, Y(pe, pe.currentTarget.value, {
      source: "compositionEnd"
    }), S == null || S(pe);
  }, Q = function(pe) {
    s && pe.key === "Enter" && s(pe), a == null || a(pe);
  }, ne = function(pe) {
    T(!0), i == null || i(pe);
  }, q = function(pe) {
    T(!1), o == null || o(pe);
  }, te = function(pe) {
    L(""), R(), E.current && Bp(E.current, pe, r);
  }, fe = K && "".concat(u, "-out-of-range"), Se = function() {
    var pe = zn(e, [
      "prefixCls",
      "onPressEnter",
      "addonBefore",
      "addonAfter",
      "prefix",
      "suffix",
      "allowClear",
      // Input elements must be either controlled or uncontrolled,
      // specify either the value prop, or the defaultValue prop, but not both.
      "defaultValue",
      "showCount",
      "count",
      "classes",
      "htmlSize",
      "styles",
      "classNames"
    ]);
    return /* @__PURE__ */ U.createElement("input", we({
      autoComplete: n
    }, pe, {
      onChange: X,
      onFocus: ne,
      onBlur: q,
      onKeyDown: Q,
      className: se(u, re({}, "".concat(u, "-disabled"), c), w == null ? void 0 : w.input),
      style: C == null ? void 0 : C.input,
      ref: E,
      size: d,
      type: b,
      onCompositionStart: function(Re) {
        D.current = !0, y == null || y(Re);
      },
      onCompositionEnd: Z
    }));
  }, de = function() {
    var pe = Number(W) > 0;
    if (p || H.show) {
      var Oe = H.showFormatter ? H.showFormatter({
        value: N,
        count: G,
        maxLength: W
      }) : "".concat(G).concat(pe ? " / ".concat(W) : "");
      return /* @__PURE__ */ U.createElement(U.Fragment, null, H.show && /* @__PURE__ */ U.createElement("span", {
        className: se("".concat(u, "-show-count-suffix"), re({}, "".concat(u, "-show-count-has-suffix"), !!p), w == null ? void 0 : w.count),
        style: ie({}, C == null ? void 0 : C.count)
      }, Oe), p);
    }
    return null;
  };
  return /* @__PURE__ */ U.createElement(vM, we({}, A, {
    prefixCls: u,
    className: se(f, fe),
    handleReset: te,
    value: N,
    focused: _,
    triggerFocus: R,
    suffix: de(),
    disabled: c,
    classes: x,
    classNames: w,
    styles: C
  }), Se());
});
const LU = (e) => {
  const {
    getPrefixCls: t,
    direction: n
  } = Yt(rt), {
    prefixCls: r,
    className: i
  } = e, o = t("input-group", r), s = t("input"), [a, l] = O1(s), u = se(o, {
    [`${o}-lg`]: e.size === "large",
    [`${o}-sm`]: e.size === "small",
    [`${o}-compact`]: e.compact,
    [`${o}-rtl`]: n === "rtl"
  }, l, i), c = Yt(Yr), d = mt(() => Object.assign(Object.assign({}, c), {
    isFormItemInput: !1
  }), [c]);
  return process.env.NODE_ENV !== "production" && Zt("Input.Group").deprecated(!1, "Input.Group", "Space.Compact"), a(/* @__PURE__ */ O.createElement("span", {
    className: u,
    style: e.style,
    onMouseEnter: e.onMouseEnter,
    onMouseLeave: e.onMouseLeave,
    onFocus: e.onFocus,
    onBlur: e.onBlur
  }, /* @__PURE__ */ O.createElement(Yr.Provider, {
    value: d
  }, e.children)));
}, yM = (e) => {
  let t;
  return typeof e == "object" && (e != null && e.clearIcon) ? t = e : e && (t = {
    clearIcon: /* @__PURE__ */ U.createElement(bl, null)
  }), t;
};
function wM(e, t) {
  const n = he([]), r = () => {
    n.current.push(setTimeout(() => {
      var i, o, s, a;
      !((i = e.current) === null || i === void 0) && i.input && ((o = e.current) === null || o === void 0 ? void 0 : o.input.getAttribute("type")) === "password" && (!((s = e.current) === null || s === void 0) && s.input.hasAttribute("value")) && ((a = e.current) === null || a === void 0 || a.input.removeAttribute("value"));
    }));
  };
  return Pe(() => (t && r(), () => n.current.forEach((i) => {
    i && clearTimeout(i);
  })), []), r;
}
function FU(e) {
  return !!(e.prefix || e.suffix || e.allowClear || e.showCount);
}
var BU = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
function jU(e, t) {
  if (!e)
    return;
  e.focus(t);
  const {
    cursor: n
  } = t || {};
  if (n) {
    const r = e.value.length;
    switch (n) {
      case "start":
        e.setSelectionRange(0, 0);
        break;
      case "end":
        e.setSelectionRange(r, r);
        break;
      default:
        e.setSelectionRange(0, r);
        break;
    }
  }
}
const Ef = /* @__PURE__ */ li((e, t) => {
  var n;
  const {
    prefixCls: r,
    bordered: i = !0,
    status: o,
    size: s,
    disabled: a,
    onBlur: l,
    onFocus: u,
    suffix: c,
    allowClear: d,
    addonAfter: f,
    addonBefore: h,
    className: p,
    style: g,
    styles: m,
    rootClassName: v,
    onChange: b,
    classNames: x,
    variant: w
  } = e, C = BU(e, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "style", "styles", "rootClassName", "onChange", "classNames", "variant"]);
  if (process.env.NODE_ENV !== "production") {
    const {
      deprecated: q
    } = Zt("Input");
    q(!("bordered" in e), "bordered", "variant");
  }
  const {
    getPrefixCls: y,
    direction: S,
    input: A
  } = U.useContext(rt), $ = y("input", r), M = he(null), _ = Kn($), [T, D, E] = O1($, _), {
    compactSize: R,
    compactItemClassnames: I
  } = Jc($, S), k = so((q) => {
    var te;
    return (te = s ?? R) !== null && te !== void 0 ? te : q;
  }), P = U.useContext(Ko), L = a ?? P, {
    status: N,
    hasFeedback: F,
    feedbackIcon: B
  } = Yt(Yr), j = wf(N, o), z = FU(e) || !!F, H = he(z);
  if (process.env.NODE_ENV !== "production") {
    const q = Zt("Input");
    Pe(() => {
      var te;
      z && !H.current && process.env.NODE_ENV !== "production" && q(document.activeElement === ((te = M.current) === null || te === void 0 ? void 0 : te.input), "usage", "When Input is focused, dynamic add or remove prefix / suffix will make it lose focus caused by dom structure change. Read more: https://ant.design/components/input/#FAQ"), H.current = z;
    }, [z]);
  }
  const W = wM(M, !0), G = (q) => {
    W(), l == null || l(q);
  }, K = (q) => {
    W(), u == null || u(q);
  }, Y = (q) => {
    W(), b == null || b(q);
  }, X = (F || c) && /* @__PURE__ */ U.createElement(U.Fragment, null, c, F && B), Z = yM(d ?? (A == null ? void 0 : A.allowClear)), [Q, ne] = Ug(w, i);
  return T(/* @__PURE__ */ U.createElement(NU, Object.assign({
    ref: xi(t, M),
    prefixCls: $,
    autoComplete: A == null ? void 0 : A.autoComplete
  }, C, {
    disabled: L,
    onBlur: G,
    onFocus: K,
    style: Object.assign(Object.assign({}, A == null ? void 0 : A.style), g),
    styles: Object.assign(Object.assign({}, A == null ? void 0 : A.styles), m),
    suffix: X,
    allowClear: Z,
    className: se(p, v, E, _, I, A == null ? void 0 : A.className),
    onChange: Y,
    addonAfter: f && /* @__PURE__ */ U.createElement(wd, null, /* @__PURE__ */ U.createElement(Sb, {
      override: !0,
      status: !0
    }, f)),
    addonBefore: h && /* @__PURE__ */ U.createElement(wd, null, /* @__PURE__ */ U.createElement(Sb, {
      override: !0,
      status: !0
    }, h)),
    classNames: Object.assign(Object.assign(Object.assign({}, x), A == null ? void 0 : A.classNames), {
      input: se({
        [`${$}-sm`]: k === "small",
        [`${$}-lg`]: k === "large",
        [`${$}-rtl`]: S === "rtl"
      }, x == null ? void 0 : x.input, (n = A == null ? void 0 : A.classNames) === null || n === void 0 ? void 0 : n.input, D),
      variant: se({
        [`${$}-${Q}`]: ne
      }, $d($, j)),
      affixWrapper: se({
        [`${$}-affix-wrapper-sm`]: k === "small",
        [`${$}-affix-wrapper-lg`]: k === "large",
        [`${$}-affix-wrapper-rtl`]: S === "rtl"
      }, D),
      wrapper: se({
        [`${$}-group-rtl`]: S === "rtl"
      }, D),
      groupWrapper: se({
        [`${$}-group-wrapper-sm`]: k === "small",
        [`${$}-group-wrapper-lg`]: k === "large",
        [`${$}-group-wrapper-rtl`]: S === "rtl",
        [`${$}-group-wrapper-${Q}`]: ne
      }, $d(`${$}-group-wrapper`, j, F), D)
    })
  })));
});
process.env.NODE_ENV !== "production" && (Ef.displayName = "Input");
const zU = (e) => {
  const {
    componentCls: t,
    paddingXS: n
  } = e;
  return {
    [`${t}`]: {
      display: "inline-flex",
      alignItems: "center",
      flexWrap: "nowrap",
      columnGap: n,
      "&-rtl": {
        direction: "rtl"
      },
      [`${t}-input`]: {
        textAlign: "center",
        paddingInline: e.paddingXXS
      },
      // ================= Size =================
      [`&${t}-sm ${t}-input`]: {
        paddingInline: e.calc(e.paddingXXS).div(2).equal()
      },
      [`&${t}-lg ${t}-input`]: {
        paddingInline: e.paddingXS
      }
    }
  };
}, HU = $n(["Input", "OTP"], (e) => {
  const t = Jt(e, TR(e));
  return [zU(t)];
}, RR);
var VU = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const WU = /* @__PURE__ */ O.forwardRef((e, t) => {
  const {
    value: n,
    onChange: r,
    onActiveChange: i,
    index: o
  } = e, s = VU(e, ["value", "onChange", "onActiveChange", "index"]), a = (f) => {
    r(o, f.target.value);
  }, l = O.useRef(null);
  O.useImperativeHandle(t, () => l.current);
  const u = () => {
    rn(() => {
      var f;
      const h = (f = l.current) === null || f === void 0 ? void 0 : f.input;
      document.activeElement === h && h && h.select();
    });
  }, c = (f) => {
    let {
      key: h
    } = f;
    h === "ArrowLeft" ? i(o - 1) : h === "ArrowRight" && i(o + 1), u();
  }, d = (f) => {
    f.key === "Backspace" && !n && i(o - 1), u();
  };
  return /* @__PURE__ */ O.createElement(Ef, Object.assign({}, s, {
    ref: l,
    value: n,
    onInput: a,
    onFocus: u,
    onKeyDown: c,
    onKeyUp: d,
    onMouseDown: u,
    onMouseUp: u
  }));
});
var UU = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
function th(e) {
  return (e || "").split("");
}
const GU = /* @__PURE__ */ O.forwardRef((e, t) => {
  const {
    prefixCls: n,
    length: r = 6,
    size: i,
    defaultValue: o,
    value: s,
    onChange: a,
    formatter: l,
    variant: u,
    disabled: c,
    status: d,
    autoFocus: f
  } = e, h = UU(e, ["prefixCls", "length", "size", "defaultValue", "value", "onChange", "formatter", "variant", "disabled", "status", "autoFocus"]), {
    getPrefixCls: p,
    direction: g
  } = O.useContext(rt), m = p("otp", n), v = $s(h, {
    aria: !0,
    data: !0,
    attr: !0
  }), b = Kn(m), [x, w, C] = HU(m, b), y = so((N) => i ?? N), S = O.useContext(Yr), A = wf(S.status, d), $ = O.useMemo(() => Object.assign(Object.assign({}, S), {
    status: A,
    hasFeedback: !1,
    feedbackIcon: null
  }), [S, A]), M = O.useRef(null), _ = O.useRef({});
  O.useImperativeHandle(t, () => ({
    focus: () => {
      var N;
      (N = _.current[0]) === null || N === void 0 || N.focus();
    },
    blur: () => {
      var N;
      for (let F = 0; F < r; F += 1)
        (N = _.current[F]) === null || N === void 0 || N.blur();
    },
    nativeElement: M.current
  }));
  const T = (N) => l ? l(N) : N, [D, E] = O.useState(th(T(o || "")));
  O.useEffect(() => {
    s !== void 0 && E(th(s));
  }, [s]);
  const R = Nn((N) => {
    E(N), a && N.length === r && N.every((F) => F) && N.some((F, B) => D[B] !== F) && a(N.join(""));
  }), I = Nn((N, F) => {
    let B = _e(D);
    for (let z = 0; z < N; z += 1)
      B[z] || (B[z] = "");
    F.length <= 1 ? B[N] = F : B = B.slice(0, N).concat(th(F)), B = B.slice(0, r);
    for (let z = B.length - 1; z >= 0 && !B[z]; z -= 1)
      B.pop();
    const j = T(B.map((z) => z || " ").join(""));
    return B = th(j).map((z, H) => z === " " && !B[H] ? B[H] : z), B;
  }), k = (N, F) => {
    var B;
    const j = I(N, F), z = Math.min(N + F.length, r - 1);
    z !== N && ((B = _.current[z]) === null || B === void 0 || B.focus()), R(j);
  }, P = (N) => {
    var F;
    (F = _.current[N]) === null || F === void 0 || F.focus();
  }, L = {
    variant: u,
    disabled: c,
    status: A
  };
  return x(/* @__PURE__ */ O.createElement("div", Object.assign({}, v, {
    ref: M,
    className: se(m, {
      [`${m}-sm`]: y === "small",
      [`${m}-lg`]: y === "large",
      [`${m}-rtl`]: g === "rtl"
    }, C, w)
  }), /* @__PURE__ */ O.createElement(Yr.Provider, {
    value: $
  }, new Array(r).fill(0).map((N, F) => {
    const B = `otp-${F}`, j = D[F] || "";
    return /* @__PURE__ */ O.createElement(WU, Object.assign({
      ref: (z) => {
        _.current[F] = z;
      },
      key: B,
      index: F,
      size: y,
      htmlSize: 1,
      className: `${m}-input`,
      onChange: k,
      value: j,
      onActiveChange: P,
      autoFocus: F === 0 && f
    }, L));
  }))));
});
var KU = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { tag: "path", attrs: { d: "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, name: "eye-invisible", theme: "outlined" }, XU = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: KU
  }));
}, CM = /* @__PURE__ */ O.forwardRef(XU);
process.env.NODE_ENV !== "production" && (CM.displayName = "EyeInvisibleOutlined");
var YU = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, name: "eye", theme: "outlined" }, qU = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: YU
  }));
}, SM = /* @__PURE__ */ O.forwardRef(qU);
process.env.NODE_ENV !== "production" && (SM.displayName = "EyeOutlined");
var QU = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const ZU = (e) => e ? /* @__PURE__ */ O.createElement(SM, null) : /* @__PURE__ */ O.createElement(CM, null), JU = {
  click: "onClick",
  hover: "onMouseOver"
}, xM = /* @__PURE__ */ O.forwardRef((e, t) => {
  const {
    visibilityToggle: n = !0
  } = e, r = typeof n == "object" && n.visible !== void 0, [i, o] = ht(() => r ? n.visible : !1), s = he(null);
  O.useEffect(() => {
    r && o(n.visible);
  }, [r, n]);
  const a = wM(s), l = () => {
    const {
      disabled: C
    } = e;
    C || (i && a(), o((y) => {
      var S;
      const A = !y;
      return typeof n == "object" && ((S = n.onVisibleChange) === null || S === void 0 || S.call(n, A)), A;
    }));
  }, u = (C) => {
    const {
      action: y = "click",
      iconRender: S = ZU
    } = e, A = JU[y] || "", $ = S(i), M = {
      [A]: l,
      className: `${C}-icon`,
      key: "passwordIcon",
      onMouseDown: (_) => {
        _.preventDefault();
      },
      onMouseUp: (_) => {
        _.preventDefault();
      }
    };
    return /* @__PURE__ */ O.cloneElement(/* @__PURE__ */ O.isValidElement($) ? $ : /* @__PURE__ */ O.createElement("span", null, $), M);
  }, {
    className: c,
    prefixCls: d,
    inputPrefixCls: f,
    size: h
  } = e, p = QU(e, ["className", "prefixCls", "inputPrefixCls", "size"]), {
    getPrefixCls: g
  } = O.useContext(rt), m = g("input", f), v = g("input-password", d), b = n && u(v), x = se(v, c, {
    [`${v}-${h}`]: !!h
  }), w = Object.assign(Object.assign({}, zn(p, ["suffix", "iconRender", "visibilityToggle"])), {
    type: i ? "text" : "password",
    className: x,
    prefixCls: m,
    suffix: b
  });
  return h && (w.size = h), /* @__PURE__ */ O.createElement(Ef, Object.assign({
    ref: xi(t, s)
  }, w));
});
process.env.NODE_ENV !== "production" && (xM.displayName = "Input.Password");
var eG = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const EM = /* @__PURE__ */ O.forwardRef((e, t) => {
  const {
    prefixCls: n,
    inputPrefixCls: r,
    className: i,
    size: o,
    suffix: s,
    enterButton: a = !1,
    addonAfter: l,
    loading: u,
    disabled: c,
    onSearch: d,
    onChange: f,
    onCompositionStart: h,
    onCompositionEnd: p
  } = e, g = eG(e, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]), {
    getPrefixCls: m,
    direction: v
  } = O.useContext(rt), b = O.useRef(!1), x = m("input-search", n), w = m("input", r), {
    compactSize: C
  } = Jc(x, v), y = so((N) => {
    var F;
    return (F = o ?? C) !== null && F !== void 0 ? F : N;
  }), S = O.useRef(null), A = (N) => {
    N && N.target && N.type === "click" && d && d(N.target.value, N, {
      source: "clear"
    }), f && f(N);
  }, $ = (N) => {
    var F;
    document.activeElement === ((F = S.current) === null || F === void 0 ? void 0 : F.input) && N.preventDefault();
  }, M = (N) => {
    var F, B;
    d && d((B = (F = S.current) === null || F === void 0 ? void 0 : F.input) === null || B === void 0 ? void 0 : B.value, N, {
      source: "input"
    });
  }, _ = (N) => {
    b.current || u || M(N);
  }, T = typeof a == "boolean" ? /* @__PURE__ */ O.createElement(h1, null) : null, D = `${x}-button`;
  let E;
  const R = a || {}, I = R.type && R.type.__ANT_BUTTON === !0;
  I || R.type === "button" ? E = oi(R, Object.assign({
    onMouseDown: $,
    onClick: (N) => {
      var F, B;
      (B = (F = R == null ? void 0 : R.props) === null || F === void 0 ? void 0 : F.onClick) === null || B === void 0 || B.call(F, N), M(N);
    },
    key: "enterButton"
  }, I ? {
    className: D,
    size: y
  } : {})) : E = /* @__PURE__ */ O.createElement(Ut, {
    className: D,
    type: a ? "primary" : void 0,
    size: y,
    disabled: c,
    key: "enterButton",
    onMouseDown: $,
    onClick: M,
    loading: u,
    icon: T
  }, a), l && (E = [E, oi(l, {
    key: "addonAfter"
  })]);
  const k = se(x, {
    [`${x}-rtl`]: v === "rtl",
    [`${x}-${y}`]: !!y,
    [`${x}-with-button`]: !!a
  }, i), P = (N) => {
    b.current = !0, h == null || h(N);
  }, L = (N) => {
    b.current = !1, p == null || p(N);
  };
  return /* @__PURE__ */ O.createElement(Ef, Object.assign({
    ref: xi(S, t),
    onPressEnter: _
  }, g, {
    size: y,
    onCompositionStart: P,
    onCompositionEnd: L,
    prefixCls: w,
    addonAfter: E,
    suffix: s,
    onChange: A,
    className: k,
    disabled: c
  }));
});
process.env.NODE_ENV !== "production" && (EM.displayName = "Search");
var tG = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`, nG = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"], fv = {}, Ki;
function rG(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = e.getAttribute("id") || e.getAttribute("data-reactid") || e.getAttribute("name");
  if (t && fv[n])
    return fv[n];
  var r = window.getComputedStyle(e), i = r.getPropertyValue("box-sizing") || r.getPropertyValue("-moz-box-sizing") || r.getPropertyValue("-webkit-box-sizing"), o = parseFloat(r.getPropertyValue("padding-bottom")) + parseFloat(r.getPropertyValue("padding-top")), s = parseFloat(r.getPropertyValue("border-bottom-width")) + parseFloat(r.getPropertyValue("border-top-width")), a = nG.map(function(u) {
    return "".concat(u, ":").concat(r.getPropertyValue(u));
  }).join(";"), l = {
    sizingStyle: a,
    paddingSize: o,
    borderSize: s,
    boxSizing: i
  };
  return t && n && (fv[n] = l), l;
}
function iG(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  Ki || (Ki = document.createElement("textarea"), Ki.setAttribute("tab-index", "-1"), Ki.setAttribute("aria-hidden", "true"), document.body.appendChild(Ki)), e.getAttribute("wrap") ? Ki.setAttribute("wrap", e.getAttribute("wrap")) : Ki.removeAttribute("wrap");
  var i = rG(e, t), o = i.paddingSize, s = i.borderSize, a = i.boxSizing, l = i.sizingStyle;
  Ki.setAttribute("style", "".concat(l, ";").concat(tG)), Ki.value = e.value || e.placeholder || "";
  var u = void 0, c = void 0, d, f = Ki.scrollHeight;
  if (a === "border-box" ? f += s : a === "content-box" && (f -= o), n !== null || r !== null) {
    Ki.value = " ";
    var h = Ki.scrollHeight - o;
    n !== null && (u = h * n, a === "border-box" && (u = u + o + s), f = Math.max(u, f)), r !== null && (c = h * r, a === "border-box" && (c = c + o + s), d = f > c ? "" : "hidden", f = Math.min(c, f));
  }
  var p = {
    height: f,
    overflowY: d,
    resize: "none"
  };
  return u && (p.minHeight = u), c && (p.maxHeight = c), p;
}
var oG = ["prefixCls", "onPressEnter", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"], hv = 0, pv = 1, gv = 2, sG = /* @__PURE__ */ O.forwardRef(function(e, t) {
  var n = e, r = n.prefixCls;
  n.onPressEnter;
  var i = n.defaultValue, o = n.value, s = n.autoSize, a = n.onResize, l = n.className, u = n.style, c = n.disabled, d = n.onChange, f = n.onInternalAutoSize, h = Rt(n, oG), p = Un(i, {
    value: o,
    postState: function(H) {
      return H ?? "";
    }
  }), g = ae(p, 2), m = g[0], v = g[1], b = function(H) {
    v(H.target.value), d == null || d(H);
  }, x = O.useRef();
  O.useImperativeHandle(t, function() {
    return {
      textArea: x.current
    };
  });
  var w = O.useMemo(function() {
    return s && wt(s) === "object" ? [s.minRows, s.maxRows] : [];
  }, [s]), C = ae(w, 2), y = C[0], S = C[1], A = !!s, $ = function() {
    try {
      if (document.activeElement === x.current) {
        var H = x.current, W = H.selectionStart, G = H.selectionEnd, K = H.scrollTop;
        x.current.setSelectionRange(W, G), x.current.scrollTop = K;
      }
    } catch {
    }
  }, M = O.useState(gv), _ = ae(M, 2), T = _[0], D = _[1], E = O.useState(), R = ae(E, 2), I = R[0], k = R[1], P = function() {
    D(hv), process.env.NODE_ENV === "test" && (f == null || f());
  };
  sn(function() {
    A && P();
  }, [o, y, S, A]), sn(function() {
    if (T === hv)
      D(pv);
    else if (T === pv) {
      var z = iG(x.current, !1, y, S);
      D(gv), k(z);
    } else
      $();
  }, [T]);
  var L = O.useRef(), N = function() {
    rn.cancel(L.current);
  }, F = function(H) {
    T === gv && (a == null || a(H), s && (N(), L.current = rn(function() {
      P();
    })));
  };
  O.useEffect(function() {
    return N;
  }, []);
  var B = A ? I : null, j = ie(ie({}, u), B);
  return (T === hv || T === pv) && (j.overflowY = "hidden", j.overflowX = "hidden"), /* @__PURE__ */ O.createElement(Ci, {
    onResize: F,
    disabled: !(s || a)
  }, /* @__PURE__ */ O.createElement("textarea", we({}, h, {
    ref: x,
    style: j,
    className: se(r, l, re({}, "".concat(r, "-disabled"), c)),
    disabled: c,
    value: m,
    onChange: b
  })));
}), aG = ["defaultValue", "value", "onFocus", "onBlur", "onChange", "allowClear", "maxLength", "onCompositionStart", "onCompositionEnd", "suffix", "prefixCls", "showCount", "count", "className", "style", "disabled", "hidden", "classNames", "styles", "onResize"], lG = /* @__PURE__ */ U.forwardRef(function(e, t) {
  var n, r, i = e.defaultValue, o = e.value, s = e.onFocus, a = e.onBlur, l = e.onChange, u = e.allowClear, c = e.maxLength, d = e.onCompositionStart, f = e.onCompositionEnd, h = e.suffix, p = e.prefixCls, g = p === void 0 ? "rc-textarea" : p, m = e.showCount, v = e.count, b = e.className, x = e.style, w = e.disabled, C = e.hidden, y = e.classNames, S = e.styles, A = e.onResize, $ = Rt(e, aG), M = Un(i, {
    value: o,
    defaultValue: i
  }), _ = ae(M, 2), T = _[0], D = _[1], E = T == null ? "" : String(T), R = U.useState(!1), I = ae(R, 2), k = I[0], P = I[1], L = U.useRef(!1), N = U.useState(null), F = ae(N, 2), B = F[0], j = F[1], z = he(null), H = function() {
    var ve;
    return (ve = z.current) === null || ve === void 0 ? void 0 : ve.textArea;
  }, W = function() {
    H().focus();
  };
  fl(t, function() {
    return {
      resizableTextArea: z.current,
      focus: W,
      blur: function() {
        H().blur();
      }
    };
  }), Pe(function() {
    P(function(ge) {
      return !w && ge;
    });
  }, [w]);
  var G = U.useState(null), K = ae(G, 2), Y = K[0], X = K[1];
  U.useEffect(function() {
    if (Y) {
      var ge;
      (ge = H()).setSelectionRange.apply(ge, _e(Y));
    }
  }, [Y]);
  var Z = bM(v, m), Q = (n = Z.max) !== null && n !== void 0 ? n : c, ne = Number(Q) > 0, q = Z.strategy(E), te = !!Q && q > Q, fe = function(ve, me) {
    var Fe = me;
    !L.current && Z.exceedFormatter && Z.max && Z.strategy(me) > Z.max && (Fe = Z.exceedFormatter(me, {
      max: Z.max
    }), me !== Fe && X([H().selectionStart || 0, H().selectionEnd || 0])), D(Fe), Bp(ve.currentTarget, ve, l, Fe);
  }, Se = function(ve) {
    L.current = !0, d == null || d(ve);
  }, de = function(ve) {
    L.current = !1, fe(ve, ve.currentTarget.value), f == null || f(ve);
  }, ce = function(ve) {
    fe(ve, ve.target.value);
  }, pe = function(ve) {
    var me = $.onPressEnter, Fe = $.onKeyDown;
    ve.key === "Enter" && me && me(ve), Fe == null || Fe(ve);
  }, Oe = function(ve) {
    P(!0), s == null || s(ve);
  }, Re = function(ve) {
    P(!1), a == null || a(ve);
  }, De = function(ve) {
    D(""), W(), Bp(H(), ve, l);
  }, Me = h, Ue;
  Z.show && (Z.showFormatter ? Ue = Z.showFormatter({
    value: E,
    count: q,
    maxLength: Q
  }) : Ue = "".concat(q).concat(ne ? " / ".concat(Q) : ""), Me = /* @__PURE__ */ U.createElement(U.Fragment, null, Me, /* @__PURE__ */ U.createElement("span", {
    className: se("".concat(g, "-data-count"), y == null ? void 0 : y.count),
    style: S == null ? void 0 : S.count
  }, Ue)));
  var oe = function(ve) {
    var me;
    A == null || A(ve), (me = H()) !== null && me !== void 0 && me.style.height && j(!0);
  }, Ce = !$.autoSize && !m && !u;
  return /* @__PURE__ */ U.createElement(vM, {
    value: E,
    allowClear: u,
    handleReset: De,
    suffix: Me,
    prefixCls: g,
    classNames: ie(ie({}, y), {}, {
      affixWrapper: se(y == null ? void 0 : y.affixWrapper, (r = {}, re(r, "".concat(g, "-show-count"), m), re(r, "".concat(g, "-textarea-allow-clear"), u), r))
    }),
    disabled: w,
    focused: k,
    className: se(b, te && "".concat(g, "-out-of-range")),
    style: ie(ie({}, x), B && !Ce ? {
      height: "auto"
    } : {}),
    dataAttrs: {
      affixWrapper: {
        "data-count": typeof Ue == "string" ? Ue : void 0
      }
    },
    hidden: C
  }, /* @__PURE__ */ U.createElement(sG, we({}, $, {
    maxLength: c,
    onKeyDown: pe,
    onChange: ce,
    onFocus: Oe,
    onBlur: Re,
    onCompositionStart: Se,
    onCompositionEnd: de,
    className: se(y == null ? void 0 : y.textarea),
    style: ie(ie({}, S == null ? void 0 : S.textarea), {}, {
      resize: x == null ? void 0 : x.resize
    }),
    disabled: w,
    prefixCls: g,
    onResize: oe,
    ref: z
  })));
}), cG = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const $M = /* @__PURE__ */ li((e, t) => {
  var n, r;
  const {
    prefixCls: i,
    bordered: o = !0,
    size: s,
    disabled: a,
    status: l,
    allowClear: u,
    classNames: c,
    rootClassName: d,
    className: f,
    style: h,
    styles: p,
    variant: g
  } = e, m = cG(e, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear", "classNames", "rootClassName", "className", "style", "styles", "variant"]);
  if (process.env.NODE_ENV !== "production") {
    const {
      deprecated: N
    } = Zt("TextArea");
    N(!("bordered" in e), "bordered", "variant");
  }
  const {
    getPrefixCls: v,
    direction: b,
    textArea: x
  } = O.useContext(rt), w = so(s), C = O.useContext(Ko), y = a ?? C, {
    status: S,
    hasFeedback: A,
    feedbackIcon: $
  } = O.useContext(Yr), M = wf(S, l), _ = O.useRef(null);
  O.useImperativeHandle(t, () => {
    var N;
    return {
      resizableTextArea: (N = _.current) === null || N === void 0 ? void 0 : N.resizableTextArea,
      focus: (F) => {
        var B, j;
        jU((j = (B = _.current) === null || B === void 0 ? void 0 : B.resizableTextArea) === null || j === void 0 ? void 0 : j.textArea, F);
      },
      blur: () => {
        var F;
        return (F = _.current) === null || F === void 0 ? void 0 : F.blur();
      }
    };
  });
  const T = v("input", i), D = Kn(T), [E, R, I] = O1(T, D), [k, P] = Ug(g, o), L = yM(u ?? (x == null ? void 0 : x.allowClear));
  return E(/* @__PURE__ */ O.createElement(lG, Object.assign({
    autoComplete: x == null ? void 0 : x.autoComplete
  }, m, {
    style: Object.assign(Object.assign({}, x == null ? void 0 : x.style), h),
    styles: Object.assign(Object.assign({}, x == null ? void 0 : x.styles), p),
    disabled: y,
    allowClear: L,
    className: se(I, D, f, d, x == null ? void 0 : x.className),
    classNames: Object.assign(Object.assign(Object.assign({}, c), x == null ? void 0 : x.classNames), {
      textarea: se({
        [`${T}-sm`]: w === "small",
        [`${T}-lg`]: w === "large"
      }, R, c == null ? void 0 : c.textarea, (n = x == null ? void 0 : x.classNames) === null || n === void 0 ? void 0 : n.textarea),
      variant: se({
        [`${T}-${k}`]: P
      }, $d(T, M)),
      affixWrapper: se(`${T}-textarea-affix-wrapper`, {
        [`${T}-affix-wrapper-rtl`]: b === "rtl",
        [`${T}-affix-wrapper-sm`]: w === "small",
        [`${T}-affix-wrapper-lg`]: w === "large",
        [`${T}-textarea-show-count`]: e.showCount || ((r = e.count) === null || r === void 0 ? void 0 : r.show)
      }, R)
    }),
    prefixCls: T,
    suffix: A && /* @__PURE__ */ O.createElement("span", {
      className: `${T}-textarea-suffix`
    }, $),
    ref: _
  })));
}), $o = Ef;
$o.Group = LU;
$o.Search = EM;
$o.TextArea = $M;
$o.Password = xM;
$o.OTP = GU;
function FE(e) {
  return ["small", "middle", "large"].includes(e);
}
function BE(e) {
  return e ? typeof e == "number" && !Number.isNaN(e) : !1;
}
const OM = /* @__PURE__ */ U.createContext({
  latestIndex: 0
}), uG = OM.Provider, dG = (e) => {
  let {
    className: t,
    index: n,
    children: r,
    split: i,
    style: o
  } = e;
  const {
    latestIndex: s
  } = O.useContext(OM);
  return r == null ? null : /* @__PURE__ */ O.createElement(O.Fragment, null, /* @__PURE__ */ O.createElement("div", {
    className: t,
    style: o
  }, r), n < s && i && /* @__PURE__ */ O.createElement("span", {
    className: `${t}-split`
  }, i));
};
var fG = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const hG = /* @__PURE__ */ O.forwardRef((e, t) => {
  var n, r;
  const {
    getPrefixCls: i,
    space: o,
    direction: s
  } = O.useContext(rt), {
    size: a = (o == null ? void 0 : o.size) || "small",
    align: l,
    className: u,
    rootClassName: c,
    children: d,
    direction: f = "horizontal",
    prefixCls: h,
    split: p,
    style: g,
    wrap: m = !1,
    classNames: v,
    styles: b
  } = e, x = fG(e, ["size", "align", "className", "rootClassName", "children", "direction", "prefixCls", "split", "style", "wrap", "classNames", "styles"]), [w, C] = Array.isArray(a) ? a : [a, a], y = FE(C), S = FE(w), A = BE(C), $ = BE(w), M = Xr(d, {
    keepEmpty: !0
  }), _ = l === void 0 && f === "horizontal" ? "center" : l, T = i("space", h), [D, E, R] = M_(T), I = se(T, o == null ? void 0 : o.className, E, `${T}-${f}`, {
    [`${T}-rtl`]: s === "rtl",
    [`${T}-align-${_}`]: _,
    [`${T}-gap-row-${C}`]: y,
    [`${T}-gap-col-${w}`]: S
  }, u, c, R), k = se(`${T}-item`, (n = v == null ? void 0 : v.item) !== null && n !== void 0 ? n : (r = o == null ? void 0 : o.classNames) === null || r === void 0 ? void 0 : r.item);
  let P = 0;
  const L = M.map((B, j) => {
    var z, H;
    B != null && (P = j);
    const W = B && B.key || `${k}-${j}`;
    return /* @__PURE__ */ O.createElement(dG, {
      className: k,
      key: W,
      index: j,
      split: p,
      style: (z = b == null ? void 0 : b.item) !== null && z !== void 0 ? z : (H = o == null ? void 0 : o.styles) === null || H === void 0 ? void 0 : H.item
    }, B);
  }), N = O.useMemo(() => ({
    latestIndex: P
  }), [P]);
  if (M.length === 0)
    return null;
  const F = {};
  return m && (F.flexWrap = "wrap"), !S && $ && (F.columnGap = w), !y && A && (F.rowGap = C), D(/* @__PURE__ */ O.createElement("div", Object.assign({
    ref: t,
    className: I,
    style: Object.assign(Object.assign(Object.assign({}, F), o == null ? void 0 : o.style), g)
  }, x), /* @__PURE__ */ O.createElement(uG, {
    value: N
  }, L)));
}), M1 = hG;
M1.Compact = XB;
process.env.NODE_ENV !== "production" && (M1.displayName = "Space");
var pG = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const AM = (e) => {
  const {
    getPopupContainer: t,
    getPrefixCls: n,
    direction: r
  } = O.useContext(rt), {
    prefixCls: i,
    type: o = "default",
    danger: s,
    disabled: a,
    loading: l,
    onClick: u,
    htmlType: c,
    children: d,
    className: f,
    menu: h,
    arrow: p,
    autoFocus: g,
    overlay: m,
    trigger: v,
    align: b,
    open: x,
    onOpenChange: w,
    placement: C,
    getPopupContainer: y,
    href: S,
    icon: A = /* @__PURE__ */ O.createElement(Qg, null),
    title: $,
    buttonsRender: M = (K) => K,
    mouseEnterDelay: _,
    mouseLeaveDelay: T,
    overlayClassName: D,
    overlayStyle: E,
    destroyPopupOnHide: R,
    dropdownRender: I
  } = e, k = pG(e, ["prefixCls", "type", "danger", "disabled", "loading", "onClick", "htmlType", "children", "className", "menu", "arrow", "autoFocus", "overlay", "trigger", "align", "open", "onOpenChange", "placement", "getPopupContainer", "href", "icon", "title", "buttonsRender", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyPopupOnHide", "dropdownRender"]), P = n("dropdown", i), L = `${P}-button`, N = {
    menu: h,
    arrow: p,
    autoFocus: g,
    align: b,
    disabled: a,
    trigger: a ? [] : v,
    onOpenChange: w,
    getPopupContainer: y || t,
    mouseEnterDelay: _,
    mouseLeaveDelay: T,
    overlayClassName: D,
    overlayStyle: E,
    destroyPopupOnHide: R,
    dropdownRender: I
  }, {
    compactSize: F,
    compactItemClassnames: B
  } = Jc(P, r), j = se(L, B, f);
  "overlay" in e && (N.overlay = m), "open" in e && (N.open = x), "placement" in e ? N.placement = C : N.placement = r === "rtl" ? "bottomLeft" : "bottomRight";
  const z = /* @__PURE__ */ O.createElement(Ut, {
    type: o,
    danger: s,
    disabled: a,
    loading: l,
    onClick: u,
    htmlType: c,
    href: S,
    title: $
  }, d), H = /* @__PURE__ */ O.createElement(Ut, {
    type: o,
    danger: s,
    icon: A
  }), [W, G] = M([z, H]);
  return /* @__PURE__ */ O.createElement(M1.Compact, Object.assign({
    className: j,
    size: F,
    block: !0
  }, k), W, /* @__PURE__ */ O.createElement(xf, Object.assign({}, N), G));
};
AM.__ANT_BUTTON = !0;
const da = xf;
da.Button = AM;
function jp(e) {
  const [t, n] = O.useState(e);
  return O.useEffect(() => {
    const r = setTimeout(() => {
      n(e);
    }, e.length ? 0 : 10);
    return () => {
      clearTimeout(r);
    };
  }, [e]), t;
}
const gG = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-show-help`, r = `${t}-show-help-item`;
  return {
    [n]: {
      // Explain holder
      transition: `opacity ${e.motionDurationSlow} ${e.motionEaseInOut}`,
      "&-appear, &-enter": {
        opacity: 0,
        "&-active": {
          opacity: 1
        }
      },
      "&-leave": {
        opacity: 1,
        "&-active": {
          opacity: 0
        }
      },
      // Explain
      [r]: {
        overflow: "hidden",
        transition: `height ${e.motionDurationSlow} ${e.motionEaseInOut},
                     opacity ${e.motionDurationSlow} ${e.motionEaseInOut},
                     transform ${e.motionDurationSlow} ${e.motionEaseInOut} !important`,
        [`&${r}-appear, &${r}-enter`]: {
          transform: "translateY(-5px)",
          opacity: 0,
          "&-active": {
            transform: "translateY(0)",
            opacity: 1
          }
        },
        [`&${r}-leave-active`]: {
          transform: "translateY(-5px)"
        }
      }
    }
  };
}, mG = (e) => ({
  legend: {
    display: "block",
    width: "100%",
    marginBottom: e.marginLG,
    padding: 0,
    color: e.colorTextDescription,
    fontSize: e.fontSizeLG,
    lineHeight: "inherit",
    border: 0,
    borderBottom: `${le(e.lineWidth)} ${e.lineType} ${e.colorBorder}`
  },
  'input[type="search"]': {
    boxSizing: "border-box"
  },
  // Position radios and checkboxes better
  'input[type="radio"], input[type="checkbox"]': {
    lineHeight: "normal"
  },
  'input[type="file"]': {
    display: "block"
  },
  // Make range inputs behave like textual form controls
  'input[type="range"]': {
    display: "block",
    width: "100%"
  },
  // Make multiple select elements height not fixed
  "select[multiple], select[size]": {
    height: "auto"
  },
  // Focus for file, radio, and checkbox
  "input[type='file']:focus,\n  input[type='radio']:focus,\n  input[type='checkbox']:focus": {
    outline: 0,
    boxShadow: `0 0 0 ${le(e.controlOutlineWidth)} ${e.controlOutline}`
  },
  // Adjust output element
  output: {
    display: "block",
    paddingTop: 15,
    color: e.colorText,
    fontSize: e.fontSize,
    lineHeight: e.lineHeight
  }
}), jE = (e, t) => {
  const {
    formItemCls: n
  } = e;
  return {
    [n]: {
      [`${n}-label > label`]: {
        height: t
      },
      [`${n}-control-input`]: {
        minHeight: t
      }
    }
  };
}, vG = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [e.componentCls]: Object.assign(Object.assign(Object.assign({}, Gn(e)), mG(e)), {
      [`${t}-text`]: {
        display: "inline-block",
        paddingInlineEnd: e.paddingSM
      },
      // ================================================================
      // =                             Size                             =
      // ================================================================
      "&-small": Object.assign({}, jE(e, e.controlHeightSM)),
      "&-large": Object.assign({}, jE(e, e.controlHeightLG))
    })
  };
}, bG = (e) => {
  const {
    formItemCls: t,
    iconCls: n,
    componentCls: r,
    rootPrefixCls: i,
    labelRequiredMarkColor: o,
    labelColor: s,
    labelFontSize: a,
    labelHeight: l,
    labelColonMarginInlineStart: u,
    labelColonMarginInlineEnd: c,
    itemMarginBottom: d
  } = e;
  return {
    [t]: Object.assign(Object.assign({}, Gn(e)), {
      marginBottom: d,
      verticalAlign: "top",
      "&-with-help": {
        transition: "none"
      },
      [`&-hidden,
        &-hidden.${i}-row`]: {
        // https://github.com/ant-design/ant-design/issues/26141
        display: "none"
      },
      "&-has-warning": {
        [`${t}-split`]: {
          color: e.colorError
        }
      },
      "&-has-error": {
        [`${t}-split`]: {
          color: e.colorWarning
        }
      },
      // ==============================================================
      // =                            Label                           =
      // ==============================================================
      [`${t}-label`]: {
        flexGrow: 0,
        overflow: "hidden",
        whiteSpace: "nowrap",
        textAlign: "end",
        verticalAlign: "middle",
        "&-left": {
          textAlign: "start"
        },
        "&-wrap": {
          overflow: "unset",
          lineHeight: e.lineHeight,
          whiteSpace: "unset"
        },
        "> label": {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          maxWidth: "100%",
          height: l,
          color: s,
          fontSize: a,
          [`> ${n}`]: {
            fontSize: e.fontSize,
            verticalAlign: "top"
          },
          // Required mark
          [`&${t}-required:not(${t}-required-mark-optional)::before`]: {
            display: "inline-block",
            marginInlineEnd: e.marginXXS,
            color: o,
            fontSize: e.fontSize,
            fontFamily: "SimSun, sans-serif",
            lineHeight: 1,
            content: '"*"',
            [`${r}-hide-required-mark &`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${t}-optional`]: {
            display: "inline-block",
            marginInlineStart: e.marginXXS,
            color: e.colorTextDescription,
            [`${r}-hide-required-mark &`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${t}-tooltip`]: {
            color: e.colorTextDescription,
            cursor: "help",
            writingMode: "horizontal-tb",
            marginInlineStart: e.marginXXS
          },
          "&::after": {
            content: '":"',
            position: "relative",
            marginBlock: 0,
            marginInlineStart: u,
            marginInlineEnd: c
          },
          [`&${t}-no-colon::after`]: {
            content: '"\\a0"'
          }
        }
      },
      // ==============================================================
      // =                            Input                           =
      // ==============================================================
      [`${t}-control`]: {
        "--ant-display": "flex",
        flexDirection: "column",
        flexGrow: 1,
        [`&:first-child:not([class^="'${i}-col-'"]):not([class*="' ${i}-col-'"])`]: {
          width: "100%"
        },
        "&-input": {
          position: "relative",
          display: "flex",
          alignItems: "center",
          minHeight: e.controlHeight,
          "&-content": {
            flex: "auto",
            maxWidth: "100%"
          }
        }
      },
      // ==============================================================
      // =                           Explain                          =
      // ==============================================================
      [t]: {
        "&-explain, &-extra": {
          clear: "both",
          color: e.colorTextDescription,
          fontSize: e.fontSize,
          lineHeight: e.lineHeight
        },
        "&-explain-connected": {
          width: "100%"
        },
        "&-extra": {
          minHeight: e.controlHeightSM,
          transition: `color ${e.motionDurationMid} ${e.motionEaseOut}`
          // sync input color transition
        },
        "&-explain": {
          "&-error": {
            color: e.colorError
          },
          "&-warning": {
            color: e.colorWarning
          }
        }
      },
      [`&-with-help ${t}-explain`]: {
        height: "auto",
        opacity: 1
      },
      // ==============================================================
      // =                        Feedback Icon                       =
      // ==============================================================
      [`${t}-feedback-icon`]: {
        fontSize: e.fontSize,
        textAlign: "center",
        visibility: "visible",
        animationName: Zw,
        animationDuration: e.motionDurationMid,
        animationTimingFunction: e.motionEaseOutBack,
        pointerEvents: "none",
        "&-success": {
          color: e.colorSuccess
        },
        "&-error": {
          color: e.colorError
        },
        "&-warning": {
          color: e.colorWarning
        },
        "&-validating": {
          color: e.colorPrimary
        }
      }
    })
  };
}, yG = (e) => {
  const {
    componentCls: t,
    formItemCls: n
  } = e;
  return {
    [`${t}-horizontal`]: {
      [`${n}-label`]: {
        flexGrow: 0
      },
      [`${n}-control`]: {
        flex: "1 1 0",
        // https://github.com/ant-design/ant-design/issues/32777
        // https://github.com/ant-design/ant-design/issues/33773
        minWidth: 0
      },
      // Do not change this to `ant-col-24`! `-24` match all the responsive rules
      // https://github.com/ant-design/ant-design/issues/32980
      // https://github.com/ant-design/ant-design/issues/34903
      // https://github.com/ant-design/ant-design/issues/44538
      [`${n}-label[class$='-24'], ${n}-label[class*='-24 ']`]: {
        [`& + ${n}-control`]: {
          minWidth: "unset"
        }
      }
    }
  };
}, wG = (e) => {
  const {
    componentCls: t,
    formItemCls: n
  } = e;
  return {
    [`${t}-inline`]: {
      display: "flex",
      flexWrap: "wrap",
      [n]: {
        flex: "none",
        marginInlineEnd: e.margin,
        marginBottom: 0,
        "&-row": {
          flexWrap: "nowrap"
        },
        [`> ${n}-label,
        > ${n}-control`]: {
          display: "inline-block",
          verticalAlign: "top"
        },
        [`> ${n}-label`]: {
          flex: "none"
        },
        [`${t}-text`]: {
          display: "inline-block"
        },
        [`${n}-has-feedback`]: {
          display: "inline-block"
        }
      }
    }
  };
}, ec = (e) => ({
  padding: e.verticalLabelPadding,
  margin: e.verticalLabelMargin,
  whiteSpace: "initial",
  textAlign: "start",
  "> label": {
    margin: 0,
    "&::after": {
      // https://github.com/ant-design/ant-design/issues/43538
      visibility: "hidden"
    }
  }
}), CG = (e) => {
  const {
    componentCls: t,
    formItemCls: n,
    rootPrefixCls: r
  } = e;
  return {
    [`${n} ${n}-label`]: ec(e),
    // ref: https://github.com/ant-design/ant-design/issues/45122
    [`${t}:not(${t}-inline)`]: {
      [n]: {
        flexWrap: "wrap",
        [`${n}-label, ${n}-control`]: {
          // When developer pass `xs: { span }`,
          // It should follow the `xs` screen config
          // ref: https://github.com/ant-design/ant-design/issues/44386
          [`&:not([class*=" ${r}-col-xs"])`]: {
            flex: "0 0 100%",
            maxWidth: "100%"
          }
        }
      }
    }
  };
}, SG = (e) => {
  const {
    componentCls: t,
    formItemCls: n,
    rootPrefixCls: r
  } = e;
  return {
    [`${t}-vertical`]: {
      [n]: {
        "&-row": {
          flexDirection: "column"
        },
        "&-label > label": {
          height: "auto"
        },
        [`${t}-item-control`]: {
          width: "100%"
        }
      }
    },
    [`${t}-vertical ${n}-label,
      .${r}-col-24${n}-label,
      .${r}-col-xl-24${n}-label`]: ec(e),
    [`@media (max-width: ${le(e.screenXSMax)})`]: [CG(e), {
      [t]: {
        [`.${r}-col-xs-24${n}-label`]: ec(e)
      }
    }],
    [`@media (max-width: ${le(e.screenSMMax)})`]: {
      [t]: {
        [`.${r}-col-sm-24${n}-label`]: ec(e)
      }
    },
    [`@media (max-width: ${le(e.screenMDMax)})`]: {
      [t]: {
        [`.${r}-col-md-24${n}-label`]: ec(e)
      }
    },
    [`@media (max-width: ${le(e.screenLGMax)})`]: {
      [t]: {
        [`.${r}-col-lg-24${n}-label`]: ec(e)
      }
    }
  };
}, xG = (e) => ({
  labelRequiredMarkColor: e.colorError,
  labelColor: e.colorTextHeading,
  labelFontSize: e.fontSize,
  labelHeight: e.controlHeight,
  labelColonMarginInlineStart: e.marginXXS / 2,
  labelColonMarginInlineEnd: e.marginXS,
  itemMarginBottom: e.marginLG,
  verticalLabelPadding: `0 0 ${e.paddingXS}px`,
  verticalLabelMargin: 0
}), DM = (e, t) => Jt(e, {
  formItemCls: `${e.componentCls}-item`,
  rootPrefixCls: t
}), I1 = $n("Form", (e, t) => {
  let {
    rootPrefixCls: n
  } = t;
  const r = DM(e, n);
  return [vG(r), bG(r), gG(r), yG(r), wG(r), SG(r), sT(r), Zw];
}, xG, {
  // Let From style before the Grid
  // ref https://github.com/ant-design/ant-design/issues/44386
  order: -1e3
}), zE = [];
function mv(e, t, n) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
  return {
    key: typeof e == "string" ? e : `${t}-${r}`,
    error: e,
    errorStatus: n
  };
}
const _M = (e) => {
  let {
    help: t,
    helpStatus: n,
    errors: r = zE,
    warnings: i = zE,
    className: o,
    fieldId: s,
    onVisibleChanged: a
  } = e;
  const {
    prefixCls: l
  } = O.useContext(Kw), u = `${l}-item-explain`, c = Kn(l), [d, f, h] = I1(l, c), p = mt(() => cb(l), [l]), g = jp(r), m = jp(i), v = O.useMemo(() => t != null ? [mv(t, "help", n)] : [].concat(_e(g.map((x, w) => mv(x, "error", "error", w))), _e(m.map((x, w) => mv(x, "warning", "warning", w)))), [t, n, g, m]), b = {};
  return s && (b.id = `${s}_help`), d(/* @__PURE__ */ O.createElement(qo, {
    motionDeadline: p.motionDeadline,
    motionName: `${l}-show-help`,
    visible: !!v.length,
    onVisibleChanged: a
  }, (x) => {
    const {
      className: w,
      style: C
    } = x;
    return /* @__PURE__ */ O.createElement("div", Object.assign({}, b, {
      className: se(u, w, h, c, o, f),
      style: C,
      role: "alert"
    }), /* @__PURE__ */ O.createElement(f_, Object.assign({
      keys: v
    }, cb(l), {
      motionName: `${l}-show-help-item`,
      component: !1
    }), (y) => {
      const {
        key: S,
        error: A,
        errorStatus: $,
        className: M,
        style: _
      } = y;
      return /* @__PURE__ */ O.createElement("div", {
        key: S,
        className: se(M, {
          [`${u}-${$}`]: $
        }),
        style: _
      }, A);
    }));
  }));
}, EG = ["parentNode"], $G = "form_item";
function td(e) {
  return e === void 0 || e === !1 ? [] : Array.isArray(e) ? e : [e];
}
function TM(e, t) {
  if (!e.length)
    return;
  const n = e.join("_");
  return t ? `${t}_${n}` : EG.includes(n) ? `${$G}_${n}` : n;
}
function RM(e, t, n, r, i, o) {
  let s = r;
  return o !== void 0 ? s = o : n.validating ? s = "validating" : e.length ? s = "error" : t.length ? s = "warning" : (n.touched || i && n.validated) && (s = "success"), s;
}
function HE(e) {
  return td(e).join("_");
}
function MM(e) {
  const [t] = Gw(), n = O.useRef({}), r = O.useMemo(() => e ?? Object.assign(Object.assign({}, t), {
    __INTERNAL__: {
      itemRef: (i) => (o) => {
        const s = HE(i);
        o ? n.current[s] = o : delete n.current[s];
      }
    },
    scrollToField: function(i) {
      let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const s = td(i), a = TM(s, r.__INTERNAL__.name), l = a ? document.getElementById(a) : null;
      l && rB(l, Object.assign({
        scrollMode: "if-needed",
        block: "nearest"
      }, o));
    },
    getFieldInstance: (i) => {
      const o = HE(i);
      return n.current[o];
    }
  }), [e, t]);
  return [r];
}
const nh = {};
function OG(e) {
  let {
    name: t
  } = e;
  const n = Zt("Form");
  Pe(() => {
    if (t)
      return nh[t] = (nh[t] || 0) + 1, process.env.NODE_ENV !== "production" && n(nh[t] <= 1, "usage", "There exist multiple Form with same `name`."), () => {
        nh[t] -= 1;
      };
  }, [t]);
}
var AG = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const DG = (e, t) => {
  const n = O.useContext(Ko), {
    getPrefixCls: r,
    direction: i,
    form: o
  } = O.useContext(rt), {
    prefixCls: s,
    className: a,
    rootClassName: l,
    size: u,
    disabled: c = n,
    form: d,
    colon: f,
    labelAlign: h,
    labelWrap: p,
    labelCol: g,
    wrapperCol: m,
    hideRequiredMark: v,
    layout: b = "horizontal",
    scrollToFirstError: x,
    requiredMark: w,
    onFinishFailed: C,
    name: y,
    style: S,
    feedbackIcons: A,
    variant: $
  } = e, M = AG(e, ["prefixCls", "className", "rootClassName", "size", "disabled", "form", "colon", "labelAlign", "labelWrap", "labelCol", "wrapperCol", "hideRequiredMark", "layout", "scrollToFirstError", "requiredMark", "onFinishFailed", "name", "style", "feedbackIcons", "variant"]), _ = so(u), T = O.useContext(MD);
  process.env.NODE_ENV !== "production" && OG(e);
  const D = mt(() => w !== void 0 ? w : v ? !1 : o && o.requiredMark !== void 0 ? o.requiredMark : !0, [v, w, o]), E = f ?? (o == null ? void 0 : o.colon), R = r("form", s), I = Kn(R), [k, P, L] = I1(R, I), N = se(R, `${R}-${b}`, {
    [`${R}-hide-required-mark`]: D === !1,
    [`${R}-rtl`]: i === "rtl",
    [`${R}-${_}`]: _
  }, L, I, P, o == null ? void 0 : o.className, a, l), [F] = MM(d), {
    __INTERNAL__: B
  } = F;
  B.name = y;
  const j = mt(() => ({
    name: y,
    labelAlign: h,
    labelCol: g,
    labelWrap: p,
    wrapperCol: m,
    vertical: b === "vertical",
    colon: E,
    requiredMark: D,
    itemRef: B.itemRef,
    form: F,
    feedbackIcons: A
  }), [y, h, g, m, b, E, D, F, A]);
  O.useImperativeHandle(t, () => F);
  const z = (W, G) => {
    if (W) {
      let K = {
        block: "nearest"
      };
      typeof W == "object" && (K = W), F.scrollToField(G, K);
    }
  }, H = (W) => {
    if (C == null || C(W), W.errorFields.length) {
      const G = W.errorFields[0].name;
      if (x !== void 0) {
        z(x, G);
        return;
      }
      o && o.scrollToFirstError !== void 0 && z(o.scrollToFirstError, G);
    }
  };
  return k(/* @__PURE__ */ O.createElement(rT.Provider, {
    value: $
  }, /* @__PURE__ */ O.createElement(Tw, {
    disabled: c
  }, /* @__PURE__ */ O.createElement(Qa.Provider, {
    value: _
  }, /* @__PURE__ */ O.createElement(nT, {
    // This is not list in API, we pass with spread
    validateMessages: T
  }, /* @__PURE__ */ O.createElement(As.Provider, {
    value: j
  }, /* @__PURE__ */ O.createElement(eu, Object.assign({
    id: y
  }, M, {
    name: y,
    onFinishFailed: H,
    form: F,
    style: Object.assign(Object.assign({}, o == null ? void 0 : o.style), S),
    className: N
  }))))))));
}, IM = /* @__PURE__ */ O.forwardRef(DG);
process.env.NODE_ENV !== "production" && (IM.displayName = "Form");
function _G(e) {
  if (typeof e == "function")
    return e;
  const t = Xr(e);
  return t.length <= 1 ? t[0] : t;
}
const kM = () => {
  const {
    status: e,
    errors: t = [],
    warnings: n = []
  } = Yt(Yr);
  if (process.env.NODE_ENV !== "production") {
    const r = Zt("Form.Item");
    process.env.NODE_ENV !== "production" && r(e !== void 0, "usage", "Form.Item.useStatus should be used under Form.Item component. For more information: https://u.ant.design/form-item-usestatus");
  }
  return {
    status: e,
    errors: t,
    warnings: n
  };
};
kM.Context = Yr;
function TG(e) {
  const [t, n] = O.useState(e), r = he(null), i = he([]), o = he(!1);
  O.useEffect(() => (o.current = !1, () => {
    o.current = !0, rn.cancel(r.current), r.current = null;
  }), []);
  function s(a) {
    o.current || (r.current === null && (i.current = [], r.current = rn(() => {
      r.current = null, n((l) => {
        let u = l;
        return i.current.forEach((c) => {
          u = c(u);
        }), u;
      });
    })), i.current.push(a));
  }
  return [t, s];
}
function RG() {
  const {
    itemRef: e
  } = O.useContext(As), t = O.useRef({});
  function n(r, i) {
    const o = i && typeof i == "object" && i.ref, s = r.join("_");
    return (t.current.name !== s || t.current.originRef !== o) && (t.current.name = s, t.current.originRef = o, t.current.ref = xi(e(r), o)), t.current.ref;
  }
  return n;
}
const MG = (e) => {
  const {
    formItemCls: t
  } = e;
  return {
    "@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none)": {
      // Fallback for IE, safe to remove we not support it anymore
      [`${t}-control`]: {
        display: "flex"
      }
    }
  };
}, IG = Ig(["Form", "item-item"], (e, t) => {
  let {
    rootPrefixCls: n
  } = t;
  const r = DM(e, n);
  return [MG(r)];
}), kG = (e) => {
  const {
    prefixCls: t,
    status: n,
    wrapperCol: r,
    children: i,
    errors: o,
    warnings: s,
    _internalItemRender: a,
    extra: l,
    help: u,
    fieldId: c,
    marginBottom: d,
    onErrorVisibleChanged: f
  } = e, h = `${t}-item`, p = O.useContext(As), g = r || p.wrapperCol || {}, m = se(`${h}-control`, g.className), v = O.useMemo(() => Object.assign({}, p), [p]);
  delete v.labelCol, delete v.wrapperCol;
  const b = /* @__PURE__ */ O.createElement("div", {
    className: `${h}-control-input`
  }, /* @__PURE__ */ O.createElement("div", {
    className: `${h}-control-input-content`
  }, i)), x = O.useMemo(() => ({
    prefixCls: t,
    status: n
  }), [t, n]), w = d !== null || o.length || s.length ? /* @__PURE__ */ O.createElement("div", {
    style: {
      display: "flex",
      flexWrap: "nowrap"
    }
  }, /* @__PURE__ */ O.createElement(Kw.Provider, {
    value: x
  }, /* @__PURE__ */ O.createElement(_M, {
    fieldId: c,
    errors: o,
    warnings: s,
    help: u,
    helpStatus: n,
    className: `${h}-explain-connected`,
    onVisibleChanged: f
  })), !!d && /* @__PURE__ */ O.createElement("div", {
    style: {
      width: 0,
      height: d
    }
  })) : null, C = {};
  c && (C.id = `${c}_extra`);
  const y = l ? /* @__PURE__ */ O.createElement("div", Object.assign({}, C, {
    className: `${h}-extra`
  }), l) : null, S = a && a.mark === "pro_table_render" && a.render ? a.render(e, {
    input: b,
    errorList: w,
    extra: y
  }) : /* @__PURE__ */ O.createElement(O.Fragment, null, b, w, y);
  return /* @__PURE__ */ O.createElement(As.Provider, {
    value: v
  }, /* @__PURE__ */ O.createElement(R1, Object.assign({}, g, {
    className: m
  }), S), /* @__PURE__ */ O.createElement(IG, {
    prefixCls: t
  }));
};
var PG = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, name: "question-circle", theme: "outlined" }, NG = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: PG
  }));
}, PM = /* @__PURE__ */ O.forwardRef(NG);
process.env.NODE_ENV !== "production" && (PM.displayName = "QuestionCircleOutlined");
var LG = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
function FG(e) {
  return e ? typeof e == "object" && !/* @__PURE__ */ O.isValidElement(e) ? e : {
    title: e
  } : null;
}
const BG = (e) => {
  let {
    prefixCls: t,
    label: n,
    htmlFor: r,
    labelCol: i,
    labelAlign: o,
    colon: s,
    required: a,
    requiredMark: l,
    tooltip: u
  } = e;
  var c;
  const [d] = ml("Form"), {
    vertical: f,
    labelAlign: h,
    labelCol: p,
    labelWrap: g,
    colon: m
  } = O.useContext(As);
  if (!n)
    return null;
  const v = i || p || {}, b = o || h, x = `${t}-item-label`, w = se(x, b === "left" && `${x}-left`, v.className, {
    [`${x}-wrap`]: !!g
  });
  let C = n;
  const y = s === !0 || m !== !1 && s !== !1;
  y && !f && typeof n == "string" && n.trim() !== "" && (C = n.replace(/[:|]\s*$/, ""));
  const A = FG(u);
  if (A) {
    const {
      icon: T = /* @__PURE__ */ O.createElement(PM, null)
    } = A, D = LG(A, ["icon"]), E = /* @__PURE__ */ O.createElement(lr, Object.assign({}, D), /* @__PURE__ */ O.cloneElement(T, {
      className: `${t}-item-tooltip`,
      title: "",
      onClick: (R) => {
        R.preventDefault();
      },
      tabIndex: null
    }));
    C = /* @__PURE__ */ O.createElement(O.Fragment, null, C, E);
  }
  const $ = l === "optional", M = typeof l == "function";
  M ? C = l(C, {
    required: !!a
  }) : $ && !a && (C = /* @__PURE__ */ O.createElement(O.Fragment, null, C, /* @__PURE__ */ O.createElement("span", {
    className: `${t}-item-optional`,
    title: ""
  }, (d == null ? void 0 : d.optional) || ((c = xs.Form) === null || c === void 0 ? void 0 : c.optional))));
  const _ = se({
    [`${t}-item-required`]: a,
    [`${t}-item-required-mark-optional`]: $ || M,
    [`${t}-item-no-colon`]: !y
  });
  return /* @__PURE__ */ O.createElement(R1, Object.assign({}, v, {
    className: w
  }), /* @__PURE__ */ O.createElement("label", {
    htmlFor: r,
    className: _,
    title: typeof n == "string" ? n : ""
  }, C));
}, jG = {
  success: ff,
  warning: yl,
  error: bl,
  validating: wl
};
function NM(e) {
  let {
    children: t,
    errors: n,
    warnings: r,
    hasFeedback: i,
    validateStatus: o,
    prefixCls: s,
    meta: a,
    noStyle: l
  } = e;
  const u = `${s}-item`, {
    feedbackIcons: c
  } = O.useContext(As), d = RM(n, r, a, null, !!i, o), {
    isFormItemInput: f,
    status: h,
    hasFeedback: p,
    feedbackIcon: g
  } = O.useContext(Yr), m = O.useMemo(() => {
    var v;
    let b;
    if (i) {
      const w = i !== !0 && i.icons || c, C = d && ((v = w == null ? void 0 : w({
        status: d,
        errors: n,
        warnings: r
      })) === null || v === void 0 ? void 0 : v[d]), y = d && jG[d];
      b = C !== !1 && y ? /* @__PURE__ */ O.createElement("span", {
        className: se(`${u}-feedback-icon`, `${u}-feedback-icon-${d}`)
      }, C || /* @__PURE__ */ O.createElement(y, null)) : null;
    }
    const x = {
      status: d || "",
      errors: n,
      warnings: r,
      hasFeedback: !!i,
      feedbackIcon: b,
      isFormItemInput: !0
    };
    return l && (x.status = (d ?? h) || "", x.isFormItemInput = f, x.hasFeedback = !!(i ?? p), x.feedbackIcon = i !== void 0 ? x.feedbackIcon : g), x;
  }, [d, i, l, f, h]);
  return /* @__PURE__ */ O.createElement(Yr.Provider, {
    value: m
  }, t);
}
var zG = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
function HG(e) {
  const {
    prefixCls: t,
    className: n,
    rootClassName: r,
    style: i,
    help: o,
    errors: s,
    warnings: a,
    validateStatus: l,
    meta: u,
    hasFeedback: c,
    hidden: d,
    children: f,
    fieldId: h,
    required: p,
    isRequired: g,
    onSubItemMetaChange: m
  } = e, v = zG(e, ["prefixCls", "className", "rootClassName", "style", "help", "errors", "warnings", "validateStatus", "meta", "hasFeedback", "hidden", "children", "fieldId", "required", "isRequired", "onSubItemMetaChange"]), b = `${t}-item`, {
    requiredMark: x
  } = O.useContext(As), w = O.useRef(null), C = jp(s), y = jp(a), S = o != null, A = !!(S || s.length || a.length), $ = !!w.current && Fg(w.current), [M, _] = O.useState(null);
  sn(() => {
    if (A && w.current) {
      const I = getComputedStyle(w.current);
      _(parseInt(I.marginBottom, 10));
    }
  }, [A, $]);
  const T = (I) => {
    I || _(null);
  }, E = function() {
    let I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    const k = I ? C : u.errors, P = I ? y : u.warnings;
    return RM(k, P, u, "", !!c, l);
  }(), R = se(b, n, r, {
    [`${b}-with-help`]: S || C.length || y.length,
    // Status
    [`${b}-has-feedback`]: E && c,
    [`${b}-has-success`]: E === "success",
    [`${b}-has-warning`]: E === "warning",
    [`${b}-has-error`]: E === "error",
    [`${b}-is-validating`]: E === "validating",
    [`${b}-hidden`]: d
  });
  return /* @__PURE__ */ O.createElement("div", {
    className: R,
    style: i,
    ref: w
  }, /* @__PURE__ */ O.createElement(mM, Object.assign({
    className: `${b}-row`
  }, zn(v, [
    "_internalItemRender",
    "colon",
    "dependencies",
    "extra",
    "fieldKey",
    "getValueFromEvent",
    "getValueProps",
    "htmlFor",
    "id",
    // It is deprecated because `htmlFor` is its replacement.
    "initialValue",
    "isListField",
    "label",
    "labelAlign",
    "labelCol",
    "labelWrap",
    "messageVariables",
    "name",
    "normalize",
    "noStyle",
    "preserve",
    "requiredMark",
    "rules",
    "shouldUpdate",
    "trigger",
    "tooltip",
    "validateFirst",
    "validateTrigger",
    "valuePropName",
    "wrapperCol",
    "validateDebounce"
  ])), /* @__PURE__ */ O.createElement(BG, Object.assign({
    htmlFor: h
  }, e, {
    requiredMark: x,
    required: p ?? g,
    prefixCls: t
  })), /* @__PURE__ */ O.createElement(kG, Object.assign({}, e, u, {
    errors: C,
    warnings: y,
    prefixCls: t,
    status: E,
    help: o,
    marginBottom: M,
    onErrorVisibleChanged: T
  }), /* @__PURE__ */ O.createElement(tT.Provider, {
    value: m
  }, /* @__PURE__ */ O.createElement(NM, {
    prefixCls: t,
    meta: u,
    errors: u.errors,
    warnings: u.warnings,
    hasFeedback: c,
    // Already calculated
    validateStatus: E
  }, f)))), !!M && /* @__PURE__ */ O.createElement("div", {
    className: `${b}-margin-offset`,
    style: {
      marginBottom: -M
    }
  }));
}
const VG = "__SPLIT__";
function WG(e, t) {
  const n = Object.keys(e), r = Object.keys(t);
  return n.length === r.length && n.every((i) => {
    const o = e[i], s = t[i];
    return o === s || typeof o == "function" || typeof s == "function";
  });
}
const UG = /* @__PURE__ */ O.memo((e) => {
  let {
    children: t
  } = e;
  return t;
}, (e, t) => WG(e.control, t.control) && e.update === t.update && e.childProps.length === t.childProps.length && e.childProps.every((n, r) => n === t.childProps[r]));
function VE() {
  return {
    errors: [],
    warnings: [],
    touched: !1,
    validating: !1,
    name: [],
    validated: !1
  };
}
function GG(e) {
  const {
    name: t,
    noStyle: n,
    className: r,
    dependencies: i,
    prefixCls: o,
    shouldUpdate: s,
    rules: a,
    children: l,
    required: u,
    label: c,
    messageVariables: d,
    trigger: f = "onChange",
    validateTrigger: h,
    hidden: p,
    help: g
  } = e, {
    getPrefixCls: m
  } = O.useContext(rt), {
    name: v
  } = O.useContext(As), b = _G(l), x = typeof b == "function", w = O.useContext(tT), {
    validateTrigger: C
  } = O.useContext(Ja), y = h !== void 0 ? h : C, S = t != null, A = m("form", o), $ = Kn(A), [M, _, T] = I1(A, $), D = Zt("Form.Item");
  process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && D(t !== null, "usage", "`null` is passed as `name` property");
  const E = O.useContext(Sd), R = O.useRef(), [I, k] = TG({}), [P, L] = ta(() => VE()), N = (G) => {
    const K = E == null ? void 0 : E.getKey(G.name);
    if (L(G.destroy ? VE() : G, !0), n && g !== !1 && w) {
      let Y = G.name;
      if (G.destroy)
        Y = R.current || Y;
      else if (K !== void 0) {
        const [X, Z] = K;
        Y = [X].concat(_e(Z)), R.current = Y;
      }
      w(G, Y);
    }
  }, F = (G, K) => {
    k((Y) => {
      const X = Object.assign({}, Y), Q = [].concat(_e(G.name.slice(0, -1)), _e(K)).join(VG);
      return G.destroy ? delete X[Q] : X[Q] = G, X;
    });
  }, [B, j] = O.useMemo(() => {
    const G = _e(P.errors), K = _e(P.warnings);
    return Object.values(I).forEach((Y) => {
      G.push.apply(G, _e(Y.errors || [])), K.push.apply(K, _e(Y.warnings || []));
    }), [G, K];
  }, [I, P.errors, P.warnings]), z = RG();
  function H(G, K, Y) {
    return n && !p ? /* @__PURE__ */ O.createElement(NM, {
      prefixCls: A,
      hasFeedback: e.hasFeedback,
      validateStatus: e.validateStatus,
      meta: P,
      errors: B,
      warnings: j,
      noStyle: !0
    }, G) : /* @__PURE__ */ O.createElement(HG, Object.assign({
      key: "row"
    }, e, {
      className: se(r, T, $, _),
      prefixCls: A,
      fieldId: K,
      isRequired: Y,
      errors: B,
      warnings: j,
      meta: P,
      onSubItemMetaChange: F
    }), G);
  }
  if (!S && !x && !i)
    return M(H(b));
  let W = {};
  return typeof c == "string" ? W.label = c : t && (W.label = String(t)), d && (W = Object.assign(Object.assign({}, W), d)), M(/* @__PURE__ */ O.createElement(Uw, Object.assign({}, e, {
    messageVariables: W,
    trigger: f,
    validateTrigger: y,
    onMetaChange: N
  }), (G, K, Y) => {
    const X = td(t).length && K ? K.name : [], Z = TM(X, v), Q = u !== void 0 ? u : !!(a && a.some((te) => {
      if (te && typeof te == "object" && te.required && !te.warningOnly)
        return !0;
      if (typeof te == "function") {
        const fe = te(Y);
        return fe && fe.required && !fe.warningOnly;
      }
      return !1;
    })), ne = Object.assign({}, G);
    let q = null;
    if (process.env.NODE_ENV !== "production" && D(!(s && i), "usage", "`shouldUpdate` and `dependencies` shouldn't be used together. See https://u.ant.design/form-deps."), Array.isArray(b) && S)
      process.env.NODE_ENV !== "production" && D(!1, "usage", "A `Form.Item` with a `name` prop must have a single child element. For information on how to render more complex form items, see https://u.ant.design/complex-form-item."), q = b;
    else if (x && (!(s || i) || S))
      process.env.NODE_ENV !== "production" && D(!!(s || i), "usage", "A `Form.Item` with a render function must have either `shouldUpdate` or `dependencies`."), process.env.NODE_ENV !== "production" && D(!S, "usage", "A `Form.Item` with a render function cannot be a field, and thus cannot have a `name` prop.");
    else if (i && !x && !S)
      process.env.NODE_ENV !== "production" && D(!1, "usage", "Must set `name` or use a render function when `dependencies` is set.");
    else if (/* @__PURE__ */ O.isValidElement(b)) {
      process.env.NODE_ENV !== "production" && D(b.props.defaultValue === void 0, "usage", "`defaultValue` will not work on controlled Field. You should use `initialValues` of Form instead.");
      const te = Object.assign(Object.assign({}, b.props), ne);
      if (te.id || (te.id = Z), g || B.length > 0 || j.length > 0 || e.extra) {
        const de = [];
        (g || B.length > 0) && de.push(`${Z}_help`), e.extra && de.push(`${Z}_extra`), te["aria-describedby"] = de.join(" ");
      }
      B.length > 0 && (te["aria-invalid"] = "true"), Q && (te["aria-required"] = "true"), Ms(b) && (te.ref = z(X, b)), new Set([].concat(_e(td(f)), _e(td(y)))).forEach((de) => {
        te[de] = function() {
          for (var ce, pe, Oe, Re, De, Me = arguments.length, Ue = new Array(Me), oe = 0; oe < Me; oe++)
            Ue[oe] = arguments[oe];
          (Oe = ne[de]) === null || Oe === void 0 || (ce = Oe).call.apply(ce, [ne].concat(Ue)), (De = (Re = b.props)[de]) === null || De === void 0 || (pe = De).call.apply(pe, [Re].concat(Ue));
        };
      });
      const Se = [te["aria-required"], te["aria-invalid"], te["aria-describedby"]];
      q = /* @__PURE__ */ O.createElement(UG, {
        control: ne,
        update: b,
        childProps: Se
      }, oi(b, te));
    } else
      x && (s || i) && !S ? q = b(Y) : (process.env.NODE_ENV !== "production" && D(!X.length, "usage", "`name` is only used for validate React element. If you are using Form.Item as layout display, please remove `name` instead."), q = b);
    return H(q, Z, Q);
  }));
}
const LM = GG;
LM.useStatus = kM;
var KG = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const XG = (e) => {
  var {
    prefixCls: t,
    children: n
  } = e, r = KG(e, ["prefixCls", "children"]);
  if (process.env.NODE_ENV !== "production") {
    const a = Zt("Form.List");
    process.env.NODE_ENV !== "production" && a(typeof r.name == "number" || (Array.isArray(r.name) ? !!r.name.length : !!r.name), "usage", "Miss `name` prop.");
  }
  const {
    getPrefixCls: i
  } = O.useContext(rt), o = i("form", t), s = O.useMemo(() => ({
    prefixCls: o,
    status: "error"
  }), [o]);
  return /* @__PURE__ */ O.createElement(Q_, Object.assign({}, r), (a, l, u) => /* @__PURE__ */ O.createElement(Kw.Provider, {
    value: s
  }, n(a.map((c) => Object.assign(Object.assign({}, c), {
    fieldKey: c.key
  })), l, {
    errors: u.errors,
    warnings: u.warnings
  })));
};
function YG() {
  const {
    form: e
  } = Yt(As);
  return e;
}
const Pn = IM;
Pn.Item = LM;
Pn.List = XG;
Pn.ErrorList = _M;
Pn.useForm = MM;
Pn.useFormInstance = YG;
Pn.useWatch = eT;
Pn.Provider = nT;
Pn.create = () => {
  process.env.NODE_ENV !== "production" && gl(!1, "Form", "antd v4 removed `Form.create`. Please remove or use `@ant-design/compatible` instead.");
};
var qG = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M847.9 592H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h605.2L612.9 851c-4.1 5.2-.4 13 6.3 13h72.5c4.9 0 9.5-2.2 12.6-6.1l168.8-214.1c16.5-21 1.6-51.8-25.2-51.8zM872 356H266.8l144.3-183c4.1-5.2.4-13-6.3-13h-72.5c-4.9 0-9.5 2.2-12.6 6.1L150.9 380.2c-16.5 21-1.6 51.8 25.1 51.8h696c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, name: "swap", theme: "outlined" }, QG = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: qG
  }));
}, k1 = /* @__PURE__ */ O.forwardRef(QG);
process.env.NODE_ENV !== "production" && (k1.displayName = "SwapOutlined");
const ZG = new Gt("antSpinMove", {
  to: {
    opacity: 1
  }
}), JG = new Gt("antRotate", {
  to: {
    transform: "rotate(405deg)"
  }
}), eK = (e) => {
  const {
    componentCls: t,
    calc: n
  } = e;
  return {
    [`${t}`]: Object.assign(Object.assign({}, Gn(e)), {
      position: "absolute",
      display: "none",
      color: e.colorPrimary,
      fontSize: 0,
      textAlign: "center",
      verticalAlign: "middle",
      opacity: 0,
      transition: `transform ${e.motionDurationSlow} ${e.motionEaseInOutCirc}`,
      "&-spinning": {
        position: "static",
        display: "inline-block",
        opacity: 1
      },
      [`${t}-text`]: {
        fontSize: e.fontSize,
        paddingTop: n(n(e.dotSize).sub(e.fontSize)).div(2).add(2).equal()
      },
      "&-fullscreen": {
        position: "fixed",
        width: "100vw",
        height: "100vh",
        backgroundColor: e.colorBgMask,
        zIndex: e.zIndexPopupBase,
        inset: 0,
        display: "flex",
        alignItems: "center",
        flexDirection: "column",
        justifyContent: "center",
        opacity: 0,
        visibility: "hidden",
        transition: `all ${e.motionDurationMid}`,
        "&-show": {
          opacity: 1,
          visibility: "visible"
        },
        [`${t}-dot ${t}-dot-item`]: {
          backgroundColor: e.colorWhite
        },
        [`${t}-text`]: {
          color: e.colorTextLightSolid
        }
      },
      "&-nested-loading": {
        position: "relative",
        [`> div > ${t}`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          zIndex: 4,
          display: "block",
          width: "100%",
          height: "100%",
          maxHeight: e.contentHeight,
          [`${t}-dot`]: {
            position: "absolute",
            top: "50%",
            insetInlineStart: "50%",
            margin: n(e.dotSize).mul(-1).div(2).equal()
          },
          [`${t}-text`]: {
            position: "absolute",
            top: "50%",
            width: "100%",
            textShadow: `0 1px 2px ${e.colorBgContainer}`
            // FIXME: shadow
          },
          [`&${t}-show-text ${t}-dot`]: {
            marginTop: n(e.dotSize).div(2).mul(-1).sub(10).equal()
          },
          "&-sm": {
            [`${t}-dot`]: {
              margin: n(e.dotSizeSM).mul(-1).div(2).equal()
            },
            [`${t}-text`]: {
              paddingTop: n(n(e.dotSizeSM).sub(e.fontSize)).div(2).add(2).equal()
            },
            [`&${t}-show-text ${t}-dot`]: {
              marginTop: n(e.dotSizeSM).div(2).mul(-1).sub(10).equal()
            }
          },
          "&-lg": {
            [`${t}-dot`]: {
              margin: n(e.dotSizeLG).mul(-1).div(2).equal()
            },
            [`${t}-text`]: {
              paddingTop: n(n(e.dotSizeLG).sub(e.fontSize)).div(2).add(2).equal()
            },
            [`&${t}-show-text ${t}-dot`]: {
              marginTop: n(e.dotSizeLG).div(2).mul(-1).sub(10).equal()
            }
          }
        },
        [`${t}-container`]: {
          position: "relative",
          transition: `opacity ${e.motionDurationSlow}`,
          "&::after": {
            position: "absolute",
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            zIndex: 10,
            width: "100%",
            height: "100%",
            background: e.colorBgContainer,
            opacity: 0,
            transition: `all ${e.motionDurationSlow}`,
            content: '""',
            pointerEvents: "none"
          }
        },
        [`${t}-blur`]: {
          clear: "both",
          opacity: 0.5,
          userSelect: "none",
          pointerEvents: "none",
          "&::after": {
            opacity: 0.4,
            pointerEvents: "auto"
          }
        }
      },
      // tip
      // ------------------------------
      "&-tip": {
        color: e.spinDotDefault
      },
      // dots
      // ------------------------------
      [`${t}-dot`]: {
        position: "relative",
        display: "inline-block",
        fontSize: e.dotSize,
        width: "1em",
        height: "1em",
        "&-item": {
          position: "absolute",
          display: "block",
          width: n(e.dotSize).sub(n(e.marginXXS).div(2)).div(2).equal(),
          height: n(e.dotSize).sub(n(e.marginXXS).div(2)).div(2).equal(),
          backgroundColor: e.colorPrimary,
          borderRadius: "100%",
          transform: "scale(0.75)",
          transformOrigin: "50% 50%",
          opacity: 0.3,
          animationName: ZG,
          animationDuration: "1s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear",
          animationDirection: "alternate",
          "&:nth-child(1)": {
            top: 0,
            insetInlineStart: 0,
            animationDelay: "0s"
          },
          "&:nth-child(2)": {
            top: 0,
            insetInlineEnd: 0,
            animationDelay: "0.4s"
          },
          "&:nth-child(3)": {
            insetInlineEnd: 0,
            bottom: 0,
            animationDelay: "0.8s"
          },
          "&:nth-child(4)": {
            bottom: 0,
            insetInlineStart: 0,
            animationDelay: "1.2s"
          }
        },
        "&-spin": {
          transform: "rotate(45deg)",
          animationName: JG,
          animationDuration: "1.2s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear"
        }
      },
      // small
      [`&-sm ${t}-dot`]: {
        fontSize: e.dotSizeSM,
        i: {
          width: n(n(e.dotSizeSM).sub(n(e.marginXXS).div(2))).div(2).equal(),
          height: n(n(e.dotSizeSM).sub(n(e.marginXXS).div(2))).div(2).equal()
        }
      },
      // large
      [`&-lg ${t}-dot`]: {
        fontSize: e.dotSizeLG,
        i: {
          width: n(n(e.dotSizeLG).sub(e.marginXXS)).div(2).equal(),
          height: n(n(e.dotSizeLG).sub(e.marginXXS)).div(2).equal()
        }
      },
      [`&${t}-show-text ${t}-text`]: {
        display: "block"
      }
    })
  };
}, tK = (e) => {
  const {
    controlHeightLG: t,
    controlHeight: n
  } = e;
  return {
    contentHeight: 400,
    dotSize: t / 2,
    dotSizeSM: t * 0.35,
    dotSizeLG: n
  };
}, nK = $n("Spin", (e) => {
  const t = Jt(e, {
    spinDotDefault: e.colorTextDescription
  });
  return [eK(t)];
}, tK);
var rK = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
let op = null;
function iK(e, t) {
  const {
    indicator: n
  } = t, r = `${e}-dot`;
  return n === null ? null : /* @__PURE__ */ O.isValidElement(n) ? oi(n, {
    className: se(n.props.className, r)
  }) : /* @__PURE__ */ O.isValidElement(op) ? oi(op, {
    className: se(op.props.className, r)
  }) : /* @__PURE__ */ O.createElement("span", {
    className: se(r, `${e}-dot-spin`)
  }, /* @__PURE__ */ O.createElement("i", {
    className: `${e}-dot-item`,
    key: 1
  }), /* @__PURE__ */ O.createElement("i", {
    className: `${e}-dot-item`,
    key: 2
  }), /* @__PURE__ */ O.createElement("i", {
    className: `${e}-dot-item`,
    key: 3
  }), /* @__PURE__ */ O.createElement("i", {
    className: `${e}-dot-item`,
    key: 4
  }));
}
function oK(e, t) {
  return !!e && !!t && !isNaN(Number(t));
}
const $f = (e) => {
  const {
    prefixCls: t,
    spinning: n = !0,
    delay: r = 0,
    className: i,
    rootClassName: o,
    size: s = "default",
    tip: a,
    wrapperClassName: l,
    style: u,
    children: c,
    fullscreen: d = !1
  } = e, f = rK(e, ["prefixCls", "spinning", "delay", "className", "rootClassName", "size", "tip", "wrapperClassName", "style", "children", "fullscreen"]), {
    getPrefixCls: h
  } = O.useContext(rt), p = h("spin", t), [g, m, v] = nK(p), [b, x] = O.useState(() => n && !oK(n, r));
  O.useEffect(() => {
    if (n) {
      const T = DW(r, () => {
        x(!0);
      });
      return T(), () => {
        var D;
        (D = T == null ? void 0 : T.cancel) === null || D === void 0 || D.call(T);
      };
    }
    x(!1);
  }, [r, n]);
  const w = O.useMemo(() => typeof c < "u" && !d, [c, d]);
  if (process.env.NODE_ENV !== "production") {
    const T = Zt("Spin");
    process.env.NODE_ENV !== "production" && T(!a || w || d, "usage", "`tip` only work in nest or fullscreen pattern.");
  }
  const {
    direction: C,
    spin: y
  } = O.useContext(rt), S = se(p, y == null ? void 0 : y.className, {
    [`${p}-sm`]: s === "small",
    [`${p}-lg`]: s === "large",
    [`${p}-spinning`]: b,
    [`${p}-show-text`]: !!a,
    [`${p}-fullscreen`]: d,
    [`${p}-fullscreen-show`]: d && b,
    [`${p}-rtl`]: C === "rtl"
  }, i, o, m, v), A = se(`${p}-container`, {
    [`${p}-blur`]: b
  }), $ = zn(f, ["indicator"]), M = Object.assign(Object.assign({}, y == null ? void 0 : y.style), u), _ = /* @__PURE__ */ O.createElement("div", Object.assign({}, $, {
    style: M,
    className: S,
    "aria-live": "polite",
    "aria-busy": b
  }), iK(p, e), a && (w || d) ? /* @__PURE__ */ O.createElement("div", {
    className: `${p}-text`
  }, a) : null);
  return g(w ? /* @__PURE__ */ O.createElement("div", Object.assign({}, $, {
    className: se(`${p}-nested-loading`, l, m, v)
  }), b && /* @__PURE__ */ O.createElement("div", {
    key: "loading"
  }, _), /* @__PURE__ */ O.createElement("div", {
    className: A,
    key: "container"
  }, c)) : _);
};
$f.setDefaultIndicator = (e) => {
  op = e;
};
process.env.NODE_ENV !== "production" && ($f.displayName = "Spin");
let Yi = null, Ba = (e) => e(), Dd = [], _d = {};
function WE() {
  const {
    getContainer: e,
    duration: t,
    rtl: n,
    maxCount: r,
    top: i
  } = _d, o = (e == null ? void 0 : e()) || document.body;
  return {
    getContainer: () => o,
    duration: t,
    rtl: n,
    maxCount: r,
    top: i
  };
}
const sK = /* @__PURE__ */ U.forwardRef((e, t) => {
  const {
    messageConfig: n,
    sync: r
  } = e, {
    getPrefixCls: i
  } = Yt(rt), o = _d.prefixCls || i("message"), s = Yt(OT), [a, l] = T_(Object.assign(Object.assign(Object.assign({}, n), {
    prefixCls: o
  }), s.message));
  return U.useImperativeHandle(t, () => {
    const u = Object.assign({}, a);
    return Object.keys(u).forEach((c) => {
      u[c] = function() {
        return r(), a[c].apply(a, arguments);
      };
    }), {
      instance: u,
      sync: r
    };
  }), l;
}), aK = /* @__PURE__ */ U.forwardRef((e, t) => {
  const [n, r] = U.useState(WE), i = () => {
    r(WE);
  };
  U.useEffect(i, []);
  const o = df(), s = o.getRootPrefixCls(), a = o.getIconPrefixCls(), l = o.getTheme(), u = /* @__PURE__ */ U.createElement(sK, {
    ref: t,
    sync: i,
    messageConfig: n
  });
  return /* @__PURE__ */ U.createElement(qc, {
    prefixCls: s,
    iconPrefixCls: a,
    theme: l
  }, o.holderRender ? o.holderRender(u) : u);
});
function im() {
  if (!Yi) {
    const e = document.createDocumentFragment(), t = {
      fragment: e
    };
    Yi = t, Ba(() => {
      Lg(/* @__PURE__ */ U.createElement(aK, {
        ref: (n) => {
          const {
            instance: r,
            sync: i
          } = n || {};
          Promise.resolve().then(() => {
            !t.instance && r && (t.instance = r, t.sync = i, im());
          });
        }
      }), e);
    });
    return;
  }
  Yi.instance && (Dd.forEach((e) => {
    const {
      type: t,
      skipped: n
    } = e;
    if (!n)
      switch (t) {
        case "open": {
          Ba(() => {
            const r = Yi.instance.open(Object.assign(Object.assign({}, _d), e.config));
            r == null || r.then(e.resolve), e.setCloseFn(r);
          });
          break;
        }
        case "destroy":
          Ba(() => {
            Yi == null || Yi.instance.destroy(e.key);
          });
          break;
        default:
          Ba(() => {
            var r;
            const i = (r = Yi.instance)[t].apply(r, _e(e.args));
            i == null || i.then(e.resolve), e.setCloseFn(i);
          });
      }
  }), Dd = []);
}
function lK(e) {
  _d = Object.assign(Object.assign({}, _d), e), Ba(() => {
    var t;
    (t = Yi == null ? void 0 : Yi.sync) === null || t === void 0 || t.call(Yi);
  });
}
function cK(e) {
  const t = Nw((n) => {
    let r;
    const i = {
      type: "open",
      config: e,
      resolve: n,
      setCloseFn: (o) => {
        r = o;
      }
    };
    return Dd.push(i), () => {
      r ? Ba(() => {
        r();
      }) : i.skipped = !0;
    };
  });
  return im(), t;
}
function uK(e, t) {
  const n = df();
  process.env.NODE_ENV !== "production" && !n.holderRender && kw("message");
  const r = Nw((i) => {
    let o;
    const s = {
      type: e,
      args: t,
      resolve: i,
      setCloseFn: (a) => {
        o = a;
      }
    };
    return Dd.push(s), () => {
      o ? Ba(() => {
        o();
      }) : s.skipped = !0;
    };
  });
  return im(), r;
}
const dK = (e) => {
  Dd.push({
    type: "destroy",
    key: e
  }), im();
}, fK = ["success", "info", "warning", "error", "loading"], hK = {
  open: cK,
  destroy: dK,
  config: lK,
  useMessage: OB,
  _InternalPanelDoNotUseOrYouWillBeFired: bB
}, Cr = hK;
fK.forEach((e) => {
  Cr[e] = function() {
    for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
      n[r] = arguments[r];
    return uK(e, n);
  };
});
process.env.NODE_ENV;
process.env.NODE_ENV;
var pK = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const gK = (e) => {
  const {
    prefixCls: t,
    className: n,
    closeIcon: r,
    closable: i,
    type: o,
    title: s,
    children: a,
    footer: l
  } = e, u = pK(e, ["prefixCls", "className", "closeIcon", "closable", "type", "title", "children", "footer"]), {
    getPrefixCls: c
  } = O.useContext(rt), d = c(), f = t || c("modal"), h = Kn(d), [p, g, m] = cT(f, h), v = `${f}-confirm`;
  let b = {};
  return o ? b = {
    closable: i ?? !1,
    title: "",
    footer: "",
    children: /* @__PURE__ */ O.createElement(dT, Object.assign({}, e, {
      prefixCls: f,
      confirmPrefixCls: v,
      rootPrefixCls: d,
      content: a
    }))
  } : b = {
    closable: i ?? !0,
    title: s,
    footer: l !== null && /* @__PURE__ */ O.createElement(oT, Object.assign({}, e)),
    children: a
  }, p(/* @__PURE__ */ O.createElement(Vw, Object.assign({
    prefixCls: f,
    className: se(g, `${f}-pure-panel`, o && v, o && `${v}-${o}`, n, m, h)
  }, u, {
    closeIcon: iT(f, r),
    closable: i
  }, b)));
}, mK = AT(gK);
function FM(e) {
  return bf(gT(e));
}
const pr = uT;
pr.useModal = Oj;
pr.info = function(t) {
  return bf(mT(t));
};
pr.success = function(t) {
  return bf(vT(t));
};
pr.error = function(t) {
  return bf(bT(t));
};
pr.warning = FM;
pr.warn = FM;
pr.confirm = function(t) {
  return bf(yT(t));
};
pr.destroyAll = function() {
  for (; Fa.length; ) {
    const t = Fa.pop();
    t && t();
  }
};
pr.config = Cj;
pr._InternalPanelDoNotUseOrYouWillBeFired = mK;
process.env.NODE_ENV !== "production" && (pr.displayName = "Modal");
let fo = null, sp = (e) => e(), zp = [], Td = {};
function UE() {
  const {
    getContainer: e,
    rtl: t,
    maxCount: n,
    top: r,
    bottom: i
  } = Td, o = (e == null ? void 0 : e()) || document.body;
  return {
    getContainer: () => o,
    rtl: t,
    maxCount: n,
    top: r,
    bottom: i
  };
}
const vK = /* @__PURE__ */ U.forwardRef((e, t) => {
  const {
    notificationConfig: n,
    sync: r
  } = e, {
    getPrefixCls: i
  } = Yt(rt), o = Td.prefixCls || i("notification"), s = Yt(OT), [a, l] = $T(Object.assign(Object.assign(Object.assign({}, n), {
    prefixCls: o
  }), s.notification));
  return U.useEffect(r, []), U.useImperativeHandle(t, () => {
    const u = Object.assign({}, a);
    return Object.keys(u).forEach((c) => {
      u[c] = function() {
        return r(), a[c].apply(a, arguments);
      };
    }), {
      instance: u,
      sync: r
    };
  }), l;
}), bK = /* @__PURE__ */ U.forwardRef((e, t) => {
  const [n, r] = U.useState(UE), i = () => {
    r(UE);
  };
  U.useEffect(i, []);
  const o = df(), s = o.getRootPrefixCls(), a = o.getIconPrefixCls(), l = o.getTheme(), u = /* @__PURE__ */ U.createElement(vK, {
    ref: t,
    sync: i,
    notificationConfig: n
  });
  return /* @__PURE__ */ U.createElement(qc, {
    prefixCls: s,
    iconPrefixCls: a,
    theme: l
  }, o.holderRender ? o.holderRender(u) : u);
});
function P1() {
  if (!fo) {
    const e = document.createDocumentFragment(), t = {
      fragment: e
    };
    fo = t, sp(() => {
      Lg(/* @__PURE__ */ U.createElement(bK, {
        ref: (n) => {
          const {
            instance: r,
            sync: i
          } = n || {};
          Promise.resolve().then(() => {
            !t.instance && r && (t.instance = r, t.sync = i, P1());
          });
        }
      }), e);
    });
    return;
  }
  fo.instance && (zp.forEach((e) => {
    switch (e.type) {
      case "open": {
        sp(() => {
          fo.instance.open(Object.assign(Object.assign({}, Td), e.config));
        });
        break;
      }
      case "destroy":
        sp(() => {
          fo == null || fo.instance.destroy(e.key);
        });
        break;
    }
  }), zp = []);
}
function yK(e) {
  Td = Object.assign(Object.assign({}, Td), e), sp(() => {
    var t;
    (t = fo == null ? void 0 : fo.sync) === null || t === void 0 || t.call(fo);
  });
}
function BM(e) {
  const t = df();
  process.env.NODE_ENV !== "production" && !t.holderRender && kw("notification"), zp.push({
    type: "open",
    config: e
  }), P1();
}
const wK = (e) => {
  zp.push({
    type: "destroy",
    key: e
  }), P1();
}, CK = ["success", "info", "warning", "error"], SK = {
  open: BM,
  destroy: wK,
  config: yK,
  useNotification: Kj,
  _InternalPanelDoNotUseOrYouWillBeFired: Fj
}, ap = SK;
CK.forEach((e) => {
  ap[e] = (t) => BM(Object.assign(Object.assign({}, t), {
    type: e
  }));
});
process.env.NODE_ENV;
process.env.NODE_ENV;
const xK = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    antCls: r,
    zIndexPopup: i,
    colorText: o,
    colorWarning: s,
    marginXXS: a,
    marginXS: l,
    fontSize: u,
    fontWeightStrong: c,
    colorTextHeading: d
  } = e;
  return {
    [t]: {
      zIndex: i,
      [`&${r}-popover`]: {
        fontSize: u
      },
      [`${t}-message`]: {
        marginBottom: l,
        display: "flex",
        flexWrap: "nowrap",
        alignItems: "start",
        [`> ${t}-message-icon ${n}`]: {
          color: s,
          fontSize: u,
          lineHeight: 1,
          marginInlineEnd: l
        },
        [`${t}-title`]: {
          fontWeight: c,
          color: d,
          "&:only-child": {
            fontWeight: "normal"
          }
        },
        [`${t}-description`]: {
          marginTop: a,
          color: o
        }
      },
      [`${t}-buttons`]: {
        textAlign: "end",
        whiteSpace: "nowrap",
        button: {
          marginInlineStart: l
        }
      }
    }
  };
}, EK = (e) => {
  const {
    zIndexPopupBase: t
  } = e;
  return {
    zIndexPopup: t + 60
  };
}, jM = $n("Popconfirm", (e) => xK(e), EK, {
  resetStyle: !1
});
var $K = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const zM = (e) => {
  const {
    prefixCls: t,
    okButtonProps: n,
    cancelButtonProps: r,
    title: i,
    description: o,
    cancelText: s,
    okText: a,
    okType: l = "primary",
    icon: u = /* @__PURE__ */ O.createElement(yl, null),
    showCancel: c = !0,
    close: d,
    onConfirm: f,
    onCancel: h,
    onPopupClick: p
  } = e, {
    getPrefixCls: g
  } = O.useContext(rt), [m] = ml("Popconfirm", xs.Popconfirm), v = Mc(i), b = Mc(o);
  return /* @__PURE__ */ O.createElement("div", {
    className: `${t}-inner-content`,
    onClick: p
  }, /* @__PURE__ */ O.createElement("div", {
    className: `${t}-message`
  }, u && /* @__PURE__ */ O.createElement("span", {
    className: `${t}-message-icon`
  }, u), /* @__PURE__ */ O.createElement("div", {
    className: `${t}-message-text`
  }, v && /* @__PURE__ */ O.createElement("div", {
    className: se(`${t}-title`)
  }, v), b && /* @__PURE__ */ O.createElement("div", {
    className: `${t}-description`
  }, b))), /* @__PURE__ */ O.createElement("div", {
    className: `${t}-buttons`
  }, c && /* @__PURE__ */ O.createElement(Ut, Object.assign({
    onClick: h,
    size: "small"
  }, r), s || (m == null ? void 0 : m.cancelText)), /* @__PURE__ */ O.createElement(Hw, {
    buttonProps: Object.assign(Object.assign({
      size: "small"
    }, Bw(l)), n),
    actionFn: f,
    close: d,
    prefixCls: g("btn"),
    quitOnNullishReturnValue: !0,
    emitEvent: !0
  }, a || (m == null ? void 0 : m.okText))));
}, OK = (e) => {
  const {
    prefixCls: t,
    placement: n,
    className: r,
    style: i
  } = e, o = $K(e, ["prefixCls", "placement", "className", "style"]), {
    getPrefixCls: s
  } = O.useContext(rt), a = s("popconfirm", t), [l] = jM(a);
  return l(/* @__PURE__ */ O.createElement(fR, {
    placement: n,
    className: se(a, r),
    style: i,
    content: /* @__PURE__ */ O.createElement(zM, Object.assign({
      prefixCls: a
    }, o))
  }));
};
var AK = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const DK = /* @__PURE__ */ O.forwardRef((e, t) => {
  var n, r;
  const {
    prefixCls: i,
    placement: o = "top",
    trigger: s = "click",
    okType: a = "primary",
    icon: l = /* @__PURE__ */ O.createElement(yl, null),
    children: u,
    overlayClassName: c,
    onOpenChange: d,
    onVisibleChange: f
  } = e, h = AK(e, ["prefixCls", "placement", "trigger", "okType", "icon", "children", "overlayClassName", "onOpenChange", "onVisibleChange"]), {
    getPrefixCls: p
  } = O.useContext(rt), [g, m] = Un(!1, {
    value: (n = e.open) !== null && n !== void 0 ? n : e.visible,
    defaultValue: (r = e.defaultOpen) !== null && r !== void 0 ? r : e.defaultVisible
  }), v = ($, M) => {
    m($, !0), f == null || f($), d == null || d($, M);
  }, b = ($) => {
    v(!1, $);
  }, x = ($) => {
    var M;
    return (M = e.onConfirm) === null || M === void 0 ? void 0 : M.call(void 0, $);
  }, w = ($) => {
    var M;
    v(!1, $), (M = e.onCancel) === null || M === void 0 || M.call(void 0, $);
  }, C = ($, M) => {
    const {
      disabled: _ = !1
    } = e;
    _ || v($, M);
  }, y = p("popconfirm", i), S = se(y, c), [A] = jM(y);
  return A(/* @__PURE__ */ O.createElement(Kg, Object.assign({}, zn(h, ["title"]), {
    trigger: s,
    placement: o,
    onOpenChange: C,
    open: g,
    ref: t,
    overlayClassName: S,
    content: /* @__PURE__ */ O.createElement(zM, Object.assign({
      okType: a,
      icon: l
    }, e, {
      prefixCls: y,
      close: b,
      onConfirm: x,
      onCancel: w
    })),
    "data-popover-inject": !0
  }), u));
}), N1 = DK;
N1._InternalPanelDoNotUseOrYouWillBeFired = OK;
process.env.NODE_ENV !== "production" && (N1.displayName = "Popconfirm");
const _K = (e) => {
  const t = e != null && e.algorithm ? gd(e.algorithm) : gd(uf), n = Object.assign(Object.assign({}, Tc), e == null ? void 0 : e.token);
  return fD(n, {
    override: e == null ? void 0 : e.token
  }, t, Rw);
};
function TK(e) {
  const {
    sizeUnit: t,
    sizeStep: n
  } = e, r = n - 2;
  return {
    sizeXXL: t * (r + 10),
    sizeXL: t * (r + 6),
    sizeLG: t * (r + 2),
    sizeMD: t * (r + 2),
    sizeMS: t * (r + 1),
    size: t * r,
    sizeSM: t * r,
    sizeXS: t * (r - 1),
    sizeXXS: t * (r - 1)
  };
}
const RK = (e, t) => {
  const n = t ?? uf(e), r = n.fontSizeSM, i = n.controlHeight - 4;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, n), TK(t ?? e)), HD(r)), {
    // controlHeight
    controlHeight: i
  }), zD(Object.assign(Object.assign({}, n), {
    controlHeight: i
  })));
}, rs = (e, t) => new ir(e).setAlpha(t).toRgbString(), Wl = (e, t) => new ir(e).lighten(t).toHexString(), MK = (e) => {
  const t = Es(e, {
    theme: "dark"
  });
  return {
    1: t[0],
    2: t[1],
    3: t[2],
    4: t[3],
    5: t[6],
    6: t[5],
    7: t[4],
    8: t[6],
    9: t[5],
    10: t[4]
    // 8: colors[9],
    // 9: colors[8],
    // 10: colors[7],
  };
}, IK = (e, t) => {
  const n = e || "#000", r = t || "#fff";
  return {
    colorBgBase: n,
    colorTextBase: r,
    colorText: rs(r, 0.85),
    colorTextSecondary: rs(r, 0.65),
    colorTextTertiary: rs(r, 0.45),
    colorTextQuaternary: rs(r, 0.25),
    colorFill: rs(r, 0.18),
    colorFillSecondary: rs(r, 0.12),
    colorFillTertiary: rs(r, 0.08),
    colorFillQuaternary: rs(r, 0.04),
    colorBgElevated: Wl(n, 12),
    colorBgContainer: Wl(n, 8),
    colorBgLayout: Wl(n, 0),
    colorBgSpotlight: Wl(n, 26),
    colorBgBlur: rs(r, 0.04),
    colorBorder: Wl(n, 26),
    colorBorderSecondary: Wl(n, 19)
  };
}, kK = (e, t) => {
  const n = Object.keys(Dw).map((i) => {
    const o = Es(e[i], {
      theme: "dark"
    });
    return new Array(10).fill(1).reduce((s, a, l) => (s[`${i}-${l + 1}`] = o[l], s[`${i}${l + 1}`] = o[l], s), {});
  }).reduce((i, o) => (i = Object.assign(Object.assign({}, i), o), i), {}), r = t ?? uf(e);
  return Object.assign(Object.assign(Object.assign({}, r), n), jD(e, {
    generateColorPalettes: MK,
    generateNeutralColorPalettes: IK
  }));
};
function PK() {
  const [e, t, n] = Sr();
  return {
    theme: e,
    token: t,
    hashId: n
  };
}
const no = {
  /** @private Test Usage. Do not use in production. */
  defaultConfig: bd,
  /** Default seedToken */
  defaultSeed: bd.token,
  useToken: PK,
  defaultAlgorithm: uf,
  darkAlgorithm: kK,
  compactAlgorithm: RK,
  getDesignToken: _K
};
var NK = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" } }] }, name: "delete", theme: "outlined" }, LK = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: NK
  }));
}, lu = /* @__PURE__ */ O.forwardRef(LK);
process.env.NODE_ENV !== "production" && (lu.displayName = "DeleteOutlined");
var FK = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const BK = {
  border: 0,
  background: "transparent",
  padding: 0,
  lineHeight: "inherit",
  display: "inline-block"
}, HM = /* @__PURE__ */ O.forwardRef((e, t) => {
  const n = (u) => {
    const {
      keyCode: c
    } = u;
    c === xe.ENTER && u.preventDefault();
  }, r = (u) => {
    const {
      keyCode: c
    } = u, {
      onClick: d
    } = e;
    c === xe.ENTER && d && d();
  }, {
    style: i,
    noStyle: o,
    disabled: s
  } = e, a = FK(e, ["style", "noStyle", "disabled"]);
  let l = {};
  return o || (l = Object.assign({}, BK)), s && (l.pointerEvents = "none"), l = Object.assign(Object.assign({}, l), i), /* @__PURE__ */ O.createElement("div", Object.assign({
    role: "button",
    tabIndex: 0,
    ref: t
  }, a, {
    onKeyDown: n,
    onKeyUp: r,
    style: l
  }));
});
var jK = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" } }] }, name: "edit", theme: "outlined" }, zK = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: jK
  }));
}, VM = /* @__PURE__ */ O.forwardRef(zK);
process.env.NODE_ENV !== "production" && (VM.displayName = "EditOutlined");
var HK = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z" } }] }, name: "enter", theme: "outlined" }, VK = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: HK
  }));
}, WM = /* @__PURE__ */ O.forwardRef(VK);
process.env.NODE_ENV !== "production" && (WM.displayName = "EnterOutlined");
const WK = (e, t, n, r) => {
  const {
    titleMarginBottom: i,
    fontWeightStrong: o
  } = r;
  return {
    marginBottom: i,
    color: n,
    fontWeight: o,
    fontSize: e,
    lineHeight: t
  };
}, UK = (e) => {
  const t = [1, 2, 3, 4, 5], n = {};
  return t.forEach((r) => {
    n[`
      h${r}&,
      div&-h${r},
      div&-h${r} > textarea,
      h${r}
    `] = WK(e[`fontSizeHeading${r}`], e[`lineHeightHeading${r}`], e.colorTextHeading, e);
  }), n;
}, GK = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    "a&, a": Object.assign(Object.assign({}, QD(e)), {
      textDecoration: e.linkDecoration,
      "&:active, &:hover": {
        textDecoration: e.linkHoverDecoration
      },
      [`&[disabled], &${t}-disabled`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed",
        "&:active, &:hover": {
          color: e.colorTextDisabled
        },
        "&:active": {
          pointerEvents: "none"
        }
      }
    })
  };
}, KK = (e) => ({
  code: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.2em 0.1em",
    fontSize: "85%",
    fontFamily: e.fontFamilyCode,
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3
  },
  kbd: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.15em 0.1em",
    fontSize: "90%",
    fontFamily: e.fontFamilyCode,
    background: "rgba(150, 150, 150, 0.06)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderBottomWidth: 2,
    borderRadius: 3
  },
  mark: {
    padding: 0,
    // FIXME hardcode in v4
    backgroundColor: S3[2]
  },
  "u, ins": {
    textDecoration: "underline",
    textDecorationSkipInk: "auto"
  },
  "s, del": {
    textDecoration: "line-through"
  },
  strong: {
    fontWeight: 600
  },
  // list
  "ul, ol": {
    marginInline: 0,
    marginBlock: "0 1em",
    padding: 0,
    li: {
      marginInline: "20px 0",
      marginBlock: 0,
      paddingInline: "4px 0",
      paddingBlock: 0
    }
  },
  ul: {
    listStyleType: "circle",
    ul: {
      listStyleType: "disc"
    }
  },
  ol: {
    listStyleType: "decimal"
  },
  // pre & block
  "pre, blockquote": {
    margin: "1em 0"
  },
  pre: {
    padding: "0.4em 0.6em",
    whiteSpace: "pre-wrap",
    wordWrap: "break-word",
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3,
    fontFamily: e.fontFamilyCode,
    // Compatible for marked
    code: {
      display: "inline",
      margin: 0,
      padding: 0,
      fontSize: "inherit",
      fontFamily: "inherit",
      background: "transparent",
      border: 0
    }
  },
  blockquote: {
    paddingInline: "0.6em 0",
    paddingBlock: 0,
    borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
    opacity: 0.85
  }
}), XK = (e) => {
  const {
    componentCls: t,
    paddingSM: n
  } = e, r = n;
  return {
    "&-edit-content": {
      position: "relative",
      "div&": {
        insetInlineStart: e.calc(e.paddingSM).mul(-1).equal(),
        marginTop: e.calc(r).mul(-1).equal(),
        marginBottom: `calc(1em - ${le(r)})`
      },
      [`${t}-edit-content-confirm`]: {
        position: "absolute",
        insetInlineEnd: e.calc(e.marginXS).add(2).equal(),
        insetBlockEnd: e.marginXS,
        color: e.colorTextDescription,
        // default style
        fontWeight: "normal",
        fontSize: e.fontSize,
        fontStyle: "normal",
        pointerEvents: "none"
      },
      textarea: {
        margin: "0!important",
        // Fix Editable Textarea flash in Firefox
        MozTransition: "none",
        height: "1em"
      }
    }
  };
}, YK = (e) => ({
  [`${e.componentCls}-copy-success`]: {
    "\n    &,\n    &:hover,\n    &:focus": {
      color: e.colorSuccess
    }
  },
  [`${e.componentCls}-copy-icon-only`]: {
    marginInlineStart: 0
  }
}), qK = () => ({
  "\n  a&-ellipsis,\n  span&-ellipsis\n  ": {
    display: "inline-block",
    maxWidth: "100%"
  },
  "&-single-line": {
    whiteSpace: "nowrap"
  },
  "&-ellipsis-single-line": {
    overflow: "hidden",
    textOverflow: "ellipsis",
    // https://blog.csdn.net/iefreer/article/details/50421025
    "a&, span&": {
      verticalAlign: "bottom"
    },
    "> code": {
      paddingBlock: 0,
      maxWidth: "calc(100% - 1.2em)",
      display: "inline-block",
      overflow: "hidden",
      textOverflow: "ellipsis",
      verticalAlign: "bottom",
      // https://github.com/ant-design/ant-design/issues/45953
      boxSizing: "content-box"
    }
  },
  "&-ellipsis-multiple-line": {
    display: "-webkit-box",
    overflow: "hidden",
    WebkitLineClamp: 3,
    WebkitBoxOrient: "vertical"
  }
}), QK = (e) => {
  const {
    componentCls: t,
    titleMarginTop: n
  } = e;
  return {
    [t]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      color: e.colorText,
      wordBreak: "break-word",
      lineHeight: e.lineHeight,
      [`&${t}-secondary`]: {
        color: e.colorTextDescription
      },
      [`&${t}-success`]: {
        color: e.colorSuccess
      },
      [`&${t}-warning`]: {
        color: e.colorWarning
      },
      [`&${t}-danger`]: {
        color: e.colorError,
        "a&:active, a&:focus": {
          color: e.colorErrorActive
        },
        "a&:hover": {
          color: e.colorErrorHover
        }
      },
      [`&${t}-disabled`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed",
        userSelect: "none"
      },
      "\n        div&,\n        p\n      ": {
        marginBottom: "1em"
      }
    }, UK(e)), {
      [`
      & + h1${t},
      & + h2${t},
      & + h3${t},
      & + h4${t},
      & + h5${t}
      `]: {
        marginTop: n
      },
      "\n      div,\n      ul,\n      li,\n      p,\n      h1,\n      h2,\n      h3,\n      h4,\n      h5": {
        "\n        + h1,\n        + h2,\n        + h3,\n        + h4,\n        + h5\n        ": {
          marginTop: n
        }
      }
    }), KK(e)), GK(e)), {
      // Operation
      [`
        ${t}-expand,
        ${t}-collapse,
        ${t}-edit,
        ${t}-copy
      `]: Object.assign(Object.assign({}, QD(e)), {
        marginInlineStart: e.marginXXS
      })
    }), XK(e)), YK(e)), qK()), {
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
}, ZK = () => ({
  titleMarginTop: "1.2em",
  titleMarginBottom: "0.5em"
}), UM = $n("Typography", (e) => [QK(e)], ZK), JK = (e) => {
  const {
    prefixCls: t,
    "aria-label": n,
    className: r,
    style: i,
    direction: o,
    maxLength: s,
    autoSize: a = !0,
    value: l,
    onSave: u,
    onCancel: c,
    onEnd: d,
    component: f,
    enterIcon: h = /* @__PURE__ */ O.createElement(WM, null)
  } = e, p = O.useRef(null), g = O.useRef(!1), m = O.useRef(), [v, b] = O.useState(l);
  O.useEffect(() => {
    b(l);
  }, [l]), O.useEffect(() => {
    if (p.current && p.current.resizableTextArea) {
      const {
        textArea: R
      } = p.current.resizableTextArea;
      R.focus();
      const {
        length: I
      } = R.value;
      R.setSelectionRange(I, I);
    }
  }, []);
  const x = (R) => {
    let {
      target: I
    } = R;
    b(I.value.replace(/[\n\r]/g, ""));
  }, w = () => {
    g.current = !0;
  }, C = () => {
    g.current = !1;
  }, y = (R) => {
    let {
      keyCode: I
    } = R;
    g.current || (m.current = I);
  }, S = () => {
    u(v.trim());
  }, A = (R) => {
    let {
      keyCode: I,
      ctrlKey: k,
      altKey: P,
      metaKey: L,
      shiftKey: N
    } = R;
    m.current === I && !g.current && !k && !P && !L && !N && (I === xe.ENTER ? (S(), d == null || d()) : I === xe.ESC && c());
  }, $ = () => {
    S();
  }, M = f ? `${t}-${f}` : "", [_, T, D] = UM(t), E = se(t, `${t}-edit-content`, {
    [`${t}-rtl`]: o === "rtl"
  }, r, M, T, D);
  return _(/* @__PURE__ */ O.createElement("div", {
    className: E,
    style: i
  }, /* @__PURE__ */ O.createElement($M, {
    ref: p,
    maxLength: s,
    value: v,
    onChange: x,
    onKeyDown: y,
    onKeyUp: A,
    onCompositionStart: w,
    onCompositionEnd: C,
    onBlur: $,
    "aria-label": n,
    rows: 1,
    autoSize: a
  }), h !== null ? oi(h, {
    className: `${t}-edit-content-confirm`
  }) : null));
};
var eX = function() {
  var e = document.getSelection();
  if (!e.rangeCount)
    return function() {
    };
  for (var t = document.activeElement, n = [], r = 0; r < e.rangeCount; r++)
    n.push(e.getRangeAt(r));
  switch (t.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      t.blur();
      break;
    default:
      t = null;
      break;
  }
  return e.removeAllRanges(), function() {
    e.type === "Caret" && e.removeAllRanges(), e.rangeCount || n.forEach(function(i) {
      e.addRange(i);
    }), t && t.focus();
  };
}, tX = eX, GE = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
}, nX = "Copy to clipboard: #{key}, Enter";
function rX(e) {
  var t = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
  return e.replace(/#{\s*key\s*}/g, t);
}
function iX(e, t) {
  var n, r, i, o, s, a, l = !1;
  t || (t = {}), n = t.debug || !1;
  try {
    i = tX(), o = document.createRange(), s = document.getSelection(), a = document.createElement("span"), a.textContent = e, a.ariaHidden = "true", a.style.all = "unset", a.style.position = "fixed", a.style.top = 0, a.style.clip = "rect(0, 0, 0, 0)", a.style.whiteSpace = "pre", a.style.webkitUserSelect = "text", a.style.MozUserSelect = "text", a.style.msUserSelect = "text", a.style.userSelect = "text", a.addEventListener("copy", function(c) {
      if (c.stopPropagation(), t.format)
        if (c.preventDefault(), typeof c.clipboardData > "u") {
          n && console.warn("unable to use e.clipboardData"), n && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
          var d = GE[t.format] || GE.default;
          window.clipboardData.setData(d, e);
        } else
          c.clipboardData.clearData(), c.clipboardData.setData(t.format, e);
      t.onCopy && (c.preventDefault(), t.onCopy(c.clipboardData));
    }), document.body.appendChild(a), o.selectNodeContents(a), s.addRange(o);
    var u = document.execCommand("copy");
    if (!u)
      throw new Error("copy command was unsuccessful");
    l = !0;
  } catch (c) {
    n && console.error("unable to copy using execCommand: ", c), n && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(t.format || "text", e), t.onCopy && t.onCopy(window.clipboardData), l = !0;
    } catch (d) {
      n && console.error("unable to copy using clipboardData: ", d), n && console.error("falling back to prompt"), r = rX("message" in t ? t.message : nX), window.prompt(r, e);
    }
  } finally {
    s && (typeof s.removeRange == "function" ? s.removeRange(o) : s.removeAllRanges()), a && document.body.removeChild(a), i();
  }
  return l;
}
var oX = iX;
const sX = /* @__PURE__ */ hl(oX);
var aX = function(e, t, n, r) {
  function i(o) {
    return o instanceof n ? o : new n(function(s) {
      s(o);
    });
  }
  return new (n || (n = Promise))(function(o, s) {
    function a(c) {
      try {
        u(r.next(c));
      } catch (d) {
        s(d);
      }
    }
    function l(c) {
      try {
        u(r.throw(c));
      } catch (d) {
        s(d);
      }
    }
    function u(c) {
      c.done ? o(c.value) : i(c.value).then(a, l);
    }
    u((r = r.apply(e, t || [])).next());
  });
};
const lX = (e) => {
  let {
    copyConfig: t,
    children: n
  } = e;
  const [r, i] = O.useState(!1), [o, s] = O.useState(!1), a = O.useRef(null), l = () => {
    a.current && clearTimeout(a.current);
  }, u = {};
  t.format && (u.format = t.format), O.useEffect(() => l, []);
  const c = Nn((d) => aX(void 0, void 0, void 0, function* () {
    var f;
    d == null || d.preventDefault(), d == null || d.stopPropagation(), s(!0);
    try {
      const h = typeof t.text == "function" ? yield t.text() : t.text;
      sX(h || String(n) || "", u), s(!1), i(!0), l(), a.current = setTimeout(() => {
        i(!1);
      }, 3e3), (f = t.onCopy) === null || f === void 0 || f.call(t, d);
    } catch (h) {
      throw s(!1), h;
    }
  }));
  return {
    copied: r,
    copyLoading: o,
    onClick: c
  };
};
function vv(e, t) {
  return O.useMemo(() => {
    const n = !!e;
    return [n, Object.assign(Object.assign({}, t), n && typeof e == "object" ? e : null)];
  }, [e]);
}
const cX = (e, t) => {
  const n = O.useRef(!1);
  O.useEffect(() => {
    n.current ? e() : n.current = !0;
  }, t);
};
var uX = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const L1 = /* @__PURE__ */ O.forwardRef((e, t) => {
  const {
    prefixCls: n,
    component: r = "article",
    className: i,
    rootClassName: o,
    setContentRef: s,
    children: a,
    direction: l,
    style: u
  } = e, c = uX(e, ["prefixCls", "component", "className", "rootClassName", "setContentRef", "children", "direction", "style"]), {
    getPrefixCls: d,
    direction: f,
    typography: h
  } = O.useContext(rt), p = l ?? f;
  let g = t;
  s && (g = xi(t, s)), process.env.NODE_ENV !== "production" && Zt("Typography").deprecated(!s, "setContentRef", "ref");
  const m = d("typography", n), [v, b, x] = UM(m), w = se(m, h == null ? void 0 : h.className, {
    [`${m}-rtl`]: p === "rtl"
  }, i, o, b, x), C = Object.assign(Object.assign({}, h == null ? void 0 : h.style), u);
  return v(
    // @ts-expect-error: Expression produces a union type that is too complex to represent.
    /* @__PURE__ */ O.createElement(r, Object.assign({
      className: w,
      style: C,
      ref: g
    }, c), a)
  );
});
process.env.NODE_ENV !== "production" && (L1.displayName = "Typography");
var dX = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, name: "copy", theme: "outlined" }, fX = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: dX
  }));
}, F1 = /* @__PURE__ */ O.forwardRef(fX);
process.env.NODE_ENV !== "production" && (F1.displayName = "CopyOutlined");
function KE(e) {
  return e === !1 ? [!1, !1] : Array.isArray(e) ? e : [e];
}
function rh(e, t, n) {
  return e === !0 || e === void 0 ? t : e || n && t;
}
function hX(e) {
  const {
    prefixCls: t,
    copied: n,
    locale: r = {},
    onCopy: i,
    iconOnly: o,
    tooltips: s,
    icon: a,
    loading: l
  } = e, u = KE(s), c = KE(a), {
    copied: d,
    copy: f
  } = r, h = n ? rh(u[1], d) : rh(u[0], f), g = typeof h == "string" ? h : n ? d : f;
  return /* @__PURE__ */ O.createElement(lr, {
    key: "copy",
    title: h
  }, /* @__PURE__ */ O.createElement(HM, {
    className: se(`${t}-copy`, {
      [`${t}-copy-success`]: n,
      [`${t}-copy-icon-only`]: o
    }),
    onClick: i,
    "aria-label": g
  }, n ? rh(c[1], /* @__PURE__ */ O.createElement(f1, null), !0) : rh(c[0], l ? /* @__PURE__ */ O.createElement(wl, null) : /* @__PURE__ */ O.createElement(F1, null), !0)));
}
const ih = /* @__PURE__ */ O.forwardRef((e, t) => {
  let {
    style: n,
    children: r
  } = e;
  const i = O.useRef(null);
  return O.useImperativeHandle(t, () => ({
    isExceed: () => {
      const o = i.current;
      return o.scrollHeight > o.clientHeight;
    },
    getHeight: () => i.current.clientHeight
  })), /* @__PURE__ */ O.createElement("span", {
    "aria-hidden": !0,
    ref: i,
    style: Object.assign({
      position: "fixed",
      display: "block",
      left: 0,
      top: 0,
      pointerEvents: "none",
      backgroundColor: "rgba(255, 0, 0, 0.65)"
    }, n)
  }, r);
});
function GM(e) {
  const t = typeof e;
  return t === "string" || t === "number";
}
function pX(e) {
  let t = 0;
  return e.forEach((n) => {
    GM(n) ? t += String(n).length : t += 1;
  }), t;
}
function XE(e, t) {
  let n = 0;
  const r = [];
  for (let i = 0; i < e.length; i += 1) {
    if (n === t)
      return r;
    const o = e[i], a = GM(o) ? String(o).length : 1, l = n + a;
    if (l > t) {
      const u = t - n;
      return r.push(String(o).slice(0, u)), r;
    }
    r.push(o), n = l;
  }
  return e;
}
const bv = 0, yv = 1, wv = 2, YE = 3, oh = {
  display: "-webkit-box",
  overflow: "hidden",
  WebkitBoxOrient: "vertical"
};
function gX(e) {
  const {
    enableMeasure: t,
    width: n,
    text: r,
    children: i,
    rows: o,
    expanded: s,
    miscDeps: a,
    onEllipsis: l
  } = e, u = O.useMemo(() => Xr(r), [r]), c = O.useMemo(() => pX(u), [r]), d = O.useMemo(() => i(u, !1), [r]), [f, h] = O.useState(null), p = O.useRef(null), g = O.useRef(null), m = O.useRef(null), v = O.useRef(null), [b, x] = O.useState(!1), [w, C] = O.useState(bv), [y, S] = O.useState(0);
  sn(() => {
    C(t && n && c ? yv : bv);
  }, [n, r, o, t, u]), sn(() => {
    var _, T, D, E;
    if (w === yv) {
      const R = !!(!((_ = g.current) === null || _ === void 0) && _.isExceed());
      C(R ? wv : YE), h(R ? [0, c] : null), x(R);
      const I = ((T = g.current) === null || T === void 0 ? void 0 : T.getHeight()) || 0, k = o === 1 ? 0 : ((D = m.current) === null || D === void 0 ? void 0 : D.getHeight()) || 0, P = ((E = v.current) === null || E === void 0 ? void 0 : E.getHeight()) || 0, L = k + P, N = Math.max(I, L);
      S(N + 1), l(R);
    }
  }, [w]);
  const A = f ? Math.ceil((f[0] + f[1]) / 2) : 0;
  sn(() => {
    var _;
    const [T, D] = f || [0, 0];
    if (T !== D) {
      const R = (((_ = p.current) === null || _ === void 0 ? void 0 : _.getHeight()) || 0) > y;
      let I = A;
      D - T === 1 && (I = R ? T : D), h(R ? [T, I] : [I, D]);
    }
  }, [f, A]);
  const $ = O.useMemo(() => {
    if (w !== wv || !f || f[0] !== f[1]) {
      const _ = i(u, !1);
      return w !== YE && w !== bv ? /* @__PURE__ */ O.createElement("span", {
        style: Object.assign(Object.assign({}, oh), {
          WebkitLineClamp: o
        })
      }, _) : _;
    }
    return i(s ? u : XE(u, f[0]), b);
  }, [s, w, f, u].concat(_e(a))), M = {
    width: n,
    whiteSpace: "normal",
    margin: 0,
    padding: 0
  };
  return /* @__PURE__ */ O.createElement(O.Fragment, null, $, w === yv && /* @__PURE__ */ O.createElement(O.Fragment, null, /* @__PURE__ */ O.createElement(ih, {
    style: Object.assign(Object.assign(Object.assign({}, M), oh), {
      WebkitLineClamp: o
    }),
    ref: g
  }, d), /* @__PURE__ */ O.createElement(ih, {
    style: Object.assign(Object.assign(Object.assign({}, M), oh), {
      WebkitLineClamp: o - 1
    }),
    ref: m
  }, d), /* @__PURE__ */ O.createElement(ih, {
    style: Object.assign(Object.assign(Object.assign({}, M), oh), {
      WebkitLineClamp: 1
    }),
    ref: v
  }, i([], !0))), w === wv && f && f[0] !== f[1] && /* @__PURE__ */ O.createElement(ih, {
    style: Object.assign(Object.assign({}, M), {
      top: 400
    }),
    ref: p
  }, i(XE(u, A), !0)));
}
const KM = (e) => {
  let {
    enableEllipsis: t,
    isEllipsis: n,
    children: r,
    tooltipProps: i
  } = e;
  return !(i != null && i.title) || !t ? r : /* @__PURE__ */ O.createElement(lr, Object.assign({
    open: n ? void 0 : !1
  }, i), r);
};
process.env.NODE_ENV !== "production" && (KM.displayName = "EllipsisTooltip");
var mX = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
function vX(e, t) {
  let {
    mark: n,
    code: r,
    underline: i,
    delete: o,
    strong: s,
    keyboard: a,
    italic: l
  } = e, u = t;
  function c(d, f) {
    f && (u = /* @__PURE__ */ O.createElement(d, {}, u));
  }
  return c("strong", s), c("u", i), c("del", o), c("code", r), c("mark", n), c("kbd", a), c("i", l), u;
}
const bX = "...", om = /* @__PURE__ */ O.forwardRef((e, t) => {
  var n, r, i;
  const {
    prefixCls: o,
    className: s,
    style: a,
    type: l,
    disabled: u,
    children: c,
    ellipsis: d,
    editable: f,
    copyable: h,
    component: p,
    title: g
  } = e, m = mX(e, ["prefixCls", "className", "style", "type", "disabled", "children", "ellipsis", "editable", "copyable", "component", "title"]), {
    getPrefixCls: v,
    direction: b
  } = O.useContext(rt), [x] = ml("Text"), w = O.useRef(null), C = O.useRef(null), y = v("typography", o), S = zn(m, ["mark", "code", "delete", "underline", "strong", "keyboard", "italic"]), [A, $] = vv(f), [M, _] = Un(!1, {
    value: $.editing
  }), {
    triggerType: T = ["icon"]
  } = $, D = ($e) => {
    var ze;
    $e && ((ze = $.onStart) === null || ze === void 0 || ze.call($)), _($e);
  };
  cX(() => {
    var $e;
    M || ($e = C.current) === null || $e === void 0 || $e.focus();
  }, [M]);
  const E = ($e) => {
    $e == null || $e.preventDefault(), D(!0);
  }, R = ($e) => {
    var ze;
    (ze = $.onChange) === null || ze === void 0 || ze.call($, $e), D(!1);
  }, I = () => {
    var $e;
    ($e = $.onCancel) === null || $e === void 0 || $e.call($), D(!1);
  }, [k, P] = vv(h), {
    copied: L,
    copyLoading: N,
    onClick: F
  } = lX({
    copyConfig: P,
    children: c
  }), [B, j] = O.useState(!1), [z, H] = O.useState(!1), [W, G] = O.useState(!1), [K, Y] = O.useState(!1), [X, Z] = O.useState(!0), [Q, ne] = vv(d, {
    expandable: !1,
    symbol: ($e) => $e ? x == null ? void 0 : x.collapse : x == null ? void 0 : x.expand
  }), [q, te] = Un(ne.defaultExpanded || !1, {
    value: ne.expanded
  }), fe = Q && (!q || ne.expandable === "collapsible"), {
    rows: Se = 1
  } = ne, de = O.useMemo(() => (
    // Disable ellipsis
    fe && // Provide suffix
    (ne.suffix !== void 0 || ne.onEllipsis || // Can't use css ellipsis since we need to provide the place for button
    ne.expandable || A || k)
  ), [fe, ne, A, k]);
  sn(() => {
    Q && !de && (j(Sx("webkitLineClamp")), H(Sx("textOverflow")));
  }, [de, Q]);
  const [ce, pe] = O.useState(fe), Oe = O.useMemo(() => de ? !1 : Se === 1 ? z : B, [de, z, B]);
  sn(() => {
    pe(Oe && fe);
  }, [Oe, fe]);
  const Re = fe && (ce ? K : W), De = fe && Se === 1 && ce, Me = fe && Se > 1 && ce, Ue = ($e, ze) => {
    var at;
    te(ze.expanded), (at = ne.onExpand) === null || at === void 0 || at.call(ne, $e, ze);
  }, [oe, Ce] = O.useState(0), ge = ($e) => {
    let {
      offsetWidth: ze
    } = $e;
    Ce(ze);
  }, ve = ($e) => {
    var ze;
    G($e), W !== $e && ((ze = ne.onEllipsis) === null || ze === void 0 || ze.call(ne, $e));
  };
  O.useEffect(() => {
    const $e = w.current;
    if (Q && ce && $e) {
      const ze = Me ? $e.offsetHeight < $e.scrollHeight : $e.offsetWidth < $e.scrollWidth;
      K !== ze && Y(ze);
    }
  }, [Q, ce, c, Me, X, oe]), O.useEffect(() => {
    const $e = w.current;
    if (typeof IntersectionObserver > "u" || !$e || !ce || !fe)
      return;
    const ze = new IntersectionObserver(() => {
      Z(!!$e.offsetParent);
    });
    return ze.observe($e), () => {
      ze.disconnect();
    };
  }, [ce, fe]);
  let me = {};
  ne.tooltip === !0 ? me = {
    title: (n = $.text) !== null && n !== void 0 ? n : c
  } : /* @__PURE__ */ O.isValidElement(ne.tooltip) ? me = {
    title: ne.tooltip
  } : typeof ne.tooltip == "object" ? me = Object.assign({
    title: (r = $.text) !== null && r !== void 0 ? r : c
  }, ne.tooltip) : me = {
    title: ne.tooltip
  };
  const Fe = O.useMemo(() => {
    const $e = (ze) => ["string", "number"].includes(typeof ze);
    if (!(!Q || ce)) {
      if ($e($.text))
        return $.text;
      if ($e(c))
        return c;
      if ($e(g))
        return g;
      if ($e(me.title))
        return me.title;
    }
  }, [Q, ce, g, me.title, Re]);
  if (M)
    return /* @__PURE__ */ O.createElement(JK, {
      value: (i = $.text) !== null && i !== void 0 ? i : typeof c == "string" ? c : "",
      onSave: R,
      onCancel: I,
      onEnd: $.onEnd,
      prefixCls: y,
      className: s,
      style: a,
      direction: b,
      component: p,
      maxLength: $.maxLength,
      autoSize: $.autoSize,
      enterIcon: $.enterIcon
    });
  const Be = () => {
    const {
      expandable: $e,
      symbol: ze
    } = ne;
    return !$e || q && $e !== "collapsible" ? null : /* @__PURE__ */ O.createElement("a", {
      key: "expand",
      className: `${y}-${q ? "collapse" : "expand"}`,
      onClick: (at) => Ue(at, {
        expanded: !q
      }),
      "aria-label": q ? x.collapse : x == null ? void 0 : x.expand
    }, typeof ze == "function" ? ze(q) : ze);
  }, qe = () => {
    if (!A)
      return;
    const {
      icon: $e,
      tooltip: ze
    } = $, at = Xr(ze)[0] || (x == null ? void 0 : x.edit), xt = typeof at == "string" ? at : "";
    return T.includes("icon") ? /* @__PURE__ */ O.createElement(lr, {
      key: "edit",
      title: ze === !1 ? "" : at
    }, /* @__PURE__ */ O.createElement(HM, {
      ref: C,
      className: `${y}-edit`,
      onClick: E,
      "aria-label": xt
    }, $e || /* @__PURE__ */ O.createElement(VM, {
      role: "button"
    }))) : null;
  }, Ve = () => k ? /* @__PURE__ */ O.createElement(hX, Object.assign({
    key: "copy"
  }, P, {
    prefixCls: y,
    copied: L,
    locale: x,
    onCopy: F,
    loading: N,
    iconOnly: c == null
  })) : null, We = ($e) => [
    // (renderExpanded || ellipsisConfig.collapsible) && renderExpand(),
    $e && Be(),
    qe(),
    Ve()
  ], Ge = ($e) => [$e && !q && /* @__PURE__ */ O.createElement("span", {
    "aria-hidden": !0,
    key: "ellipsis"
  }, bX), ne.suffix, We($e)];
  return /* @__PURE__ */ O.createElement(Ci, {
    onResize: ge,
    disabled: !fe
  }, ($e) => /* @__PURE__ */ O.createElement(KM, {
    tooltipProps: me,
    enableEllipsis: fe,
    isEllipsis: Re
  }, /* @__PURE__ */ O.createElement(L1, Object.assign({
    className: se({
      [`${y}-${l}`]: l,
      [`${y}-disabled`]: u,
      [`${y}-ellipsis`]: Q,
      [`${y}-single-line`]: fe && Se === 1 && !q,
      [`${y}-ellipsis-single-line`]: De,
      [`${y}-ellipsis-multiple-line`]: Me
    }, s),
    prefixCls: o,
    style: Object.assign(Object.assign({}, a), {
      WebkitLineClamp: Me ? Se : void 0
    }),
    component: p,
    ref: xi($e, w, t),
    direction: b,
    onClick: T.includes("text") ? E : void 0,
    "aria-label": Fe == null ? void 0 : Fe.toString(),
    title: g
  }, S), /* @__PURE__ */ O.createElement(gX, {
    enableMeasure: fe && !ce,
    text: c,
    rows: Se,
    width: oe,
    onEllipsis: ve,
    expanded: q,
    miscDeps: [L, q, N, A, k]
  }, (ze, at) => {
    let xt = ze;
    return ze.length && at && !q && Fe && (xt = /* @__PURE__ */ O.createElement("span", {
      key: "show-content",
      "aria-hidden": !0
    }, xt)), vX(e, /* @__PURE__ */ O.createElement(O.Fragment, null, xt, Ge(at)));
  }))));
});
var yX = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const wX = /* @__PURE__ */ O.forwardRef((e, t) => {
  var {
    ellipsis: n,
    rel: r
  } = e, i = yX(e, ["ellipsis", "rel"]);
  if (process.env.NODE_ENV !== "production") {
    const s = Zt("Typography.Link");
    process.env.NODE_ENV !== "production" && s(typeof n != "object", "usage", "`ellipsis` only supports boolean value.");
  }
  const o = Object.assign(Object.assign({}, i), {
    rel: r === void 0 && i.target === "_blank" ? "noopener noreferrer" : r
  });
  return delete o.navigate, /* @__PURE__ */ O.createElement(om, Object.assign({}, o, {
    ref: t,
    ellipsis: !!n,
    component: "a"
  }));
}), CX = /* @__PURE__ */ O.forwardRef((e, t) => /* @__PURE__ */ O.createElement(om, Object.assign({
  ref: t
}, e, {
  component: "div"
})));
var SX = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const xX = (e, t) => {
  var {
    ellipsis: n
  } = e, r = SX(e, ["ellipsis"]);
  const i = O.useMemo(() => n && typeof n == "object" ? zn(n, ["expandable", "rows"]) : n, [n]);
  if (process.env.NODE_ENV !== "production") {
    const o = Zt("Typography.Text");
    process.env.NODE_ENV !== "production" && o(typeof n != "object" || !n || !("expandable" in n) && !("rows" in n), "usage", "`ellipsis` do not support `expandable` or `rows` props.");
  }
  return /* @__PURE__ */ O.createElement(om, Object.assign({
    ref: t
  }, r, {
    ellipsis: i,
    component: "span"
  }));
}, EX = /* @__PURE__ */ O.forwardRef(xX);
var $X = function(e, t) {
  var n = {};
  for (var r in e)
    Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(e); i < r.length; i++)
      t.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[i]) && (n[r[i]] = e[r[i]]);
  return n;
};
const qE = [1, 2, 3, 4, 5], OX = /* @__PURE__ */ O.forwardRef((e, t) => {
  const {
    level: n = 1
  } = e, r = $X(e, ["level"]);
  let i;
  if (process.env.NODE_ENV !== "production") {
    const o = Zt("Typography.Title");
    process.env.NODE_ENV !== "production" && o(qE.includes(n), "usage", "Title only accept `1 | 2 | 3 | 4 | 5` as `level` value. And `5` need 4.6.0+ version.");
  }
  return qE.includes(n) ? i = `h${n}` : i = "h1", /* @__PURE__ */ O.createElement(om, Object.assign({
    ref: t
  }, r, {
    component: i
  }));
}), Bt = L1;
Bt.Text = EX;
Bt.Link = wX;
Bt.Title = OX;
Bt.Paragraph = CX;
const XM = Yo({
  dragDropManager: void 0
});
function Xi(e) {
  return "Minified Redux error #" + e + "; visit https://redux.js.org/Errors?code=" + e + " for the full message or use the non-minified dev environment for full errors. ";
}
var QE = function() {
  return typeof Symbol == "function" && Symbol.observable || "@@observable";
}(), Cv = function() {
  return Math.random().toString(36).substring(7).split("").join(".");
}, ZE = {
  INIT: "@@redux/INIT" + Cv(),
  REPLACE: "@@redux/REPLACE" + Cv(),
  PROBE_UNKNOWN_ACTION: function() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + Cv();
  }
};
function AX(e) {
  if (typeof e != "object" || e === null)
    return !1;
  for (var t = e; Object.getPrototypeOf(t) !== null; )
    t = Object.getPrototypeOf(t);
  return Object.getPrototypeOf(e) === t;
}
function DX(e) {
  if (e === void 0)
    return "undefined";
  if (e === null)
    return "null";
  var t = typeof e;
  switch (t) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function":
      return t;
  }
  if (Array.isArray(e))
    return "array";
  if (RX(e))
    return "date";
  if (TX(e))
    return "error";
  var n = _X(e);
  switch (n) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return n;
  }
  return t.slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function _X(e) {
  return typeof e.constructor == "function" ? e.constructor.name : null;
}
function TX(e) {
  return e instanceof Error || typeof e.message == "string" && e.constructor && typeof e.constructor.stackTraceLimit == "number";
}
function RX(e) {
  return e instanceof Date ? !0 : typeof e.toDateString == "function" && typeof e.getDate == "function" && typeof e.setDate == "function";
}
function Ul(e) {
  var t = typeof e;
  return process.env.NODE_ENV !== "production" && (t = DX(e)), t;
}
function YM(e, t, n) {
  var r;
  if (typeof t == "function" && typeof n == "function" || typeof n == "function" && typeof arguments[3] == "function")
    throw new Error(process.env.NODE_ENV === "production" ? Xi(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  if (typeof t == "function" && typeof n > "u" && (n = t, t = void 0), typeof n < "u") {
    if (typeof n != "function")
      throw new Error(process.env.NODE_ENV === "production" ? Xi(1) : "Expected the enhancer to be a function. Instead, received: '" + Ul(n) + "'");
    return n(YM)(e, t);
  }
  if (typeof e != "function")
    throw new Error(process.env.NODE_ENV === "production" ? Xi(2) : "Expected the root reducer to be a function. Instead, received: '" + Ul(e) + "'");
  var i = e, o = t, s = [], a = s, l = !1;
  function u() {
    a === s && (a = s.slice());
  }
  function c() {
    if (l)
      throw new Error(process.env.NODE_ENV === "production" ? Xi(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    return o;
  }
  function d(g) {
    if (typeof g != "function")
      throw new Error(process.env.NODE_ENV === "production" ? Xi(4) : "Expected the listener to be a function. Instead, received: '" + Ul(g) + "'");
    if (l)
      throw new Error(process.env.NODE_ENV === "production" ? Xi(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    var m = !0;
    return u(), a.push(g), function() {
      if (m) {
        if (l)
          throw new Error(process.env.NODE_ENV === "production" ? Xi(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
        m = !1, u();
        var b = a.indexOf(g);
        a.splice(b, 1), s = null;
      }
    };
  }
  function f(g) {
    if (!AX(g))
      throw new Error(process.env.NODE_ENV === "production" ? Xi(7) : "Actions must be plain objects. Instead, the actual type was: '" + Ul(g) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    if (typeof g.type > "u")
      throw new Error(process.env.NODE_ENV === "production" ? Xi(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    if (l)
      throw new Error(process.env.NODE_ENV === "production" ? Xi(9) : "Reducers may not dispatch actions.");
    try {
      l = !0, o = i(o, g);
    } finally {
      l = !1;
    }
    for (var m = s = a, v = 0; v < m.length; v++) {
      var b = m[v];
      b();
    }
    return g;
  }
  function h(g) {
    if (typeof g != "function")
      throw new Error(process.env.NODE_ENV === "production" ? Xi(10) : "Expected the nextReducer to be a function. Instead, received: '" + Ul(g));
    i = g, f({
      type: ZE.REPLACE
    });
  }
  function p() {
    var g, m = d;
    return g = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function(b) {
        if (typeof b != "object" || b === null)
          throw new Error(process.env.NODE_ENV === "production" ? Xi(11) : "Expected the observer to be an object. Instead, received: '" + Ul(b) + "'");
        function x() {
          b.next && b.next(c());
        }
        x();
        var w = m(x);
        return {
          unsubscribe: w
        };
      }
    }, g[QE] = function() {
      return this;
    }, g;
  }
  return f({
    type: ZE.INIT
  }), r = {
    dispatch: f,
    subscribe: d,
    getState: c,
    replaceReducer: h
  }, r[QE] = p, r;
}
function Ft(e, t, ...n) {
  if (MX() && t === void 0)
    throw new Error("invariant requires an error message argument");
  if (!e) {
    let r;
    if (t === void 0)
      r = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    else {
      let i = 0;
      r = new Error(t.replace(/%s/g, function() {
        return n[i++];
      })), r.name = "Invariant Violation";
    }
    throw r.framesToPop = 1, r;
  }
}
function MX() {
  return typeof process < "u" && process.env.NODE_ENV === "production";
}
function IX(e, t, n) {
  return t.split(".").reduce(
    (r, i) => r && r[i] ? r[i] : n || null,
    e
  );
}
function kX(e, t) {
  return e.filter(
    (n) => n !== t
  );
}
function qM(e) {
  return typeof e == "object";
}
function PX(e, t) {
  const n = /* @__PURE__ */ new Map(), r = (o) => {
    n.set(o, n.has(o) ? n.get(o) + 1 : 1);
  };
  e.forEach(r), t.forEach(r);
  const i = [];
  return n.forEach((o, s) => {
    o === 1 && i.push(s);
  }), i;
}
function NX(e, t) {
  return e.filter(
    (n) => t.indexOf(n) > -1
  );
}
const B1 = "dnd-core/INIT_COORDS", sm = "dnd-core/BEGIN_DRAG", j1 = "dnd-core/PUBLISH_DRAG_SOURCE", am = "dnd-core/HOVER", lm = "dnd-core/DROP", cm = "dnd-core/END_DRAG";
function JE(e, t) {
  return {
    type: B1,
    payload: {
      sourceClientOffset: t || null,
      clientOffset: e || null
    }
  };
}
const LX = {
  type: B1,
  payload: {
    clientOffset: null,
    sourceClientOffset: null
  }
};
function FX(e) {
  return function(n = [], r = {
    publishSource: !0
  }) {
    const { publishSource: i = !0, clientOffset: o, getSourceClientOffset: s } = r, a = e.getMonitor(), l = e.getRegistry();
    e.dispatch(JE(o)), BX(n, a, l);
    const u = HX(n, a);
    if (u == null) {
      e.dispatch(LX);
      return;
    }
    let c = null;
    if (o) {
      if (!s)
        throw new Error("getSourceClientOffset must be defined");
      jX(s), c = s(u);
    }
    e.dispatch(JE(o, c));
    const f = l.getSource(u).beginDrag(a, u);
    if (f == null)
      return;
    zX(f), l.pinSource(u);
    const h = l.getSourceType(u);
    return {
      type: sm,
      payload: {
        itemType: h,
        item: f,
        sourceId: u,
        clientOffset: o || null,
        sourceClientOffset: c || null,
        isSourcePublic: !!i
      }
    };
  };
}
function BX(e, t, n) {
  Ft(!t.isDragging(), "Cannot call beginDrag while dragging."), e.forEach(function(r) {
    Ft(n.getSource(r), "Expected sourceIds to be registered.");
  });
}
function jX(e) {
  Ft(typeof e == "function", "When clientOffset is provided, getSourceClientOffset must be a function.");
}
function zX(e) {
  Ft(qM(e), "Item must be an object.");
}
function HX(e, t) {
  let n = null;
  for (let r = e.length - 1; r >= 0; r--)
    if (t.canDragSource(e[r])) {
      n = e[r];
      break;
    }
  return n;
}
function VX(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function WX(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      VX(e, i, n[i]);
    });
  }
  return e;
}
function UX(e) {
  return function(n = {}) {
    const r = e.getMonitor(), i = e.getRegistry();
    GX(r), YX(r).forEach((s, a) => {
      const l = KX(s, a, i, r), u = {
        type: lm,
        payload: {
          dropResult: WX({}, n, l)
        }
      };
      e.dispatch(u);
    });
  };
}
function GX(e) {
  Ft(e.isDragging(), "Cannot call drop while not dragging."), Ft(!e.didDrop(), "Cannot call drop twice during one drag operation.");
}
function KX(e, t, n, r) {
  const i = n.getTarget(e);
  let o = i ? i.drop(r, e) : void 0;
  return XX(o), typeof o > "u" && (o = t === 0 ? {} : r.getDropResult()), o;
}
function XX(e) {
  Ft(typeof e > "u" || qM(e), "Drop result must either be an object or undefined.");
}
function YX(e) {
  const t = e.getTargetIds().filter(e.canDropOnTarget, e);
  return t.reverse(), t;
}
function qX(e) {
  return function() {
    const n = e.getMonitor(), r = e.getRegistry();
    QX(n);
    const i = n.getSourceId();
    return i != null && (r.getSource(i, !0).endDrag(n, i), r.unpinSource()), {
      type: cm
    };
  };
}
function QX(e) {
  Ft(e.isDragging(), "Cannot call endDrag while not dragging.");
}
function Bb(e, t) {
  return t === null ? e === null : Array.isArray(e) ? e.some(
    (n) => n === t
  ) : e === t;
}
function ZX(e) {
  return function(n, { clientOffset: r } = {}) {
    JX(n);
    const i = n.slice(0), o = e.getMonitor(), s = e.getRegistry(), a = o.getItemType();
    return tY(i, s, a), eY(i, o, s), nY(i, o, s), {
      type: am,
      payload: {
        targetIds: i,
        clientOffset: r || null
      }
    };
  };
}
function JX(e) {
  Ft(Array.isArray(e), "Expected targetIds to be an array.");
}
function eY(e, t, n) {
  Ft(t.isDragging(), "Cannot call hover while not dragging."), Ft(!t.didDrop(), "Cannot call hover after drop.");
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    Ft(e.lastIndexOf(i) === r, "Expected targetIds to be unique in the passed array.");
    const o = n.getTarget(i);
    Ft(o, "Expected targetIds to be registered.");
  }
}
function tY(e, t, n) {
  for (let r = e.length - 1; r >= 0; r--) {
    const i = e[r], o = t.getTargetType(i);
    Bb(o, n) || e.splice(r, 1);
  }
}
function nY(e, t, n) {
  e.forEach(function(r) {
    n.getTarget(r).hover(t, r);
  });
}
function rY(e) {
  return function() {
    if (e.getMonitor().isDragging())
      return {
        type: j1
      };
  };
}
function iY(e) {
  return {
    beginDrag: FX(e),
    publishDragSource: rY(e),
    hover: ZX(e),
    drop: UX(e),
    endDrag: qX(e)
  };
}
class oY {
  receiveBackend(t) {
    this.backend = t;
  }
  getMonitor() {
    return this.monitor;
  }
  getBackend() {
    return this.backend;
  }
  getRegistry() {
    return this.monitor.registry;
  }
  getActions() {
    const t = this, { dispatch: n } = this.store;
    function r(o) {
      return (...s) => {
        const a = o.apply(t, s);
        typeof a < "u" && n(a);
      };
    }
    const i = iY(this);
    return Object.keys(i).reduce((o, s) => {
      const a = i[s];
      return o[s] = r(a), o;
    }, {});
  }
  dispatch(t) {
    this.store.dispatch(t);
  }
  constructor(t, n) {
    this.isSetUp = !1, this.handleRefCountChange = () => {
      const r = this.store.getState().refCount > 0;
      this.backend && (r && !this.isSetUp ? (this.backend.setup(), this.isSetUp = !0) : !r && this.isSetUp && (this.backend.teardown(), this.isSetUp = !1));
    }, this.store = t, this.monitor = n, t.subscribe(this.handleRefCountChange);
  }
}
function sY(e, t) {
  return {
    x: e.x + t.x,
    y: e.y + t.y
  };
}
function QM(e, t) {
  return {
    x: e.x - t.x,
    y: e.y - t.y
  };
}
function aY(e) {
  const { clientOffset: t, initialClientOffset: n, initialSourceClientOffset: r } = e;
  return !t || !n || !r ? null : QM(sY(t, r), n);
}
function lY(e) {
  const { clientOffset: t, initialClientOffset: n } = e;
  return !t || !n ? null : QM(t, n);
}
const nd = [], z1 = [];
nd.__IS_NONE__ = !0;
z1.__IS_ALL__ = !0;
function cY(e, t) {
  return e === nd ? !1 : e === z1 || typeof t > "u" ? !0 : NX(t, e).length > 0;
}
class uY {
  subscribeToStateChange(t, n = {}) {
    const { handlerIds: r } = n;
    Ft(typeof t == "function", "listener must be a function."), Ft(typeof r > "u" || Array.isArray(r), "handlerIds, when specified, must be an array of strings.");
    let i = this.store.getState().stateId;
    const o = () => {
      const s = this.store.getState(), a = s.stateId;
      try {
        a === i || a === i + 1 && !cY(s.dirtyHandlerIds, r) || t();
      } finally {
        i = a;
      }
    };
    return this.store.subscribe(o);
  }
  subscribeToOffsetChange(t) {
    Ft(typeof t == "function", "listener must be a function.");
    let n = this.store.getState().dragOffset;
    const r = () => {
      const i = this.store.getState().dragOffset;
      i !== n && (n = i, t());
    };
    return this.store.subscribe(r);
  }
  canDragSource(t) {
    if (!t)
      return !1;
    const n = this.registry.getSource(t);
    return Ft(n, `Expected to find a valid source. sourceId=${t}`), this.isDragging() ? !1 : n.canDrag(this, t);
  }
  canDropOnTarget(t) {
    if (!t)
      return !1;
    const n = this.registry.getTarget(t);
    if (Ft(n, `Expected to find a valid target. targetId=${t}`), !this.isDragging() || this.didDrop())
      return !1;
    const r = this.registry.getTargetType(t), i = this.getItemType();
    return Bb(r, i) && n.canDrop(this, t);
  }
  isDragging() {
    return !!this.getItemType();
  }
  isDraggingSource(t) {
    if (!t)
      return !1;
    const n = this.registry.getSource(t, !0);
    if (Ft(n, `Expected to find a valid source. sourceId=${t}`), !this.isDragging() || !this.isSourcePublic())
      return !1;
    const r = this.registry.getSourceType(t), i = this.getItemType();
    return r !== i ? !1 : n.isDragging(this, t);
  }
  isOverTarget(t, n = {
    shallow: !1
  }) {
    if (!t)
      return !1;
    const { shallow: r } = n;
    if (!this.isDragging())
      return !1;
    const i = this.registry.getTargetType(t), o = this.getItemType();
    if (o && !Bb(i, o))
      return !1;
    const s = this.getTargetIds();
    if (!s.length)
      return !1;
    const a = s.indexOf(t);
    return r ? a === s.length - 1 : a > -1;
  }
  getItemType() {
    return this.store.getState().dragOperation.itemType;
  }
  getItem() {
    return this.store.getState().dragOperation.item;
  }
  getSourceId() {
    return this.store.getState().dragOperation.sourceId;
  }
  getTargetIds() {
    return this.store.getState().dragOperation.targetIds;
  }
  getDropResult() {
    return this.store.getState().dragOperation.dropResult;
  }
  didDrop() {
    return this.store.getState().dragOperation.didDrop;
  }
  isSourcePublic() {
    return !!this.store.getState().dragOperation.isSourcePublic;
  }
  getInitialClientOffset() {
    return this.store.getState().dragOffset.initialClientOffset;
  }
  getInitialSourceClientOffset() {
    return this.store.getState().dragOffset.initialSourceClientOffset;
  }
  getClientOffset() {
    return this.store.getState().dragOffset.clientOffset;
  }
  getSourceClientOffset() {
    return aY(this.store.getState().dragOffset);
  }
  getDifferenceFromInitialOffset() {
    return lY(this.store.getState().dragOffset);
  }
  constructor(t, n) {
    this.store = t, this.registry = n;
  }
}
const e$ = typeof global < "u" ? global : self, ZM = e$.MutationObserver || e$.WebKitMutationObserver;
function JM(e) {
  return function() {
    const n = setTimeout(i, 0), r = setInterval(i, 50);
    function i() {
      clearTimeout(n), clearInterval(r), e();
    }
  };
}
function dY(e) {
  let t = 1;
  const n = new ZM(e), r = document.createTextNode("");
  return n.observe(r, {
    characterData: !0
  }), function() {
    t = -t, r.data = t;
  };
}
const fY = typeof ZM == "function" ? (
  // reliably everywhere they are implemented.
  // They are implemented in all modern browsers.
  //
  // - Android 4-4.3
  // - Chrome 26-34
  // - Firefox 14-29
  // - Internet Explorer 11
  // - iPad Safari 6-7.1
  // - iPhone Safari 7-7.1
  // - Safari 6-7
  dY
) : (
  // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
  // 11-12, and in web workers in many engines.
  // Although message channels yield to any queued rendering and IO tasks, they
  // would be better than imposing the 4ms delay of timers.
  // However, they do not work reliably in Internet Explorer or Safari.
  // Internet Explorer 10 is the only browser that has setImmediate but does
  // not have MutationObservers.
  // Although setImmediate yields to the browser's renderer, it would be
  // preferrable to falling back to setTimeout since it does not have
  // the minimum 4ms penalty.
  // Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
  // Desktop to a lesser extent) that renders both setImmediate and
  // MessageChannel useless for the purposes of ASAP.
  // https://github.com/kriskowal/q/issues/396
  // Timers are implemented universally.
  // We fall back to timers in workers in most engines, and in foreground
  // contexts in the following browsers.
  // However, note that even this simple case requires nuances to operate in a
  // broad spectrum of browsers.
  //
  // - Firefox 3-13
  // - Internet Explorer 6-9
  // - iPad Safari 4.3
  // - Lynx 2.8.7
  JM
);
class hY {
  // Use the fastest means possible to execute a task in its own turn, with
  // priority over other events including IO, animation, reflow, and redraw
  // events in browsers.
  //
  // An exception thrown by a task will permanently interrupt the processing of
  // subsequent tasks. The higher level `asap` function ensures that if an
  // exception is thrown by a task, that the task queue will continue flushing as
  // soon as possible, but if you use `rawAsap` directly, you are responsible to
  // either ensure that no exceptions are thrown from your task, or to manually
  // call `rawAsap.requestFlush` if an exception is thrown.
  enqueueTask(t) {
    const { queue: n, requestFlush: r } = this;
    n.length || (r(), this.flushing = !0), n[n.length] = t;
  }
  constructor() {
    this.queue = [], this.pendingErrors = [], this.flushing = !1, this.index = 0, this.capacity = 1024, this.flush = () => {
      const { queue: t } = this;
      for (; this.index < t.length; ) {
        const n = this.index;
        if (this.index++, t[n].call(), this.index > this.capacity) {
          for (let r = 0, i = t.length - this.index; r < i; r++)
            t[r] = t[r + this.index];
          t.length -= this.index, this.index = 0;
        }
      }
      t.length = 0, this.index = 0, this.flushing = !1;
    }, this.registerPendingError = (t) => {
      this.pendingErrors.push(t), this.requestErrorThrow();
    }, this.requestFlush = fY(this.flush), this.requestErrorThrow = JM(() => {
      if (this.pendingErrors.length)
        throw this.pendingErrors.shift();
    });
  }
}
class pY {
  call() {
    try {
      this.task && this.task();
    } catch (t) {
      this.onError(t);
    } finally {
      this.task = null, this.release(this);
    }
  }
  constructor(t, n) {
    this.onError = t, this.release = n, this.task = null;
  }
}
class gY {
  create(t) {
    const n = this.freeTasks, r = n.length ? n.pop() : new pY(
      this.onError,
      (i) => n[n.length] = i
    );
    return r.task = t, r;
  }
  constructor(t) {
    this.onError = t, this.freeTasks = [];
  }
}
const eI = new hY(), mY = new gY(eI.registerPendingError);
function vY(e) {
  eI.enqueueTask(mY.create(e));
}
const H1 = "dnd-core/ADD_SOURCE", V1 = "dnd-core/ADD_TARGET", W1 = "dnd-core/REMOVE_SOURCE", um = "dnd-core/REMOVE_TARGET";
function bY(e) {
  return {
    type: H1,
    payload: {
      sourceId: e
    }
  };
}
function yY(e) {
  return {
    type: V1,
    payload: {
      targetId: e
    }
  };
}
function wY(e) {
  return {
    type: W1,
    payload: {
      sourceId: e
    }
  };
}
function CY(e) {
  return {
    type: um,
    payload: {
      targetId: e
    }
  };
}
function SY(e) {
  Ft(typeof e.canDrag == "function", "Expected canDrag to be a function."), Ft(typeof e.beginDrag == "function", "Expected beginDrag to be a function."), Ft(typeof e.endDrag == "function", "Expected endDrag to be a function.");
}
function xY(e) {
  Ft(typeof e.canDrop == "function", "Expected canDrop to be a function."), Ft(typeof e.hover == "function", "Expected hover to be a function."), Ft(typeof e.drop == "function", "Expected beginDrag to be a function.");
}
function jb(e, t) {
  if (t && Array.isArray(e)) {
    e.forEach(
      (n) => jb(n, !1)
    );
    return;
  }
  Ft(typeof e == "string" || typeof e == "symbol", t ? "Type can only be a string, a symbol, or an array of either." : "Type can only be a string or a symbol.");
}
var qi;
(function(e) {
  e.SOURCE = "SOURCE", e.TARGET = "TARGET";
})(qi || (qi = {}));
let EY = 0;
function $Y() {
  return EY++;
}
function OY(e) {
  const t = $Y().toString();
  switch (e) {
    case qi.SOURCE:
      return `S${t}`;
    case qi.TARGET:
      return `T${t}`;
    default:
      throw new Error(`Unknown Handler Role: ${e}`);
  }
}
function t$(e) {
  switch (e[0]) {
    case "S":
      return qi.SOURCE;
    case "T":
      return qi.TARGET;
    default:
      throw new Error(`Cannot parse handler ID: ${e}`);
  }
}
function n$(e, t) {
  const n = e.entries();
  let r = !1;
  do {
    const { done: i, value: [, o] } = n.next();
    if (o === t)
      return !0;
    r = !!i;
  } while (!r);
  return !1;
}
class AY {
  addSource(t, n) {
    jb(t), SY(n);
    const r = this.addHandler(qi.SOURCE, t, n);
    return this.store.dispatch(bY(r)), r;
  }
  addTarget(t, n) {
    jb(t, !0), xY(n);
    const r = this.addHandler(qi.TARGET, t, n);
    return this.store.dispatch(yY(r)), r;
  }
  containsHandler(t) {
    return n$(this.dragSources, t) || n$(this.dropTargets, t);
  }
  getSource(t, n = !1) {
    return Ft(this.isSourceId(t), "Expected a valid source ID."), n && t === this.pinnedSourceId ? this.pinnedSource : this.dragSources.get(t);
  }
  getTarget(t) {
    return Ft(this.isTargetId(t), "Expected a valid target ID."), this.dropTargets.get(t);
  }
  getSourceType(t) {
    return Ft(this.isSourceId(t), "Expected a valid source ID."), this.types.get(t);
  }
  getTargetType(t) {
    return Ft(this.isTargetId(t), "Expected a valid target ID."), this.types.get(t);
  }
  isSourceId(t) {
    return t$(t) === qi.SOURCE;
  }
  isTargetId(t) {
    return t$(t) === qi.TARGET;
  }
  removeSource(t) {
    Ft(this.getSource(t), "Expected an existing source."), this.store.dispatch(wY(t)), vY(() => {
      this.dragSources.delete(t), this.types.delete(t);
    });
  }
  removeTarget(t) {
    Ft(this.getTarget(t), "Expected an existing target."), this.store.dispatch(CY(t)), this.dropTargets.delete(t), this.types.delete(t);
  }
  pinSource(t) {
    const n = this.getSource(t);
    Ft(n, "Expected an existing source."), this.pinnedSourceId = t, this.pinnedSource = n;
  }
  unpinSource() {
    Ft(this.pinnedSource, "No source is pinned at the time."), this.pinnedSourceId = null, this.pinnedSource = null;
  }
  addHandler(t, n, r) {
    const i = OY(t);
    return this.types.set(i, n), t === qi.SOURCE ? this.dragSources.set(i, r) : t === qi.TARGET && this.dropTargets.set(i, r), i;
  }
  constructor(t) {
    this.types = /* @__PURE__ */ new Map(), this.dragSources = /* @__PURE__ */ new Map(), this.dropTargets = /* @__PURE__ */ new Map(), this.pinnedSourceId = null, this.pinnedSource = null, this.store = t;
  }
}
const DY = (e, t) => e === t;
function _Y(e, t) {
  return !e && !t ? !0 : !e || !t ? !1 : e.x === t.x && e.y === t.y;
}
function TY(e, t, n = DY) {
  if (e.length !== t.length)
    return !1;
  for (let r = 0; r < e.length; ++r)
    if (!n(e[r], t[r]))
      return !1;
  return !0;
}
function RY(e = nd, t) {
  switch (t.type) {
    case am:
      break;
    case H1:
    case V1:
    case um:
    case W1:
      return nd;
    case sm:
    case j1:
    case cm:
    case lm:
    default:
      return z1;
  }
  const { targetIds: n = [], prevTargetIds: r = [] } = t.payload, i = PX(n, r);
  if (!(i.length > 0 || !TY(n, r)))
    return nd;
  const s = r[r.length - 1], a = n[n.length - 1];
  return s !== a && (s && i.push(s), a && i.push(a)), i;
}
function MY(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function IY(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      MY(e, i, n[i]);
    });
  }
  return e;
}
const r$ = {
  initialSourceClientOffset: null,
  initialClientOffset: null,
  clientOffset: null
};
function kY(e = r$, t) {
  const { payload: n } = t;
  switch (t.type) {
    case B1:
    case sm:
      return {
        initialSourceClientOffset: n.sourceClientOffset,
        initialClientOffset: n.clientOffset,
        clientOffset: n.clientOffset
      };
    case am:
      return _Y(e.clientOffset, n.clientOffset) ? e : IY({}, e, {
        clientOffset: n.clientOffset
      });
    case cm:
    case lm:
      return r$;
    default:
      return e;
  }
}
function PY(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Gl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      PY(e, i, n[i]);
    });
  }
  return e;
}
const NY = {
  itemType: null,
  item: null,
  sourceId: null,
  targetIds: [],
  dropResult: null,
  didDrop: !1,
  isSourcePublic: null
};
function LY(e = NY, t) {
  const { payload: n } = t;
  switch (t.type) {
    case sm:
      return Gl({}, e, {
        itemType: n.itemType,
        item: n.item,
        sourceId: n.sourceId,
        isSourcePublic: n.isSourcePublic,
        dropResult: null,
        didDrop: !1
      });
    case j1:
      return Gl({}, e, {
        isSourcePublic: !0
      });
    case am:
      return Gl({}, e, {
        targetIds: n.targetIds
      });
    case um:
      return e.targetIds.indexOf(n.targetId) === -1 ? e : Gl({}, e, {
        targetIds: kX(e.targetIds, n.targetId)
      });
    case lm:
      return Gl({}, e, {
        dropResult: n.dropResult,
        didDrop: !0,
        targetIds: []
      });
    case cm:
      return Gl({}, e, {
        itemType: null,
        item: null,
        sourceId: null,
        dropResult: null,
        didDrop: !1,
        isSourcePublic: null,
        targetIds: []
      });
    default:
      return e;
  }
}
function FY(e = 0, t) {
  switch (t.type) {
    case H1:
    case V1:
      return e + 1;
    case W1:
    case um:
      return e - 1;
    default:
      return e;
  }
}
function BY(e = 0) {
  return e + 1;
}
function jY(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function zY(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      jY(e, i, n[i]);
    });
  }
  return e;
}
function HY(e = {}, t) {
  return {
    dirtyHandlerIds: RY(e.dirtyHandlerIds, {
      type: t.type,
      payload: zY({}, t.payload, {
        prevTargetIds: IX(e, "dragOperation.targetIds", [])
      })
    }),
    dragOffset: kY(e.dragOffset, t),
    refCount: FY(e.refCount, t),
    dragOperation: LY(e.dragOperation, t),
    stateId: BY(e.stateId)
  };
}
function tI(e, t = void 0, n = {}, r = !1) {
  const i = VY(r), o = new uY(i, new AY(i)), s = new oY(i, o), a = e(s, t, n);
  return s.receiveBackend(a), s;
}
function VY(e) {
  const t = typeof window < "u" && window.__REDUX_DEVTOOLS_EXTENSION__;
  return YM(HY, e && t && t({
    name: "dnd-core",
    instanceId: "dnd-core"
  }));
}
function WY(e, t) {
  if (e == null)
    return {};
  var n = UY(e, t), r, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function UY(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
let i$ = 0;
const lp = Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");
var nI = /* @__PURE__ */ Sn(function(t) {
  var { children: n } = t, r = WY(t, [
    "children"
  ]);
  const [i, o] = GY(r);
  return Pe(() => {
    if (o) {
      const s = rI();
      return ++i$, () => {
        --i$ === 0 && (s[lp] = null);
      };
    }
  }, []), /* @__PURE__ */ V.jsx(XM.Provider, {
    value: i,
    children: n
  });
});
function GY(e) {
  if ("manager" in e)
    return [
      {
        dragDropManager: e.manager
      },
      !1
    ];
  const t = KY(e.backend, e.context, e.options, e.debugMode), n = !e.context;
  return [
    t,
    n
  ];
}
function KY(e, t = rI(), n, r) {
  const i = t;
  return i[lp] || (i[lp] = {
    dragDropManager: tI(e, t, n, r)
  }), i[lp];
}
function rI() {
  return typeof global < "u" ? global : window;
}
var XY = function e(t, n) {
  if (t === n)
    return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor)
      return !1;
    var r, i, o;
    if (Array.isArray(t)) {
      if (r = t.length, r != n.length)
        return !1;
      for (i = r; i-- !== 0; )
        if (!e(t[i], n[i]))
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === n.toString();
    if (o = Object.keys(t), r = o.length, r !== Object.keys(n).length)
      return !1;
    for (i = r; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, o[i]))
        return !1;
    for (i = r; i-- !== 0; ) {
      var s = o[i];
      if (!e(t[s], n[s]))
        return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
};
const YY = /* @__PURE__ */ hl(XY), el = typeof window < "u" ? Eg : Pe;
function qY(e, t, n) {
  const [r, i] = ht(
    () => t(e)
  ), o = Kt(() => {
    const s = t(e);
    YY(r, s) || (i(s), n && n());
  }, [
    r,
    e,
    n
  ]);
  return el(o), [
    r,
    o
  ];
}
function QY(e, t, n) {
  const [r, i] = qY(e, t, n);
  return el(function() {
    const s = e.getHandlerId();
    if (s != null)
      return e.subscribeToStateChange(i, {
        handlerIds: [
          s
        ]
      });
  }, [
    e,
    i
  ]), r;
}
function iI(e, t, n) {
  return QY(
    t,
    e || (() => ({})),
    () => n.reconnect()
  );
}
function oI(e, t) {
  const n = [];
  return typeof e != "function" && n.push(e), mt(() => typeof e == "function" ? e() : e, n);
}
function ZY(e) {
  return mt(
    () => e.hooks.dragSource(),
    [
      e
    ]
  );
}
function JY(e) {
  return mt(
    () => e.hooks.dragPreview(),
    [
      e
    ]
  );
}
let Sv = !1, xv = !1;
class eq {
  receiveHandlerId(t) {
    this.sourceId = t;
  }
  getHandlerId() {
    return this.sourceId;
  }
  canDrag() {
    Ft(!Sv, "You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
    try {
      return Sv = !0, this.internalMonitor.canDragSource(this.sourceId);
    } finally {
      Sv = !1;
    }
  }
  isDragging() {
    if (!this.sourceId)
      return !1;
    Ft(!xv, "You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
    try {
      return xv = !0, this.internalMonitor.isDraggingSource(this.sourceId);
    } finally {
      xv = !1;
    }
  }
  subscribeToStateChange(t, n) {
    return this.internalMonitor.subscribeToStateChange(t, n);
  }
  isDraggingSource(t) {
    return this.internalMonitor.isDraggingSource(t);
  }
  isOverTarget(t, n) {
    return this.internalMonitor.isOverTarget(t, n);
  }
  getTargetIds() {
    return this.internalMonitor.getTargetIds();
  }
  isSourcePublic() {
    return this.internalMonitor.isSourcePublic();
  }
  getSourceId() {
    return this.internalMonitor.getSourceId();
  }
  subscribeToOffsetChange(t) {
    return this.internalMonitor.subscribeToOffsetChange(t);
  }
  canDragSource(t) {
    return this.internalMonitor.canDragSource(t);
  }
  canDropOnTarget(t) {
    return this.internalMonitor.canDropOnTarget(t);
  }
  getItemType() {
    return this.internalMonitor.getItemType();
  }
  getItem() {
    return this.internalMonitor.getItem();
  }
  getDropResult() {
    return this.internalMonitor.getDropResult();
  }
  didDrop() {
    return this.internalMonitor.didDrop();
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset();
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset();
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset();
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset();
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset();
  }
  constructor(t) {
    this.sourceId = null, this.internalMonitor = t.getMonitor();
  }
}
let Ev = !1;
class tq {
  receiveHandlerId(t) {
    this.targetId = t;
  }
  getHandlerId() {
    return this.targetId;
  }
  subscribeToStateChange(t, n) {
    return this.internalMonitor.subscribeToStateChange(t, n);
  }
  canDrop() {
    if (!this.targetId)
      return !1;
    Ft(!Ev, "You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");
    try {
      return Ev = !0, this.internalMonitor.canDropOnTarget(this.targetId);
    } finally {
      Ev = !1;
    }
  }
  isOver(t) {
    return this.targetId ? this.internalMonitor.isOverTarget(this.targetId, t) : !1;
  }
  getItemType() {
    return this.internalMonitor.getItemType();
  }
  getItem() {
    return this.internalMonitor.getItem();
  }
  getDropResult() {
    return this.internalMonitor.getDropResult();
  }
  didDrop() {
    return this.internalMonitor.didDrop();
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset();
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset();
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset();
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset();
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset();
  }
  constructor(t) {
    this.targetId = null, this.internalMonitor = t.getMonitor();
  }
}
function nq(e, t, n) {
  const r = n.getRegistry(), i = r.addTarget(e, t);
  return [
    i,
    () => r.removeTarget(i)
  ];
}
function rq(e, t, n) {
  const r = n.getRegistry(), i = r.addSource(e, t);
  return [
    i,
    () => r.removeSource(i)
  ];
}
function zb(e, t, n, r) {
  let i;
  if (i !== void 0)
    return !!i;
  if (e === t)
    return !0;
  if (typeof e != "object" || !e || typeof t != "object" || !t)
    return !1;
  const o = Object.keys(e), s = Object.keys(t);
  if (o.length !== s.length)
    return !1;
  const a = Object.prototype.hasOwnProperty.bind(t);
  for (let l = 0; l < o.length; l++) {
    const u = o[l];
    if (!a(u))
      return !1;
    const c = e[u], d = t[u];
    if (i = void 0, i === !1 || i === void 0 && c !== d)
      return !1;
  }
  return !0;
}
function Hb(e) {
  return (
    // eslint-disable-next-line no-prototype-builtins
    e !== null && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current")
  );
}
function iq(e) {
  if (typeof e.type == "string")
    return;
  const t = e.type.displayName || e.type.name || "the component";
  throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${t} into a <div>, or turn it into a drag source or a drop target itself.`);
}
function oq(e) {
  return (t = null, n = null) => {
    if (!jA(t)) {
      const o = t;
      return e(o, n), o;
    }
    const r = t;
    return iq(r), sq(r, n ? (o) => e(o, n) : e);
  };
}
function sI(e) {
  const t = {};
  return Object.keys(e).forEach((n) => {
    const r = e[n];
    if (n.endsWith("Ref"))
      t[n] = e[n];
    else {
      const i = oq(r);
      t[n] = () => i;
    }
  }), t;
}
function o$(e, t) {
  typeof e == "function" ? e(t) : e.current = t;
}
function sq(e, t) {
  const n = e.ref;
  return Ft(typeof n != "string", "Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs"), n ? M0(e, {
    ref: (r) => {
      o$(n, r), o$(t, r);
    }
  }) : M0(e, {
    ref: t
  });
}
class aq {
  receiveHandlerId(t) {
    this.handlerId !== t && (this.handlerId = t, this.reconnect());
  }
  get connectTarget() {
    return this.dragSource;
  }
  get dragSourceOptions() {
    return this.dragSourceOptionsInternal;
  }
  set dragSourceOptions(t) {
    this.dragSourceOptionsInternal = t;
  }
  get dragPreviewOptions() {
    return this.dragPreviewOptionsInternal;
  }
  set dragPreviewOptions(t) {
    this.dragPreviewOptionsInternal = t;
  }
  reconnect() {
    const t = this.reconnectDragSource();
    this.reconnectDragPreview(t);
  }
  reconnectDragSource() {
    const t = this.dragSource, n = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();
    return n && this.disconnectDragSource(), this.handlerId ? t ? (n && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDragSource = t, this.lastConnectedDragSourceOptions = this.dragSourceOptions, this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, t, this.dragSourceOptions)), n) : (this.lastConnectedDragSource = t, n) : n;
  }
  reconnectDragPreview(t = !1) {
    const n = this.dragPreview, r = t || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();
    if (r && this.disconnectDragPreview(), !!this.handlerId) {
      if (!n) {
        this.lastConnectedDragPreview = n;
        return;
      }
      r && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDragPreview = n, this.lastConnectedDragPreviewOptions = this.dragPreviewOptions, this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, n, this.dragPreviewOptions));
    }
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId;
  }
  didConnectedDragSourceChange() {
    return this.lastConnectedDragSource !== this.dragSource;
  }
  didConnectedDragPreviewChange() {
    return this.lastConnectedDragPreview !== this.dragPreview;
  }
  didDragSourceOptionsChange() {
    return !zb(this.lastConnectedDragSourceOptions, this.dragSourceOptions);
  }
  didDragPreviewOptionsChange() {
    return !zb(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);
  }
  disconnectDragSource() {
    this.dragSourceUnsubscribe && (this.dragSourceUnsubscribe(), this.dragSourceUnsubscribe = void 0);
  }
  disconnectDragPreview() {
    this.dragPreviewUnsubscribe && (this.dragPreviewUnsubscribe(), this.dragPreviewUnsubscribe = void 0, this.dragPreviewNode = null, this.dragPreviewRef = null);
  }
  get dragSource() {
    return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;
  }
  get dragPreview() {
    return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;
  }
  clearDragSource() {
    this.dragSourceNode = null, this.dragSourceRef = null;
  }
  clearDragPreview() {
    this.dragPreviewNode = null, this.dragPreviewRef = null;
  }
  constructor(t) {
    this.hooks = sI({
      dragSource: (n, r) => {
        this.clearDragSource(), this.dragSourceOptions = r || null, Hb(n) ? this.dragSourceRef = n : this.dragSourceNode = n, this.reconnectDragSource();
      },
      dragPreview: (n, r) => {
        this.clearDragPreview(), this.dragPreviewOptions = r || null, Hb(n) ? this.dragPreviewRef = n : this.dragPreviewNode = n, this.reconnectDragPreview();
      }
    }), this.handlerId = null, this.dragSourceRef = null, this.dragSourceOptionsInternal = null, this.dragPreviewRef = null, this.dragPreviewOptionsInternal = null, this.lastConnectedHandlerId = null, this.lastConnectedDragSource = null, this.lastConnectedDragSourceOptions = null, this.lastConnectedDragPreview = null, this.lastConnectedDragPreviewOptions = null, this.backend = t;
  }
}
class lq {
  get connectTarget() {
    return this.dropTarget;
  }
  reconnect() {
    const t = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();
    t && this.disconnectDropTarget();
    const n = this.dropTarget;
    if (this.handlerId) {
      if (!n) {
        this.lastConnectedDropTarget = n;
        return;
      }
      t && (this.lastConnectedHandlerId = this.handlerId, this.lastConnectedDropTarget = n, this.lastConnectedDropTargetOptions = this.dropTargetOptions, this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, n, this.dropTargetOptions));
    }
  }
  receiveHandlerId(t) {
    t !== this.handlerId && (this.handlerId = t, this.reconnect());
  }
  get dropTargetOptions() {
    return this.dropTargetOptionsInternal;
  }
  set dropTargetOptions(t) {
    this.dropTargetOptionsInternal = t;
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId;
  }
  didDropTargetChange() {
    return this.lastConnectedDropTarget !== this.dropTarget;
  }
  didOptionsChange() {
    return !zb(this.lastConnectedDropTargetOptions, this.dropTargetOptions);
  }
  disconnectDropTarget() {
    this.unsubscribeDropTarget && (this.unsubscribeDropTarget(), this.unsubscribeDropTarget = void 0);
  }
  get dropTarget() {
    return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;
  }
  clearDropTarget() {
    this.dropTargetRef = null, this.dropTargetNode = null;
  }
  constructor(t) {
    this.hooks = sI({
      dropTarget: (n, r) => {
        this.clearDropTarget(), this.dropTargetOptions = r, Hb(n) ? this.dropTargetRef = n : this.dropTargetNode = n, this.reconnect();
      }
    }), this.handlerId = null, this.dropTargetRef = null, this.dropTargetOptionsInternal = null, this.lastConnectedHandlerId = null, this.lastConnectedDropTarget = null, this.lastConnectedDropTargetOptions = null, this.backend = t;
  }
}
function cu() {
  const { dragDropManager: e } = Yt(XM);
  return Ft(e != null, "Expected drag drop context"), e;
}
function cq(e, t) {
  const n = cu(), r = mt(
    () => new aq(n.getBackend()),
    [
      n
    ]
  );
  return el(() => (r.dragSourceOptions = e || null, r.reconnect(), () => r.disconnectDragSource()), [
    r,
    e
  ]), el(() => (r.dragPreviewOptions = t || null, r.reconnect(), () => r.disconnectDragPreview()), [
    r,
    t
  ]), r;
}
function uq() {
  const e = cu();
  return mt(
    () => new eq(e),
    [
      e
    ]
  );
}
class dq {
  beginDrag() {
    const t = this.spec, n = this.monitor;
    let r = null;
    return typeof t.item == "object" ? r = t.item : typeof t.item == "function" ? r = t.item(n) : r = {}, r ?? null;
  }
  canDrag() {
    const t = this.spec, n = this.monitor;
    return typeof t.canDrag == "boolean" ? t.canDrag : typeof t.canDrag == "function" ? t.canDrag(n) : !0;
  }
  isDragging(t, n) {
    const r = this.spec, i = this.monitor, { isDragging: o } = r;
    return o ? o(i) : n === t.getSourceId();
  }
  endDrag() {
    const t = this.spec, n = this.monitor, r = this.connector, { end: i } = t;
    i && i(n.getItem(), n), r.reconnect();
  }
  constructor(t, n, r) {
    this.spec = t, this.monitor = n, this.connector = r;
  }
}
function fq(e, t, n) {
  const r = mt(
    () => new dq(e, t, n),
    [
      t,
      n
    ]
  );
  return Pe(() => {
    r.spec = e;
  }, [
    e
  ]), r;
}
function hq(e) {
  return mt(() => {
    const t = e.type;
    return Ft(t != null, "spec.type must be defined"), t;
  }, [
    e
  ]);
}
function pq(e, t, n) {
  const r = cu(), i = fq(e, t, n), o = hq(e);
  el(function() {
    if (o != null) {
      const [a, l] = rq(o, i, r);
      return t.receiveHandlerId(a), n.receiveHandlerId(a), l;
    }
  }, [
    r,
    t,
    n,
    i,
    o
  ]);
}
function U1(e, t) {
  const n = oI(e);
  Ft(!n.begin, "useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)");
  const r = uq(), i = cq(n.options, n.previewOptions);
  return pq(n, r, i), [
    iI(n.collect, r, i),
    ZY(i),
    JY(i)
  ];
}
function gq(e) {
  return mt(
    () => e.hooks.dropTarget(),
    [
      e
    ]
  );
}
function mq(e) {
  const t = cu(), n = mt(
    () => new lq(t.getBackend()),
    [
      t
    ]
  );
  return el(() => (n.dropTargetOptions = e || null, n.reconnect(), () => n.disconnectDropTarget()), [
    e
  ]), n;
}
function vq() {
  const e = cu();
  return mt(
    () => new tq(e),
    [
      e
    ]
  );
}
function bq(e) {
  const { accept: t } = e;
  return mt(() => (Ft(e.accept != null, "accept must be defined"), Array.isArray(t) ? t : [
    t
  ]), [
    t
  ]);
}
class yq {
  canDrop() {
    const t = this.spec, n = this.monitor;
    return t.canDrop ? t.canDrop(n.getItem(), n) : !0;
  }
  hover() {
    const t = this.spec, n = this.monitor;
    t.hover && t.hover(n.getItem(), n);
  }
  drop() {
    const t = this.spec, n = this.monitor;
    if (t.drop)
      return t.drop(n.getItem(), n);
  }
  constructor(t, n) {
    this.spec = t, this.monitor = n;
  }
}
function wq(e, t) {
  const n = mt(
    () => new yq(e, t),
    [
      t
    ]
  );
  return Pe(() => {
    n.spec = e;
  }, [
    e
  ]), n;
}
function Cq(e, t, n) {
  const r = cu(), i = wq(e, t), o = bq(e);
  el(function() {
    const [a, l] = nq(o, i, r);
    return t.receiveHandlerId(a), n.receiveHandlerId(a), l;
  }, [
    r,
    t,
    i,
    n,
    o.map(
      (s) => s.toString()
    ).join("|")
  ]);
}
function G1(e, t) {
  const n = oI(e), r = vq(), i = mq(n.options);
  return Cq(n, r, i), [
    iI(n.collect, r, i),
    gq(i)
  ];
}
function aI(e) {
  let t = null;
  return () => (t == null && (t = e()), t);
}
function Sq(e, t) {
  return e.filter(
    (n) => n !== t
  );
}
function xq(e, t) {
  const n = /* @__PURE__ */ new Set(), r = (o) => n.add(o);
  e.forEach(r), t.forEach(r);
  const i = [];
  return n.forEach(
    (o) => i.push(o)
  ), i;
}
class Eq {
  enter(t) {
    const n = this.entered.length, r = (i) => this.isNodeInDocument(i) && (!i.contains || i.contains(t));
    return this.entered = xq(this.entered.filter(r), [
      t
    ]), n === 0 && this.entered.length > 0;
  }
  leave(t) {
    const n = this.entered.length;
    return this.entered = Sq(this.entered.filter(this.isNodeInDocument), t), n > 0 && this.entered.length === 0;
  }
  reset() {
    this.entered = [];
  }
  constructor(t) {
    this.entered = [], this.isNodeInDocument = t;
  }
}
class $q {
  initializeExposedProperties() {
    Object.keys(this.config.exposeProperties).forEach((t) => {
      Object.defineProperty(this.item, t, {
        configurable: !0,
        enumerable: !0,
        get() {
          return console.warn(`Browser doesn't allow reading "${t}" until the drop event.`), null;
        }
      });
    });
  }
  loadDataTransfer(t) {
    if (t) {
      const n = {};
      Object.keys(this.config.exposeProperties).forEach((r) => {
        const i = this.config.exposeProperties[r];
        i != null && (n[r] = {
          value: i(t, this.config.matchesTypes),
          configurable: !0,
          enumerable: !0
        });
      }), Object.defineProperties(this.item, n);
    }
  }
  canDrag() {
    return !0;
  }
  beginDrag() {
    return this.item;
  }
  isDragging(t, n) {
    return n === t.getSourceId();
  }
  endDrag() {
  }
  constructor(t) {
    this.config = t, this.item = {}, this.initializeExposedProperties();
  }
}
const lI = "__NATIVE_FILE__", cI = "__NATIVE_URL__", uI = "__NATIVE_TEXT__", dI = "__NATIVE_HTML__", s$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FILE: lI,
  HTML: dI,
  TEXT: uI,
  URL: cI
}, Symbol.toStringTag, { value: "Module" }));
function $v(e, t, n) {
  const r = t.reduce(
    (i, o) => i || e.getData(o),
    ""
  );
  return r ?? n;
}
const Vb = {
  [lI]: {
    exposeProperties: {
      files: (e) => Array.prototype.slice.call(e.files),
      items: (e) => e.items,
      dataTransfer: (e) => e
    },
    matchesTypes: [
      "Files"
    ]
  },
  [dI]: {
    exposeProperties: {
      html: (e, t) => $v(e, t, ""),
      dataTransfer: (e) => e
    },
    matchesTypes: [
      "Html",
      "text/html"
    ]
  },
  [cI]: {
    exposeProperties: {
      urls: (e, t) => $v(e, t, "").split(`
`),
      dataTransfer: (e) => e
    },
    matchesTypes: [
      "Url",
      "text/uri-list"
    ]
  },
  [uI]: {
    exposeProperties: {
      text: (e, t) => $v(e, t, ""),
      dataTransfer: (e) => e
    },
    matchesTypes: [
      "Text",
      "text/plain"
    ]
  }
};
function Oq(e, t) {
  const n = Vb[e];
  if (!n)
    throw new Error(`native type ${e} has no configuration`);
  const r = new $q(n);
  return r.loadDataTransfer(t), r;
}
function Ov(e) {
  if (!e)
    return null;
  const t = Array.prototype.slice.call(e.types || []);
  return Object.keys(Vb).filter((n) => {
    const r = Vb[n];
    return r != null && r.matchesTypes ? r.matchesTypes.some(
      (i) => t.indexOf(i) > -1
    ) : !1;
  })[0] || null;
}
const Aq = aI(
  () => /firefox/i.test(navigator.userAgent)
), fI = aI(
  () => !!window.safari
);
class a$ {
  interpolate(t) {
    const { xs: n, ys: r, c1s: i, c2s: o, c3s: s } = this;
    let a = n.length - 1;
    if (t === n[a])
      return r[a];
    let l = 0, u = s.length - 1, c;
    for (; l <= u; ) {
      c = Math.floor(0.5 * (l + u));
      const h = n[c];
      if (h < t)
        l = c + 1;
      else if (h > t)
        u = c - 1;
      else
        return r[c];
    }
    a = Math.max(0, u);
    const d = t - n[a], f = d * d;
    return r[a] + i[a] * d + o[a] * f + s[a] * d * f;
  }
  constructor(t, n) {
    const { length: r } = t, i = [];
    for (let h = 0; h < r; h++)
      i.push(h);
    i.sort(
      (h, p) => t[h] < t[p] ? -1 : 1
    );
    const o = [], s = [];
    let a, l;
    for (let h = 0; h < r - 1; h++)
      a = t[h + 1] - t[h], l = n[h + 1] - n[h], o.push(a), s.push(l / a);
    const u = [
      s[0]
    ];
    for (let h = 0; h < o.length - 1; h++) {
      const p = s[h], g = s[h + 1];
      if (p * g <= 0)
        u.push(0);
      else {
        a = o[h];
        const m = o[h + 1], v = a + m;
        u.push(3 * v / ((v + m) / p + (v + a) / g));
      }
    }
    u.push(s[s.length - 1]);
    const c = [], d = [];
    let f;
    for (let h = 0; h < u.length - 1; h++) {
      f = s[h];
      const p = u[h], g = 1 / o[h], m = p + u[h + 1] - f - f;
      c.push((f - p - m) * g), d.push(m * g * g);
    }
    this.xs = t, this.ys = n, this.c1s = u, this.c2s = c, this.c3s = d;
  }
}
const Dq = 1;
function hI(e) {
  const t = e.nodeType === Dq ? e : e.parentElement;
  if (!t)
    return null;
  const { top: n, left: r } = t.getBoundingClientRect();
  return {
    x: r,
    y: n
  };
}
function sh(e) {
  return {
    x: e.clientX,
    y: e.clientY
  };
}
function _q(e) {
  var t;
  return e.nodeName === "IMG" && (Aq() || !(!((t = document.documentElement) === null || t === void 0) && t.contains(e)));
}
function Tq(e, t, n, r) {
  let i = e ? t.width : n, o = e ? t.height : r;
  return fI() && e && (o /= window.devicePixelRatio, i /= window.devicePixelRatio), {
    dragPreviewWidth: i,
    dragPreviewHeight: o
  };
}
function Rq(e, t, n, r, i) {
  const o = _q(t), a = hI(o ? e : t), l = {
    x: n.x - a.x,
    y: n.y - a.y
  }, { offsetWidth: u, offsetHeight: c } = e, { anchorX: d, anchorY: f } = r, { dragPreviewWidth: h, dragPreviewHeight: p } = Tq(o, t, u, c), g = () => {
    let y = new a$([
      0,
      0.5,
      1
    ], [
      // Dock to the top
      l.y,
      // Align at the center
      l.y / c * p,
      // Dock to the bottom
      l.y + p - c
    ]).interpolate(f);
    return fI() && o && (y += (window.devicePixelRatio - 1) * p), y;
  }, m = () => new a$([
    0,
    0.5,
    1
  ], [
    // Dock to the left
    l.x,
    // Align at the center
    l.x / u * h,
    // Dock to the right
    l.x + h - u
  ]).interpolate(d), { offsetX: v, offsetY: b } = i, x = v === 0 || v, w = b === 0 || b;
  return {
    x: x ? v : m(),
    y: w ? b : g()
  };
}
class Mq {
  get window() {
    if (this.globalContext)
      return this.globalContext;
    if (typeof window < "u")
      return window;
  }
  get document() {
    var t;
    return !((t = this.globalContext) === null || t === void 0) && t.document ? this.globalContext.document : this.window ? this.window.document : void 0;
  }
  get rootElement() {
    var t;
    return ((t = this.optionsArgs) === null || t === void 0 ? void 0 : t.rootElement) || this.window;
  }
  constructor(t, n) {
    this.ownerDocument = null, this.globalContext = t, this.optionsArgs = n;
  }
}
function Iq(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function l$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {}, r = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (r = r.concat(Object.getOwnPropertySymbols(n).filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    }))), r.forEach(function(i) {
      Iq(e, i, n[i]);
    });
  }
  return e;
}
class kq {
  /**
  * Generate profiling statistics for the HTML5Backend.
  */
  profile() {
    var t, n;
    return {
      sourcePreviewNodes: this.sourcePreviewNodes.size,
      sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
      sourceNodeOptions: this.sourceNodeOptions.size,
      sourceNodes: this.sourceNodes.size,
      dragStartSourceIds: ((t = this.dragStartSourceIds) === null || t === void 0 ? void 0 : t.length) || 0,
      dropTargetIds: this.dropTargetIds.length,
      dragEnterTargetIds: this.dragEnterTargetIds.length,
      dragOverTargetIds: ((n = this.dragOverTargetIds) === null || n === void 0 ? void 0 : n.length) || 0
    };
  }
  // public for test
  get window() {
    return this.options.window;
  }
  get document() {
    return this.options.document;
  }
  /**
  * Get the root element to use for event subscriptions
  */
  get rootElement() {
    return this.options.rootElement;
  }
  setup() {
    const t = this.rootElement;
    if (t !== void 0) {
      if (t.__isReactDndBackendSetUp)
        throw new Error("Cannot have two HTML5 backends at the same time.");
      t.__isReactDndBackendSetUp = !0, this.addEventListeners(t);
    }
  }
  teardown() {
    const t = this.rootElement;
    if (t !== void 0 && (t.__isReactDndBackendSetUp = !1, this.removeEventListeners(this.rootElement), this.clearCurrentDragSourceNode(), this.asyncEndDragFrameId)) {
      var n;
      (n = this.window) === null || n === void 0 || n.cancelAnimationFrame(this.asyncEndDragFrameId);
    }
  }
  connectDragPreview(t, n, r) {
    return this.sourcePreviewNodeOptions.set(t, r), this.sourcePreviewNodes.set(t, n), () => {
      this.sourcePreviewNodes.delete(t), this.sourcePreviewNodeOptions.delete(t);
    };
  }
  connectDragSource(t, n, r) {
    this.sourceNodes.set(t, n), this.sourceNodeOptions.set(t, r);
    const i = (s) => this.handleDragStart(s, t), o = (s) => this.handleSelectStart(s);
    return n.setAttribute("draggable", "true"), n.addEventListener("dragstart", i), n.addEventListener("selectstart", o), () => {
      this.sourceNodes.delete(t), this.sourceNodeOptions.delete(t), n.removeEventListener("dragstart", i), n.removeEventListener("selectstart", o), n.setAttribute("draggable", "false");
    };
  }
  connectDropTarget(t, n) {
    const r = (s) => this.handleDragEnter(s, t), i = (s) => this.handleDragOver(s, t), o = (s) => this.handleDrop(s, t);
    return n.addEventListener("dragenter", r), n.addEventListener("dragover", i), n.addEventListener("drop", o), () => {
      n.removeEventListener("dragenter", r), n.removeEventListener("dragover", i), n.removeEventListener("drop", o);
    };
  }
  addEventListeners(t) {
    t.addEventListener && (t.addEventListener("dragstart", this.handleTopDragStart), t.addEventListener("dragstart", this.handleTopDragStartCapture, !0), t.addEventListener("dragend", this.handleTopDragEndCapture, !0), t.addEventListener("dragenter", this.handleTopDragEnter), t.addEventListener("dragenter", this.handleTopDragEnterCapture, !0), t.addEventListener("dragleave", this.handleTopDragLeaveCapture, !0), t.addEventListener("dragover", this.handleTopDragOver), t.addEventListener("dragover", this.handleTopDragOverCapture, !0), t.addEventListener("drop", this.handleTopDrop), t.addEventListener("drop", this.handleTopDropCapture, !0));
  }
  removeEventListeners(t) {
    t.removeEventListener && (t.removeEventListener("dragstart", this.handleTopDragStart), t.removeEventListener("dragstart", this.handleTopDragStartCapture, !0), t.removeEventListener("dragend", this.handleTopDragEndCapture, !0), t.removeEventListener("dragenter", this.handleTopDragEnter), t.removeEventListener("dragenter", this.handleTopDragEnterCapture, !0), t.removeEventListener("dragleave", this.handleTopDragLeaveCapture, !0), t.removeEventListener("dragover", this.handleTopDragOver), t.removeEventListener("dragover", this.handleTopDragOverCapture, !0), t.removeEventListener("drop", this.handleTopDrop), t.removeEventListener("drop", this.handleTopDropCapture, !0));
  }
  getCurrentSourceNodeOptions() {
    const t = this.monitor.getSourceId(), n = this.sourceNodeOptions.get(t);
    return l$({
      dropEffect: this.altKeyPressed ? "copy" : "move"
    }, n || {});
  }
  getCurrentDropEffect() {
    return this.isDraggingNativeItem() ? "copy" : this.getCurrentSourceNodeOptions().dropEffect;
  }
  getCurrentSourcePreviewNodeOptions() {
    const t = this.monitor.getSourceId(), n = this.sourcePreviewNodeOptions.get(t);
    return l$({
      anchorX: 0.5,
      anchorY: 0.5,
      captureDraggingState: !1
    }, n || {});
  }
  isDraggingNativeItem() {
    const t = this.monitor.getItemType();
    return Object.keys(s$).some(
      (n) => s$[n] === t
    );
  }
  beginDragNativeItem(t, n) {
    this.clearCurrentDragSourceNode(), this.currentNativeSource = Oq(t, n), this.currentNativeHandle = this.registry.addSource(t, this.currentNativeSource), this.actions.beginDrag([
      this.currentNativeHandle
    ]);
  }
  setCurrentDragSourceNode(t) {
    this.clearCurrentDragSourceNode(), this.currentDragSourceNode = t;
    const n = 1e3;
    this.mouseMoveTimeoutTimer = setTimeout(() => {
      var r;
      return (r = this.rootElement) === null || r === void 0 ? void 0 : r.addEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, !0);
    }, n);
  }
  clearCurrentDragSourceNode() {
    if (this.currentDragSourceNode) {
      if (this.currentDragSourceNode = null, this.rootElement) {
        var t;
        (t = this.window) === null || t === void 0 || t.clearTimeout(this.mouseMoveTimeoutTimer || void 0), this.rootElement.removeEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, !0);
      }
      return this.mouseMoveTimeoutTimer = null, !0;
    }
    return !1;
  }
  handleDragStart(t, n) {
    t.defaultPrevented || (this.dragStartSourceIds || (this.dragStartSourceIds = []), this.dragStartSourceIds.unshift(n));
  }
  handleDragEnter(t, n) {
    this.dragEnterTargetIds.unshift(n);
  }
  handleDragOver(t, n) {
    this.dragOverTargetIds === null && (this.dragOverTargetIds = []), this.dragOverTargetIds.unshift(n);
  }
  handleDrop(t, n) {
    this.dropTargetIds.unshift(n);
  }
  constructor(t, n, r) {
    this.sourcePreviewNodes = /* @__PURE__ */ new Map(), this.sourcePreviewNodeOptions = /* @__PURE__ */ new Map(), this.sourceNodes = /* @__PURE__ */ new Map(), this.sourceNodeOptions = /* @__PURE__ */ new Map(), this.dragStartSourceIds = null, this.dropTargetIds = [], this.dragEnterTargetIds = [], this.currentNativeSource = null, this.currentNativeHandle = null, this.currentDragSourceNode = null, this.altKeyPressed = !1, this.mouseMoveTimeoutTimer = null, this.asyncEndDragFrameId = null, this.dragOverTargetIds = null, this.lastClientOffset = null, this.hoverRafId = null, this.getSourceClientOffset = (i) => {
      const o = this.sourceNodes.get(i);
      return o && hI(o) || null;
    }, this.endDragNativeItem = () => {
      this.isDraggingNativeItem() && (this.actions.endDrag(), this.currentNativeHandle && this.registry.removeSource(this.currentNativeHandle), this.currentNativeHandle = null, this.currentNativeSource = null);
    }, this.isNodeInDocument = (i) => !!(i && this.document && this.document.body && this.document.body.contains(i)), this.endDragIfSourceWasRemovedFromDOM = () => {
      const i = this.currentDragSourceNode;
      i == null || this.isNodeInDocument(i) || (this.clearCurrentDragSourceNode() && this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover());
    }, this.scheduleHover = (i) => {
      this.hoverRafId === null && typeof requestAnimationFrame < "u" && (this.hoverRafId = requestAnimationFrame(() => {
        this.monitor.isDragging() && this.actions.hover(i || [], {
          clientOffset: this.lastClientOffset
        }), this.hoverRafId = null;
      }));
    }, this.cancelHover = () => {
      this.hoverRafId !== null && typeof cancelAnimationFrame < "u" && (cancelAnimationFrame(this.hoverRafId), this.hoverRafId = null);
    }, this.handleTopDragStartCapture = () => {
      this.clearCurrentDragSourceNode(), this.dragStartSourceIds = [];
    }, this.handleTopDragStart = (i) => {
      if (i.defaultPrevented)
        return;
      const { dragStartSourceIds: o } = this;
      this.dragStartSourceIds = null;
      const s = sh(i);
      this.monitor.isDragging() && (this.actions.endDrag(), this.cancelHover()), this.actions.beginDrag(o || [], {
        publishSource: !1,
        getSourceClientOffset: this.getSourceClientOffset,
        clientOffset: s
      });
      const { dataTransfer: a } = i, l = Ov(a);
      if (this.monitor.isDragging()) {
        if (a && typeof a.setDragImage == "function") {
          const c = this.monitor.getSourceId(), d = this.sourceNodes.get(c), f = this.sourcePreviewNodes.get(c) || d;
          if (f) {
            const { anchorX: h, anchorY: p, offsetX: g, offsetY: m } = this.getCurrentSourcePreviewNodeOptions(), x = Rq(d, f, s, {
              anchorX: h,
              anchorY: p
            }, {
              offsetX: g,
              offsetY: m
            });
            a.setDragImage(f, x.x, x.y);
          }
        }
        try {
          a == null || a.setData("application/json", {});
        } catch {
        }
        this.setCurrentDragSourceNode(i.target);
        const { captureDraggingState: u } = this.getCurrentSourcePreviewNodeOptions();
        u ? this.actions.publishDragSource() : setTimeout(
          () => this.actions.publishDragSource(),
          0
        );
      } else if (l)
        this.beginDragNativeItem(l);
      else {
        if (a && !a.types && (i.target && !i.target.hasAttribute || !i.target.hasAttribute("draggable")))
          return;
        i.preventDefault();
      }
    }, this.handleTopDragEndCapture = () => {
      this.clearCurrentDragSourceNode() && this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover();
    }, this.handleTopDragEnterCapture = (i) => {
      if (this.dragEnterTargetIds = [], this.isDraggingNativeItem()) {
        var o;
        (o = this.currentNativeSource) === null || o === void 0 || o.loadDataTransfer(i.dataTransfer);
      }
      if (!this.enterLeaveCounter.enter(i.target) || this.monitor.isDragging())
        return;
      const { dataTransfer: a } = i, l = Ov(a);
      l && this.beginDragNativeItem(l, a);
    }, this.handleTopDragEnter = (i) => {
      const { dragEnterTargetIds: o } = this;
      if (this.dragEnterTargetIds = [], !this.monitor.isDragging())
        return;
      this.altKeyPressed = i.altKey, o.length > 0 && this.actions.hover(o, {
        clientOffset: sh(i)
      }), o.some(
        (a) => this.monitor.canDropOnTarget(a)
      ) && (i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = this.getCurrentDropEffect()));
    }, this.handleTopDragOverCapture = (i) => {
      if (this.dragOverTargetIds = [], this.isDraggingNativeItem()) {
        var o;
        (o = this.currentNativeSource) === null || o === void 0 || o.loadDataTransfer(i.dataTransfer);
      }
    }, this.handleTopDragOver = (i) => {
      const { dragOverTargetIds: o } = this;
      if (this.dragOverTargetIds = [], !this.monitor.isDragging()) {
        i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = "none");
        return;
      }
      this.altKeyPressed = i.altKey, this.lastClientOffset = sh(i), this.scheduleHover(o), (o || []).some(
        (a) => this.monitor.canDropOnTarget(a)
      ) ? (i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = this.getCurrentDropEffect())) : this.isDraggingNativeItem() ? i.preventDefault() : (i.preventDefault(), i.dataTransfer && (i.dataTransfer.dropEffect = "none"));
    }, this.handleTopDragLeaveCapture = (i) => {
      this.isDraggingNativeItem() && i.preventDefault(), this.enterLeaveCounter.leave(i.target) && (this.isDraggingNativeItem() && setTimeout(
        () => this.endDragNativeItem(),
        0
      ), this.cancelHover());
    }, this.handleTopDropCapture = (i) => {
      if (this.dropTargetIds = [], this.isDraggingNativeItem()) {
        var o;
        i.preventDefault(), (o = this.currentNativeSource) === null || o === void 0 || o.loadDataTransfer(i.dataTransfer);
      } else
        Ov(i.dataTransfer) && i.preventDefault();
      this.enterLeaveCounter.reset();
    }, this.handleTopDrop = (i) => {
      const { dropTargetIds: o } = this;
      this.dropTargetIds = [], this.actions.hover(o, {
        clientOffset: sh(i)
      }), this.actions.drop({
        dropEffect: this.getCurrentDropEffect()
      }), this.isDraggingNativeItem() ? this.endDragNativeItem() : this.monitor.isDragging() && this.actions.endDrag(), this.cancelHover();
    }, this.handleSelectStart = (i) => {
      const o = i.target;
      typeof o.dragDrop == "function" && (o.tagName === "INPUT" || o.tagName === "SELECT" || o.tagName === "TEXTAREA" || o.isContentEditable || (i.preventDefault(), o.dragDrop()));
    }, this.options = new Mq(n, r), this.actions = t.getActions(), this.monitor = t.getMonitor(), this.registry = t.getRegistry(), this.enterLeaveCounter = new Eq(this.isNodeInDocument);
  }
}
const K1 = function(t, n, r) {
  return new kq(t, n, r);
}, pI = U.createContext({}), Pq = ({ children: e, getContainer: t }) => {
  const [n, r] = ht(void 0), i = (o) => (n == null ? void 0 : n.type) === o;
  return /* @__PURE__ */ V.jsx(
    pI.Provider,
    {
      value: {
        dialog: n,
        setDialog: r,
        isDialogActive: i,
        getContainer: t
      },
      children: e
    }
  );
}, Of = () => U.useContext(pI);
var Nq = function e(t, n) {
  if (t === n)
    return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor)
      return !1;
    var r, i, o;
    if (Array.isArray(t)) {
      if (r = t.length, r != n.length)
        return !1;
      for (i = r; i-- !== 0; )
        if (!e(t[i], n[i]))
          return !1;
      return !0;
    }
    if (t instanceof Map && n instanceof Map) {
      if (t.size !== n.size)
        return !1;
      for (i of t.entries())
        if (!n.has(i[0]))
          return !1;
      for (i of t.entries())
        if (!e(i[1], n.get(i[0])))
          return !1;
      return !0;
    }
    if (t instanceof Set && n instanceof Set) {
      if (t.size !== n.size)
        return !1;
      for (i of t.entries())
        if (!n.has(i[0]))
          return !1;
      return !0;
    }
    if (ArrayBuffer.isView(t) && ArrayBuffer.isView(n)) {
      if (r = t.length, r != n.length)
        return !1;
      for (i = r; i-- !== 0; )
        if (t[i] !== n[i])
          return !1;
      return !0;
    }
    if (t.constructor === RegExp)
      return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf)
      return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString)
      return t.toString() === n.toString();
    if (o = Object.keys(t), r = o.length, r !== Object.keys(n).length)
      return !1;
    for (i = r; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, o[i]))
        return !1;
    for (i = r; i-- !== 0; ) {
      var s = o[i];
      if (!(s === "_owner" && t.$$typeof) && !e(t[s], n[s]))
        return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
};
const ro = /* @__PURE__ */ hl(Nq);
var gI = Symbol.for("immer-nothing"), c$ = Symbol.for("immer-draftable"), Li = Symbol.for("immer-state"), Lq = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function mi(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Lq[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Pc = Object.getPrototypeOf;
function Nc(e) {
  return !!e && !!e[Li];
}
function tl(e) {
  var t;
  return e ? mI(e) || Array.isArray(e) || !!e[c$] || !!((t = e.constructor) != null && t[c$]) || fm(e) || hm(e) : !1;
}
var Fq = Object.prototype.constructor.toString();
function mI(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Pc(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Fq;
}
function Hp(e, t) {
  dm(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function dm(e) {
  const t = e[Li];
  return t ? t.type_ : Array.isArray(e) ? 1 : fm(e) ? 2 : hm(e) ? 3 : 0;
}
function Wb(e, t) {
  return dm(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function vI(e, t, n) {
  const r = dm(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Bq(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function fm(e) {
  return e instanceof Map;
}
function hm(e) {
  return e instanceof Set;
}
function Da(e) {
  return e.copy_ || e.base_;
}
function Ub(e, t) {
  if (fm(e))
    return new Map(e);
  if (hm(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  if (!t && mI(e))
    return Pc(e) ? { ...e } : Object.assign(/* @__PURE__ */ Object.create(null), e);
  const n = Object.getOwnPropertyDescriptors(e);
  delete n[Li];
  let r = Reflect.ownKeys(n);
  for (let i = 0; i < r.length; i++) {
    const o = r[i], s = n[o];
    s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (n[o] = {
      configurable: !0,
      writable: !0,
      // could live with !!desc.set as well here...
      enumerable: s.enumerable,
      value: e[o]
    });
  }
  return Object.create(Pc(e), n);
}
function X1(e, t = !1) {
  return pm(e) || Nc(e) || !tl(e) || (dm(e) > 1 && (e.set = e.add = e.clear = e.delete = jq), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => X1(r, !0))), e;
}
function jq() {
  mi(2);
}
function pm(e) {
  return Object.isFrozen(e);
}
var zq = {};
function nl(e) {
  const t = zq[e];
  return t || mi(0, e), t;
}
var Rd;
function bI() {
  return Rd;
}
function Hq(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function u$(e, t) {
  t && (nl("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Gb(e) {
  Kb(e), e.drafts_.forEach(Vq), e.drafts_ = null;
}
function Kb(e) {
  e === Rd && (Rd = e.parent_);
}
function d$(e) {
  return Rd = Hq(Rd, e);
}
function Vq(e) {
  const t = e[Li];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function f$(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Li].modified_ && (Gb(t), mi(4)), tl(e) && (e = Vp(t, e), t.parent_ || Wp(t, e)), t.patches_ && nl("Patches").generateReplacementPatches_(
    n[Li].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Vp(t, n, []), Gb(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== gI ? e : void 0;
}
function Vp(e, t, n) {
  if (pm(t))
    return t;
  const r = t[Li];
  if (!r)
    return Hp(
      t,
      (i, o) => h$(e, r, t, i, o, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Wp(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const i = r.copy_;
    let o = i, s = !1;
    r.type_ === 3 && (o = new Set(i), i.clear(), s = !0), Hp(
      o,
      (a, l) => h$(e, r, i, a, l, n, s)
    ), Wp(e, i, !1), n && e.patches_ && nl("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function h$(e, t, n, r, i, o, s) {
  if (process.env.NODE_ENV !== "production" && i === n && mi(5), Nc(i)) {
    const a = o && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Wb(t.assigned_, r) ? o.concat(r) : void 0, l = Vp(e, i, a);
    if (vI(n, r, l), Nc(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else
    s && n.add(i);
  if (tl(i) && !pm(i)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Vp(e, i), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Wp(e, i);
  }
}
function Wp(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && X1(t, n);
}
function Wq(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : bI(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let i = r, o = Y1;
  n && (i = [r], o = Md);
  const { revoke: s, proxy: a } = Proxy.revocable(i, o);
  return r.draft_ = a, r.revoke_ = s, a;
}
var Y1 = {
  get(e, t) {
    if (t === Li)
      return e;
    const n = Da(e);
    if (!Wb(n, t))
      return Uq(e, n, t);
    const r = n[t];
    return e.finalized_ || !tl(r) ? r : r === Av(e.base_, t) ? (Dv(e), e.copy_[t] = Yb(r, e)) : r;
  },
  has(e, t) {
    return t in Da(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Da(e));
  },
  set(e, t, n) {
    const r = yI(Da(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const i = Av(Da(e), t), o = i == null ? void 0 : i[Li];
      if (o && o.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Bq(n, i) && (n !== void 0 || Wb(e.base_, t)))
        return !0;
      Dv(e), Xb(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Av(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Dv(e), Xb(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Da(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    mi(11);
  },
  getPrototypeOf(e) {
    return Pc(e.base_);
  },
  setPrototypeOf() {
    mi(12);
  }
}, Md = {};
Hp(Y1, (e, t) => {
  Md[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Md.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && mi(13), Md.set.call(this, e, t, void 0);
};
Md.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && mi(14), Y1.set.call(this, e[0], t, n, e[0]);
};
function Av(e, t) {
  const n = e[Li];
  return (n ? Da(n) : e)[t];
}
function Uq(e, t, n) {
  var i;
  const r = yI(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (i = r.get) == null ? void 0 : i.call(e.draft_)
  ) : void 0;
}
function yI(e, t) {
  if (!(t in e))
    return;
  let n = Pc(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Pc(n);
  }
}
function Xb(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Xb(e.parent_));
}
function Dv(e) {
  e.copy_ || (e.copy_ = Ub(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Gq = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const o = n;
        n = t;
        const s = this;
        return function(l = o, ...u) {
          return s.produce(l, (c) => n.call(this, c, ...u));
        };
      }
      typeof n != "function" && mi(6), r !== void 0 && typeof r != "function" && mi(7);
      let i;
      if (tl(t)) {
        const o = d$(this), s = Yb(t, void 0);
        let a = !0;
        try {
          i = n(s), a = !1;
        } finally {
          a ? Gb(o) : Kb(o);
        }
        return u$(o, r), f$(i, o);
      } else if (!t || typeof t != "object") {
        if (i = n(t), i === void 0 && (i = t), i === gI && (i = void 0), this.autoFreeze_ && X1(i, !0), r) {
          const o = [], s = [];
          nl("Patches").generateReplacementPatches_(t, i, o, s), r(o, s);
        }
        return i;
      } else
        mi(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (s, ...a) => this.produceWithPatches(s, (l) => t(l, ...a));
      let r, i;
      return [this.produce(t, n, (s, a) => {
        r = s, i = a;
      }), r, i];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    tl(e) || mi(8), Nc(e) && (e = Kq(e));
    const t = d$(this), n = Yb(e, void 0);
    return n[Li].isManual_ = !0, Kb(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Li];
    (!n || !n.isManual_) && mi(9);
    const { scope_: r } = n;
    return u$(r, t), f$(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const i = t[n];
      if (i.path.length === 0 && i.op === "replace") {
        e = i.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = nl("Patches").applyPatches_;
    return Nc(e) ? r(e, t) : this.produce(
      e,
      (i) => r(i, t)
    );
  }
};
function Yb(e, t) {
  const n = fm(e) ? nl("MapSet").proxyMap_(e, t) : hm(e) ? nl("MapSet").proxySet_(e, t) : Wq(e, t);
  return (t ? t.scope_ : bI()).drafts_.push(n), n;
}
function Kq(e) {
  return Nc(e) || mi(10, e), wI(e);
}
function wI(e) {
  if (!tl(e) || pm(e))
    return e;
  const t = e[Li];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Ub(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Ub(e, !0);
  return Hp(n, (r, i) => {
    vI(n, r, wI(i));
  }), t && (t.finalized_ = !1), n;
}
var Fi = new Gq(), Mn = Fi.produce;
Fi.produceWithPatches.bind(
  Fi
);
Fi.setAutoFreeze.bind(Fi);
Fi.setUseStrictShallowCopy.bind(Fi);
Fi.applyPatches.bind(Fi);
Fi.createDraft.bind(Fi);
Fi.finishDraft.bind(Fi);
var Xq = { BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const p$ = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), r = (c, d) => {
    const f = typeof c == "function" ? c(t) : c;
    if (!Object.is(f, t)) {
      const h = t;
      t = d ?? (typeof f != "object" || f === null) ? f : Object.assign({}, t, f), n.forEach((p) => p(t, h));
    }
  }, i = () => t, l = { setState: r, getState: i, getInitialState: () => u, subscribe: (c) => (n.add(c), () => n.delete(c)), destroy: () => {
    (Xq ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, u = t = e(r, i, l);
  return l;
}, CI = (e) => e ? p$(e) : p$;
var qb = { exports: {} }, _v = {}, ah = { exports: {} }, Tv = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var g$;
function Yq() {
  if (g$)
    return Tv;
  g$ = 1;
  var e = U;
  function t(d, f) {
    return d === f && (d !== 0 || 1 / d === 1 / f) || d !== d && f !== f;
  }
  var n = typeof Object.is == "function" ? Object.is : t, r = e.useState, i = e.useEffect, o = e.useLayoutEffect, s = e.useDebugValue;
  function a(d, f) {
    var h = f(), p = r({ inst: { value: h, getSnapshot: f } }), g = p[0].inst, m = p[1];
    return o(function() {
      g.value = h, g.getSnapshot = f, l(g) && m({ inst: g });
    }, [d, h, f]), i(function() {
      return l(g) && m({ inst: g }), d(function() {
        l(g) && m({ inst: g });
      });
    }, [d]), s(h), h;
  }
  function l(d) {
    var f = d.getSnapshot;
    d = d.value;
    try {
      var h = f();
      return !n(d, h);
    } catch {
      return !0;
    }
  }
  function u(d, f) {
    return f();
  }
  var c = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? u : a;
  return Tv.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : c, Tv;
}
var Rv = {};
/**
 * @license React
 * use-sync-external-store-shim.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var m$;
function qq() {
  return m$ || (m$ = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = U, t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function n(x) {
      {
        for (var w = arguments.length, C = new Array(w > 1 ? w - 1 : 0), y = 1; y < w; y++)
          C[y - 1] = arguments[y];
        r("error", x, C);
      }
    }
    function r(x, w, C) {
      {
        var y = t.ReactDebugCurrentFrame, S = y.getStackAddendum();
        S !== "" && (w += "%s", C = C.concat([S]));
        var A = C.map(function($) {
          return String($);
        });
        A.unshift("Warning: " + w), Function.prototype.apply.call(console[x], console, A);
      }
    }
    function i(x, w) {
      return x === w && (x !== 0 || 1 / x === 1 / w) || x !== x && w !== w;
    }
    var o = typeof Object.is == "function" ? Object.is : i, s = e.useState, a = e.useEffect, l = e.useLayoutEffect, u = e.useDebugValue, c = !1, d = !1;
    function f(x, w, C) {
      c || e.startTransition !== void 0 && (c = !0, n("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."));
      var y = w();
      if (!d) {
        var S = w();
        o(y, S) || (n("The result of getSnapshot should be cached to avoid an infinite loop"), d = !0);
      }
      var A = s({
        inst: {
          value: y,
          getSnapshot: w
        }
      }), $ = A[0].inst, M = A[1];
      return l(function() {
        $.value = y, $.getSnapshot = w, h($) && M({
          inst: $
        });
      }, [x, y, w]), a(function() {
        h($) && M({
          inst: $
        });
        var _ = function() {
          h($) && M({
            inst: $
          });
        };
        return x(_);
      }, [x]), u(y), y;
    }
    function h(x) {
      var w = x.getSnapshot, C = x.value;
      try {
        var y = w();
        return !o(C, y);
      } catch {
        return !0;
      }
    }
    function p(x, w, C) {
      return w();
    }
    var g = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", m = !g, v = m ? p : f, b = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : v;
    Rv.useSyncExternalStore = b, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Rv;
}
var v$;
function SI() {
  return v$ || (v$ = 1, process.env.NODE_ENV === "production" ? ah.exports = Yq() : ah.exports = qq()), ah.exports;
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$;
function Qq() {
  if (b$)
    return _v;
  b$ = 1;
  var e = U, t = SI();
  function n(u, c) {
    return u === c && (u !== 0 || 1 / u === 1 / c) || u !== u && c !== c;
  }
  var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, s = e.useEffect, a = e.useMemo, l = e.useDebugValue;
  return _v.useSyncExternalStoreWithSelector = function(u, c, d, f, h) {
    var p = o(null);
    if (p.current === null) {
      var g = { hasValue: !1, value: null };
      p.current = g;
    } else
      g = p.current;
    p = a(function() {
      function v(y) {
        if (!b) {
          if (b = !0, x = y, y = f(y), h !== void 0 && g.hasValue) {
            var S = g.value;
            if (h(S, y))
              return w = S;
          }
          return w = y;
        }
        if (S = w, r(x, y))
          return S;
        var A = f(y);
        return h !== void 0 && h(S, A) ? S : (x = y, w = A);
      }
      var b = !1, x, w, C = d === void 0 ? null : d;
      return [function() {
        return v(c());
      }, C === null ? void 0 : function() {
        return v(C());
      }];
    }, [c, d, f, h]);
    var m = i(u, p[0], p[1]);
    return s(function() {
      g.hasValue = !0, g.value = m;
    }, [m]), l(m), m;
  }, _v;
}
var Mv = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var y$;
function Zq() {
  return y$ || (y$ = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = U, t = SI();
    function n(c, d) {
      return c === d && (c !== 0 || 1 / c === 1 / d) || c !== c && d !== d;
    }
    var r = typeof Object.is == "function" ? Object.is : n, i = t.useSyncExternalStore, o = e.useRef, s = e.useEffect, a = e.useMemo, l = e.useDebugValue;
    function u(c, d, f, h, p) {
      var g = o(null), m;
      g.current === null ? (m = {
        hasValue: !1,
        value: null
      }, g.current = m) : m = g.current;
      var v = a(function() {
        var C = !1, y, S, A = function(T) {
          if (!C) {
            C = !0, y = T;
            var D = h(T);
            if (p !== void 0 && m.hasValue) {
              var E = m.value;
              if (p(E, D))
                return S = E, E;
            }
            return S = D, D;
          }
          var R = y, I = S;
          if (r(R, T))
            return I;
          var k = h(T);
          return p !== void 0 && p(I, k) ? I : (y = T, S = k, k);
        }, $ = f === void 0 ? null : f, M = function() {
          return A(d());
        }, _ = $ === null ? void 0 : function() {
          return A($());
        };
        return [M, _];
      }, [d, f, h, p]), b = v[0], x = v[1], w = i(c, b, x);
      return s(function() {
        m.hasValue = !0, m.value = w;
      }, [w]), l(w), w;
    }
    Mv.useSyncExternalStoreWithSelector = u, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), Mv;
}
process.env.NODE_ENV === "production" ? qb.exports = Qq() : qb.exports = Zq();
var Jq = qb.exports;
const xI = /* @__PURE__ */ hl(Jq);
var EI = { BASE_URL: "/", MODE: "production", DEV: !1, PROD: !0, SSR: !1 };
const { useDebugValue: eQ } = U, { useSyncExternalStoreWithSelector: tQ } = xI;
let w$ = !1;
const nQ = (e) => e;
function rQ(e, t = nQ, n) {
  (EI ? "production" : void 0) !== "production" && n && !w$ && (console.warn(
    "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
  ), w$ = !0);
  const r = tQ(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return eQ(r), r;
}
const C$ = (e) => {
  (EI ? "production" : void 0) !== "production" && typeof e != "function" && console.warn(
    "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
  );
  const t = typeof e == "function" ? CI(e) : e, n = (r, i) => rQ(t, r, i);
  return Object.assign(n, t), n;
}, pc = (e) => e ? C$(e) : C$, S$ = (e, t, n) => {
  const r = [...e.inputs, ...e.outputs], i = {
    _id: t._id || crypto.randomUUID(),
    _description: t._description
  };
  return r.forEach((o) => {
    if (n && i._id === n)
      return i[o.id] = (t == null ? void 0 : t[o.id]) || (o == null ? void 0 : o.defaultValue) || "";
    i[o.id] = (t == null ? void 0 : t[o.id]) || "";
  }), i;
}, lh = (e, t) => {
  const n = (e == null ? void 0 : e.rules) || [], r = [...e.inputs, ...e.outputs];
  return n.map((i) => {
    const o = {
      _id: i._id || crypto.randomUUID(),
      _description: i._description
    };
    return r.forEach((s) => {
      o[s.id] = (i == null ? void 0 : i[s.id]) || "";
    }), o;
  });
}, Id = (e) => {
  var n, r;
  const t = {
    hitPolicy: (e == null ? void 0 : e.hitPolicy) || "first",
    inputs: (e == null ? void 0 : e.inputs) || [],
    outputs: (e == null ? void 0 : e.outputs) || [],
    rules: (e == null ? void 0 : e.rules) || []
  };
  return ((n = t.inputs) == null ? void 0 : n.length) === 0 && (t.inputs = [
    {
      id: crypto.randomUUID(),
      name: "Input",
      type: "expression"
    }
  ]), ((r = t.outputs) == null ? void 0 : r.length) === 0 && (t.outputs = [
    {
      id: crypto.randomUUID(),
      field: "output",
      name: "Output",
      type: "expression"
    }
  ]), t.rules.forEach((i) => {
    typeof i._id == "string" && i._id.length > 0 || (i._id = crypto.randomUUID());
  }), t;
}, Af = U.createContext({}), iQ = (e) => {
  const { children: t } = e, n = mt(
    () => pc(() => ({
      id: void 0,
      name: void 0,
      decisionTable: Id(),
      cursor: null,
      activeRules: [],
      disabled: !1,
      configurable: !0,
      disableHitPolicy: !1,
      colWidth: 200,
      minColWidth: 150,
      inputsSchema: void 0,
      outputsSchema: void 0
    })),
    []
  ), r = mt(
    () => pc(() => ({
      onChange: void 0,
      cellRenderer: void 0
    })),
    []
  ), i = mt(
    () => ({
      setDecisionTable: (o) => n.setState({ decisionTable: o }),
      setCursor: (o) => n.setState({ cursor: o }),
      commitData: (o, s) => {
        var u, c;
        const { decisionTable: a } = n.getState(), l = Mn(a, (d) => {
          const { x: f, y: h } = s;
          return d.rules[h][f] = o, d;
        });
        n.setState({ decisionTable: l }), (c = (u = r.getState()).onChange) == null || c.call(u, l);
      },
      swapRows: (o, s) => {
        var u, c;
        const { decisionTable: a } = n.getState(), l = Mn(a, (d) => {
          var h;
          const f = (h = d == null ? void 0 : d.rules) == null ? void 0 : h[o];
          return d.rules.splice(o, 1), d.rules.splice(s, 0, f), d;
        });
        n.setState({ decisionTable: l, cursor: null }), (c = (u = r.getState()).onChange) == null || c.call(u, l);
      },
      addRowAbove: (o) => {
        var u, c;
        const { decisionTable: s } = n.getState(), a = Mn(s, (d) => {
          o === void 0 && (o = 0);
          const f = crypto.randomUUID();
          return d.rules.splice(o, 0, S$(d, { _id: f }, f)), d;
        });
        n.setState({ decisionTable: a }), (c = (u = r.getState()).onChange) == null || c.call(u, a);
        const { cursor: l } = n.getState();
        l && (l == null ? void 0 : l.y) === o && n.setState({ cursor: { x: l.x, y: l.y + 1 } });
      },
      addRowBelow: (o) => {
        var u, c;
        const { decisionTable: s } = n.getState(), a = Mn(s, (d) => {
          var h;
          o === void 0 ? o = (h = d == null ? void 0 : d.rules) == null ? void 0 : h.length : o += 1;
          const f = crypto.randomUUID();
          return d.rules.splice(o, 0, S$(d, { _id: f }, f)), d;
        });
        n.setState({ decisionTable: a }), (c = (u = r.getState()).onChange) == null || c.call(u, a);
        const { cursor: l } = n.getState();
        l && (l == null ? void 0 : l.y) === o && n.setState({ cursor: { x: l.x, y: l.y - 1 } });
      },
      removeRow: (o) => {
        var l, u;
        const { decisionTable: s } = n.getState(), a = Mn(s, (c) => {
          var d;
          return o === void 0 && (o = ((d = c == null ? void 0 : c.rules) == null ? void 0 : d.length) || 0), c.rules.splice(o, 1), c;
        });
        n.setState({ decisionTable: a }), (u = (l = r.getState()).onChange) == null || u.call(l, a);
      },
      addColumn: (o, s) => {
        var u, c;
        const { decisionTable: a } = n.getState(), l = Mn(a, (d) => (d[o].push(s), d.rules = lh(d), d));
        n.setState({ decisionTable: l }), (c = (u = r.getState()).onChange) == null || c.call(u, l);
      },
      updateColumn: (o, s, a) => {
        var c, d;
        const { decisionTable: l } = n.getState(), u = Mn(l, (f) => (f[o] = f[o].map((h) => h.id === s ? {
          ...h,
          name: a == null ? void 0 : a.name,
          field: a == null ? void 0 : a.field,
          defaultValue: a == null ? void 0 : a.defaultValue
        } : h), f.rules = lh(f), f));
        n.setState({ decisionTable: u }), (d = (c = r.getState()).onChange) == null || d.call(c, u);
      },
      removeColumn: (o, s) => {
        var u, c;
        const { decisionTable: a } = n.getState(), l = Id(
          Mn(a, (d) => (d[o] = ((d == null ? void 0 : d[o]) || []).filter((f) => (f == null ? void 0 : f.id) !== s), d.rules = lh(d), d))
        );
        n.setState({ decisionTable: l, cursor: null }), (c = (u = r.getState()).onChange) == null || c.call(u, l);
      },
      reorderColumns: (o, s) => {
        var u, c;
        const { decisionTable: a } = n.getState(), l = Mn(a, (d) => (d[o] = s, d.rules = lh(d), d));
        n.setState({ decisionTable: l }), (c = (u = r.getState()).onChange) == null || c.call(u, l);
      },
      updateHitPolicy: (o) => {
        var l, u;
        const { decisionTable: s } = n.getState(), a = Mn(s, (c) => (c.hitPolicy = o, c));
        n.setState({ decisionTable: a }), (u = (l = r.getState()).onChange) == null || u.call(l, a);
      }
    }),
    []
  );
  return /* @__PURE__ */ V.jsx(
    Af.Provider,
    {
      value: {
        stateStore: n,
        listenerStore: r,
        actions: i
      },
      children: t
    }
  );
};
function io(e, t = ro) {
  return U.useContext(Af).stateStore(e, t);
}
function oQ(e, t = ro) {
  return U.useContext(Af).listenerStore(e, t);
}
function Qo() {
  return U.useContext(Af).actions;
}
const $I = () => U.useContext(Af), q1 = (e, t) => {
  const n = e == null ? void 0 : e[0];
  if (!n)
    return;
  const r = t.find((i) => i.field === n);
  return r != null && r.items ? q1(e.slice(1), r.items) : r;
}, OI = (e, t) => {
  if (!(!e || !t))
    for (let n = 0; n < t.length; n++) {
      const r = t[n];
      if (r.field === e)
        return [r.field];
      if (r.items) {
        const i = OI(e, r.items);
        if (!i)
          continue;
        return [r.field, ...i];
      }
    }
}, sQ = (e) => (t) => [
  ...t.decisionTable.inputs.map((n) => ({
    ...n,
    colType: "input"
  })),
  ...t.decisionTable.outputs.map((n) => ({
    ...n,
    colType: "output"
  }))
].find((n) => n.id === e);
function AI(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number")
    r += e;
  else if (typeof e == "object")
    if (Array.isArray(e)) {
      var i = e.length;
      for (t = 0; t < i; t++)
        e[t] && (n = AI(e[t])) && (r && (r += " "), r += n);
    } else
      for (n in e)
        e[n] && (r && (r += " "), r += n);
  return r;
}
function wn() {
  for (var e, t, n = 0, r = "", i = arguments.length; n < i; n++)
    (e = arguments[n]) && (t = AI(e)) && (r && (r += " "), r += t);
  return r;
}
function DI(...e) {
  return e.length === 2 ? E$(e[0], e[1]) || null : e.slice(1).reduce(
    (n, r) => E$(n, r),
    e[0]
  ) || null;
}
const x$ = /* @__PURE__ */ new WeakMap();
function E$(e, t) {
  if (e && t) {
    const n = x$.get(e) || /* @__PURE__ */ new WeakMap();
    x$.set(e, n);
    const r = n.get(t) || ((i) => {
      $$(e, i), $$(t, i);
    });
    return n.set(t, r), r;
  }
  return e || t;
}
function $$(e, t) {
  typeof e == "function" ? e(t) : e.current = t;
}
const O$ = (e, t) => {
  const n = getComputedStyle(e), r = parseInt(n.lineHeight), i = parseInt(n.paddingTop), o = parseInt(n.paddingBottom);
  e.rows = 1;
  const s = e.scrollHeight - i - o, a = Math.floor(s / r);
  e.rows = Math.min(Math.max(a, 1), t);
}, Q1 = U.forwardRef(
  ({ maxRows: e, className: t, value: n, ...r }, i) => {
    const o = he(null);
    return Pe(() => {
      o.current && O$(o.current, e);
    }, [n, e]), Pe(() => {
      if (!o.current)
        return;
      const s = (l) => {
        window.requestAnimationFrame(() => {
          !Array.isArray(l) || l.length === 0 || O$(l[0].target, e);
        });
      }, a = new ResizeObserver(s);
      return a.observe(o.current), () => {
        a.disconnect();
      };
    }, [e]), /* @__PURE__ */ V.jsx(
      "textarea",
      {
        className: wn("grl-textarea-input", t),
        ref: DI(o, i),
        value: n,
        ...r
      }
    );
  }
);
class fn {
  /**
  Get the line description around the given position.
  */
  lineAt(t) {
    if (t < 0 || t > this.length)
      throw new RangeError(`Invalid position ${t} in document of length ${this.length}`);
    return this.lineInner(t, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(t) {
    if (t < 1 || t > this.lines)
      throw new RangeError(`Invalid line number ${t} in ${this.lines}-line document`);
    return this.lineInner(t, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(t, n, r) {
    [t, n] = Lc(this, t, n);
    let i = [];
    return this.decompose(
      0,
      t,
      i,
      2
      /* Open.To */
    ), r.length && r.decompose(
      0,
      r.length,
      i,
      3
      /* Open.To */
    ), this.decompose(
      n,
      this.length,
      i,
      1
      /* Open.From */
    ), Ho.from(i, this.length - (n - t) + r.length);
  }
  /**
  Append another document to this one.
  */
  append(t) {
    return this.replace(this.length, this.length, t);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(t, n = this.length) {
    [t, n] = Lc(this, t, n);
    let r = [];
    return this.decompose(t, n, r, 0), Ho.from(r, n - t);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(t) {
    if (t == this)
      return !0;
    if (t.length != this.length || t.lines != this.lines)
      return !1;
    let n = this.scanIdentical(t, 1), r = this.length - this.scanIdentical(t, -1), i = new rd(this), o = new rd(t);
    for (let s = n, a = n; ; ) {
      if (i.next(s), o.next(s), s = 0, i.lineBreak != o.lineBreak || i.done != o.done || i.value != o.value)
        return !1;
      if (a += i.value.length, i.done || a >= r)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(t = 1) {
    return new rd(this, t);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(t, n = this.length) {
    return new _I(this, t, n);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(t, n) {
    let r;
    if (t == null)
      r = this.iter();
    else {
      n == null && (n = this.lines + 1);
      let i = this.line(t).from;
      r = this.iterRange(i, Math.max(i, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));
    }
    return new TI(r);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let t = [];
    return this.flatten(t), t;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(t) {
    if (t.length == 0)
      throw new RangeError("A document must have at least one line");
    return t.length == 1 && !t[0] ? fn.empty : t.length <= 32 ? new rr(t) : Ho.from(rr.split(t, []));
  }
}
class rr extends fn {
  constructor(t, n = aQ(t)) {
    super(), this.text = t, this.length = n;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(t, n, r, i) {
    for (let o = 0; ; o++) {
      let s = this.text[o], a = i + s.length;
      if ((n ? r : a) >= t)
        return new lQ(i, a, r, s);
      i = a + 1, r++;
    }
  }
  decompose(t, n, r, i) {
    let o = t <= 0 && n >= this.length ? this : new rr(A$(this.text, t, n), Math.min(n, this.length) - Math.max(0, t));
    if (i & 1) {
      let s = r.pop(), a = cp(o.text, s.text.slice(), 0, o.length);
      if (a.length <= 32)
        r.push(new rr(a, s.length + o.length));
      else {
        let l = a.length >> 1;
        r.push(new rr(a.slice(0, l)), new rr(a.slice(l)));
      }
    } else
      r.push(o);
  }
  replace(t, n, r) {
    if (!(r instanceof rr))
      return super.replace(t, n, r);
    [t, n] = Lc(this, t, n);
    let i = cp(this.text, cp(r.text, A$(this.text, 0, t)), n), o = this.length + r.length - (n - t);
    return i.length <= 32 ? new rr(i, o) : Ho.from(rr.split(i, []), o);
  }
  sliceString(t, n = this.length, r = `
`) {
    [t, n] = Lc(this, t, n);
    let i = "";
    for (let o = 0, s = 0; o <= n && s < this.text.length; s++) {
      let a = this.text[s], l = o + a.length;
      o > t && s && (i += r), t < l && n > o && (i += a.slice(Math.max(0, t - o), n - o)), o = l + 1;
    }
    return i;
  }
  flatten(t) {
    for (let n of this.text)
      t.push(n);
  }
  scanIdentical() {
    return 0;
  }
  static split(t, n) {
    let r = [], i = -1;
    for (let o of t)
      r.push(o), i += o.length + 1, r.length == 32 && (n.push(new rr(r, i)), r = [], i = -1);
    return i > -1 && n.push(new rr(r, i)), n;
  }
}
class Ho extends fn {
  constructor(t, n) {
    super(), this.children = t, this.length = n, this.lines = 0;
    for (let r of t)
      this.lines += r.lines;
  }
  lineInner(t, n, r, i) {
    for (let o = 0; ; o++) {
      let s = this.children[o], a = i + s.length, l = r + s.lines - 1;
      if ((n ? l : a) >= t)
        return s.lineInner(t, n, r, i);
      i = a + 1, r = l + 1;
    }
  }
  decompose(t, n, r, i) {
    for (let o = 0, s = 0; s <= n && o < this.children.length; o++) {
      let a = this.children[o], l = s + a.length;
      if (t <= l && n >= s) {
        let u = i & ((s <= t ? 1 : 0) | (l >= n ? 2 : 0));
        s >= t && l <= n && !u ? r.push(a) : a.decompose(t - s, n - s, r, u);
      }
      s = l + 1;
    }
  }
  replace(t, n, r) {
    if ([t, n] = Lc(this, t, n), r.lines < this.lines)
      for (let i = 0, o = 0; i < this.children.length; i++) {
        let s = this.children[i], a = o + s.length;
        if (t >= o && n <= a) {
          let l = s.replace(t - o, n - o, r), u = this.lines - s.lines + l.lines;
          if (l.lines < u >> 4 && l.lines > u >> 6) {
            let c = this.children.slice();
            return c[i] = l, new Ho(c, this.length - (n - t) + r.length);
          }
          return super.replace(o, a, l);
        }
        o = a + 1;
      }
    return super.replace(t, n, r);
  }
  sliceString(t, n = this.length, r = `
`) {
    [t, n] = Lc(this, t, n);
    let i = "";
    for (let o = 0, s = 0; o < this.children.length && s <= n; o++) {
      let a = this.children[o], l = s + a.length;
      s > t && o && (i += r), t < l && n > s && (i += a.sliceString(t - s, n - s, r)), s = l + 1;
    }
    return i;
  }
  flatten(t) {
    for (let n of this.children)
      n.flatten(t);
  }
  scanIdentical(t, n) {
    if (!(t instanceof Ho))
      return 0;
    let r = 0, [i, o, s, a] = n > 0 ? [0, 0, this.children.length, t.children.length] : [this.children.length - 1, t.children.length - 1, -1, -1];
    for (; ; i += n, o += n) {
      if (i == s || o == a)
        return r;
      let l = this.children[i], u = t.children[o];
      if (l != u)
        return r + l.scanIdentical(u, n);
      r += l.length + 1;
    }
  }
  static from(t, n = t.reduce((r, i) => r + i.length + 1, -1)) {
    let r = 0;
    for (let h of t)
      r += h.lines;
    if (r < 32) {
      let h = [];
      for (let p of t)
        p.flatten(h);
      return new rr(h, n);
    }
    let i = Math.max(
      32,
      r >> 5
      /* Tree.BranchShift */
    ), o = i << 1, s = i >> 1, a = [], l = 0, u = -1, c = [];
    function d(h) {
      let p;
      if (h.lines > o && h instanceof Ho)
        for (let g of h.children)
          d(g);
      else
        h.lines > s && (l > s || !l) ? (f(), a.push(h)) : h instanceof rr && l && (p = c[c.length - 1]) instanceof rr && h.lines + p.lines <= 32 ? (l += h.lines, u += h.length + 1, c[c.length - 1] = new rr(p.text.concat(h.text), p.length + 1 + h.length)) : (l + h.lines > i && f(), l += h.lines, u += h.length + 1, c.push(h));
    }
    function f() {
      l != 0 && (a.push(c.length == 1 ? c[0] : Ho.from(c, u)), u = -1, l = c.length = 0);
    }
    for (let h of t)
      d(h);
    return f(), a.length == 1 ? a[0] : new Ho(a, n);
  }
}
fn.empty = /* @__PURE__ */ new rr([""], 0);
function aQ(e) {
  let t = -1;
  for (let n of e)
    t += n.length + 1;
  return t;
}
function cp(e, t, n = 0, r = 1e9) {
  for (let i = 0, o = 0, s = !0; o < e.length && i <= r; o++) {
    let a = e[o], l = i + a.length;
    l >= n && (l > r && (a = a.slice(0, r - i)), i < n && (a = a.slice(n - i)), s ? (t[t.length - 1] += a, s = !1) : t.push(a)), i = l + 1;
  }
  return t;
}
function A$(e, t, n) {
  return cp(e, [""], t, n);
}
class rd {
  constructor(t, n = 1) {
    this.dir = n, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [t], this.offsets = [n > 0 ? 1 : (t instanceof rr ? t.text.length : t.children.length) << 1];
  }
  nextInner(t, n) {
    for (this.done = this.lineBreak = !1; ; ) {
      let r = this.nodes.length - 1, i = this.nodes[r], o = this.offsets[r], s = o >> 1, a = i instanceof rr ? i.text.length : i.children.length;
      if (s == (n > 0 ? a : 0)) {
        if (r == 0)
          return this.done = !0, this.value = "", this;
        n > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((o & 1) == (n > 0 ? 0 : 1)) {
        if (this.offsets[r] += n, t == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        t--;
      } else if (i instanceof rr) {
        let l = i.text[s + (n < 0 ? -1 : 0)];
        if (this.offsets[r] += n, l.length > Math.max(0, t))
          return this.value = t == 0 ? l : n > 0 ? l.slice(t) : l.slice(0, l.length - t), this;
        t -= l.length;
      } else {
        let l = i.children[s + (n < 0 ? -1 : 0)];
        t > l.length ? (t -= l.length, this.offsets[r] += n) : (n < 0 && this.offsets[r]--, this.nodes.push(l), this.offsets.push(n > 0 ? 1 : (l instanceof rr ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(t = 0) {
    return t < 0 && (this.nextInner(-t, -this.dir), t = this.value.length), this.nextInner(t, this.dir);
  }
}
class _I {
  constructor(t, n, r) {
    this.value = "", this.done = !1, this.cursor = new rd(t, n > r ? -1 : 1), this.pos = n > r ? t.length : 0, this.from = Math.min(n, r), this.to = Math.max(n, r);
  }
  nextInner(t, n) {
    if (n < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    t += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);
    let r = n < 0 ? this.pos - this.from : this.to - this.pos;
    t > r && (t = r), r -= t;
    let { value: i } = this.cursor.next(t);
    return this.pos += (i.length + t) * n, this.value = i.length <= r ? i : n < 0 ? i.slice(i.length - r) : i.slice(0, r), this.done = !this.value, this;
  }
  next(t = 0) {
    return t < 0 ? t = Math.max(t, this.from - this.pos) : t > 0 && (t = Math.min(t, this.to - this.pos)), this.nextInner(t, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class TI {
  constructor(t) {
    this.inner = t, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(t = 0) {
    let { done: n, lineBreak: r, value: i } = this.inner.next(t);
    return n && this.afterBreak ? (this.value = "", this.afterBreak = !1) : n ? (this.done = !0, this.value = "") : r ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (fn.prototype[Symbol.iterator] = function() {
  return this.iter();
}, rd.prototype[Symbol.iterator] = _I.prototype[Symbol.iterator] = TI.prototype[Symbol.iterator] = function() {
  return this;
});
class lQ {
  /**
  @internal
  */
  constructor(t, n, r, i) {
    this.from = t, this.to = n, this.number = r, this.text = i;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
function Lc(e, t, n) {
  return t = Math.max(0, Math.min(e.length, t)), [t, Math.max(t, Math.min(e.length, n))];
}
let gc = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((e) => e ? parseInt(e, 36) : 1);
for (let e = 1; e < gc.length; e++)
  gc[e] += gc[e - 1];
function cQ(e) {
  for (let t = 1; t < gc.length; t += 2)
    if (gc[t] > e)
      return gc[t - 1] <= e;
  return !1;
}
function D$(e) {
  return e >= 127462 && e <= 127487;
}
const _$ = 8205;
function gs(e, t, n = !0, r = !0) {
  return (n ? RI : uQ)(e, t, r);
}
function RI(e, t, n) {
  if (t == e.length)
    return t;
  t && MI(e.charCodeAt(t)) && II(e.charCodeAt(t - 1)) && t--;
  let r = ei(e, t);
  for (t += ho(r); t < e.length; ) {
    let i = ei(e, t);
    if (r == _$ || i == _$ || n && cQ(i))
      t += ho(i), r = i;
    else if (D$(i)) {
      let o = 0, s = t - 2;
      for (; s >= 0 && D$(ei(e, s)); )
        o++, s -= 2;
      if (o % 2 == 0)
        break;
      t += 2;
    } else
      break;
  }
  return t;
}
function uQ(e, t, n) {
  for (; t > 0; ) {
    let r = RI(e, t - 2, n);
    if (r < t)
      return r;
    t--;
  }
  return 0;
}
function MI(e) {
  return e >= 56320 && e < 57344;
}
function II(e) {
  return e >= 55296 && e < 56320;
}
function ei(e, t) {
  let n = e.charCodeAt(t);
  if (!II(n) || t + 1 == e.length)
    return n;
  let r = e.charCodeAt(t + 1);
  return MI(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;
}
function kI(e) {
  return e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10) + 55296, (e & 1023) + 56320));
}
function ho(e) {
  return e < 65536 ? 1 : 2;
}
const Qb = /\r\n?|\n/;
var ni = /* @__PURE__ */ function(e) {
  return e[e.Simple = 0] = "Simple", e[e.TrackDel = 1] = "TrackDel", e[e.TrackBefore = 2] = "TrackBefore", e[e.TrackAfter = 3] = "TrackAfter", e;
}(ni || (ni = {}));
class bs {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(t) {
    this.sections = t;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let t = 0;
    for (let n = 0; n < this.sections.length; n += 2)
      t += this.sections[n];
    return t;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let t = 0;
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n + 1];
      t += r < 0 ? this.sections[n] : r;
    }
    return t;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(t) {
    for (let n = 0, r = 0, i = 0; n < this.sections.length; ) {
      let o = this.sections[n++], s = this.sections[n++];
      s < 0 ? (t(r, i, o), i += o) : i += s, r += o;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(t, n = !1) {
    Zb(this, t, n);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let t = [];
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++], i = this.sections[n++];
      i < 0 ? t.push(r, i) : t.push(i, r);
    }
    return new bs(t);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(t) {
    return this.empty ? t : t.empty ? this : PI(this, t);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(t, n = !1) {
    return t.empty ? this : Jb(this, t, n);
  }
  mapPos(t, n = -1, r = ni.Simple) {
    let i = 0, o = 0;
    for (let s = 0; s < this.sections.length; ) {
      let a = this.sections[s++], l = this.sections[s++], u = i + a;
      if (l < 0) {
        if (u > t)
          return o + (t - i);
        o += a;
      } else {
        if (r != ni.Simple && u >= t && (r == ni.TrackDel && i < t && u > t || r == ni.TrackBefore && i < t || r == ni.TrackAfter && u > t))
          return null;
        if (u > t || u == t && n < 0 && !a)
          return t == i || n < 0 ? o : o + l;
        o += l;
      }
      i = u;
    }
    if (t > i)
      throw new RangeError(`Position ${t} is out of range for changeset of length ${i}`);
    return o;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(t, n = t) {
    for (let r = 0, i = 0; r < this.sections.length && i <= n; ) {
      let o = this.sections[r++], s = this.sections[r++], a = i + o;
      if (s >= 0 && i <= n && a >= t)
        return i < t && a > n ? "cover" : !0;
      i = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let t = "";
    for (let n = 0; n < this.sections.length; ) {
      let r = this.sections[n++], i = this.sections[n++];
      t += (t ? " " : "") + r + (i >= 0 ? ":" + i : "");
    }
    return t;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2 || t.some((n) => typeof n != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new bs(t);
  }
  /**
  @internal
  */
  static create(t) {
    return new bs(t);
  }
}
class wr extends bs {
  constructor(t, n) {
    super(t), this.inserted = n;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(t) {
    if (this.length != t.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return Zb(this, (n, r, i, o, s) => t = t.replace(i, i + (r - n), s), !1), t;
  }
  mapDesc(t, n = !1) {
    return Jb(this, t, n, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(t) {
    let n = this.sections.slice(), r = [];
    for (let i = 0, o = 0; i < n.length; i += 2) {
      let s = n[i], a = n[i + 1];
      if (a >= 0) {
        n[i] = a, n[i + 1] = s;
        let l = i >> 1;
        for (; r.length < l; )
          r.push(fn.empty);
        r.push(s ? t.slice(o, o + s) : fn.empty);
      }
      o += s;
    }
    return new wr(n, r);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA`  `docB` and `other` represents `docB`  `docC`, the
  returned value will represent the change `docA`  `docC`.
  */
  compose(t) {
    return this.empty ? t : t.empty ? this : PI(this, t, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(t, n = !1) {
    return t.empty ? this : Jb(this, t, n, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(t, n = !1) {
    Zb(this, t, n);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return bs.create(this.sections);
  }
  /**
  @internal
  */
  filter(t) {
    let n = [], r = [], i = [], o = new kd(this);
    e:
      for (let s = 0, a = 0; ; ) {
        let l = s == t.length ? 1e9 : t[s++];
        for (; a < l || a == l && o.len == 0; ) {
          if (o.done)
            break e;
          let c = Math.min(o.len, l - a);
          Ur(i, c, -1);
          let d = o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0;
          Ur(n, c, d), d > 0 && qs(r, n, o.text), o.forward(c), a += c;
        }
        let u = t[s++];
        for (; a < u; ) {
          if (o.done)
            break e;
          let c = Math.min(o.len, u - a);
          Ur(n, c, -1), Ur(i, c, o.ins == -1 ? -1 : o.off == 0 ? o.ins : 0), o.forward(c), a += c;
        }
      }
    return {
      changes: new wr(n, r),
      filtered: bs.create(i)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let t = [];
    for (let n = 0; n < this.sections.length; n += 2) {
      let r = this.sections[n], i = this.sections[n + 1];
      i < 0 ? t.push(r) : i == 0 ? t.push([r]) : t.push([r].concat(this.inserted[n >> 1].toJSON()));
    }
    return t;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(t, n, r) {
    let i = [], o = [], s = 0, a = null;
    function l(c = !1) {
      if (!c && !i.length)
        return;
      s < n && Ur(i, n - s, -1);
      let d = new wr(i, o);
      a = a ? a.compose(d.map(a)) : d, i = [], o = [], s = 0;
    }
    function u(c) {
      if (Array.isArray(c))
        for (let d of c)
          u(d);
      else if (c instanceof wr) {
        if (c.length != n)
          throw new RangeError(`Mismatched change set length (got ${c.length}, expected ${n})`);
        l(), a = a ? a.compose(c.map(a)) : c;
      } else {
        let { from: d, to: f = d, insert: h } = c;
        if (d > f || d < 0 || f > n)
          throw new RangeError(`Invalid change range ${d} to ${f} (in doc of length ${n})`);
        let p = h ? typeof h == "string" ? fn.of(h.split(r || Qb)) : h : fn.empty, g = p.length;
        if (d == f && g == 0)
          return;
        d < s && l(), d > s && Ur(i, d - s, -1), Ur(i, f - d, g), qs(o, i, p), s = f;
      }
    }
    return u(t), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(t) {
    return new wr(t ? [t, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(t) {
    if (!Array.isArray(t))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let n = [], r = [];
    for (let i = 0; i < t.length; i++) {
      let o = t[i];
      if (typeof o == "number")
        n.push(o, -1);
      else {
        if (!Array.isArray(o) || typeof o[0] != "number" || o.some((s, a) => a && typeof s != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (o.length == 1)
          n.push(o[0], 0);
        else {
          for (; r.length < i; )
            r.push(fn.empty);
          r[i] = fn.of(o.slice(1)), n.push(o[0], r[i].length);
        }
      }
    }
    return new wr(n, r);
  }
  /**
  @internal
  */
  static createSet(t, n) {
    return new wr(t, n);
  }
}
function Ur(e, t, n, r = !1) {
  if (t == 0 && n <= 0)
    return;
  let i = e.length - 2;
  i >= 0 && n <= 0 && n == e[i + 1] ? e[i] += t : t == 0 && e[i] == 0 ? e[i + 1] += n : r ? (e[i] += t, e[i + 1] += n) : e.push(t, n);
}
function qs(e, t, n) {
  if (n.length == 0)
    return;
  let r = t.length - 2 >> 1;
  if (r < e.length)
    e[e.length - 1] = e[e.length - 1].append(n);
  else {
    for (; e.length < r; )
      e.push(fn.empty);
    e.push(n);
  }
}
function Zb(e, t, n) {
  let r = e.inserted;
  for (let i = 0, o = 0, s = 0; s < e.sections.length; ) {
    let a = e.sections[s++], l = e.sections[s++];
    if (l < 0)
      i += a, o += a;
    else {
      let u = i, c = o, d = fn.empty;
      for (; u += a, c += l, l && r && (d = d.append(r[s - 2 >> 1])), !(n || s == e.sections.length || e.sections[s + 1] < 0); )
        a = e.sections[s++], l = e.sections[s++];
      t(i, u, o, c, d), i = u, o = c;
    }
  }
}
function Jb(e, t, n, r = !1) {
  let i = [], o = r ? [] : null, s = new kd(e), a = new kd(t);
  for (let l = -1; ; )
    if (s.ins == -1 && a.ins == -1) {
      let u = Math.min(s.len, a.len);
      Ur(i, u, -1), s.forward(u), a.forward(u);
    } else if (a.ins >= 0 && (s.ins < 0 || l == s.i || s.off == 0 && (a.len < s.len || a.len == s.len && !n))) {
      let u = a.len;
      for (Ur(i, a.ins, -1); u; ) {
        let c = Math.min(s.len, u);
        s.ins >= 0 && l < s.i && s.len <= c && (Ur(i, 0, s.ins), o && qs(o, i, s.text), l = s.i), s.forward(c), u -= c;
      }
      a.next();
    } else if (s.ins >= 0) {
      let u = 0, c = s.len;
      for (; c; )
        if (a.ins == -1) {
          let d = Math.min(c, a.len);
          u += d, c -= d, a.forward(d);
        } else if (a.ins == 0 && a.len < c)
          c -= a.len, a.next();
        else
          break;
      Ur(i, u, l < s.i ? s.ins : 0), o && l < s.i && qs(o, i, s.text), l = s.i, s.forward(s.len - c);
    } else {
      if (s.done && a.done)
        return o ? wr.createSet(i, o) : bs.create(i);
      throw new Error("Mismatched change set lengths");
    }
}
function PI(e, t, n = !1) {
  let r = [], i = n ? [] : null, o = new kd(e), s = new kd(t);
  for (let a = !1; ; ) {
    if (o.done && s.done)
      return i ? wr.createSet(r, i) : bs.create(r);
    if (o.ins == 0)
      Ur(r, o.len, 0, a), o.next();
    else if (s.len == 0 && !s.done)
      Ur(r, 0, s.ins, a), i && qs(i, r, s.text), s.next();
    else {
      if (o.done || s.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(o.len2, s.len), u = r.length;
        if (o.ins == -1) {
          let c = s.ins == -1 ? -1 : s.off ? 0 : s.ins;
          Ur(r, l, c, a), i && c && qs(i, r, s.text);
        } else
          s.ins == -1 ? (Ur(r, o.off ? 0 : o.len, l, a), i && qs(i, r, o.textBit(l))) : (Ur(r, o.off ? 0 : o.len, s.off ? 0 : s.ins, a), i && !s.off && qs(i, r, s.text));
        a = (o.ins > l || s.ins >= 0 && s.len > l) && (a || r.length > u), o.forward2(l), s.forward(l);
      }
    }
  }
}
class kd {
  constructor(t) {
    this.set = t, this.i = 0, this.next();
  }
  next() {
    let { sections: t } = this.set;
    this.i < t.length ? (this.len = t[this.i++], this.ins = t[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: t } = this.set, n = this.i - 2 >> 1;
    return n >= t.length ? fn.empty : t[n];
  }
  textBit(t) {
    let { inserted: n } = this.set, r = this.i - 2 >> 1;
    return r >= n.length && !t ? fn.empty : n[r].slice(this.off, t == null ? void 0 : this.off + t);
  }
  forward(t) {
    t == this.len ? this.next() : (this.len -= t, this.off += t);
  }
  forward2(t) {
    this.ins == -1 ? this.forward(t) : t == this.ins ? this.next() : (this.ins -= t, this.off += t);
  }
}
class ja {
  constructor(t, n, r) {
    this.from = t, this.to = n, this.flags = r;
  }
  /**
  The anchor of the rangethe side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 32 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 32 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let t = this.flags & 7;
    return t == 7 ? null : t;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let t = this.flags >> 6;
    return t == 16777215 ? void 0 : t;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(t, n = -1) {
    let r, i;
    return this.empty ? r = i = t.mapPos(this.from, n) : (r = t.mapPos(this.from, 1), i = t.mapPos(this.to, -1)), r == this.from && i == this.to ? this : new ja(r, i, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(t, n = t) {
    if (t <= this.anchor && n >= this.anchor)
      return st.range(t, n);
    let r = Math.abs(t - this.anchor) > Math.abs(n - this.anchor) ? t : n;
    return st.range(this.anchor, r);
  }
  /**
  Compare this range to another range.
  */
  eq(t, n = !1) {
    return this.anchor == t.anchor && this.head == t.head && (!n || !this.empty || this.assoc == t.assoc);
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(t) {
    if (!t || typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return st.range(t.anchor, t.head);
  }
  /**
  @internal
  */
  static create(t, n, r) {
    return new ja(t, n, r);
  }
}
class st {
  constructor(t, n) {
    this.ranges = t, this.mainIndex = n;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(t, n = -1) {
    return t.empty ? this : st.create(this.ranges.map((r) => r.map(t, n)), this.mainIndex);
  }
  /**
  Compare this selection to another selection. By default, ranges
  are compared only by position. When `includeAssoc` is true,
  cursor ranges must also have the same
  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.
  */
  eq(t, n = !1) {
    if (this.ranges.length != t.ranges.length || this.mainIndex != t.mainIndex)
      return !1;
    for (let r = 0; r < this.ranges.length; r++)
      if (!this.ranges[r].eq(t.ranges[r], n))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new st([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(t, n = !0) {
    return st.create([t].concat(this.ranges), n ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(t, n = this.mainIndex) {
    let r = this.ranges.slice();
    return r[n] = t, st.create(r, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((t) => t.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(t) {
    if (!t || !Array.isArray(t.ranges) || typeof t.main != "number" || t.main >= t.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new st(t.ranges.map((n) => ja.fromJSON(n)), t.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(t, n = t) {
    return new st([st.range(t, n)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(t, n = 0) {
    if (t.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let r = 0, i = 0; i < t.length; i++) {
      let o = t[i];
      if (o.empty ? o.from <= r : o.from < r)
        return st.normalized(t.slice(), n);
      r = o.to;
    }
    return new st(t, n);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(t, n = 0, r, i) {
    return ja.create(t, t, (n == 0 ? 0 : n < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i ?? 16777215) << 6);
  }
  /**
  Create a selection range.
  */
  static range(t, n, r, i) {
    let o = (r ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));
    return n < t ? ja.create(n, t, 48 | o) : ja.create(t, n, (n > t ? 8 : 0) | o);
  }
  /**
  @internal
  */
  static normalized(t, n = 0) {
    let r = t[n];
    t.sort((i, o) => i.from - o.from), n = t.indexOf(r);
    for (let i = 1; i < t.length; i++) {
      let o = t[i], s = t[i - 1];
      if (o.empty ? o.from <= s.to : o.from < s.to) {
        let a = s.from, l = Math.max(o.to, s.to);
        i <= n && n--, t.splice(--i, 2, o.anchor > o.head ? st.range(l, a) : st.range(a, l));
      }
    }
    return new st(t, n);
  }
}
function NI(e, t) {
  for (let n of e.ranges)
    if (n.to > t)
      throw new RangeError("Selection points outside of document");
}
let Z1 = 0;
class Pt {
  constructor(t, n, r, i, o) {
    this.combine = t, this.compareInput = n, this.compare = r, this.isStatic = i, this.id = Z1++, this.default = t([]), this.extensions = typeof o == "function" ? o(this) : o;
  }
  /**
  Returns a facet reader for this facet, which can be used to
  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.
  */
  get reader() {
    return this;
  }
  /**
  Define a new facet.
  */
  static define(t = {}) {
    return new Pt(t.combine || ((n) => n), t.compareInput || ((n, r) => n === r), t.compare || (t.combine ? (n, r) => n === r : J1), !!t.static, t.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(t) {
    return new up([], this, 0, t);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(t, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new up(t, this, 1, n);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(t, n) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new up(t, this, 2, n);
  }
  from(t, n) {
    return n || (n = (r) => r), this.compute([t], (r) => n(r.field(t)));
  }
}
function J1(e, t) {
  return e == t || e.length == t.length && e.every((n, r) => n === t[r]);
}
class up {
  constructor(t, n, r, i) {
    this.dependencies = t, this.facet = n, this.type = r, this.value = i, this.id = Z1++;
  }
  dynamicSlot(t) {
    var n;
    let r = this.value, i = this.facet.compareInput, o = this.id, s = t[o] >> 1, a = this.type == 2, l = !1, u = !1, c = [];
    for (let d of this.dependencies)
      d == "doc" ? l = !0 : d == "selection" ? u = !0 : ((n = t[d.id]) !== null && n !== void 0 ? n : 1) & 1 || c.push(t[d.id]);
    return {
      create(d) {
        return d.values[s] = r(d), 1;
      },
      update(d, f) {
        if (l && f.docChanged || u && (f.docChanged || f.selection) || ey(d, c)) {
          let h = r(d);
          if (a ? !T$(h, d.values[s], i) : !i(h, d.values[s]))
            return d.values[s] = h, 1;
        }
        return 0;
      },
      reconfigure: (d, f) => {
        let h, p = f.config.address[o];
        if (p != null) {
          let g = Gp(f, p);
          if (this.dependencies.every((m) => m instanceof Pt ? f.facet(m) === d.facet(m) : m instanceof Zo ? f.field(m, !1) == d.field(m, !1) : !0) || (a ? T$(h = r(d), g, i) : i(h = r(d), g)))
            return d.values[s] = g, 0;
        } else
          h = r(d);
        return d.values[s] = h, 1;
      }
    };
  }
}
function T$(e, t, n) {
  if (e.length != t.length)
    return !1;
  for (let r = 0; r < e.length; r++)
    if (!n(e[r], t[r]))
      return !1;
  return !0;
}
function ey(e, t) {
  let n = !1;
  for (let r of t)
    id(e, r) & 1 && (n = !0);
  return n;
}
function dQ(e, t, n) {
  let r = n.map((l) => e[l.id]), i = n.map((l) => l.type), o = r.filter((l) => !(l & 1)), s = e[t.id] >> 1;
  function a(l) {
    let u = [];
    for (let c = 0; c < r.length; c++) {
      let d = Gp(l, r[c]);
      if (i[c] == 2)
        for (let f of d)
          u.push(f);
      else
        u.push(d);
    }
    return t.combine(u);
  }
  return {
    create(l) {
      for (let u of r)
        id(l, u);
      return l.values[s] = a(l), 1;
    },
    update(l, u) {
      if (!ey(l, o))
        return 0;
      let c = a(l);
      return t.compare(c, l.values[s]) ? 0 : (l.values[s] = c, 1);
    },
    reconfigure(l, u) {
      let c = ey(l, r), d = u.config.facets[t.id], f = u.facet(t);
      if (d && !c && J1(n, d))
        return l.values[s] = f, 0;
      let h = a(l);
      return t.compare(h, f) ? (l.values[s] = f, 0) : (l.values[s] = h, 1);
    }
  };
}
const R$ = /* @__PURE__ */ Pt.define({ static: !0 });
class Zo {
  constructor(t, n, r, i, o) {
    this.id = t, this.createF = n, this.updateF = r, this.compareF = i, this.spec = o, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(t) {
    let n = new Zo(Z1++, t.create, t.update, t.compare || ((r, i) => r === i), t);
    return t.provide && (n.provides = t.provide(n)), n;
  }
  create(t) {
    let n = t.facet(R$).find((r) => r.field == this);
    return ((n == null ? void 0 : n.create) || this.createF)(t);
  }
  /**
  @internal
  */
  slot(t) {
    let n = t[this.id] >> 1;
    return {
      create: (r) => (r.values[n] = this.create(r), 1),
      update: (r, i) => {
        let o = r.values[n], s = this.updateF(o, i);
        return this.compareF(o, s) ? 0 : (r.values[n] = s, 1);
      },
      reconfigure: (r, i) => i.config.address[this.id] != null ? (r.values[n] = i.field(this), 0) : (r.values[n] = this.create(r), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(t) {
    return [this, R$.of({ field: this, create: t })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const ka = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function xu(e) {
  return (t) => new LI(t, e);
}
const Df = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ xu(ka.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ xu(ka.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ xu(ka.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ xu(ka.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ xu(ka.lowest)
};
class LI {
  constructor(t, n) {
    this.inner = t, this.prec = n;
  }
}
class fs {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(t) {
    return new ty(this, t);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(t) {
    return fs.reconfigure.of({ compartment: this, extension: t });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(t) {
    return t.config.compartments.get(this);
  }
}
class ty {
  constructor(t, n) {
    this.compartment = t, this.inner = n;
  }
}
class Up {
  constructor(t, n, r, i, o, s) {
    for (this.base = t, this.compartments = n, this.dynamicSlots = r, this.address = i, this.staticValues = o, this.facets = s, this.statusTemplate = []; this.statusTemplate.length < r.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(t) {
    let n = this.address[t.id];
    return n == null ? t.default : this.staticValues[n >> 1];
  }
  static resolve(t, n, r) {
    let i = [], o = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ new Map();
    for (let f of fQ(t, n, s))
      f instanceof Zo ? i.push(f) : (o[f.facet.id] || (o[f.facet.id] = [])).push(f);
    let a = /* @__PURE__ */ Object.create(null), l = [], u = [];
    for (let f of i)
      a[f.id] = u.length << 1, u.push((h) => f.slot(h));
    let c = r == null ? void 0 : r.config.facets;
    for (let f in o) {
      let h = o[f], p = h[0].facet, g = c && c[f] || [];
      if (h.every(
        (m) => m.type == 0
        /* Provider.Static */
      ))
        if (a[p.id] = l.length << 1 | 1, J1(g, h))
          l.push(r.facet(p));
        else {
          let m = p.combine(h.map((v) => v.value));
          l.push(r && p.compare(m, r.facet(p)) ? r.facet(p) : m);
        }
      else {
        for (let m of h)
          m.type == 0 ? (a[m.id] = l.length << 1 | 1, l.push(m.value)) : (a[m.id] = u.length << 1, u.push((v) => m.dynamicSlot(v)));
        a[p.id] = u.length << 1, u.push((m) => dQ(m, p, h));
      }
    }
    let d = u.map((f) => f(a));
    return new Up(t, s, d, a, l, o);
  }
}
function fQ(e, t, n) {
  let r = [[], [], [], [], []], i = /* @__PURE__ */ new Map();
  function o(s, a) {
    let l = i.get(s);
    if (l != null) {
      if (l <= a)
        return;
      let u = r[l].indexOf(s);
      u > -1 && r[l].splice(u, 1), s instanceof ty && n.delete(s.compartment);
    }
    if (i.set(s, a), Array.isArray(s))
      for (let u of s)
        o(u, a);
    else if (s instanceof ty) {
      if (n.has(s.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let u = t.get(s.compartment) || s.inner;
      n.set(s.compartment, u), o(u, a);
    } else if (s instanceof LI)
      o(s.inner, s.prec);
    else if (s instanceof Zo)
      r[a].push(s), s.provides && o(s.provides, a);
    else if (s instanceof up)
      r[a].push(s), s.facet.extensions && o(s.facet.extensions, ka.default);
    else {
      let u = s.extension;
      if (!u)
        throw new Error(`Unrecognized extension value in extension set (${s}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      o(u, a);
    }
  }
  return o(e, ka.default), r.reduce((s, a) => s.concat(a));
}
function id(e, t) {
  if (t & 1)
    return 2;
  let n = t >> 1, r = e.status[n];
  if (r == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (r & 2)
    return r;
  e.status[n] = 4;
  let i = e.computeSlot(e, e.config.dynamicSlots[n]);
  return e.status[n] = 2 | i;
}
function Gp(e, t) {
  return t & 1 ? e.config.staticValues[t >> 1] : e.values[t >> 1];
}
const FI = /* @__PURE__ */ Pt.define(), ny = /* @__PURE__ */ Pt.define({
  combine: (e) => e.some((t) => t),
  static: !0
}), BI = /* @__PURE__ */ Pt.define({
  combine: (e) => e.length ? e[0] : void 0,
  static: !0
}), jI = /* @__PURE__ */ Pt.define(), zI = /* @__PURE__ */ Pt.define(), HI = /* @__PURE__ */ Pt.define(), VI = /* @__PURE__ */ Pt.define({
  combine: (e) => e.length ? e[0] : !1
});
class El {
  /**
  @internal
  */
  constructor(t, n) {
    this.type = t, this.value = n;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new hQ();
  }
}
class hQ {
  /**
  Create an instance of this annotation.
  */
  of(t) {
    return new El(this, t);
  }
}
class pQ {
  /**
  @internal
  */
  constructor(t) {
    this.map = t;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(t) {
    return new In(this, t);
  }
}
class In {
  /**
  @internal
  */
  constructor(t, n) {
    this.type = t, this.value = n;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(t) {
    let n = this.type.map(this.value, t);
    return n === void 0 ? void 0 : n == this.value ? this : new In(this.type, n);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(t) {
    return this.type == t;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(t = {}) {
    return new pQ(t.map || ((n) => n));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(t, n) {
    if (!t.length)
      return t;
    let r = [];
    for (let i of t) {
      let o = i.map(n);
      o && r.push(o);
    }
    return r;
  }
}
In.reconfigure = /* @__PURE__ */ In.define();
In.appendConfig = /* @__PURE__ */ In.define();
class Kr {
  constructor(t, n, r, i, o, s) {
    this.startState = t, this.changes = n, this.selection = r, this.effects = i, this.annotations = o, this.scrollIntoView = s, this._doc = null, this._state = null, r && NI(r, n.newLength), o.some((a) => a.type == Kr.time) || (this.annotations = o.concat(Kr.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(t, n, r, i, o, s) {
    return new Kr(t, n, r, i, o, s);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(t) {
    for (let n of this.annotations)
      if (n.type == t)
        return n.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(t) {
    let n = this.annotation(Kr.userEvent);
    return !!(n && (n == t || n.length > t.length && n.slice(0, t.length) == t && n[t.length] == "."));
  }
}
Kr.time = /* @__PURE__ */ El.define();
Kr.userEvent = /* @__PURE__ */ El.define();
Kr.addToHistory = /* @__PURE__ */ El.define();
Kr.remote = /* @__PURE__ */ El.define();
function gQ(e, t) {
  let n = [];
  for (let r = 0, i = 0; ; ) {
    let o, s;
    if (r < e.length && (i == t.length || t[i] >= e[r]))
      o = e[r++], s = e[r++];
    else if (i < t.length)
      o = t[i++], s = t[i++];
    else
      return n;
    !n.length || n[n.length - 1] < o ? n.push(o, s) : n[n.length - 1] < s && (n[n.length - 1] = s);
  }
}
function WI(e, t, n) {
  var r;
  let i, o, s;
  return n ? (i = t.changes, o = wr.empty(t.changes.length), s = e.changes.compose(t.changes)) : (i = t.changes.map(e.changes), o = e.changes.mapDesc(t.changes, !0), s = e.changes.compose(i)), {
    changes: s,
    selection: t.selection ? t.selection.map(o) : (r = e.selection) === null || r === void 0 ? void 0 : r.map(i),
    effects: In.mapEffects(e.effects, i).concat(In.mapEffects(t.effects, o)),
    annotations: e.annotations.length ? e.annotations.concat(t.annotations) : t.annotations,
    scrollIntoView: e.scrollIntoView || t.scrollIntoView
  };
}
function ry(e, t, n) {
  let r = t.selection, i = mc(t.annotations);
  return t.userEvent && (i = i.concat(Kr.userEvent.of(t.userEvent))), {
    changes: t.changes instanceof wr ? t.changes : wr.of(t.changes || [], n, e.facet(BI)),
    selection: r && (r instanceof st ? r : st.single(r.anchor, r.head)),
    effects: mc(t.effects),
    annotations: i,
    scrollIntoView: !!t.scrollIntoView
  };
}
function UI(e, t, n) {
  let r = ry(e, t.length ? t[0] : {}, e.doc.length);
  t.length && t[0].filter === !1 && (n = !1);
  for (let o = 1; o < t.length; o++) {
    t[o].filter === !1 && (n = !1);
    let s = !!t[o].sequential;
    r = WI(r, ry(e, t[o], s ? r.changes.newLength : e.doc.length), s);
  }
  let i = Kr.create(e, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);
  return vQ(n ? mQ(i) : i);
}
function mQ(e) {
  let t = e.startState, n = !0;
  for (let i of t.facet(jI)) {
    let o = i(e);
    if (o === !1) {
      n = !1;
      break;
    }
    Array.isArray(o) && (n = n === !0 ? o : gQ(n, o));
  }
  if (n !== !0) {
    let i, o;
    if (n === !1)
      o = e.changes.invertedDesc, i = wr.empty(t.doc.length);
    else {
      let s = e.changes.filter(n);
      i = s.changes, o = s.filtered.mapDesc(s.changes).invertedDesc;
    }
    e = Kr.create(t, i, e.selection && e.selection.map(o), In.mapEffects(e.effects, o), e.annotations, e.scrollIntoView);
  }
  let r = t.facet(zI);
  for (let i = r.length - 1; i >= 0; i--) {
    let o = r[i](e);
    o instanceof Kr ? e = o : Array.isArray(o) && o.length == 1 && o[0] instanceof Kr ? e = o[0] : e = UI(t, mc(o), !1);
  }
  return e;
}
function vQ(e) {
  let t = e.startState, n = t.facet(HI), r = e;
  for (let i = n.length - 1; i >= 0; i--) {
    let o = n[i](e);
    o && Object.keys(o).length && (r = WI(r, ry(t, o, e.changes.newLength), !0));
  }
  return r == e ? e : Kr.create(t, e.changes, e.selection, r.effects, r.annotations, r.scrollIntoView);
}
const bQ = [];
function mc(e) {
  return e == null ? bQ : Array.isArray(e) ? e : [e];
}
var Qi = /* @__PURE__ */ function(e) {
  return e[e.Word = 0] = "Word", e[e.Space = 1] = "Space", e[e.Other = 2] = "Other", e;
}(Qi || (Qi = {}));
const yQ = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let iy;
try {
  iy = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function wQ(e) {
  if (iy)
    return iy.test(e);
  for (let t = 0; t < e.length; t++) {
    let n = e[t];
    if (/\w/.test(n) || n > "" && (n.toUpperCase() != n.toLowerCase() || yQ.test(n)))
      return !0;
  }
  return !1;
}
function CQ(e) {
  return (t) => {
    if (!/\S/.test(t))
      return Qi.Space;
    if (wQ(t))
      return Qi.Word;
    for (let n = 0; n < e.length; n++)
      if (t.indexOf(e[n]) > -1)
        return Qi.Word;
    return Qi.Other;
  };
}
class hn {
  constructor(t, n, r, i, o, s) {
    this.config = t, this.doc = n, this.selection = r, this.values = i, this.status = t.statusTemplate.slice(), this.computeSlot = o, s && (s._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      id(this, a << 1);
    this.computeSlot = null;
  }
  field(t, n = !0) {
    let r = this.config.address[t.id];
    if (r == null) {
      if (n)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return id(this, r), Gp(this, r);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...t) {
    return UI(this, t, !0);
  }
  /**
  @internal
  */
  applyTransaction(t) {
    let n = this.config, { base: r, compartments: i } = n;
    for (let a of t.effects)
      a.is(fs.reconfigure) ? (n && (i = /* @__PURE__ */ new Map(), n.compartments.forEach((l, u) => i.set(u, l)), n = null), i.set(a.value.compartment, a.value.extension)) : a.is(In.reconfigure) ? (n = null, r = a.value) : a.is(In.appendConfig) && (n = null, r = mc(r).concat(a.value));
    let o;
    n ? o = t.startState.values.slice() : (n = Up.resolve(r, i, this), o = new hn(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (l, u) => u.reconfigure(l, this), null).values);
    let s = t.startState.facet(ny) ? t.newSelection : t.newSelection.asSingle();
    new hn(n, t.newDoc, s, o, (a, l) => l.update(a, t), t);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(t) {
    return typeof t == "string" && (t = this.toText(t)), this.changeByRange((n) => ({
      changes: { from: n.from, to: n.to, insert: t },
      range: st.cursor(n.from + t.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(t) {
    let n = this.selection, r = t(n.ranges[0]), i = this.changes(r.changes), o = [r.range], s = mc(r.effects);
    for (let a = 1; a < n.ranges.length; a++) {
      let l = t(n.ranges[a]), u = this.changes(l.changes), c = u.map(i);
      for (let f = 0; f < a; f++)
        o[f] = o[f].map(c);
      let d = i.mapDesc(u, !0);
      o.push(l.range.map(d)), i = i.compose(c), s = In.mapEffects(s, c).concat(In.mapEffects(mc(l.effects), d));
    }
    return {
      changes: i,
      selection: st.create(o, n.mainIndex),
      effects: s
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(t = []) {
    return t instanceof wr ? t : wr.of(t, this.doc.length, this.facet(hn.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(t) {
    return fn.of(t.split(this.facet(hn.lineSeparator) || Qb));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(t = 0, n = this.doc.length) {
    return this.doc.sliceString(t, n, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(t) {
    let n = this.config.address[t.id];
    return n == null ? t.default : (id(this, n), Gp(this, n));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(t) {
    let n = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (t)
      for (let r in t) {
        let i = t[r];
        i instanceof Zo && this.config.address[i.id] != null && (n[r] = i.spec.toJSON(this.field(t[r]), this));
      }
    return n;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(t, n = {}, r) {
    if (!t || typeof t.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let i = [];
    if (r) {
      for (let o in r)
        if (Object.prototype.hasOwnProperty.call(t, o)) {
          let s = r[o], a = t[o];
          i.push(s.init((l) => s.spec.fromJSON(a, l)));
        }
    }
    return hn.create({
      doc: t.doc,
      selection: st.fromJSON(t.selection),
      extensions: n.extensions ? i.concat([n.extensions]) : i
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorupdated states are created by applying
  transactions.
  */
  static create(t = {}) {
    let n = Up.resolve(t.extensions || [], /* @__PURE__ */ new Map()), r = t.doc instanceof fn ? t.doc : fn.of((t.doc || "").split(n.staticFacet(hn.lineSeparator) || Qb)), i = t.selection ? t.selection instanceof st ? t.selection : st.single(t.selection.anchor, t.selection.head) : st.single(0);
    return NI(i, r.length), n.staticFacet(ny) || (i = i.asSingle()), new hn(n, r, i, n.dynamicSlots.map(() => null), (o, s) => s.create(o), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(hn.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(hn.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(VI);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(t, ...n) {
    for (let r of this.facet(hn.phrases))
      if (Object.prototype.hasOwnProperty.call(r, t)) {
        t = r[t];
        break;
      }
    return n.length && (t = t.replace(/\$(\$|\d*)/g, (r, i) => {
      if (i == "$")
        return "$";
      let o = +(i || 1);
      return !o || o > n.length ? r : n[o - 1];
    })), t;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(t, n, r = -1) {
    let i = [];
    for (let o of this.facet(FI))
      for (let s of o(this, n, r))
        Object.prototype.hasOwnProperty.call(s, t) && i.push(s[t]);
    return i;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(t) {
    return CQ(this.languageDataAt("wordChars", t).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(t) {
    let { text: n, from: r, length: i } = this.doc.lineAt(t), o = this.charCategorizer(t), s = t - r, a = t - r;
    for (; s > 0; ) {
      let l = gs(n, s, !1);
      if (o(n.slice(l, s)) != Qi.Word)
        break;
      s = l;
    }
    for (; a < i; ) {
      let l = gs(n, a);
      if (o(n.slice(a, l)) != Qi.Word)
        break;
      a = l;
    }
    return s == a ? null : st.range(s + r, a + r);
  }
}
hn.allowMultipleSelections = ny;
hn.tabSize = /* @__PURE__ */ Pt.define({
  combine: (e) => e.length ? e[0] : 4
});
hn.lineSeparator = BI;
hn.readOnly = VI;
hn.phrases = /* @__PURE__ */ Pt.define({
  compare(e, t) {
    let n = Object.keys(e), r = Object.keys(t);
    return n.length == r.length && n.every((i) => e[i] == t[i]);
  }
});
hn.languageData = FI;
hn.changeFilter = jI;
hn.transactionFilter = zI;
hn.transactionExtender = HI;
fs.reconfigure = /* @__PURE__ */ In.define();
function SQ(e, t, n = {}) {
  let r = {};
  for (let i of e)
    for (let o of Object.keys(i)) {
      let s = i[o], a = r[o];
      if (a === void 0)
        r[o] = s;
      else if (!(a === s || s === void 0))
        if (Object.hasOwnProperty.call(n, o))
          r[o] = n[o](a, s);
        else
          throw new Error("Config merge conflict for field " + o);
    }
  for (let i in t)
    r[i] === void 0 && (r[i] = t[i]);
  return r;
}
class rl {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(t) {
    return this == t;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(t, n = t) {
    return oy.create(t, n, this);
  }
}
rl.prototype.startSide = rl.prototype.endSide = 0;
rl.prototype.point = !1;
rl.prototype.mapMode = ni.TrackDel;
let oy = class GI {
  constructor(t, n, r) {
    this.from = t, this.to = n, this.value = r;
  }
  /**
  @internal
  */
  static create(t, n, r) {
    return new GI(t, n, r);
  }
};
function sy(e, t) {
  return e.from - t.from || e.value.startSide - t.value.startSide;
}
class eC {
  constructor(t, n, r, i) {
    this.from = t, this.to = n, this.value = r, this.maxPoint = i;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(t, n, r, i = 0) {
    let o = r ? this.to : this.from;
    for (let s = i, a = o.length; ; ) {
      if (s == a)
        return s;
      let l = s + a >> 1, u = o[l] - t || (r ? this.value[l].endSide : this.value[l].startSide) - n;
      if (l == s)
        return u >= 0 ? s : a;
      u >= 0 ? a = l : s = l + 1;
    }
  }
  between(t, n, r, i) {
    for (let o = this.findIndex(n, -1e9, !0), s = this.findIndex(r, 1e9, !1, o); o < s; o++)
      if (i(this.from[o] + t, this.to[o] + t, this.value[o]) === !1)
        return !1;
  }
  map(t, n) {
    let r = [], i = [], o = [], s = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let u = this.value[l], c = this.from[l] + t, d = this.to[l] + t, f, h;
      if (c == d) {
        let p = n.mapPos(c, u.startSide, u.mapMode);
        if (p == null || (f = h = p, u.startSide != u.endSide && (h = n.mapPos(c, u.endSide), h < f)))
          continue;
      } else if (f = n.mapPos(c, u.startSide), h = n.mapPos(d, u.endSide), f > h || f == h && u.startSide > 0 && u.endSide <= 0)
        continue;
      (h - f || u.endSide - u.startSide) < 0 || (s < 0 && (s = f), u.point && (a = Math.max(a, h - f)), r.push(u), i.push(f - s), o.push(h - s));
    }
    return { mapped: r.length ? new eC(i, o, r, a) : null, pos: s };
  }
}
class En {
  constructor(t, n, r, i) {
    this.chunkPos = t, this.chunk = n, this.nextLayer = r, this.maxPoint = i;
  }
  /**
  @internal
  */
  static create(t, n, r, i) {
    return new En(t, n, r, i);
  }
  /**
  @internal
  */
  get length() {
    let t = this.chunk.length - 1;
    return t < 0 ? 0 : Math.max(this.chunkEnd(t), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let t = this.nextLayer.size;
    for (let n of this.chunk)
      t += n.value.length;
    return t;
  }
  /**
  @internal
  */
  chunkEnd(t) {
    return this.chunkPos[t] + this.chunk[t].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(t) {
    let { add: n = [], sort: r = !1, filterFrom: i = 0, filterTo: o = this.length } = t, s = t.filter;
    if (n.length == 0 && !s)
      return this;
    if (r && (n = n.slice().sort(sy)), this.isEmpty)
      return n.length ? En.of(n) : this;
    let a = new KI(this, null, -1).goto(0), l = 0, u = [], c = new Pd();
    for (; a.value || l < n.length; )
      if (l < n.length && (a.from - n[l].from || a.startSide - n[l].value.startSide) >= 0) {
        let d = n[l++];
        c.addInner(d.from, d.to, d.value) || u.push(d);
      } else
        a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == n.length || this.chunkEnd(a.chunkIndex) < n[l].from) && (!s || i > this.chunkEnd(a.chunkIndex) || o < this.chunkPos[a.chunkIndex]) && c.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!s || i > a.to || o < a.from || s(a.from, a.to, a.value)) && (c.addInner(a.from, a.to, a.value) || u.push(oy.create(a.from, a.to, a.value))), a.next());
    return c.finishInner(this.nextLayer.isEmpty && !u.length ? En.empty : this.nextLayer.update({ add: u, filter: s, filterFrom: i, filterTo: o }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(t) {
    if (t.empty || this.isEmpty)
      return this;
    let n = [], r = [], i = -1;
    for (let s = 0; s < this.chunk.length; s++) {
      let a = this.chunkPos[s], l = this.chunk[s], u = t.touchesRange(a, a + l.length);
      if (u === !1)
        i = Math.max(i, l.maxPoint), n.push(l), r.push(t.mapPos(a));
      else if (u === !0) {
        let { mapped: c, pos: d } = l.map(a, t);
        c && (i = Math.max(i, c.maxPoint), n.push(c), r.push(d));
      }
    }
    let o = this.nextLayer.map(t);
    return n.length == 0 ? o : new En(r, n, o || En.empty, i);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(t, n, r) {
    if (!this.isEmpty) {
      for (let i = 0; i < this.chunk.length; i++) {
        let o = this.chunkPos[i], s = this.chunk[i];
        if (n >= o && t <= o + s.length && s.between(o, t - o, n - o, r) === !1)
          return;
      }
      this.nextLayer.between(t, n, r);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(t = 0) {
    return Nd.from([this]).goto(t);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(t, n = 0) {
    return Nd.from(t).goto(n);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(t, n, r, i, o = -1) {
    let s = t.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= o), a = n.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= o), l = M$(s, a, r), u = new Eu(s, l, o), c = new Eu(a, l, o);
    r.iterGaps((d, f, h) => I$(u, d, c, f, h, i)), r.empty && r.length == 0 && I$(u, 0, c, 0, 0, i);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(t, n, r = 0, i) {
    i == null && (i = 999999999);
    let o = t.filter((c) => !c.isEmpty && n.indexOf(c) < 0), s = n.filter((c) => !c.isEmpty && t.indexOf(c) < 0);
    if (o.length != s.length)
      return !1;
    if (!o.length)
      return !0;
    let a = M$(o, s), l = new Eu(o, a, 0).goto(r), u = new Eu(s, a, 0).goto(r);
    for (; ; ) {
      if (l.to != u.to || !ay(l.active, u.active) || l.point && (!u.point || !l.point.eq(u.point)))
        return !1;
      if (l.to > i)
        return !0;
      l.next(), u.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(t, n, r, i, o = -1) {
    let s = new Eu(t, null, o).goto(n), a = n, l = s.openStart;
    for (; ; ) {
      let u = Math.min(s.to, r);
      if (s.point) {
        let c = s.activeForPoint(s.to), d = s.pointFrom < n ? c.length + 1 : s.point.startSide < 0 ? c.length : Math.min(c.length, l);
        i.point(a, u, s.point, c, d, s.pointRank), l = Math.min(s.openEnd(u), c.length);
      } else
        u > a && (i.span(a, u, s.active, l), l = s.openEnd(u));
      if (s.to > r)
        return l + (s.point && s.to > r ? 1 : 0);
      a = s.to, s.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(t, n = !1) {
    let r = new Pd();
    for (let i of t instanceof oy ? [t] : n ? xQ(t) : t)
      r.add(i.from, i.to, i.value);
    return r.finish();
  }
  /**
  Join an array of range sets into a single set.
  */
  static join(t) {
    if (!t.length)
      return En.empty;
    let n = t[t.length - 1];
    for (let r = t.length - 2; r >= 0; r--)
      for (let i = t[r]; i != En.empty; i = i.nextLayer)
        n = new En(i.chunkPos, i.chunk, n, Math.max(i.maxPoint, n.maxPoint));
    return n;
  }
}
En.empty = /* @__PURE__ */ new En([], [], null, -1);
function xQ(e) {
  if (e.length > 1)
    for (let t = e[0], n = 1; n < e.length; n++) {
      let r = e[n];
      if (sy(t, r) > 0)
        return e.slice().sort(sy);
      t = r;
    }
  return e;
}
En.empty.nextLayer = En.empty;
class Pd {
  finishChunk(t) {
    this.chunks.push(new eC(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, t && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(t, n, r) {
    this.addInner(t, n, r) || (this.nextLayer || (this.nextLayer = new Pd())).add(t, n, r);
  }
  /**
  @internal
  */
  addInner(t, n, r) {
    let i = t - this.lastTo || r.startSide - this.last.endSide;
    if (i <= 0 && (t - this.lastFrom || r.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = t), this.from.push(t - this.chunkStart), this.to.push(n - this.chunkStart), this.last = r, this.lastFrom = t, this.lastTo = n, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, n - t)), !0);
  }
  /**
  @internal
  */
  addChunk(t, n) {
    if ((t - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(t);
    let r = n.value.length - 1;
    return this.last = n.value[r], this.lastFrom = n.from[r] + t, this.lastTo = n.to[r] + t, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(En.empty);
  }
  /**
  @internal
  */
  finishInner(t) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return t;
    let n = En.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(t) : t, this.setMaxPoint);
    return this.from = null, n;
  }
}
function M$(e, t, n) {
  let r = /* @__PURE__ */ new Map();
  for (let o of e)
    for (let s = 0; s < o.chunk.length; s++)
      o.chunk[s].maxPoint <= 0 && r.set(o.chunk[s], o.chunkPos[s]);
  let i = /* @__PURE__ */ new Set();
  for (let o of t)
    for (let s = 0; s < o.chunk.length; s++) {
      let a = r.get(o.chunk[s]);
      a != null && (n ? n.mapPos(a) : a) == o.chunkPos[s] && !(n != null && n.touchesRange(a, a + o.chunk[s].length)) && i.add(o.chunk[s]);
    }
  return i;
}
class KI {
  constructor(t, n, r, i = 0) {
    this.layer = t, this.skip = n, this.minPoint = r, this.rank = i;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(t, n = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(t, n, !1), this;
  }
  gotoInner(t, n, r) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let i = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < t || i.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, r = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let i = this.layer.chunk[this.chunkIndex].findIndex(t - this.layer.chunkPos[this.chunkIndex], n, !0);
      (!r || this.rangeIndex < i) && this.setRangeIndex(i);
    }
    this.next();
  }
  forward(t, n) {
    (this.to - t || this.endSide - n) < 0 && this.gotoInner(t, n, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let t = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], r = t + n.from[this.rangeIndex];
        if (this.from = r, this.to = t + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(t) {
    if (t == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = t;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(t) {
    return this.from - t.from || this.startSide - t.startSide || this.rank - t.rank || this.to - t.to || this.endSide - t.endSide;
  }
}
class Nd {
  constructor(t) {
    this.heap = t;
  }
  static from(t, n = null, r = -1) {
    let i = [];
    for (let o = 0; o < t.length; o++)
      for (let s = t[o]; !s.isEmpty; s = s.nextLayer)
        s.maxPoint >= r && i.push(new KI(s, n, r, o));
    return i.length == 1 ? i[0] : new Nd(i);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(t, n = -1e9) {
    for (let r of this.heap)
      r.goto(t, n);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      Iv(this.heap, r);
    return this.next(), this;
  }
  forward(t, n) {
    for (let r of this.heap)
      r.forward(t, n);
    for (let r = this.heap.length >> 1; r >= 0; r--)
      Iv(this.heap, r);
    (this.to - t || this.value.endSide - n) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let t = this.heap[0];
      this.from = t.from, this.to = t.to, this.value = t.value, this.rank = t.rank, t.value && t.next(), Iv(this.heap, 0);
    }
  }
}
function Iv(e, t) {
  for (let n = e[t]; ; ) {
    let r = (t << 1) + 1;
    if (r >= e.length)
      break;
    let i = e[r];
    if (r + 1 < e.length && i.compare(e[r + 1]) >= 0 && (i = e[r + 1], r++), n.compare(i) < 0)
      break;
    e[r] = n, e[t] = i, t = r;
  }
}
class Eu {
  constructor(t, n, r) {
    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Nd.from(t, n, r);
  }
  goto(t, n = -1e9) {
    return this.cursor.goto(t, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = t, this.endSide = n, this.openStart = -1, this.next(), this;
  }
  forward(t, n) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - t || this.active[this.minActive].endSide - n) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(t, n);
  }
  removeActive(t) {
    ch(this.active, t), ch(this.activeTo, t), ch(this.activeRank, t), this.minActive = k$(this.active, this.activeTo);
  }
  addActive(t) {
    let n = 0, { value: r, to: i, rank: o } = this.cursor;
    for (; n < this.activeRank.length && (o - this.activeRank[n] || i - this.activeTo[n]) > 0; )
      n++;
    uh(this.active, n, r), uh(this.activeTo, n, i), uh(this.activeRank, n, o), t && uh(t, n, this.cursor.from), this.minActive = k$(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let t = this.to, n = this.point;
    this.point = null;
    let r = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let i = this.minActive;
      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[i] > t) {
          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;
          break;
        }
        this.removeActive(i), r && ch(r, i);
      } else if (this.cursor.value)
        if (this.cursor.from > t) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let o = this.cursor.value;
          if (!o.point)
            this.addActive(r), this.cursor.next();
          else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = o, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = o.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (r) {
      this.openStart = 0;
      for (let i = r.length - 1; i >= 0 && r[i] < t; i--)
        this.openStart++;
    }
  }
  activeForPoint(t) {
    if (!this.active.length)
      return this.active;
    let n = [];
    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)
      (this.activeTo[r] > t || this.activeTo[r] == t && this.active[r].endSide >= this.point.endSide) && n.push(this.active[r]);
    return n.reverse();
  }
  openEnd(t) {
    let n = 0;
    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > t; r--)
      n++;
    return n;
  }
}
function I$(e, t, n, r, i, o) {
  e.goto(t), n.goto(r);
  let s = r + i, a = r, l = r - t;
  for (; ; ) {
    let u = e.to + l - n.to || e.endSide - n.endSide, c = u < 0 ? e.to + l : n.to, d = Math.min(c, s);
    if (e.point || n.point ? e.point && n.point && (e.point == n.point || e.point.eq(n.point)) && ay(e.activeForPoint(e.to), n.activeForPoint(n.to)) || o.comparePoint(a, d, e.point, n.point) : d > a && !ay(e.active, n.active) && o.compareRange(a, d, e.active, n.active), c > s)
      break;
    a = c, u <= 0 && e.next(), u >= 0 && n.next();
  }
}
function ay(e, t) {
  if (e.length != t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] != t[n] && !e[n].eq(t[n]))
      return !1;
  return !0;
}
function ch(e, t) {
  for (let n = t, r = e.length - 1; n < r; n++)
    e[n] = e[n + 1];
  e.pop();
}
function uh(e, t, n) {
  for (let r = e.length - 1; r >= t; r--)
    e[r + 1] = e[r];
  e[t] = n;
}
function k$(e, t) {
  let n = -1, r = 1e9;
  for (let i = 0; i < t.length; i++)
    (t[i] - r || e[i].endSide - e[n].endSide) < 0 && (n = i, r = t[i]);
  return n;
}
function EQ(e, t, n, r) {
  for (let i = 0, o = 0; ; ) {
    if (o >= t)
      return i;
    if (i == e.length)
      break;
    o += e.charCodeAt(i) == 9 ? n - o % n : 1, i = gs(e, i);
  }
  return r === !0 ? -1 : e.length;
}
const ly = "", P$ = typeof Symbol > "u" ? "__" + ly : Symbol.for(ly), cy = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), N$ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class fa {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(t, n) {
    this.rules = [];
    let { finish: r } = n || {};
    function i(s) {
      return /^@/.test(s) ? [s] : s.split(/,\s*/);
    }
    function o(s, a, l, u) {
      let c = [], d = /^@(\w+)\b/.exec(s[0]), f = d && d[1] == "keyframes";
      if (d && a == null)
        return l.push(s[0] + ";");
      for (let h in a) {
        let p = a[h];
        if (/&/.test(h))
          o(
            h.split(/,\s*/).map((g) => s.map((m) => g.replace(/&/, m))).reduce((g, m) => g.concat(m)),
            p,
            l
          );
        else if (p && typeof p == "object") {
          if (!d)
            throw new RangeError("The value of a property (" + h + ") should be a primitive value.");
          o(i(h), p, c, f);
        } else
          p != null && c.push(h.replace(/_.*/, "").replace(/[A-Z]/g, (g) => "-" + g.toLowerCase()) + ": " + p + ";");
      }
      (c.length || f) && l.push((r && !d && !u ? s.map(r) : s).join(", ") + " {" + c.join(" ") + "}");
    }
    for (let s in t)
      o(i(s), t[s], this.rules);
  }
  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let t = N$[P$] || 1;
    return N$[P$] = t + 1, ly + t.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  //
  // If a Content Security Policy nonce is provided, it is added to
  // the `<style>` tag generated by the library.
  static mount(t, n, r) {
    let i = t[cy], o = r && r.nonce;
    i ? o && i.setNonce(o) : i = new $Q(t, o), i.mount(Array.isArray(n) ? n : [n], t);
  }
}
let L$ = /* @__PURE__ */ new Map();
class $Q {
  constructor(t, n) {
    let r = t.ownerDocument || t, i = r.defaultView;
    if (!t.head && t.adoptedStyleSheets && i.CSSStyleSheet) {
      let o = L$.get(r);
      if (o)
        return t[cy] = o;
      this.sheet = new i.CSSStyleSheet(), L$.set(r, this);
    } else
      this.styleTag = r.createElement("style"), n && this.styleTag.setAttribute("nonce", n);
    this.modules = [], t[cy] = this;
  }
  mount(t, n) {
    let r = this.sheet, i = 0, o = 0;
    for (let s = 0; s < t.length; s++) {
      let a = t[s], l = this.modules.indexOf(a);
      if (l < o && l > -1 && (this.modules.splice(l, 1), o--, l = -1), l == -1) {
        if (this.modules.splice(o++, 0, a), r)
          for (let u = 0; u < a.rules.length; u++)
            r.insertRule(a.rules[u], i++);
      } else {
        for (; o < l; )
          i += this.modules[o++].rules.length;
        i += a.rules.length, o++;
      }
    }
    if (r)
      n.adoptedStyleSheets.indexOf(this.sheet) < 0 && (n.adoptedStyleSheets = [this.sheet, ...n.adoptedStyleSheets]);
    else {
      let s = "";
      for (let l = 0; l < this.modules.length; l++)
        s += this.modules[l].getRules() + `
`;
      this.styleTag.textContent = s;
      let a = n.head || n;
      this.styleTag.parentNode != a && a.insertBefore(this.styleTag, a.firstChild);
    }
  }
  setNonce(t) {
    this.styleTag && this.styleTag.getAttribute("nonce") != t && this.styleTag.setAttribute("nonce", t);
  }
}
var ha = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, Ld = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, OQ = typeof navigator < "u" && /Mac/.test(navigator.platform), AQ = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var _r = 0; _r < 10; _r++)
  ha[48 + _r] = ha[96 + _r] = String(_r);
for (var _r = 1; _r <= 24; _r++)
  ha[_r + 111] = "F" + _r;
for (var _r = 65; _r <= 90; _r++)
  ha[_r] = String.fromCharCode(_r + 32), Ld[_r] = String.fromCharCode(_r);
for (var kv in ha)
  Ld.hasOwnProperty(kv) || (Ld[kv] = ha[kv]);
function DQ(e) {
  var t = OQ && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey || AQ && e.shiftKey && e.key && e.key.length == 1 || e.key == "Unidentified", n = !t && e.key || (e.shiftKey ? Ld : ha)[e.keyCode] || e.key || "Unidentified";
  return n == "Esc" && (n = "Escape"), n == "Del" && (n = "Delete"), n == "Left" && (n = "ArrowLeft"), n == "Up" && (n = "ArrowUp"), n == "Right" && (n = "ArrowRight"), n == "Down" && (n = "ArrowDown"), n;
}
function Kp(e) {
  let t;
  return e.nodeType == 11 ? t = e.getSelection ? e : e.ownerDocument : t = e, t.getSelection();
}
function uy(e, t) {
  return t ? e == t || e.contains(t.nodeType != 1 ? t.parentNode : t) : !1;
}
function _Q(e) {
  let t = e.activeElement;
  for (; t && t.shadowRoot; )
    t = t.shadowRoot.activeElement;
  return t;
}
function dp(e, t) {
  if (!t.anchorNode)
    return !1;
  try {
    return uy(e, t.anchorNode);
  } catch {
    return !1;
  }
}
function Fc(e) {
  return e.nodeType == 3 ? ol(e, 0, e.nodeValue.length).getClientRects() : e.nodeType == 1 ? e.getClientRects() : [];
}
function od(e, t, n, r) {
  return n ? F$(e, t, n, r, -1) || F$(e, t, n, r, 1) : !1;
}
function il(e) {
  for (var t = 0; ; t++)
    if (e = e.previousSibling, !e)
      return t;
}
function Xp(e) {
  return e.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(e.nodeName);
}
function F$(e, t, n, r, i) {
  for (; ; ) {
    if (e == n && t == r)
      return !0;
    if (t == (i < 0 ? 0 : Ds(e))) {
      if (e.nodeName == "DIV")
        return !1;
      let o = e.parentNode;
      if (!o || o.nodeType != 1)
        return !1;
      t = il(e) + (i < 0 ? 0 : 1), e = o;
    } else if (e.nodeType == 1) {
      if (e = e.childNodes[t + (i < 0 ? -1 : 0)], e.nodeType == 1 && e.contentEditable == "false")
        return !1;
      t = i < 0 ? Ds(e) : 0;
    } else
      return !1;
  }
}
function Ds(e) {
  return e.nodeType == 3 ? e.nodeValue.length : e.childNodes.length;
}
function gm(e, t) {
  let n = t ? e.left : e.right;
  return { left: n, right: n, top: e.top, bottom: e.bottom };
}
function TQ(e) {
  let t = e.visualViewport;
  return t ? {
    left: 0,
    right: t.width,
    top: 0,
    bottom: t.height
  } : {
    left: 0,
    right: e.innerWidth,
    top: 0,
    bottom: e.innerHeight
  };
}
function XI(e, t) {
  let n = t.width / e.offsetWidth, r = t.height / e.offsetHeight;
  return (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(t.width - e.offsetWidth) < 1) && (n = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(t.height - e.offsetHeight) < 1) && (r = 1), { scaleX: n, scaleY: r };
}
function RQ(e, t, n, r, i, o, s, a) {
  let l = e.ownerDocument, u = l.defaultView || window;
  for (let c = e, d = !1; c && !d; )
    if (c.nodeType == 1) {
      let f, h = c == l.body, p = 1, g = 1;
      if (h)
        f = TQ(u);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(c).position) && (d = !0), c.scrollHeight <= c.clientHeight && c.scrollWidth <= c.clientWidth) {
          c = c.assignedSlot || c.parentNode;
          continue;
        }
        let b = c.getBoundingClientRect();
        ({ scaleX: p, scaleY: g } = XI(c, b)), f = {
          left: b.left,
          right: b.left + c.clientWidth * p,
          top: b.top,
          bottom: b.top + c.clientHeight * g
        };
      }
      let m = 0, v = 0;
      if (i == "nearest")
        t.top < f.top ? (v = -(f.top - t.top + s), n > 0 && t.bottom > f.bottom + v && (v = t.bottom - f.bottom + v + s)) : t.bottom > f.bottom && (v = t.bottom - f.bottom + s, n < 0 && t.top - v < f.top && (v = -(f.top + v - t.top + s)));
      else {
        let b = t.bottom - t.top, x = f.bottom - f.top;
        v = (i == "center" && b <= x ? t.top + b / 2 - x / 2 : i == "start" || i == "center" && n < 0 ? t.top - s : t.bottom - x + s) - f.top;
      }
      if (r == "nearest" ? t.left < f.left ? (m = -(f.left - t.left + o), n > 0 && t.right > f.right + m && (m = t.right - f.right + m + o)) : t.right > f.right && (m = t.right - f.right + o, n < 0 && t.left < f.left + m && (m = -(f.left + m - t.left + o))) : m = (r == "center" ? t.left + (t.right - t.left) / 2 - (f.right - f.left) / 2 : r == "start" == a ? t.left - o : t.right - (f.right - f.left) + o) - f.left, m || v)
        if (h)
          u.scrollBy(m, v);
        else {
          let b = 0, x = 0;
          if (v) {
            let w = c.scrollTop;
            c.scrollTop += v / g, x = (c.scrollTop - w) * g;
          }
          if (m) {
            let w = c.scrollLeft;
            c.scrollLeft += m / p, b = (c.scrollLeft - w) * p;
          }
          t = {
            left: t.left - b,
            top: t.top - x,
            right: t.right - b,
            bottom: t.bottom - x
          }, b && Math.abs(b - m) < 1 && (r = "nearest"), x && Math.abs(x - v) < 1 && (i = "nearest");
        }
      if (h)
        break;
      c = c.assignedSlot || c.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
}
function MQ(e) {
  let t = e.ownerDocument;
  for (let n = e.parentNode; n && n != t.body; )
    if (n.nodeType == 1) {
      if (n.scrollHeight > n.clientHeight || n.scrollWidth > n.clientWidth)
        return n;
      n = n.assignedSlot || n.parentNode;
    } else if (n.nodeType == 11)
      n = n.host;
    else
      break;
  return null;
}
class IQ {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t) {
    return this.anchorNode == t.anchorNode && this.anchorOffset == t.anchorOffset && this.focusNode == t.focusNode && this.focusOffset == t.focusOffset;
  }
  setRange(t) {
    let { anchorNode: n, focusNode: r } = t;
    this.set(n, Math.min(t.anchorOffset, n ? Ds(n) : 0), r, Math.min(t.focusOffset, r ? Ds(r) : 0));
  }
  set(t, n, r, i) {
    this.anchorNode = t, this.anchorOffset = n, this.focusNode = r, this.focusOffset = i;
  }
}
let Kl = null;
function YI(e) {
  if (e.setActive)
    return e.setActive();
  if (Kl)
    return e.focus(Kl);
  let t = [];
  for (let n = e; n && (t.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode)
    ;
  if (e.focus(Kl == null ? {
    get preventScroll() {
      return Kl = { preventScroll: !0 }, !0;
    }
  } : void 0), !Kl) {
    Kl = !1;
    for (let n = 0; n < t.length; ) {
      let r = t[n++], i = t[n++], o = t[n++];
      r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != o && (r.scrollLeft = o);
    }
  }
}
let B$;
function ol(e, t, n = t) {
  let r = B$ || (B$ = document.createRange());
  return r.setEnd(e, n), r.setStart(e, t), r;
}
function vc(e, t, n, r) {
  let i = { key: t, code: t, keyCode: n, which: n, cancelable: !0 };
  r && ({ altKey: i.altKey, ctrlKey: i.ctrlKey, shiftKey: i.shiftKey, metaKey: i.metaKey } = r);
  let o = new KeyboardEvent("keydown", i);
  o.synthetic = !0, e.dispatchEvent(o);
  let s = new KeyboardEvent("keyup", i);
  return s.synthetic = !0, e.dispatchEvent(s), o.defaultPrevented || s.defaultPrevented;
}
function kQ(e) {
  for (; e; ) {
    if (e && (e.nodeType == 9 || e.nodeType == 11 && e.host))
      return e;
    e = e.assignedSlot || e.parentNode;
  }
  return null;
}
function qI(e) {
  for (; e.attributes.length; )
    e.removeAttributeNode(e.attributes[0]);
}
function PQ(e, t) {
  let n = t.focusNode, r = t.focusOffset;
  if (!n || t.anchorNode != n || t.anchorOffset != r)
    return !1;
  for (r = Math.min(r, Ds(n)); ; )
    if (r) {
      if (n.nodeType != 1)
        return !1;
      let i = n.childNodes[r - 1];
      i.contentEditable == "false" ? r-- : (n = i, r = Ds(n));
    } else {
      if (n == e)
        return !0;
      r = il(n), n = n.parentNode;
    }
}
function QI(e) {
  return e.scrollTop > Math.max(1, e.scrollHeight - e.clientHeight - 4);
}
function ZI(e, t) {
  for (let n = e, r = t; ; ) {
    if (n.nodeType == 3 && r > 0)
      return { node: n, offset: r };
    if (n.nodeType == 1 && r > 0) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[r - 1], r = Ds(n);
    } else if (n.parentNode && !Xp(n))
      r = il(n), n = n.parentNode;
    else
      return null;
  }
}
function JI(e, t) {
  for (let n = e, r = t; ; ) {
    if (n.nodeType == 3 && r < n.nodeValue.length)
      return { node: n, offset: r };
    if (n.nodeType == 1 && r < n.childNodes.length) {
      if (n.contentEditable == "false")
        return null;
      n = n.childNodes[r], r = 0;
    } else if (n.parentNode && !Xp(n))
      r = il(n) + 1, n = n.parentNode;
    else
      return null;
  }
}
class Gr {
  constructor(t, n, r = !0) {
    this.node = t, this.offset = n, this.precise = r;
  }
  static before(t, n) {
    return new Gr(t.parentNode, il(t), n);
  }
  static after(t, n) {
    return new Gr(t.parentNode, il(t) + 1, n);
  }
}
const tC = [];
class Cn {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t) {
    let n = this.posAtStart;
    for (let r of this.children) {
      if (r == t)
        return n;
      n += r.length + r.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(t) {
    return this.posBefore(t) + t.length;
  }
  sync(t, n) {
    if (this.flags & 2) {
      let r = this.dom, i = null, o;
      for (let s of this.children) {
        if (s.flags & 7) {
          if (!s.dom && (o = i ? i.nextSibling : r.firstChild)) {
            let a = Cn.get(o);
            (!a || !a.parent && a.canReuseDOM(s)) && s.reuseDOM(o);
          }
          s.sync(t, n), s.flags &= -8;
        }
        if (o = i ? i.nextSibling : r.firstChild, n && !n.written && n.node == r && o != s.dom && (n.written = !0), s.dom.parentNode == r)
          for (; o && o != s.dom; )
            o = j$(o);
        else
          r.insertBefore(s.dom, o);
        i = s.dom;
      }
      for (o = i ? i.nextSibling : r.firstChild, o && n && n.node == r && (n.written = !0); o; )
        o = j$(o);
    } else if (this.flags & 1)
      for (let r of this.children)
        r.flags & 7 && (r.sync(t, n), r.flags &= -8);
  }
  reuseDOM(t) {
  }
  localPosFromDOM(t, n) {
    let r;
    if (t == this.dom)
      r = this.dom.childNodes[n];
    else {
      let i = Ds(t) == 0 ? 0 : n == 0 ? -1 : 1;
      for (; ; ) {
        let o = t.parentNode;
        if (o == this.dom)
          break;
        i == 0 && o.firstChild != o.lastChild && (t == o.firstChild ? i = -1 : i = 1), t = o;
      }
      i < 0 ? r = t : r = t.nextSibling;
    }
    if (r == this.dom.firstChild)
      return 0;
    for (; r && !Cn.get(r); )
      r = r.nextSibling;
    if (!r)
      return this.length;
    for (let i = 0, o = 0; ; i++) {
      let s = this.children[i];
      if (s.dom == r)
        return o;
      o += s.length + s.breakAfter;
    }
  }
  domBoundsAround(t, n, r = 0) {
    let i = -1, o = -1, s = -1, a = -1;
    for (let l = 0, u = r, c = r; l < this.children.length; l++) {
      let d = this.children[l], f = u + d.length;
      if (u < t && f > n)
        return d.domBoundsAround(t, n, u);
      if (f >= t && i == -1 && (i = l, o = u), u > n && d.dom.parentNode == this.dom) {
        s = l, a = c;
        break;
      }
      c = f, u = f + d.breakAfter;
    }
    return {
      from: o,
      to: a < 0 ? r + this.length : a,
      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: s < this.children.length && s >= 0 ? this.children[s].dom : null
    };
  }
  markDirty(t = !1) {
    this.flags |= 2, this.markParentsDirty(t);
  }
  markParentsDirty(t) {
    for (let n = this.parent; n; n = n.parent) {
      if (t && (n.flags |= 2), n.flags & 1)
        return;
      n.flags |= 1, t = !1;
    }
  }
  setParent(t) {
    this.parent != t && (this.parent = t, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(t) {
    this.dom != t && (this.dom && (this.dom.cmView = null), this.dom = t, t.cmView = this);
  }
  get rootView() {
    for (let t = this; ; ) {
      let n = t.parent;
      if (!n)
        return t;
      t = n;
    }
  }
  replaceChildren(t, n, r = tC) {
    this.markDirty();
    for (let i = t; i < n; i++) {
      let o = this.children[i];
      o.parent == this && r.indexOf(o) < 0 && o.destroy();
    }
    this.children.splice(t, n - t, ...r);
    for (let i = 0; i < r.length; i++)
      r[i].setParent(this);
  }
  ignoreMutation(t) {
    return !1;
  }
  ignoreEvent(t) {
    return !1;
  }
  childCursor(t = this.length) {
    return new ek(this.children, t, this.children.length);
  }
  childPos(t, n = 1) {
    return this.childCursor().findPos(t, n);
  }
  toString() {
    let t = this.constructor.name.replace("View", "");
    return t + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (t == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(t) {
    return t.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(t, n, r, i, o, s) {
    return !1;
  }
  become(t) {
    return !1;
  }
  canReuseDOM(t) {
    return t.constructor == this.constructor && !((this.flags | t.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    for (let t of this.children)
      t.parent == this && t.destroy();
    this.parent = null;
  }
}
Cn.prototype.breakAfter = 0;
function j$(e) {
  let t = e.nextSibling;
  return e.parentNode.removeChild(e), t;
}
class ek {
  constructor(t, n, r) {
    this.children = t, this.pos = n, this.i = r, this.off = 0;
  }
  findPos(t, n = 1) {
    for (; ; ) {
      if (t > this.pos || t == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = t - this.pos, this;
      let r = this.children[--this.i];
      this.pos -= r.length + r.breakAfter;
    }
  }
}
function tk(e, t, n, r, i, o, s, a, l) {
  let { children: u } = e, c = u.length ? u[t] : null, d = o.length ? o[o.length - 1] : null, f = d ? d.breakAfter : s;
  if (!(t == r && c && !s && !f && o.length < 2 && c.merge(n, i, o.length ? d : null, n == 0, a, l))) {
    if (r < u.length) {
      let h = u[r];
      h && (i < h.length || h.breakAfter && (d != null && d.breakAfter)) ? (t == r && (h = h.split(i), i = 0), !f && d && h.merge(0, i, d, !0, 0, l) ? o[o.length - 1] = h : ((i || h.children.length && !h.children[0].length) && h.merge(0, i, null, !1, 0, l), o.push(h))) : h != null && h.breakAfter && (d ? d.breakAfter = 1 : s = 1), r++;
    }
    for (c && (c.breakAfter = s, n > 0 && (!s && o.length && c.merge(n, c.length, o[0], !1, a, 0) ? c.breakAfter = o.shift().breakAfter : (n < c.length || c.children.length && c.children[c.children.length - 1].length == 0) && c.merge(n, c.length, null, !1, a, 0), t++)); t < r && o.length; )
      if (u[r - 1].become(o[o.length - 1]))
        r--, o.pop(), l = o.length ? 0 : a;
      else if (u[t].become(o[0]))
        t++, o.shift(), a = o.length ? 0 : l;
      else
        break;
    !o.length && t && r < u.length && !u[t - 1].breakAfter && u[r].merge(0, 0, u[t - 1], !1, a, l) && t--, (t < r || o.length) && e.replaceChildren(t, r, o);
  }
}
function nk(e, t, n, r, i, o) {
  let s = e.childCursor(), { i: a, off: l } = s.findPos(n, 1), { i: u, off: c } = s.findPos(t, -1), d = t - n;
  for (let f of r)
    d += f.length;
  e.length += d, tk(e, u, c, a, l, r, 0, i, o);
}
let Mi = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, dy = typeof document < "u" ? document : { documentElement: { style: {} } };
const fy = /* @__PURE__ */ /Edge\/(\d+)/.exec(Mi.userAgent), rk = /* @__PURE__ */ /MSIE \d/.test(Mi.userAgent), hy = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Mi.userAgent), mm = !!(rk || hy || fy), z$ = !mm && /* @__PURE__ */ /gecko\/(\d+)/i.test(Mi.userAgent), Pv = !mm && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Mi.userAgent), H$ = "webkitFontSmoothing" in dy.documentElement.style, ik = !mm && /* @__PURE__ */ /Apple Computer/.test(Mi.vendor), V$ = ik && (/* @__PURE__ */ /Mobile\/\w+/.test(Mi.userAgent) || Mi.maxTouchPoints > 2);
var ft = {
  mac: V$ || /* @__PURE__ */ /Mac/.test(Mi.platform),
  windows: /* @__PURE__ */ /Win/.test(Mi.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Mi.platform),
  ie: mm,
  ie_version: rk ? dy.documentMode || 6 : hy ? +hy[1] : fy ? +fy[1] : 0,
  gecko: z$,
  gecko_version: z$ ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Mi.userAgent) || [0, 0])[1] : 0,
  chrome: !!Pv,
  chrome_version: Pv ? +Pv[1] : 0,
  ios: V$,
  android: /* @__PURE__ */ /Android\b/.test(Mi.userAgent),
  webkit: H$,
  safari: ik,
  webkit_version: H$ ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: dy.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const NQ = 256;
class Oo extends Cn {
  constructor(t) {
    super(), this.text = t;
  }
  get length() {
    return this.text.length;
  }
  createDOM(t) {
    this.setDOM(t || document.createTextNode(this.text));
  }
  sync(t, n) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(t) {
    t.nodeType == 3 && this.createDOM(t);
  }
  merge(t, n, r) {
    return this.flags & 8 || r && (!(r instanceof Oo) || this.length - (n - t) + r.length > NQ || r.flags & 8) ? !1 : (this.text = this.text.slice(0, t) + (r ? r.text : "") + this.text.slice(n), this.markDirty(), !0);
  }
  split(t) {
    let n = new Oo(this.text.slice(t));
    return this.text = this.text.slice(0, t), this.markDirty(), n.flags |= this.flags & 8, n;
  }
  localPosFromDOM(t, n) {
    return t == this.dom ? n : n ? this.text.length : 0;
  }
  domAtPos(t) {
    return new Gr(this.dom, t);
  }
  domBoundsAround(t, n, r) {
    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(t, n) {
    return LQ(this.dom, t, n);
  }
}
class _s extends Cn {
  constructor(t, n = [], r = 0) {
    super(), this.mark = t, this.children = n, this.length = r;
    for (let i of n)
      i.setParent(this);
  }
  setAttrs(t) {
    if (qI(t), this.mark.class && (t.className = this.mark.class), this.mark.attrs)
      for (let n in this.mark.attrs)
        t.setAttribute(n, this.mark.attrs[n]);
    return t;
  }
  canReuseDOM(t) {
    return super.canReuseDOM(t) && !((this.flags | t.flags) & 8);
  }
  reuseDOM(t) {
    t.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, n) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t, n);
  }
  merge(t, n, r, i, o, s) {
    return r && (!(r instanceof _s && r.mark.eq(this.mark)) || t && o <= 0 || n < this.length && s <= 0) ? !1 : (nk(this, t, n, r ? r.children.slice() : [], o - 1, s - 1), this.markDirty(), !0);
  }
  split(t) {
    let n = [], r = 0, i = -1, o = 0;
    for (let a of this.children) {
      let l = r + a.length;
      l > t && n.push(r < t ? a.split(t - r) : a), i < 0 && r >= t && (i = o), r = l, o++;
    }
    let s = this.length - t;
    return this.length = t, i > -1 && (this.children.length = i, this.markDirty()), new _s(this.mark, n, s);
  }
  domAtPos(t) {
    return ok(this, t);
  }
  coordsAt(t, n) {
    return ak(this, t, n);
  }
}
function LQ(e, t, n) {
  let r = e.nodeValue.length;
  t > r && (t = r);
  let i = t, o = t, s = 0;
  t == 0 && n < 0 || t == r && n >= 0 ? ft.chrome || ft.gecko || (t ? (i--, s = 1) : o < r && (o++, s = -1)) : n < 0 ? i-- : o < r && o++;
  let a = ol(e, i, o).getClientRects();
  if (!a.length)
    return null;
  let l = a[(s ? s < 0 : n >= 0) ? 0 : a.length - 1];
  return ft.safari && !s && l.width == 0 && (l = Array.prototype.find.call(a, (u) => u.width) || l), s ? gm(l, s < 0) : l || null;
}
class Qs extends Cn {
  static create(t, n, r) {
    return new Qs(t, n, r);
  }
  constructor(t, n, r) {
    super(), this.widget = t, this.length = n, this.side = r, this.prevWidget = null;
  }
  split(t) {
    let n = Qs.create(this.widget, this.length - t, this.side);
    return this.length -= t, n;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  getSide() {
    return this.side;
  }
  merge(t, n, r, i, o, s) {
    return r && (!(r instanceof Qs) || !this.widget.compare(r.widget) || t > 0 && o <= 0 || n < this.length && s <= 0) ? !1 : (this.length = t + (r ? r.length : 0) + (this.length - n), !0);
  }
  become(t) {
    return t instanceof Qs && t.side == this.side && this.widget.constructor == t.widget.constructor ? (this.widget.compare(t.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return fn.empty;
    let t = this;
    for (; t.parent; )
      t = t.parent;
    let { view: n } = t, r = n && n.state.doc, i = this.posAtStart;
    return r ? r.slice(i, i + this.length) : fn.empty;
  }
  domAtPos(t) {
    return (this.length ? t == 0 : this.side > 0) ? Gr.before(this.dom) : Gr.after(this.dom, t == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t, n) {
    let r = this.widget.coordsAt(this.dom, t, n);
    if (r)
      return r;
    let i = this.dom.getClientRects(), o = null;
    if (!i.length)
      return null;
    let s = this.side ? this.side < 0 : t > 0;
    for (let a = s ? i.length - 1 : 0; o = i[a], !(t > 0 ? a == 0 : a == i.length - 1 || o.top < o.bottom); a += s ? -1 : 1)
      ;
    return gm(o, !s);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Bc extends Cn {
  constructor(t) {
    super(), this.side = t;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(t) {
    return t instanceof Bc && t.side == this.side;
  }
  split() {
    return new Bc(this.side);
  }
  sync() {
    if (!this.dom) {
      let t = document.createElement("img");
      t.className = "cm-widgetBuffer", t.setAttribute("aria-hidden", "true"), this.setDOM(t);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(t) {
    return this.side > 0 ? Gr.before(this.dom) : Gr.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return fn.empty;
  }
  get isHidden() {
    return !0;
  }
}
Oo.prototype.children = Qs.prototype.children = Bc.prototype.children = tC;
function ok(e, t) {
  let n = e.dom, { children: r } = e, i = 0;
  for (let o = 0; i < r.length; i++) {
    let s = r[i], a = o + s.length;
    if (!(a == o && s.getSide() <= 0)) {
      if (t > o && t < a && s.dom.parentNode == n)
        return s.domAtPos(t - o);
      if (t <= o)
        break;
      o = a;
    }
  }
  for (let o = i; o > 0; o--) {
    let s = r[o - 1];
    if (s.dom.parentNode == n)
      return s.domAtPos(s.length);
  }
  for (let o = i; o < r.length; o++) {
    let s = r[o];
    if (s.dom.parentNode == n)
      return s.domAtPos(0);
  }
  return new Gr(n, 0);
}
function sk(e, t, n) {
  let r, { children: i } = e;
  n > 0 && t instanceof _s && i.length && (r = i[i.length - 1]) instanceof _s && r.mark.eq(t.mark) ? sk(r, t.children[0], n - 1) : (i.push(t), t.setParent(e)), e.length += t.length;
}
function ak(e, t, n) {
  let r = null, i = -1, o = null, s = -1;
  function a(u, c) {
    for (let d = 0, f = 0; d < u.children.length && f <= c; d++) {
      let h = u.children[d], p = f + h.length;
      p >= c && (h.children.length ? a(h, c - f) : (!o || o.isHidden && n > 0) && (p > c || f == p && h.getSide() > 0) ? (o = h, s = c - f) : (f < c || f == p && h.getSide() < 0 && !h.isHidden) && (r = h, i = c - f)), f = p;
    }
  }
  a(e, t);
  let l = (n < 0 ? r : o) || r || o;
  return l ? l.coordsAt(Math.max(0, l == r ? i : s), n) : FQ(e);
}
function FQ(e) {
  let t = e.dom.lastChild;
  if (!t)
    return e.dom.getBoundingClientRect();
  let n = Fc(t);
  return n[n.length - 1] || null;
}
function py(e, t) {
  for (let n in e)
    n == "class" && t.class ? t.class += " " + e.class : n == "style" && t.style ? t.style += ";" + e.style : t[n] = e[n];
  return t;
}
const W$ = /* @__PURE__ */ Object.create(null);
function nC(e, t, n) {
  if (e == t)
    return !0;
  e || (e = W$), t || (t = W$);
  let r = Object.keys(e), i = Object.keys(t);
  if (r.length - (n && r.indexOf(n) > -1 ? 1 : 0) != i.length - (n && i.indexOf(n) > -1 ? 1 : 0))
    return !1;
  for (let o of r)
    if (o != n && (i.indexOf(o) == -1 || e[o] !== t[o]))
      return !1;
  return !0;
}
function gy(e, t, n) {
  let r = !1;
  if (t)
    for (let i in t)
      n && i in n || (r = !0, i == "style" ? e.style.cssText = "" : e.removeAttribute(i));
  if (n)
    for (let i in n)
      t && t[i] == n[i] || (r = !0, i == "style" ? e.style.cssText = n[i] : e.setAttribute(i, n[i]));
  return r;
}
function BQ(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n = 0; n < e.attributes.length; n++) {
    let r = e.attributes[n];
    t[r.name] = r.value;
  }
  return t;
}
class ur extends Cn {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(t, n, r, i, o, s) {
    if (r) {
      if (!(r instanceof ur))
        return !1;
      this.dom || r.transferDOM(this);
    }
    return i && this.setDeco(r ? r.attrs : null), nk(this, t, n, r ? r.children.slice() : [], o, s), !0;
  }
  split(t) {
    let n = new ur();
    if (n.breakAfter = this.breakAfter, this.length == 0)
      return n;
    let { i: r, off: i } = this.childPos(t);
    i && (n.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, !1, 0, 0), r++);
    for (let o = r; o < this.children.length; o++)
      n.append(this.children[o], 0);
    for (; r > 0 && this.children[r - 1].length == 0; )
      this.children[--r].destroy();
    return this.children.length = r, this.markDirty(), this.length = t, n;
  }
  transferDOM(t) {
    this.dom && (this.markDirty(), t.setDOM(this.dom), t.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(t) {
    nC(this.attrs, t) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t);
  }
  append(t, n) {
    sk(this, t, n);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(t) {
    let n = t.spec.attributes, r = t.spec.class;
    n && (this.attrs = py(n, this.attrs || {})), r && (this.attrs = py({ class: r }, this.attrs || {}));
  }
  domAtPos(t) {
    return ok(this, t);
  }
  reuseDOM(t) {
    t.nodeName == "DIV" && (this.setDOM(t), this.flags |= 6);
  }
  sync(t, n) {
    var r;
    this.dom ? this.flags & 4 && (qI(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (gy(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t, n);
    let i = this.dom.lastChild;
    for (; i && Cn.get(i) instanceof _s; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((r = Cn.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!ft.ios || !this.children.some((o) => o instanceof Oo))) {
      let o = document.createElement("BR");
      o.cmIgnore = !0, this.dom.appendChild(o);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let t = 0, n;
    for (let r of this.children) {
      if (!(r instanceof Oo) || /[^ -~]/.test(r.text))
        return null;
      let i = Fc(r.dom);
      if (i.length != 1)
        return null;
      t += i[0].width, n = i[0].height;
    }
    return t ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: t / this.length,
      textHeight: n
    } : null;
  }
  coordsAt(t, n) {
    let r = ak(this, t, n);
    if (!this.children.length && r && this.parent) {
      let { heightOracle: i } = this.parent.view.viewState, o = r.bottom - r.top;
      if (Math.abs(o - i.lineHeight) < 2 && i.textHeight < o) {
        let s = (o - i.textHeight) / 2;
        return { top: r.top + s, bottom: r.bottom - s, left: r.left, right: r.left };
      }
    }
    return r;
  }
  become(t) {
    return !1;
  }
  covers() {
    return !0;
  }
  static find(t, n) {
    for (let r = 0, i = 0; r < t.children.length; r++) {
      let o = t.children[r], s = i + o.length;
      if (s >= n) {
        if (o instanceof ur)
          return o;
        if (s > n)
          break;
      }
      i = s + o.breakAfter;
    }
    return null;
  }
}
class na extends Cn {
  constructor(t, n, r) {
    super(), this.widget = t, this.length = n, this.deco = r, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(t, n, r, i, o, s) {
    return r && (!(r instanceof na) || !this.widget.compare(r.widget) || t > 0 && o <= 0 || n < this.length && s <= 0) ? !1 : (this.length = t + (r ? r.length : 0) + (this.length - n), !0);
  }
  domAtPos(t) {
    return t == 0 ? Gr.before(this.dom) : Gr.after(this.dom, t == this.length);
  }
  split(t) {
    let n = this.length - t;
    this.length = t;
    let r = new na(this.widget, n, this.deco);
    return r.breakAfter = this.breakAfter, r;
  }
  get children() {
    return tC;
  }
  sync(t) {
    (!this.dom || !this.widget.updateDOM(this.dom, t)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(t)), this.widget.editable || (this.dom.contentEditable = "false"));
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : fn.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(t) {
    return t instanceof na && t.widget.constructor == this.widget.constructor ? (t.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, this.deco = t.deco, this.breakAfter = t.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(t, n) {
    return this.widget.coordsAt(this.dom, t, n);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
  covers(t) {
    let { startSide: n, endSide: r } = this.deco;
    return n == r ? !1 : t < 0 ? n < 0 : r > 0;
  }
}
class vm {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(t) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(t, n) {
    return !1;
  }
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(t) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedless than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(t, n, r) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  @internal
  */
  get editable() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(t) {
  }
}
var ys = /* @__PURE__ */ function(e) {
  return e[e.Text = 0] = "Text", e[e.WidgetBefore = 1] = "WidgetBefore", e[e.WidgetAfter = 2] = "WidgetAfter", e[e.WidgetRange = 3] = "WidgetRange", e;
}(ys || (ys = {}));
class dr extends rl {
  constructor(t, n, r, i) {
    super(), this.startSide = t, this.endSide = n, this.widget = r, this.spec = i;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(t) {
    return new _f(t);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(t) {
    let n = Math.max(-1e4, Math.min(1e4, t.side || 0)), r = !!t.block;
    return n += r && !t.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new pa(t, n, n, r, t.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(t) {
    let n = !!t.block, r, i;
    if (t.isBlockGap)
      r = -5e8, i = 4e8;
    else {
      let { start: o, end: s } = lk(t, n);
      r = (o ? n ? -3e8 : -1 : 5e8) - 1, i = (s ? n ? 2e8 : 1 : -6e8) + 1;
    }
    return new pa(t, r, i, n, t.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(t) {
    return new Tf(t);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(t, n = !1) {
    return En.of(t, n);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
dr.none = En.empty;
class _f extends dr {
  constructor(t) {
    let { start: n, end: r } = lk(t);
    super(n ? -1 : 5e8, r ? 1 : -6e8, null, t), this.tagName = t.tagName || "span", this.class = t.class || "", this.attrs = t.attributes || null;
  }
  eq(t) {
    var n, r;
    return this == t || t instanceof _f && this.tagName == t.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (t.class || ((r = t.attrs) === null || r === void 0 ? void 0 : r.class)) && nC(this.attrs, t.attrs, "class");
  }
  range(t, n = t) {
    if (t >= n)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(t, n);
  }
}
_f.prototype.point = !1;
class Tf extends dr {
  constructor(t) {
    super(-2e8, -2e8, null, t);
  }
  eq(t) {
    return t instanceof Tf && this.spec.class == t.spec.class && nC(this.spec.attributes, t.spec.attributes);
  }
  range(t, n = t) {
    if (n != t)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(t, n);
  }
}
Tf.prototype.mapMode = ni.TrackBefore;
Tf.prototype.point = !0;
class pa extends dr {
  constructor(t, n, r, i, o, s) {
    super(n, r, o, t), this.block = i, this.isReplace = s, this.mapMode = i ? n <= 0 ? ni.TrackBefore : ni.TrackAfter : ni.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide != this.endSide ? ys.WidgetRange : this.startSide <= 0 ? ys.WidgetBefore : ys.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(t) {
    return t instanceof pa && jQ(this.widget, t.widget) && this.block == t.block && this.startSide == t.startSide && this.endSide == t.endSide;
  }
  range(t, n = t) {
    if (this.isReplace && (t > n || t == n && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && n != t)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t, n);
  }
}
pa.prototype.point = !0;
function lk(e, t = !1) {
  let { inclusiveStart: n, inclusiveEnd: r } = e;
  return n == null && (n = e.inclusive), r == null && (r = e.inclusive), { start: n ?? t, end: r ?? t };
}
function jQ(e, t) {
  return e == t || !!(e && t && e.compare(t));
}
function my(e, t, n, r = 0) {
  let i = n.length - 1;
  i >= 0 && n[i] + r >= e ? n[i] = Math.max(n[i], t) : n.push(e, t);
}
class sd {
  constructor(t, n, r, i) {
    this.doc = t, this.pos = n, this.end = r, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t.iter(), this.skip = n;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let t = this.content[this.content.length - 1];
    return !(t.breakAfter || t instanceof na && t.deco.endSide < 0);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new ur()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(t = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(dh(new Bc(-1), t), t.length), this.pendingBuffer = 0);
  }
  addBlockWidget(t) {
    this.flushBuffer(), this.curLine = null, this.content.push(t);
  }
  finish(t) {
    this.pendingBuffer && t <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(t && this.content.length && this.content[this.content.length - 1] instanceof na) && this.getLine();
  }
  buildText(t, n, r) {
    for (; t > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: o, lineBreak: s, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (s) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, t--;
          continue;
        } else
          this.text = o, this.textOff = 0;
      }
      let i = Math.min(
        this.text.length - this.textOff,
        t,
        512
        /* T.Chunk */
      );
      this.flushBuffer(n.slice(n.length - r)), this.getLine().append(dh(new Oo(this.text.slice(this.textOff, this.textOff + i)), n), r), this.atCursorPos = !0, this.textOff += i, t -= i, r = 0;
    }
  }
  span(t, n, r, i) {
    this.buildText(n - t, r, i), this.pos = n, this.openStart < 0 && (this.openStart = i);
  }
  point(t, n, r, i, o, s) {
    if (this.disallowBlockEffectsFor[s] && r instanceof pa) {
      if (r.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (n > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = n - t;
    if (r instanceof pa)
      if (r.block)
        r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new na(r.widget || jc.block, a, r));
      else {
        let l = Qs.create(r.widget || jc.inline, a, a ? 0 : r.startSide), u = this.atCursorPos && !l.isEditable && o <= i.length && (t < n || r.startSide > 0), c = !l.isEditable && (t < n || o > i.length || r.startSide <= 0), d = this.getLine();
        this.pendingBuffer == 2 && !u && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), u && (d.append(dh(new Bc(1), i), o), o = i.length + Math.max(0, o - i.length)), d.append(dh(l, i), o), this.atCursorPos = c, this.pendingBuffer = c ? t < n || o > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = n), this.openStart < 0 && (this.openStart = o);
  }
  static build(t, n, r, i, o) {
    let s = new sd(t, n, r, o);
    return s.openEnd = En.spans(i, n, r, s), s.openStart < 0 && (s.openStart = s.openEnd), s.finish(s.openEnd), s;
  }
}
function dh(e, t) {
  for (let n of t)
    e = new _s(n, [e], e.length);
  return e;
}
class jc extends vm {
  constructor(t) {
    super(), this.tag = t;
  }
  eq(t) {
    return t.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t) {
    return t.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
jc.inline = /* @__PURE__ */ new jc("span");
jc.block = /* @__PURE__ */ new jc("div");
var ar = /* @__PURE__ */ function(e) {
  return e[e.LTR = 0] = "LTR", e[e.RTL = 1] = "RTL", e;
}(ar || (ar = {}));
const sl = ar.LTR, rC = ar.RTL;
function ck(e) {
  let t = [];
  for (let n = 0; n < e.length; n++)
    t.push(1 << +e[n]);
  return t;
}
const zQ = /* @__PURE__ */ ck("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), HQ = /* @__PURE__ */ ck("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), vy = /* @__PURE__ */ Object.create(null), ko = [];
for (let e of ["()", "[]", "{}"]) {
  let t = /* @__PURE__ */ e.charCodeAt(0), n = /* @__PURE__ */ e.charCodeAt(1);
  vy[t] = n, vy[n] = -t;
}
function uk(e) {
  return e <= 247 ? zQ[e] : 1424 <= e && e <= 1524 ? 2 : 1536 <= e && e <= 1785 ? HQ[e - 1536] : 1774 <= e && e <= 2220 ? 4 : 8192 <= e && e <= 8204 ? 256 : 64336 <= e && e <= 65023 ? 4 : 1;
}
const VQ = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Zs {
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? rC : sl;
  }
  /**
  @internal
  */
  constructor(t, n, r) {
    this.from = t, this.to = n, this.level = r;
  }
  /**
  @internal
  */
  side(t, n) {
    return this.dir == n == t ? this.to : this.from;
  }
  /**
  @internal
  */
  forward(t, n) {
    return t == (this.dir == n);
  }
  /**
  @internal
  */
  static find(t, n, r, i) {
    let o = -1;
    for (let s = 0; s < t.length; s++) {
      let a = t[s];
      if (a.from <= n && a.to >= n) {
        if (a.level == r)
          return s;
        (o < 0 || (i != 0 ? i < 0 ? a.from < n : a.to > n : t[o].level > a.level)) && (o = s);
      }
    }
    if (o < 0)
      throw new RangeError("Index out of range");
    return o;
  }
}
function dk(e, t) {
  if (e.length != t.length)
    return !1;
  for (let n = 0; n < e.length; n++) {
    let r = e[n], i = t[n];
    if (r.from != i.from || r.to != i.to || r.direction != i.direction || !dk(r.inner, i.inner))
      return !1;
  }
  return !0;
}
const bn = [];
function WQ(e, t, n, r, i) {
  for (let o = 0; o <= r.length; o++) {
    let s = o ? r[o - 1].to : t, a = o < r.length ? r[o].from : n, l = o ? 256 : i;
    for (let u = s, c = l, d = l; u < a; u++) {
      let f = uk(e.charCodeAt(u));
      f == 512 ? f = c : f == 8 && d == 4 && (f = 16), bn[u] = f == 4 ? 2 : f, f & 7 && (d = f), c = f;
    }
    for (let u = s, c = l, d = l; u < a; u++) {
      let f = bn[u];
      if (f == 128)
        u < a - 1 && c == bn[u + 1] && c & 24 ? f = bn[u] = c : bn[u] = 256;
      else if (f == 64) {
        let h = u + 1;
        for (; h < a && bn[h] == 64; )
          h++;
        let p = u && c == 8 || h < n && bn[h] == 8 ? d == 1 ? 1 : 8 : 256;
        for (let g = u; g < h; g++)
          bn[g] = p;
        u = h - 1;
      } else
        f == 8 && d == 1 && (bn[u] = 1);
      c = f, f & 7 && (d = f);
    }
  }
}
function UQ(e, t, n, r, i) {
  let o = i == 1 ? 2 : 1;
  for (let s = 0, a = 0, l = 0; s <= r.length; s++) {
    let u = s ? r[s - 1].to : t, c = s < r.length ? r[s].from : n;
    for (let d = u, f, h, p; d < c; d++)
      if (h = vy[f = e.charCodeAt(d)])
        if (h < 0) {
          for (let g = a - 3; g >= 0; g -= 3)
            if (ko[g + 1] == -h) {
              let m = ko[g + 2], v = m & 2 ? i : m & 4 ? m & 1 ? o : i : 0;
              v && (bn[d] = bn[ko[g]] = v), a = g;
              break;
            }
        } else {
          if (ko.length == 189)
            break;
          ko[a++] = d, ko[a++] = f, ko[a++] = l;
        }
      else if ((p = bn[d]) == 2 || p == 1) {
        let g = p == i;
        l = g ? 0 : 1;
        for (let m = a - 3; m >= 0; m -= 3) {
          let v = ko[m + 2];
          if (v & 2)
            break;
          if (g)
            ko[m + 2] |= 2;
          else {
            if (v & 4)
              break;
            ko[m + 2] |= 4;
          }
        }
      }
  }
}
function GQ(e, t, n, r) {
  for (let i = 0, o = r; i <= n.length; i++) {
    let s = i ? n[i - 1].to : e, a = i < n.length ? n[i].from : t;
    for (let l = s; l < a; ) {
      let u = bn[l];
      if (u == 256) {
        let c = l + 1;
        for (; ; )
          if (c == a) {
            if (i == n.length)
              break;
            c = n[i++].to, a = i < n.length ? n[i].from : t;
          } else if (bn[c] == 256)
            c++;
          else
            break;
        let d = o == 1, f = (c < t ? bn[c] : r) == 1, h = d == f ? d ? 1 : 2 : r;
        for (let p = c, g = i, m = g ? n[g - 1].to : e; p > l; )
          p == m && (p = n[--g].from, m = g ? n[g - 1].to : e), bn[--p] = h;
        l = c;
      } else
        o = u, l++;
    }
  }
}
function by(e, t, n, r, i, o, s) {
  let a = r % 2 ? 2 : 1;
  if (r % 2 == i % 2)
    for (let l = t, u = 0; l < n; ) {
      let c = !0, d = !1;
      if (u == o.length || l < o[u].from) {
        let g = bn[l];
        g != a && (c = !1, d = g == 16);
      }
      let f = !c && a == 1 ? [] : null, h = c ? r : r + 1, p = l;
      e:
        for (; ; )
          if (u < o.length && p == o[u].from) {
            if (d)
              break e;
            let g = o[u];
            if (!c)
              for (let m = g.to, v = u + 1; ; ) {
                if (m == n)
                  break e;
                if (v < o.length && o[v].from == m)
                  m = o[v++].to;
                else {
                  if (bn[m] == a)
                    break e;
                  break;
                }
              }
            if (u++, f)
              f.push(g);
            else {
              g.from > l && s.push(new Zs(l, g.from, h));
              let m = g.direction == sl != !(h % 2);
              yy(e, m ? r + 1 : r, i, g.inner, g.from, g.to, s), l = g.to;
            }
            p = g.to;
          } else {
            if (p == n || (c ? bn[p] != a : bn[p] == a))
              break;
            p++;
          }
      f ? by(e, l, p, r + 1, i, f, s) : l < p && s.push(new Zs(l, p, h)), l = p;
    }
  else
    for (let l = n, u = o.length; l > t; ) {
      let c = !0, d = !1;
      if (!u || l > o[u - 1].to) {
        let g = bn[l - 1];
        g != a && (c = !1, d = g == 16);
      }
      let f = !c && a == 1 ? [] : null, h = c ? r : r + 1, p = l;
      e:
        for (; ; )
          if (u && p == o[u - 1].to) {
            if (d)
              break e;
            let g = o[--u];
            if (!c)
              for (let m = g.from, v = u; ; ) {
                if (m == t)
                  break e;
                if (v && o[v - 1].to == m)
                  m = o[--v].from;
                else {
                  if (bn[m - 1] == a)
                    break e;
                  break;
                }
              }
            if (f)
              f.push(g);
            else {
              g.to < l && s.push(new Zs(g.to, l, h));
              let m = g.direction == sl != !(h % 2);
              yy(e, m ? r + 1 : r, i, g.inner, g.from, g.to, s), l = g.from;
            }
            p = g.from;
          } else {
            if (p == t || (c ? bn[p - 1] != a : bn[p - 1] == a))
              break;
            p--;
          }
      f ? by(e, p, l, r + 1, i, f, s) : p < l && s.push(new Zs(p, l, h)), l = p;
    }
}
function yy(e, t, n, r, i, o, s) {
  let a = t % 2 ? 2 : 1;
  WQ(e, i, o, r, a), UQ(e, i, o, r, a), GQ(i, o, r, a), by(e, i, o, t, n, r, s);
}
function KQ(e, t, n) {
  if (!e)
    return [new Zs(0, 0, t == rC ? 1 : 0)];
  if (t == sl && !n.length && !VQ.test(e))
    return fk(e.length);
  if (n.length)
    for (; e.length > bn.length; )
      bn[bn.length] = 256;
  let r = [], i = t == sl ? 0 : 1;
  return yy(e, i, i, n, 0, e.length, r), r;
}
function fk(e) {
  return [new Zs(0, e, 0)];
}
let hk = "";
function XQ(e, t, n, r, i) {
  var o;
  let s = r.head - e.from, a = Zs.find(t, s, (o = r.bidiLevel) !== null && o !== void 0 ? o : -1, r.assoc), l = t[a], u = l.side(i, n);
  if (s == u) {
    let f = a += i ? 1 : -1;
    if (f < 0 || f >= t.length)
      return null;
    l = t[a = f], s = l.side(!i, n), u = l.side(i, n);
  }
  let c = gs(e.text, s, l.forward(i, n));
  (c < l.from || c > l.to) && (c = u), hk = e.text.slice(Math.min(s, c), Math.max(s, c));
  let d = a == (i ? t.length - 1 : 0) ? null : t[a + (i ? 1 : -1)];
  return d && c == u && d.level + (i ? 0 : 1) < l.level ? st.cursor(d.side(!i, n) + e.from, d.forward(i, n) ? 1 : -1, d.level) : st.cursor(c + e.from, l.forward(i, n) ? -1 : 1, l.level);
}
function YQ(e, t, n) {
  for (let r = t; r < n; r++) {
    let i = uk(e.charCodeAt(r));
    if (i == 1)
      return sl;
    if (i == 2 || i == 4)
      return rC;
  }
  return sl;
}
const pk = /* @__PURE__ */ Pt.define(), gk = /* @__PURE__ */ Pt.define(), mk = /* @__PURE__ */ Pt.define(), vk = /* @__PURE__ */ Pt.define(), wy = /* @__PURE__ */ Pt.define(), bk = /* @__PURE__ */ Pt.define(), yk = /* @__PURE__ */ Pt.define(), wk = /* @__PURE__ */ Pt.define({
  combine: (e) => e.some((t) => t)
}), qQ = /* @__PURE__ */ Pt.define({
  combine: (e) => e.some((t) => t)
}), Ck = /* @__PURE__ */ Pt.define();
class bc {
  constructor(t, n = "nearest", r = "nearest", i = 5, o = 5, s = !1) {
    this.range = t, this.y = n, this.x = r, this.yMargin = i, this.xMargin = o, this.isSnapshot = s;
  }
  map(t) {
    return t.empty ? this : new bc(this.range.map(t), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
  clip(t) {
    return this.range.to <= t.doc.length ? this : new bc(st.cursor(t.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);
  }
}
const fh = /* @__PURE__ */ In.define({ map: (e, t) => e.map(t) });
function bi(e, t, n) {
  let r = e.facet(vk);
  r.length ? r[0](t) : window.onerror ? window.onerror(String(t), n, void 0, void 0, t) : n ? console.error(n + ":", t) : console.error(t);
}
const bm = /* @__PURE__ */ Pt.define({ combine: (e) => e.length ? e[0] : !0 });
let QQ = 0;
const Fu = /* @__PURE__ */ Pt.define();
class Ao {
  constructor(t, n, r, i, o) {
    this.id = t, this.create = n, this.domEventHandlers = r, this.domEventObservers = i, this.extension = o(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(t, n) {
    const { eventHandlers: r, eventObservers: i, provide: o, decorations: s } = n || {};
    return new Ao(QQ++, t, r, i, (a) => {
      let l = [Fu.of(a)];
      return s && l.push(Fd.of((u) => {
        let c = u.plugin(a);
        return c ? s(c) : dr.none;
      })), o && l.push(o(a)), l;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(t, n) {
    return Ao.define((r) => new t(r), n);
  }
}
class Nv {
  constructor(t) {
    this.spec = t, this.mustUpdate = null, this.value = null;
  }
  update(t) {
    if (this.value) {
      if (this.mustUpdate) {
        let n = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(n);
          } catch (r) {
            if (bi(n.state, r, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(t);
      } catch (n) {
        bi(t.state, n, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(t) {
    var n;
    if (!((n = this.value) === null || n === void 0) && n.destroy)
      try {
        this.value.destroy();
      } catch (r) {
        bi(t.state, r, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const Sk = /* @__PURE__ */ Pt.define(), iC = /* @__PURE__ */ Pt.define(), Fd = /* @__PURE__ */ Pt.define(), xk = /* @__PURE__ */ Pt.define(), oC = /* @__PURE__ */ Pt.define(), Ek = /* @__PURE__ */ Pt.define();
function U$(e, t) {
  let n = e.state.facet(Ek);
  if (!n.length)
    return n;
  let r = n.map((o) => o instanceof Function ? o(e) : o), i = [];
  return En.spans(r, t.from, t.to, {
    point() {
    },
    span(o, s, a, l) {
      let u = o - t.from, c = s - t.from, d = i;
      for (let f = a.length - 1; f >= 0; f--, l--) {
        let h = a[f].spec.bidiIsolate, p;
        if (h == null && (h = YQ(t.text, u, c)), l > 0 && d.length && (p = d[d.length - 1]).to == u && p.direction == h)
          p.to = c, d = p.inner;
        else {
          let g = { from: u, to: c, direction: h, inner: [] };
          d.push(g), d = g.inner;
        }
      }
    }
  }), i;
}
const $k = /* @__PURE__ */ Pt.define();
function Ok(e) {
  let t = 0, n = 0, r = 0, i = 0;
  for (let o of e.state.facet($k)) {
    let s = o(e);
    s && (s.left != null && (t = Math.max(t, s.left)), s.right != null && (n = Math.max(n, s.right)), s.top != null && (r = Math.max(r, s.top)), s.bottom != null && (i = Math.max(i, s.bottom)));
  }
  return { left: t, right: n, top: r, bottom: i };
}
const Bu = /* @__PURE__ */ Pt.define();
class eo {
  constructor(t, n, r, i) {
    this.fromA = t, this.toA = n, this.fromB = r, this.toB = i;
  }
  join(t) {
    return new eo(Math.min(this.fromA, t.fromA), Math.max(this.toA, t.toA), Math.min(this.fromB, t.fromB), Math.max(this.toB, t.toB));
  }
  addToSet(t) {
    let n = t.length, r = this;
    for (; n > 0; n--) {
      let i = t[n - 1];
      if (!(i.fromA > r.toA)) {
        if (i.toA < r.fromA)
          break;
        r = r.join(i), t.splice(n - 1, 1);
      }
    }
    return t.splice(n, 0, r), t;
  }
  static extendWithRanges(t, n) {
    if (n.length == 0)
      return t;
    let r = [];
    for (let i = 0, o = 0, s = 0, a = 0; ; i++) {
      let l = i == t.length ? null : t[i], u = s - a, c = l ? l.fromB : 1e9;
      for (; o < n.length && n[o] < c; ) {
        let d = n[o], f = n[o + 1], h = Math.max(a, d), p = Math.min(c, f);
        if (h <= p && new eo(h + u, p + u, h, p).addToSet(r), f > c)
          break;
        o += 2;
      }
      if (!l)
        return r;
      new eo(l.fromA, l.toA, l.fromB, l.toB).addToSet(r), s = l.toA, a = l.toB;
    }
  }
}
class Yp {
  constructor(t, n, r) {
    this.view = t, this.state = n, this.transactions = r, this.flags = 0, this.startState = t.state, this.changes = wr.empty(this.startState.doc.length);
    for (let o of r)
      this.changes = this.changes.compose(o.changes);
    let i = [];
    this.changes.iterChangedRanges((o, s, a, l) => i.push(new eo(o, s, a, l))), this.changedRanges = i;
  }
  /**
  @internal
  */
  static create(t, n, r) {
    return new Yp(t, n, r);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((t) => t.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
class G$ extends Cn {
  get length() {
    return this.view.state.doc.length;
  }
  constructor(t) {
    super(), this.view = t, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.lastCompositionAfterCursor = !1, this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(t.contentDOM), this.children = [new ur()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new eo(0, 0, 0, t.state.doc.length)], 0, null);
  }
  // Update the document view to a given state.
  update(t) {
    var n;
    let r = t.changedRanges;
    this.minWidth > 0 && r.length && (r.every(({ fromA: u, toA: c }) => c < this.minWidthFrom || u > this.minWidthTo) ? (this.minWidthFrom = t.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let i = -1;
    this.view.inputState.composing >= 0 && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? i = this.domChanged.newSel.head : !iZ(t.changes, this.hasComposition) && !t.selectionSet && (i = t.state.selection.main.head));
    let o = i > -1 ? JQ(this.view, t.changes, i) : null;
    if (this.domChanged = null, this.hasComposition) {
      this.markedForComposition.clear();
      let { from: u, to: c } = this.hasComposition;
      r = new eo(u, c, t.changes.mapPos(u, -1), t.changes.mapPos(c, 1)).addToSet(r.slice());
    }
    this.hasComposition = o ? { from: o.range.fromB, to: o.range.toB } : null, (ft.ie || ft.chrome) && !o && t && t.state.doc.lines != t.startState.doc.lines && (this.forceSelection = !0);
    let s = this.decorations, a = this.updateDeco(), l = nZ(s, a, t.changes);
    return r = eo.extendWithRanges(r, l), !(this.flags & 7) && r.length == 0 ? !1 : (this.updateInner(r, t.startState.doc.length, o), t.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(t, n, r) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(t, n, r);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let s = ft.chrome || ft.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, s), this.flags &= -8, s && (s.written || i.selectionRange.focusNode != s.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (s) => s.flags &= -9
      /* ViewFlag.Composition */
    );
    let o = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let s of this.children)
        s instanceof na && s.widget instanceof K$ && o.push(s.dom);
    i.updateGaps(o);
  }
  updateChildren(t, n, r) {
    let i = r ? r.range.addToSet(t.slice()) : t, o = this.childCursor(n);
    for (let s = i.length - 1; ; s--) {
      let a = s >= 0 ? i[s] : null;
      if (!a)
        break;
      let { fromA: l, toA: u, fromB: c, toB: d } = a, f, h, p, g;
      if (r && r.range.fromB < d && r.range.toB > c) {
        let w = sd.build(this.view.state.doc, c, r.range.fromB, this.decorations, this.dynamicDecorationMap), C = sd.build(this.view.state.doc, r.range.toB, d, this.decorations, this.dynamicDecorationMap);
        h = w.breakAtStart, p = w.openStart, g = C.openEnd;
        let y = this.compositionView(r);
        C.breakAtStart ? y.breakAfter = 1 : C.content.length && y.merge(y.length, y.length, C.content[0], !1, C.openStart, 0) && (y.breakAfter = C.content[0].breakAfter, C.content.shift()), w.content.length && y.merge(0, 0, w.content[w.content.length - 1], !0, 0, w.openEnd) && w.content.pop(), f = w.content.concat(y).concat(C.content);
      } else
        ({ content: f, breakAtStart: h, openStart: p, openEnd: g } = sd.build(this.view.state.doc, c, d, this.decorations, this.dynamicDecorationMap));
      let { i: m, off: v } = o.findPos(u, 1), { i: b, off: x } = o.findPos(l, -1);
      tk(this, b, x, m, v, f, h, p, g);
    }
    r && this.fixCompositionDOM(r);
  }
  compositionView(t) {
    let n = new Oo(t.text.nodeValue);
    n.flags |= 8;
    for (let { deco: i } of t.marks)
      n = new _s(i, [n], n.length);
    let r = new ur();
    return r.append(n, 0), r;
  }
  fixCompositionDOM(t) {
    let n = (o, s) => {
      s.flags |= 8 | (s.children.some(
        (l) => l.flags & 7
        /* ViewFlag.Dirty */
      ) ? 1 : 0), this.markedForComposition.add(s);
      let a = Cn.get(o);
      a && a != s && (a.dom = null), s.setDOM(o);
    }, r = this.childPos(t.range.fromB, 1), i = this.children[r.i];
    n(t.line, i);
    for (let o = t.marks.length - 1; o >= -1; o--)
      r = i.childPos(r.off, 1), i = i.children[r.i], n(o >= 0 ? t.marks[o].node : t.text, i);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(t = !1, n = !1) {
    (t || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let r = this.view.root.activeElement, i = r == this.dom, o = !i && dp(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));
    if (!(i || n || o))
      return;
    let s = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), u = a.empty ? l : this.moveToLine(this.domAtPos(a.head));
    if (ft.gecko && a.empty && !this.hasComposition && ZQ(l)) {
      let d = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(d, l.node.childNodes[l.offset] || null)), l = u = new Gr(d, 0), s = !0;
    }
    let c = this.view.observer.selectionRange;
    (s || !c.focusNode || (!od(l.node, l.offset, c.anchorNode, c.anchorOffset) || !od(u.node, u.offset, c.focusNode, c.focusOffset)) && !this.suppressWidgetCursorChange(c, a)) && (this.view.observer.ignore(() => {
      ft.android && ft.chrome && this.dom.contains(c.focusNode) && rZ(c.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let d = Kp(this.view.root);
      if (d)
        if (a.empty) {
          if (ft.gecko) {
            let f = eZ(l.node, l.offset);
            if (f && f != 3) {
              let h = (f == 1 ? ZI : JI)(l.node, l.offset);
              h && (l = new Gr(h.node, h.offset));
            }
          }
          d.collapse(l.node, l.offset), a.bidiLevel != null && d.caretBidiLevel !== void 0 && (d.caretBidiLevel = a.bidiLevel);
        } else if (d.extend) {
          d.collapse(l.node, l.offset);
          try {
            d.extend(u.node, u.offset);
          } catch {
          }
        } else {
          let f = document.createRange();
          a.anchor > a.head && ([l, u] = [u, l]), f.setEnd(u.node, u.offset), f.setStart(l.node, l.offset), d.removeAllRanges(), d.addRange(f);
        }
      o && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());
    }), this.view.observer.setSelectionRange(l, u)), this.impreciseAnchor = l.precise ? null : new Gr(c.anchorNode, c.anchorOffset), this.impreciseHead = u.precise ? null : new Gr(c.focusNode, c.focusOffset);
  }
  // If a zero-length widget is inserted next to the cursor during
  // composition, avoid moving it across it and disrupting the
  // composition.
  suppressWidgetCursorChange(t, n) {
    return this.hasComposition && n.empty && od(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset) && this.posFromDOM(t.focusNode, t.focusOffset) == n.head;
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: t } = this, n = t.state.selection.main, r = Kp(t.root), { anchorNode: i, anchorOffset: o } = t.observer.selectionRange;
    if (!r || !n.empty || !n.assoc || !r.modify)
      return;
    let s = ur.find(this, n.head);
    if (!s)
      return;
    let a = s.posAtStart;
    if (n.head == a || n.head == a + s.length)
      return;
    let l = this.coordsAt(n.head, -1), u = this.coordsAt(n.head, 1);
    if (!l || !u || l.bottom > u.top)
      return;
    let c = this.domAtPos(n.head + n.assoc);
    r.collapse(c.node, c.offset), r.modify("move", n.assoc < 0 ? "forward" : "backward", "lineboundary"), t.observer.readSelectionRange();
    let d = t.observer.selectionRange;
    t.docView.posFromDOM(d.anchorNode, d.anchorOffset) != n.from && r.collapse(i, o);
  }
  // If a position is in/near a block widget, move it to a nearby text
  // line, since we don't want the cursor inside a block widget.
  moveToLine(t) {
    let n = this.dom, r;
    if (t.node != n)
      return t;
    for (let i = t.offset; !r && i < n.childNodes.length; i++) {
      let o = Cn.get(n.childNodes[i]);
      o instanceof ur && (r = o.domAtPos(0));
    }
    for (let i = t.offset - 1; !r && i >= 0; i--) {
      let o = Cn.get(n.childNodes[i]);
      o instanceof ur && (r = o.domAtPos(o.length));
    }
    return r ? new Gr(r.node, r.offset, !0) : t;
  }
  nearest(t) {
    for (let n = t; n; ) {
      let r = Cn.get(n);
      if (r && r.rootView == this)
        return r;
      n = n.parentNode;
    }
    return null;
  }
  posFromDOM(t, n) {
    let r = this.nearest(t);
    if (!r)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return r.localPosFromDOM(t, n) + r.posAtStart;
  }
  domAtPos(t) {
    let { i: n, off: r } = this.childCursor().findPos(t, -1);
    for (; n < this.children.length - 1; ) {
      let i = this.children[n];
      if (r < i.length || i instanceof ur)
        break;
      n++, r = 0;
    }
    return this.children[n].domAtPos(r);
  }
  coordsAt(t, n) {
    let r = null, i = 0;
    for (let o = this.length, s = this.children.length - 1; s >= 0; s--) {
      let a = this.children[s], l = o - a.breakAfter, u = l - a.length;
      if (l < t)
        break;
      u <= t && (u < t || a.covers(-1)) && (l > t || a.covers(1)) && (!r || a instanceof ur && !(r instanceof ur && n >= 0)) && (r = a, i = u), o = u;
    }
    return r ? r.coordsAt(t - i, n) : null;
  }
  coordsForChar(t) {
    let { i: n, off: r } = this.childPos(t, 1), i = this.children[n];
    if (!(i instanceof ur))
      return null;
    for (; i.children.length; ) {
      let { i: a, off: l } = i.childPos(r, 1);
      for (; ; a++) {
        if (a == i.children.length)
          return null;
        if ((i = i.children[a]).length)
          break;
      }
      r = l;
    }
    if (!(i instanceof Oo))
      return null;
    let o = gs(i.text, r);
    if (o == r)
      return null;
    let s = ol(i.dom, r, o).getClientRects();
    for (let a = 0; a < s.length; a++) {
      let l = s[a];
      if (a == s.length - 1 || l.top < l.bottom && l.left < l.right)
        return l;
    }
    return null;
  }
  measureVisibleLineHeights(t) {
    let n = [], { from: r, to: i } = t, o = this.view.contentDOM.clientWidth, s = o > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == ar.LTR;
    for (let u = 0, c = 0; c < this.children.length; c++) {
      let d = this.children[c], f = u + d.length;
      if (f > i)
        break;
      if (u >= r) {
        let h = d.dom.getBoundingClientRect();
        if (n.push(h.height), s) {
          let p = d.dom.lastChild, g = p ? Fc(p) : [];
          if (g.length) {
            let m = g[g.length - 1], v = l ? m.right - h.left : h.right - m.left;
            v > a && (a = v, this.minWidth = o, this.minWidthFrom = u, this.minWidthTo = f);
          }
        }
      }
      u = f + d.breakAfter;
    }
    return n;
  }
  textDirectionAt(t) {
    let { i: n } = this.childPos(t, 1);
    return getComputedStyle(this.children[n].dom).direction == "rtl" ? ar.RTL : ar.LTR;
  }
  measureTextSize() {
    for (let o of this.children)
      if (o instanceof ur) {
        let s = o.measureTextSize();
        if (s)
          return s;
      }
    let t = document.createElement("div"), n, r, i;
    return t.className = "cm-line", t.style.width = "99999px", t.style.position = "absolute", t.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(t);
      let o = Fc(t.firstChild)[0];
      n = t.getBoundingClientRect().height, r = o ? o.width / 27 : 7, i = o ? o.height : n, t.remove();
    }), { lineHeight: n, charWidth: r, textHeight: i };
  }
  childCursor(t = this.length) {
    let n = this.children.length;
    return n && (t -= this.children[--n].length), new ek(this.children, t, n);
  }
  computeBlockGapDeco() {
    let t = [], n = this.view.viewState;
    for (let r = 0, i = 0; ; i++) {
      let o = i == n.viewports.length ? null : n.viewports[i], s = o ? o.from - 1 : this.length;
      if (s > r) {
        let a = (n.lineBlockAt(s).bottom - n.lineBlockAt(r).top) / this.view.scaleY;
        t.push(dr.replace({
          widget: new K$(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(r, s));
      }
      if (!o)
        break;
      r = o.to + 1;
    }
    return dr.set(t);
  }
  updateDeco() {
    let t = 0, n = this.view.state.facet(Fd).map((o) => (this.dynamicDecorationMap[t++] = typeof o == "function") ? o(this.view) : o), r = !1, i = this.view.state.facet(xk).map((o, s) => {
      let a = typeof o == "function";
      return a && (r = !0), a ? o(this.view) : o;
    });
    for (i.length && (this.dynamicDecorationMap[t++] = r, n.push(En.join(i))), this.decorations = [
      ...n,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ]; t < this.decorations.length; )
      this.dynamicDecorationMap[t++] = !1;
    return this.decorations;
  }
  scrollIntoView(t) {
    if (t.isSnapshot) {
      let u = this.view.viewState.lineBlockAt(t.range.head);
      this.view.scrollDOM.scrollTop = u.top - t.yMargin, this.view.scrollDOM.scrollLeft = t.xMargin;
      return;
    }
    for (let u of this.view.state.facet(Ck))
      try {
        if (u(this.view, t.range, t))
          return !0;
      } catch (c) {
        bi(this.view.state, c, "scroll handler");
      }
    let { range: n } = t, r = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), i;
    if (!r)
      return;
    !n.empty && (i = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (r = {
      left: Math.min(r.left, i.left),
      top: Math.min(r.top, i.top),
      right: Math.max(r.right, i.right),
      bottom: Math.max(r.bottom, i.bottom)
    });
    let o = Ok(this.view), s = {
      left: r.left - o.left,
      top: r.top - o.top,
      right: r.right + o.right,
      bottom: r.bottom + o.bottom
    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;
    RQ(this.view.scrollDOM, s, n.head < n.anchor ? -1 : 1, t.x, t.y, Math.max(Math.min(t.xMargin, a), -a), Math.max(Math.min(t.yMargin, l), -l), this.view.textDirection == ar.LTR);
  }
}
function ZQ(e) {
  return e.node.nodeType == 1 && e.node.firstChild && (e.offset == 0 || e.node.childNodes[e.offset - 1].contentEditable == "false") && (e.offset == e.node.childNodes.length || e.node.childNodes[e.offset].contentEditable == "false");
}
class K$ extends vm {
  constructor(t) {
    super(), this.height = t;
  }
  toDOM() {
    let t = document.createElement("div");
    return t.className = "cm-gap", this.updateDOM(t), t;
  }
  eq(t) {
    return t.height == this.height;
  }
  updateDOM(t) {
    return t.style.height = this.height + "px", !0;
  }
  get editable() {
    return !0;
  }
  get estimatedHeight() {
    return this.height;
  }
  ignoreEvent() {
    return !1;
  }
}
function Ak(e, t) {
  let n = e.observer.selectionRange;
  if (!n.focusNode)
    return null;
  let r = ZI(n.focusNode, n.focusOffset), i = JI(n.focusNode, n.focusOffset), o = r || i;
  if (i && r && i.node != r.node) {
    let a = Cn.get(i.node);
    if (!a || a instanceof Oo && a.text != i.node.nodeValue)
      o = i;
    else if (e.docView.lastCompositionAfterCursor) {
      let l = Cn.get(r.node);
      !l || l instanceof Oo && l.text != r.node.nodeValue || (o = i);
    }
  }
  if (e.docView.lastCompositionAfterCursor = o != r, !o)
    return null;
  let s = t - o.offset;
  return { from: s, to: s + o.node.nodeValue.length, node: o.node };
}
function JQ(e, t, n) {
  let r = Ak(e, n);
  if (!r)
    return null;
  let { node: i, from: o, to: s } = r, a = i.nodeValue;
  if (/[\n\r]/.test(a) || e.state.doc.sliceString(r.from, r.to) != a)
    return null;
  let l = t.invertedDesc, u = new eo(l.mapPos(o), l.mapPos(s), o, s), c = [];
  for (let d = i.parentNode; ; d = d.parentNode) {
    let f = Cn.get(d);
    if (f instanceof _s)
      c.push({ node: d, deco: f.mark });
    else {
      if (f instanceof ur || d.nodeName == "DIV" && d.parentNode == e.contentDOM)
        return { range: u, text: i, marks: c, line: d };
      if (d != e.contentDOM)
        c.push({ node: d, deco: new _f({
          inclusive: !0,
          attributes: BQ(d),
          tagName: d.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function eZ(e, t) {
  return e.nodeType != 1 ? 0 : (t && e.childNodes[t - 1].contentEditable == "false" ? 1 : 0) | (t < e.childNodes.length && e.childNodes[t].contentEditable == "false" ? 2 : 0);
}
let tZ = class {
  constructor() {
    this.changes = [];
  }
  compareRange(t, n) {
    my(t, n, this.changes);
  }
  comparePoint(t, n) {
    my(t, n, this.changes);
  }
};
function nZ(e, t, n) {
  let r = new tZ();
  return En.compare(e, t, n, r), r.changes;
}
function rZ(e, t) {
  for (let n = e; n && n != t; n = n.assignedSlot || n.parentNode)
    if (n.nodeType == 1 && n.contentEditable == "false")
      return !0;
  return !1;
}
function iZ(e, t) {
  let n = !1;
  return t && e.iterChangedRanges((r, i) => {
    r < t.to && i > t.from && (n = !0);
  }), n;
}
function oZ(e, t, n = 1) {
  let r = e.charCategorizer(t), i = e.doc.lineAt(t), o = t - i.from;
  if (i.length == 0)
    return st.cursor(t);
  o == 0 ? n = 1 : o == i.length && (n = -1);
  let s = o, a = o;
  n < 0 ? s = gs(i.text, o, !1) : a = gs(i.text, o);
  let l = r(i.text.slice(s, a));
  for (; s > 0; ) {
    let u = gs(i.text, s, !1);
    if (r(i.text.slice(u, s)) != l)
      break;
    s = u;
  }
  for (; a < i.length; ) {
    let u = gs(i.text, a);
    if (r(i.text.slice(a, u)) != l)
      break;
    a = u;
  }
  return st.range(s + i.from, a + i.from);
}
function sZ(e, t) {
  return t.left > e ? t.left - e : Math.max(0, e - t.right);
}
function aZ(e, t) {
  return t.top > e ? t.top - e : Math.max(0, e - t.bottom);
}
function Lv(e, t) {
  return e.top < t.bottom - 1 && e.bottom > t.top + 1;
}
function X$(e, t) {
  return t < e.top ? { top: t, left: e.left, right: e.right, bottom: e.bottom } : e;
}
function Y$(e, t) {
  return t > e.bottom ? { top: e.top, left: e.left, right: e.right, bottom: t } : e;
}
function Cy(e, t, n) {
  let r, i, o, s, a = !1, l, u, c, d;
  for (let p = e.firstChild; p; p = p.nextSibling) {
    let g = Fc(p);
    for (let m = 0; m < g.length; m++) {
      let v = g[m];
      i && Lv(i, v) && (v = X$(Y$(v, i.bottom), i.top));
      let b = sZ(t, v), x = aZ(n, v);
      if (b == 0 && x == 0)
        return p.nodeType == 3 ? q$(p, t, n) : Cy(p, t, n);
      if (!r || s > x || s == x && o > b) {
        r = p, i = v, o = b, s = x;
        let w = x ? n < v.top ? -1 : 1 : b ? t < v.left ? -1 : 1 : 0;
        a = !w || (w > 0 ? m < g.length - 1 : m > 0);
      }
      b == 0 ? n > v.bottom && (!c || c.bottom < v.bottom) ? (l = p, c = v) : n < v.top && (!d || d.top > v.top) && (u = p, d = v) : c && Lv(c, v) ? c = Y$(c, v.bottom) : d && Lv(d, v) && (d = X$(d, v.top));
    }
  }
  if (c && c.bottom >= n ? (r = l, i = c) : d && d.top <= n && (r = u, i = d), !r)
    return { node: e, offset: 0 };
  let f = Math.max(i.left, Math.min(i.right, t));
  if (r.nodeType == 3)
    return q$(r, f, n);
  if (a && r.contentEditable != "false")
    return Cy(r, f, n);
  let h = Array.prototype.indexOf.call(e.childNodes, r) + (t >= (i.left + i.right) / 2 ? 1 : 0);
  return { node: e, offset: h };
}
function q$(e, t, n) {
  let r = e.nodeValue.length, i = -1, o = 1e9, s = 0;
  for (let a = 0; a < r; a++) {
    let l = ol(e, a, a + 1).getClientRects();
    for (let u = 0; u < l.length; u++) {
      let c = l[u];
      if (c.top == c.bottom)
        continue;
      s || (s = t - c.left);
      let d = (c.top > n ? c.top - n : n - c.bottom) - 1;
      if (c.left - 1 <= t && c.right + 1 >= t && d < o) {
        let f = t >= (c.left + c.right) / 2, h = f;
        if ((ft.chrome || ft.gecko) && ol(e, a).getBoundingClientRect().left == c.right && (h = !f), d <= 0)
          return { node: e, offset: a + (h ? 1 : 0) };
        i = a + (h ? 1 : 0), o = d;
      }
    }
  }
  return { node: e, offset: i > -1 ? i : s > 0 ? e.nodeValue.length : 0 };
}
function Dk(e, t, n, r = -1) {
  var i, o;
  let s = e.contentDOM.getBoundingClientRect(), a = s.top + e.viewState.paddingTop, l, { docHeight: u } = e.viewState, { x: c, y: d } = t, f = d - a;
  if (f < 0)
    return 0;
  if (f > u)
    return e.state.doc.length;
  for (let w = e.viewState.heightOracle.textHeight / 2, C = !1; l = e.elementAtHeight(f), l.type != ys.Text; )
    for (; f = r > 0 ? l.bottom + w : l.top - w, !(f >= 0 && f <= u); ) {
      if (C)
        return n ? null : 0;
      C = !0, r = -r;
    }
  d = a + f;
  let h = l.from;
  if (h < e.viewport.from)
    return e.viewport.from == 0 ? 0 : n ? null : Q$(e, s, l, c, d);
  if (h > e.viewport.to)
    return e.viewport.to == e.state.doc.length ? e.state.doc.length : n ? null : Q$(e, s, l, c, d);
  let p = e.dom.ownerDocument, g = e.root.elementFromPoint ? e.root : p, m = g.elementFromPoint(c, d);
  m && !e.contentDOM.contains(m) && (m = null), m || (c = Math.max(s.left + 1, Math.min(s.right - 1, c)), m = g.elementFromPoint(c, d), m && !e.contentDOM.contains(m) && (m = null));
  let v, b = -1;
  if (m && ((i = e.docView.nearest(m)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let w = p.caretPositionFromPoint(c, d);
      w && ({ offsetNode: v, offset: b } = w);
    } else if (p.caretRangeFromPoint) {
      let w = p.caretRangeFromPoint(c, d);
      w && ({ startContainer: v, startOffset: b } = w, (!e.contentDOM.contains(v) || ft.safari && lZ(v, b, c) || ft.chrome && cZ(v, b, c)) && (v = void 0));
    }
  }
  if (!v || !e.docView.dom.contains(v)) {
    let w = ur.find(e.docView, h);
    if (!w)
      return f > l.top + l.height / 2 ? l.to : l.from;
    ({ node: v, offset: b } = Cy(w.dom, c, d));
  }
  let x = e.docView.nearest(v);
  if (!x)
    return null;
  if (x.isWidget && ((o = x.dom) === null || o === void 0 ? void 0 : o.nodeType) == 1) {
    let w = x.dom.getBoundingClientRect();
    return t.y < w.top || t.y <= w.bottom && t.x <= (w.left + w.right) / 2 ? x.posAtStart : x.posAtEnd;
  } else
    return x.localPosFromDOM(v, b) + x.posAtStart;
}
function Q$(e, t, n, r, i) {
  let o = Math.round((r - t.left) * e.defaultCharacterWidth);
  if (e.lineWrapping && n.height > e.defaultLineHeight * 1.5) {
    let a = e.viewState.heightOracle.textHeight, l = Math.floor((i - n.top - (e.defaultLineHeight - a) * 0.5) / a);
    o += l * e.viewState.heightOracle.lineLength;
  }
  let s = e.state.sliceDoc(n.from, n.to);
  return n.from + EQ(s, o, e.state.tabSize);
}
function lZ(e, t, n) {
  let r;
  if (e.nodeType != 3 || t != (r = e.nodeValue.length))
    return !1;
  for (let i = e.nextSibling; i; i = i.nextSibling)
    if (i.nodeType != 1 || i.nodeName != "BR")
      return !1;
  return ol(e, r - 1, r).getBoundingClientRect().left > n;
}
function cZ(e, t, n) {
  if (t != 0)
    return !1;
  for (let i = e; ; ) {
    let o = i.parentNode;
    if (!o || o.nodeType != 1 || o.firstChild != i)
      return !1;
    if (o.classList.contains("cm-line"))
      break;
    i = o;
  }
  let r = e.nodeType == 1 ? e.getBoundingClientRect() : ol(e, 0, Math.max(e.nodeValue.length, 1)).getBoundingClientRect();
  return n - r.left > 5;
}
function uZ(e, t) {
  let n = e.lineBlockAt(t);
  if (Array.isArray(n.type)) {
    for (let r of n.type)
      if (r.to > t || r.to == t && (r.to == n.to || r.type == ys.Text))
        return r;
  }
  return n;
}
function dZ(e, t, n, r) {
  let i = uZ(e, t.head), o = !r || i.type != ys.Text || !(e.lineWrapping || i.widgetLineBreaks) ? null : e.coordsAtPos(t.assoc < 0 && t.head > i.from ? t.head - 1 : t.head);
  if (o) {
    let s = e.dom.getBoundingClientRect(), a = e.textDirectionAt(i.from), l = e.posAtCoords({
      x: n == (a == ar.LTR) ? s.right - 1 : s.left + 1,
      y: (o.top + o.bottom) / 2
    });
    if (l != null)
      return st.cursor(l, n ? -1 : 1);
  }
  return st.cursor(n ? i.to : i.from, n ? -1 : 1);
}
function Z$(e, t, n, r) {
  let i = e.state.doc.lineAt(t.head), o = e.bidiSpans(i), s = e.textDirectionAt(i.from);
  for (let a = t, l = null; ; ) {
    let u = XQ(i, o, s, a, n), c = hk;
    if (!u) {
      if (i.number == (n ? e.state.doc.lines : 1))
        return a;
      c = `
`, i = e.state.doc.line(i.number + (n ? 1 : -1)), o = e.bidiSpans(i), u = e.visualLineSide(i, !n);
    }
    if (l) {
      if (!l(c))
        return a;
    } else {
      if (!r)
        return u;
      l = r(c);
    }
    a = u;
  }
}
function fZ(e, t, n) {
  let r = e.state.charCategorizer(t), i = r(n);
  return (o) => {
    let s = r(o);
    return i == Qi.Space && (i = s), i == s;
  };
}
function hZ(e, t, n, r) {
  let i = t.head, o = n ? 1 : -1;
  if (i == (n ? e.state.doc.length : 0))
    return st.cursor(i, t.assoc);
  let s = t.goalColumn, a, l = e.contentDOM.getBoundingClientRect(), u = e.coordsAtPos(i, t.assoc || -1), c = e.documentTop;
  if (u)
    s == null && (s = u.left - l.left), a = o < 0 ? u.top : u.bottom;
  else {
    let h = e.viewState.lineBlockAt(i);
    s == null && (s = Math.min(l.right - l.left, e.defaultCharacterWidth * (i - h.from))), a = (o < 0 ? h.top : h.bottom) + c;
  }
  let d = l.left + s, f = r ?? e.viewState.heightOracle.textHeight >> 1;
  for (let h = 0; ; h += 10) {
    let p = a + (f + h) * o, g = Dk(e, { x: d, y: p }, !1, o);
    if (p < l.top || p > l.bottom || (o < 0 ? g < i : g > i)) {
      let m = e.docView.coordsForChar(g), v = !m || p < m.top ? -1 : 1;
      return st.cursor(g, v, void 0, s);
    }
  }
}
function fp(e, t, n) {
  for (; ; ) {
    let r = 0;
    for (let i of e)
      i.between(t - 1, t + 1, (o, s, a) => {
        if (t > o && t < s) {
          let l = r || n || (t - o < s - t ? -1 : 1);
          t = l < 0 ? o : s, r = l;
        }
      });
    if (!r)
      return t;
  }
}
function Fv(e, t, n) {
  let r = fp(e.state.facet(oC).map((i) => i(e)), n.from, t.head > n.from ? -1 : 1);
  return r == n.from ? n : st.cursor(r, r < n.from ? 1 : -1);
}
class pZ {
  setSelectionOrigin(t) {
    this.lastSelectionOrigin = t, this.lastSelectionTime = Date.now();
  }
  constructor(t) {
    this.view = t, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = t.hasFocus, ft.safari && t.contentDOM.addEventListener("input", () => null), ft.gecko && TZ(t.contentDOM.ownerDocument);
  }
  handleEvent(t) {
    !SZ(this.view, t) || this.ignoreDuringComposition(t) || t.type == "keydown" && this.keydown(t) || this.runHandlers(t.type, t);
  }
  runHandlers(t, n) {
    let r = this.handlers[t];
    if (r) {
      for (let i of r.observers)
        i(this.view, n);
      for (let i of r.handlers) {
        if (n.defaultPrevented)
          break;
        if (i(this.view, n)) {
          n.preventDefault();
          break;
        }
      }
    }
  }
  ensureHandlers(t) {
    let n = gZ(t), r = this.handlers, i = this.view.contentDOM;
    for (let o in n)
      if (o != "scroll") {
        let s = !n[o].handlers.length, a = r[o];
        a && s != !a.handlers.length && (i.removeEventListener(o, this.handleEvent), a = null), a || i.addEventListener(o, this.handleEvent, { passive: s });
      }
    for (let o in r)
      o != "scroll" && !n[o] && i.removeEventListener(o, this.handleEvent);
    this.handlers = n;
  }
  keydown(t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (t.keyCode != 27 && Tk.indexOf(t.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), ft.android && ft.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return this.view.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let n;
    return ft.ios && !t.synthetic && !t.altKey && !t.metaKey && ((n = _k.find((r) => r.keyCode == t.keyCode)) && !t.ctrlKey || mZ.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = n || t, setTimeout(() => this.flushIOSKey(), 250), !0) : (t.keyCode != 229 && this.view.observer.forceFlush(), !1);
  }
  flushIOSKey(t) {
    let n = this.pendingIOSKey;
    return !n || n.key == "Enter" && t && t.from < t.to && /^\S+$/.test(t.insert.toString()) ? !1 : (this.pendingIOSKey = void 0, vc(this.view.contentDOM, n.key, n.keyCode, n instanceof KeyboardEvent ? n : void 0));
  }
  ignoreDuringComposition(t) {
    return /^key/.test(t.type) ? this.composing > 0 ? !0 : ft.safari && !ft.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  startMouseSelection(t) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t;
  }
  update(t) {
    this.mouseSelection && this.mouseSelection.update(t), this.draggedContent && t.docChanged && (this.draggedContent = this.draggedContent.map(t.changes)), t.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
function J$(e, t) {
  return (n, r) => {
    try {
      return t.call(e, r, n);
    } catch (i) {
      bi(n.state, i);
    }
  };
}
function gZ(e) {
  let t = /* @__PURE__ */ Object.create(null);
  function n(r) {
    return t[r] || (t[r] = { observers: [], handlers: [] });
  }
  for (let r of e) {
    let i = r.spec;
    if (i && i.domEventHandlers)
      for (let o in i.domEventHandlers) {
        let s = i.domEventHandlers[o];
        s && n(o).handlers.push(J$(r.value, s));
      }
    if (i && i.domEventObservers)
      for (let o in i.domEventObservers) {
        let s = i.domEventObservers[o];
        s && n(o).observers.push(J$(r.value, s));
      }
  }
  for (let r in Do)
    n(r).handlers.push(Do[r]);
  for (let r in oo)
    n(r).observers.push(oo[r]);
  return t;
}
const _k = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], mZ = "dthko", Tk = [16, 17, 18, 20, 91, 92, 224, 225], hh = 6;
function ph(e) {
  return Math.max(0, e) * 0.7 + 8;
}
function vZ(e, t) {
  return Math.max(Math.abs(e.clientX - t.clientX), Math.abs(e.clientY - t.clientY));
}
class bZ {
  constructor(t, n, r, i) {
    this.view = t, this.startEvent = n, this.style = r, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = n, this.scrollParent = MQ(t.contentDOM), this.atoms = t.state.facet(oC).map((s) => s(t));
    let o = t.contentDOM.ownerDocument;
    o.addEventListener("mousemove", this.move = this.move.bind(this)), o.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = t.state.facet(hn.allowMultipleSelections) && yZ(t, n), this.dragging = CZ(t, n) && kk(n) == 1 ? null : !1;
  }
  start(t) {
    this.dragging === !1 && this.select(t);
  }
  move(t) {
    var n;
    if (t.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && vZ(this.startEvent, t) < 10)
      return;
    this.select(this.lastEvent = t);
    let r = 0, i = 0, o = ((n = this.scrollParent) === null || n === void 0 ? void 0 : n.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, s = Ok(this.view);
    t.clientX - s.left <= o.left + hh ? r = -ph(o.left - t.clientX) : t.clientX + s.right >= o.right - hh && (r = ph(t.clientX - o.right)), t.clientY - s.top <= o.top + hh ? i = -ph(o.top - t.clientY) : t.clientY + s.bottom >= o.bottom - hh && (i = ph(t.clientY - o.bottom)), this.setScrollSpeed(r, i);
  }
  up(t) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || t.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let t = this.view.contentDOM.ownerDocument;
    t.removeEventListener("mousemove", this.move), t.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;
  }
  setScrollSpeed(t, n) {
    this.scrollSpeed = { x: t, y: n }, t || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(t) {
    let n = null;
    for (let r = 0; r < t.ranges.length; r++) {
      let i = t.ranges[r], o = null;
      if (i.empty) {
        let s = fp(this.atoms, i.from, 0);
        s != i.from && (o = st.cursor(s, -1));
      } else {
        let s = fp(this.atoms, i.from, -1), a = fp(this.atoms, i.to, 1);
        (s != i.from || a != i.to) && (o = st.range(i.from == i.anchor ? s : a, i.from == i.head ? s : a));
      }
      o && (n || (n = t.ranges.slice()), n[r] = o);
    }
    return n ? st.create(n, t.mainIndex) : t;
  }
  select(t) {
    let { view: n } = this, r = this.skipAtoms(this.style.get(t, this.extend, this.multiple));
    (this.mustSelect || !r.eq(n.state.selection, this.dragging === !1)) && this.view.dispatch({
      selection: r,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(t) {
    this.style.update(t) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function yZ(e, t) {
  let n = e.state.facet(pk);
  return n.length ? n[0](t) : ft.mac ? t.metaKey : t.ctrlKey;
}
function wZ(e, t) {
  let n = e.state.facet(gk);
  return n.length ? n[0](t) : ft.mac ? !t.altKey : !t.ctrlKey;
}
function CZ(e, t) {
  let { main: n } = e.state.selection;
  if (n.empty)
    return !1;
  let r = Kp(e.root);
  if (!r || r.rangeCount == 0)
    return !0;
  let i = r.getRangeAt(0).getClientRects();
  for (let o = 0; o < i.length; o++) {
    let s = i[o];
    if (s.left <= t.clientX && s.right >= t.clientX && s.top <= t.clientY && s.bottom >= t.clientY)
      return !0;
  }
  return !1;
}
function SZ(e, t) {
  if (!t.bubbles)
    return !0;
  if (t.defaultPrevented)
    return !1;
  for (let n = t.target, r; n != e.contentDOM; n = n.parentNode)
    if (!n || n.nodeType == 11 || (r = Cn.get(n)) && r.ignoreEvent(t))
      return !1;
  return !0;
}
const Do = /* @__PURE__ */ Object.create(null), oo = /* @__PURE__ */ Object.create(null), Rk = ft.ie && ft.ie_version < 15 || ft.ios && ft.webkit_version < 604;
function xZ(e) {
  let t = e.dom.parentNode;
  if (!t)
    return;
  let n = t.appendChild(document.createElement("textarea"));
  n.style.cssText = "position: fixed; left: -10000px; top: 10px", n.focus(), setTimeout(() => {
    e.focus(), n.remove(), Mk(e, n.value);
  }, 50);
}
function Mk(e, t) {
  let { state: n } = e, r, i = 1, o = n.toText(t), s = o.lines == n.selection.ranges.length;
  if (Sy != null && n.selection.ranges.every((l) => l.empty) && Sy == o.toString()) {
    let l = -1;
    r = n.changeByRange((u) => {
      let c = n.doc.lineAt(u.from);
      if (c.from == l)
        return { range: u };
      l = c.from;
      let d = n.toText((s ? o.line(i++).text : t) + n.lineBreak);
      return {
        changes: { from: c.from, insert: d },
        range: st.cursor(u.from + d.length)
      };
    });
  } else
    s ? r = n.changeByRange((l) => {
      let u = o.line(i++);
      return {
        changes: { from: l.from, to: l.to, insert: u.text },
        range: st.cursor(l.from + u.length)
      };
    }) : r = n.replaceSelection(o);
  e.dispatch(r, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
oo.scroll = (e) => {
  e.inputState.lastScrollTop = e.scrollDOM.scrollTop, e.inputState.lastScrollLeft = e.scrollDOM.scrollLeft;
};
Do.keydown = (e, t) => (e.inputState.setSelectionOrigin("select"), t.keyCode == 27 && (e.inputState.lastEscPress = Date.now()), !1);
oo.touchstart = (e, t) => {
  e.inputState.lastTouchTime = Date.now(), e.inputState.setSelectionOrigin("select.pointer");
};
oo.touchmove = (e) => {
  e.inputState.setSelectionOrigin("select.pointer");
};
Do.mousedown = (e, t) => {
  if (e.observer.flush(), e.inputState.lastTouchTime > Date.now() - 2e3)
    return !1;
  let n = null;
  for (let r of e.state.facet(mk))
    if (n = r(e, t), n)
      break;
  if (!n && t.button == 0 && (n = OZ(e, t)), n) {
    let r = !e.hasFocus;
    e.inputState.startMouseSelection(new bZ(e, t, n, r)), r && e.observer.ignore(() => YI(e.contentDOM));
    let i = e.inputState.mouseSelection;
    if (i)
      return i.start(t), i.dragging === !1;
  }
  return !1;
};
function eO(e, t, n, r) {
  if (r == 1)
    return st.cursor(t, n);
  if (r == 2)
    return oZ(e.state, t, n);
  {
    let i = ur.find(e.docView, t), o = e.state.doc.lineAt(i ? i.posAtEnd : t), s = i ? i.posAtStart : o.from, a = i ? i.posAtEnd : o.to;
    return a < e.state.doc.length && a == o.to && a++, st.range(s, a);
  }
}
let Ik = (e, t) => e >= t.top && e <= t.bottom, tO = (e, t, n) => Ik(t, n) && e >= n.left && e <= n.right;
function EZ(e, t, n, r) {
  let i = ur.find(e.docView, t);
  if (!i)
    return 1;
  let o = t - i.posAtStart;
  if (o == 0)
    return 1;
  if (o == i.length)
    return -1;
  let s = i.coordsAt(o, -1);
  if (s && tO(n, r, s))
    return -1;
  let a = i.coordsAt(o, 1);
  return a && tO(n, r, a) ? 1 : s && Ik(r, s) ? -1 : 1;
}
function nO(e, t) {
  let n = e.posAtCoords({ x: t.clientX, y: t.clientY }, !1);
  return { pos: n, bias: EZ(e, n, t.clientX, t.clientY) };
}
const $Z = ft.ie && ft.ie_version <= 11;
let rO = null, iO = 0, oO = 0;
function kk(e) {
  if (!$Z)
    return e.detail;
  let t = rO, n = oO;
  return rO = e, oO = Date.now(), iO = !t || n > Date.now() - 400 && Math.abs(t.clientX - e.clientX) < 2 && Math.abs(t.clientY - e.clientY) < 2 ? (iO + 1) % 3 : 1;
}
function OZ(e, t) {
  let n = nO(e, t), r = kk(t), i = e.state.selection;
  return {
    update(o) {
      o.docChanged && (n.pos = o.changes.mapPos(n.pos), i = i.map(o.changes));
    },
    get(o, s, a) {
      let l = nO(e, o), u, c = eO(e, l.pos, l.bias, r);
      if (n.pos != l.pos && !s) {
        let d = eO(e, n.pos, n.bias, r), f = Math.min(d.from, c.from), h = Math.max(d.to, c.to);
        c = f < c.from ? st.range(f, h) : st.range(h, f);
      }
      return s ? i.replaceRange(i.main.extend(c.from, c.to)) : a && r == 1 && i.ranges.length > 1 && (u = AZ(i, l.pos)) ? u : a ? i.addRange(c) : st.create([c]);
    }
  };
}
function AZ(e, t) {
  for (let n = 0; n < e.ranges.length; n++) {
    let { from: r, to: i } = e.ranges[n];
    if (r <= t && i >= t)
      return st.create(e.ranges.slice(0, n).concat(e.ranges.slice(n + 1)), e.mainIndex == n ? 0 : e.mainIndex - (e.mainIndex > n ? 1 : 0));
  }
  return null;
}
Do.dragstart = (e, t) => {
  let { selection: { main: n } } = e.state;
  if (t.target.draggable) {
    let i = e.docView.nearest(t.target);
    if (i && i.isWidget) {
      let o = i.posAtStart, s = o + i.length;
      (o >= n.to || s <= n.from) && (n = st.range(o, s));
    }
  }
  let { inputState: r } = e;
  return r.mouseSelection && (r.mouseSelection.dragging = !0), r.draggedContent = n, t.dataTransfer && (t.dataTransfer.setData("Text", e.state.sliceDoc(n.from, n.to)), t.dataTransfer.effectAllowed = "copyMove"), !1;
};
Do.dragend = (e) => (e.inputState.draggedContent = null, !1);
function sO(e, t, n, r) {
  if (!n)
    return;
  let i = e.posAtCoords({ x: t.clientX, y: t.clientY }, !1), { draggedContent: o } = e.inputState, s = r && o && wZ(e, t) ? { from: o.from, to: o.to } : null, a = { from: i, insert: n }, l = e.state.changes(s ? [s, a] : a);
  e.focus(), e.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(i, -1), head: l.mapPos(i, 1) },
    userEvent: s ? "move.drop" : "input.drop"
  }), e.inputState.draggedContent = null;
}
Do.drop = (e, t) => {
  if (!t.dataTransfer)
    return !1;
  if (e.state.readOnly)
    return !0;
  let n = t.dataTransfer.files;
  if (n && n.length) {
    let r = Array(n.length), i = 0, o = () => {
      ++i == n.length && sO(e, t, r.filter((s) => s != null).join(e.state.lineBreak), !1);
    };
    for (let s = 0; s < n.length; s++) {
      let a = new FileReader();
      a.onerror = o, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (r[s] = a.result), o();
      }, a.readAsText(n[s]);
    }
    return !0;
  } else {
    let r = t.dataTransfer.getData("Text");
    if (r)
      return sO(e, t, r, !0), !0;
  }
  return !1;
};
Do.paste = (e, t) => {
  if (e.state.readOnly)
    return !0;
  e.observer.flush();
  let n = Rk ? null : t.clipboardData;
  return n ? (Mk(e, n.getData("text/plain") || n.getData("text/uri-list")), !0) : (xZ(e), !1);
};
function DZ(e, t) {
  let n = e.dom.parentNode;
  if (!n)
    return;
  let r = n.appendChild(document.createElement("textarea"));
  r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.value = t, r.focus(), r.selectionEnd = t.length, r.selectionStart = 0, setTimeout(() => {
    r.remove(), e.focus();
  }, 50);
}
function _Z(e) {
  let t = [], n = [], r = !1;
  for (let i of e.selection.ranges)
    i.empty || (t.push(e.sliceDoc(i.from, i.to)), n.push(i));
  if (!t.length) {
    let i = -1;
    for (let { from: o } of e.selection.ranges) {
      let s = e.doc.lineAt(o);
      s.number > i && (t.push(s.text), n.push({ from: s.from, to: Math.min(e.doc.length, s.to + 1) })), i = s.number;
    }
    r = !0;
  }
  return { text: t.join(e.lineBreak), ranges: n, linewise: r };
}
let Sy = null;
Do.copy = Do.cut = (e, t) => {
  let { text: n, ranges: r, linewise: i } = _Z(e.state);
  if (!n && !i)
    return !1;
  Sy = i ? n : null, t.type == "cut" && !e.state.readOnly && e.dispatch({
    changes: r,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
  let o = Rk ? null : t.clipboardData;
  return o ? (o.clearData(), o.setData("text/plain", n), !0) : (DZ(e, n), !1);
};
const Pk = /* @__PURE__ */ El.define();
function Nk(e, t) {
  let n = [];
  for (let r of e.facet(yk)) {
    let i = r(e, t);
    i && n.push(i);
  }
  return n ? e.update({ effects: n, annotations: Pk.of(!0) }) : null;
}
function Lk(e) {
  setTimeout(() => {
    let t = e.hasFocus;
    if (t != e.inputState.notifiedFocused) {
      let n = Nk(e.state, t);
      n ? e.dispatch(n) : e.update([]);
    }
  }, 10);
}
oo.focus = (e) => {
  e.inputState.lastFocusTime = Date.now(), !e.scrollDOM.scrollTop && (e.inputState.lastScrollTop || e.inputState.lastScrollLeft) && (e.scrollDOM.scrollTop = e.inputState.lastScrollTop, e.scrollDOM.scrollLeft = e.inputState.lastScrollLeft), Lk(e);
};
oo.blur = (e) => {
  e.observer.clearSelectionRange(), Lk(e);
};
oo.compositionstart = oo.compositionupdate = (e) => {
  e.inputState.compositionFirstChange == null && (e.inputState.compositionFirstChange = !0), e.inputState.composing < 0 && (e.inputState.composing = 0);
};
oo.compositionend = (e) => {
  e.inputState.composing = -1, e.inputState.compositionEndedAt = Date.now(), e.inputState.compositionPendingKey = !0, e.inputState.compositionPendingChange = e.observer.pendingRecords().length > 0, e.inputState.compositionFirstChange = null, ft.chrome && ft.android ? e.observer.flushSoon() : e.inputState.compositionPendingChange ? Promise.resolve().then(() => e.observer.flush()) : setTimeout(() => {
    e.inputState.composing < 0 && e.docView.hasComposition && e.update([]);
  }, 50);
};
oo.contextmenu = (e) => {
  e.inputState.lastContextMenu = Date.now();
};
Do.beforeinput = (e, t) => {
  var n;
  let r;
  if (ft.chrome && ft.android && (r = _k.find((i) => i.inputType == t.inputType)) && (e.observer.delayAndroidKey(r.key, r.keyCode), r.key == "Backspace" || r.key == "Delete")) {
    let i = ((n = window.visualViewport) === null || n === void 0 ? void 0 : n.height) || 0;
    setTimeout(() => {
      var o;
      (((o = window.visualViewport) === null || o === void 0 ? void 0 : o.height) || 0) > i + 10 && e.hasFocus && (e.contentDOM.blur(), e.focus());
    }, 100);
  }
  return ft.ios && t.inputType == "deleteContentForward" && e.observer.flushSoon(), ft.safari && t.inputType == "insertText" && e.inputState.composing >= 0 && setTimeout(() => oo.compositionend(e, t), 20), !1;
};
const aO = /* @__PURE__ */ new Set();
function TZ(e) {
  aO.has(e) || (aO.add(e), e.addEventListener("copy", () => {
  }), e.addEventListener("cut", () => {
  }));
}
const lO = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class RZ {
  constructor(t) {
    this.lineWrapping = t, this.doc = fn.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(t, n) {
    let r = this.doc.lineAt(n).number - this.doc.lineAt(t).number + 1;
    return this.lineWrapping && (r += Math.max(0, Math.ceil((n - t - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;
  }
  heightForLine(t) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t) {
    return this.doc = t, this;
  }
  mustRefreshForWrapping(t) {
    return lO.indexOf(t) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t) {
    let n = !1;
    for (let r = 0; r < t.length; r++) {
      let i = t[r];
      i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (n = !0, this.heightSamples[Math.floor(i * 10)] = !0);
    }
    return n;
  }
  refresh(t, n, r, i, o, s) {
    let a = lO.indexOf(t) > -1, l = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = n, this.charWidth = r, this.textHeight = i, this.lineLength = o, l) {
      this.heightSamples = {};
      for (let u = 0; u < s.length; u++) {
        let c = s[u];
        c < 0 ? u++ : this.heightSamples[Math.floor(c * 10)] = !0;
      }
    }
    return l;
  }
}
class MZ {
  constructor(t, n) {
    this.from = t, this.heights = n, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Vo {
  /**
  @internal
  */
  constructor(t, n, r, i, o) {
    this.from = t, this.length = n, this.top = r, this.height = i, this._content = o;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? ys.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof pa ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(t) {
    let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(t._content) ? t._content : [t]);
    return new Vo(this.from, this.length + t.length, this.top, this.height + t.height, n);
  }
}
var Rn = /* @__PURE__ */ function(e) {
  return e[e.ByPos = 0] = "ByPos", e[e.ByHeight = 1] = "ByHeight", e[e.ByPosNoHeight = 2] = "ByPosNoHeight", e;
}(Rn || (Rn = {}));
const hp = 1e-3;
class ii {
  constructor(t, n, r = 2) {
    this.length = t, this.height = n, this.flags = r;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(t) {
    this.flags = (t ? 2 : 0) | this.flags & -3;
  }
  setHeight(t, n) {
    this.height != n && (Math.abs(this.height - n) > hp && (t.heightChanged = !0), this.height = n);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(t, n, r) {
    return ii.of(r);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(t, n) {
    n.push(this);
  }
  decomposeRight(t, n) {
    n.push(this);
  }
  applyChanges(t, n, r, i) {
    let o = this, s = r.doc;
    for (let a = i.length - 1; a >= 0; a--) {
      let { fromA: l, toA: u, fromB: c, toB: d } = i[a], f = o.lineAt(l, Rn.ByPosNoHeight, r.setDoc(n), 0, 0), h = f.to >= u ? f : o.lineAt(u, Rn.ByPosNoHeight, r, 0, 0);
      for (d += h.to - u, u = h.to; a > 0 && f.from <= i[a - 1].toA; )
        l = i[a - 1].fromA, c = i[a - 1].fromB, a--, l < f.from && (f = o.lineAt(l, Rn.ByPosNoHeight, r, 0, 0));
      c += f.from - l, l = f.from;
      let p = sC.build(r.setDoc(s), t, c, d);
      o = o.replace(l, u, p);
    }
    return o.updateHeight(r, 0);
  }
  static empty() {
    return new Ti(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(t) {
    if (t.length == 1)
      return t[0];
    let n = 0, r = t.length, i = 0, o = 0;
    for (; ; )
      if (n == r)
        if (i > o * 2) {
          let a = t[n - 1];
          a.break ? t.splice(--n, 1, a.left, null, a.right) : t.splice(--n, 1, a.left, a.right), r += 1 + a.break, i -= a.size;
        } else if (o > i * 2) {
          let a = t[r];
          a.break ? t.splice(r, 1, a.left, null, a.right) : t.splice(r, 1, a.left, a.right), r += 2 + a.break, o -= a.size;
        } else
          break;
      else if (i < o) {
        let a = t[n++];
        a && (i += a.size);
      } else {
        let a = t[--r];
        a && (o += a.size);
      }
    let s = 0;
    return t[n - 1] == null ? (s = 1, n--) : t[n] == null && (s = 1, r++), new IZ(ii.of(t.slice(0, n)), s, ii.of(t.slice(r)));
  }
}
ii.prototype.size = 1;
class Fk extends ii {
  constructor(t, n, r) {
    super(t, n), this.deco = r;
  }
  blockAt(t, n, r, i) {
    return new Vo(i, this.length, r, this.height, this.deco || 0);
  }
  lineAt(t, n, r, i, o) {
    return this.blockAt(0, r, i, o);
  }
  forEachLine(t, n, r, i, o, s) {
    t <= o + this.length && n >= o && s(this.blockAt(0, r, i, o));
  }
  updateHeight(t, n = 0, r = !1, i) {
    return i && i.from <= n && i.more && this.setHeight(t, i.heights[i.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Ti extends Fk {
  constructor(t, n) {
    super(t, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(t, n, r, i) {
    return new Vo(i, this.length, r, this.height, this.breaks);
  }
  replace(t, n, r) {
    let i = r[0];
    return r.length == 1 && (i instanceof Ti || i instanceof Ar && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof Ar ? i = new Ti(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : ii.of(r);
  }
  updateHeight(t, n = 0, r = !1, i) {
    return i && i.from <= n && i.more ? this.setHeight(t, i.heights[i.index++]) : (r || this.outdated) && this.setHeight(t, Math.max(this.widgetHeight, t.heightForLine(this.length - this.collapsed)) + this.breaks * t.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Ar extends ii {
  constructor(t) {
    super(t, 0);
  }
  heightMetrics(t, n) {
    let r = t.doc.lineAt(n).number, i = t.doc.lineAt(n + this.length).number, o = i - r + 1, s, a = 0;
    if (t.lineWrapping) {
      let l = Math.min(this.height, t.lineHeight * o);
      s = l / o, this.length > o + 1 && (a = (this.height - l) / (this.length - o - 1));
    } else
      s = this.height / o;
    return { firstLine: r, lastLine: i, perLine: s, perChar: a };
  }
  blockAt(t, n, r, i) {
    let { firstLine: o, lastLine: s, perLine: a, perChar: l } = this.heightMetrics(n, i);
    if (n.lineWrapping) {
      let u = i + (t < n.lineHeight ? 0 : Math.round(Math.max(0, Math.min(1, (t - r) / this.height)) * this.length)), c = n.doc.lineAt(u), d = a + c.length * l, f = Math.max(r, t - d / 2);
      return new Vo(c.from, c.length, f, d, 0);
    } else {
      let u = Math.max(0, Math.min(s - o, Math.floor((t - r) / a))), { from: c, length: d } = n.doc.line(o + u);
      return new Vo(c, d, r + a * u, a, 0);
    }
  }
  lineAt(t, n, r, i, o) {
    if (n == Rn.ByHeight)
      return this.blockAt(t, r, i, o);
    if (n == Rn.ByPosNoHeight) {
      let { from: h, to: p } = r.doc.lineAt(t);
      return new Vo(h, p - h, 0, 0, 0);
    }
    let { firstLine: s, perLine: a, perChar: l } = this.heightMetrics(r, o), u = r.doc.lineAt(t), c = a + u.length * l, d = u.number - s, f = i + a * d + l * (u.from - o - d);
    return new Vo(u.from, u.length, Math.max(i, Math.min(f, i + this.height - c)), c, 0);
  }
  forEachLine(t, n, r, i, o, s) {
    t = Math.max(t, o), n = Math.min(n, o + this.length);
    let { firstLine: a, perLine: l, perChar: u } = this.heightMetrics(r, o);
    for (let c = t, d = i; c <= n; ) {
      let f = r.doc.lineAt(c);
      if (c == t) {
        let p = f.number - a;
        d += l * p + u * (t - o - p);
      }
      let h = l + u * f.length;
      s(new Vo(f.from, f.length, d, h, 0)), d += h, c = f.to + 1;
    }
  }
  replace(t, n, r) {
    let i = this.length - n;
    if (i > 0) {
      let o = r[r.length - 1];
      o instanceof Ar ? r[r.length - 1] = new Ar(o.length + i) : r.push(null, new Ar(i - 1));
    }
    if (t > 0) {
      let o = r[0];
      o instanceof Ar ? r[0] = new Ar(t + o.length) : r.unshift(new Ar(t - 1), null);
    }
    return ii.of(r);
  }
  decomposeLeft(t, n) {
    n.push(new Ar(t - 1), null);
  }
  decomposeRight(t, n) {
    n.push(null, new Ar(this.length - t - 1));
  }
  updateHeight(t, n = 0, r = !1, i) {
    let o = n + this.length;
    if (i && i.from <= n + this.length && i.more) {
      let s = [], a = Math.max(n, i.from), l = -1;
      for (i.from > n && s.push(new Ar(i.from - n - 1).updateHeight(t, n)); a <= o && i.more; ) {
        let c = t.doc.lineAt(a).length;
        s.length && s.push(null);
        let d = i.heights[i.index++];
        l == -1 ? l = d : Math.abs(d - l) >= hp && (l = -2);
        let f = new Ti(c, d);
        f.outdated = !1, s.push(f), a += c + 1;
      }
      a <= o && s.push(null, new Ar(o - a).updateHeight(t, a));
      let u = ii.of(s);
      return (l < 0 || Math.abs(u.height - this.height) >= hp || Math.abs(l - this.heightMetrics(t, n).perLine) >= hp) && (t.heightChanged = !0), u;
    } else
      (r || this.outdated) && (this.setHeight(t, t.heightForGap(n, n + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class IZ extends ii {
  constructor(t, n, r) {
    super(t.length + n + r.length, t.height + r.height, n | (t.outdated || r.outdated ? 2 : 0)), this.left = t, this.right = r, this.size = t.size + r.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(t, n, r, i) {
    let o = r + this.left.height;
    return t < o ? this.left.blockAt(t, n, r, i) : this.right.blockAt(t, n, o, i + this.left.length + this.break);
  }
  lineAt(t, n, r, i, o) {
    let s = i + this.left.height, a = o + this.left.length + this.break, l = n == Rn.ByHeight ? t < s : t < a, u = l ? this.left.lineAt(t, n, r, i, o) : this.right.lineAt(t, n, r, s, a);
    if (this.break || (l ? u.to < a : u.from > a))
      return u;
    let c = n == Rn.ByPosNoHeight ? Rn.ByPosNoHeight : Rn.ByPos;
    return l ? u.join(this.right.lineAt(a, c, r, s, a)) : this.left.lineAt(a, c, r, i, o).join(u);
  }
  forEachLine(t, n, r, i, o, s) {
    let a = i + this.left.height, l = o + this.left.length + this.break;
    if (this.break)
      t < l && this.left.forEachLine(t, n, r, i, o, s), n >= l && this.right.forEachLine(t, n, r, a, l, s);
    else {
      let u = this.lineAt(l, Rn.ByPos, r, i, o);
      t < u.from && this.left.forEachLine(t, u.from - 1, r, i, o, s), u.to >= t && u.from <= n && s(u), n > u.to && this.right.forEachLine(u.to + 1, n, r, a, l, s);
    }
  }
  replace(t, n, r) {
    let i = this.left.length + this.break;
    if (n < i)
      return this.balanced(this.left.replace(t, n, r), this.right);
    if (t > this.left.length)
      return this.balanced(this.left, this.right.replace(t - i, n - i, r));
    let o = [];
    t > 0 && this.decomposeLeft(t, o);
    let s = o.length;
    for (let a of r)
      o.push(a);
    if (t > 0 && cO(o, s - 1), n < this.length) {
      let a = o.length;
      this.decomposeRight(n, o), cO(o, a);
    }
    return ii.of(o);
  }
  decomposeLeft(t, n) {
    let r = this.left.length;
    if (t <= r)
      return this.left.decomposeLeft(t, n);
    n.push(this.left), this.break && (r++, t >= r && n.push(null)), t > r && this.right.decomposeLeft(t - r, n);
  }
  decomposeRight(t, n) {
    let r = this.left.length, i = r + this.break;
    if (t >= i)
      return this.right.decomposeRight(t - i, n);
    t < r && this.left.decomposeRight(t, n), this.break && t < i && n.push(null), n.push(this.right);
  }
  balanced(t, n) {
    return t.size > 2 * n.size || n.size > 2 * t.size ? ii.of(this.break ? [t, null, n] : [t, n]) : (this.left = t, this.right = n, this.height = t.height + n.height, this.outdated = t.outdated || n.outdated, this.size = t.size + n.size, this.length = t.length + this.break + n.length, this);
  }
  updateHeight(t, n = 0, r = !1, i) {
    let { left: o, right: s } = this, a = n + o.length + this.break, l = null;
    return i && i.from <= n + o.length && i.more ? l = o = o.updateHeight(t, n, r, i) : o.updateHeight(t, n, r), i && i.from <= a + s.length && i.more ? l = s = s.updateHeight(t, a, r, i) : s.updateHeight(t, a, r), l ? this.balanced(o, s) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function cO(e, t) {
  let n, r;
  e[t] == null && (n = e[t - 1]) instanceof Ar && (r = e[t + 1]) instanceof Ar && e.splice(t - 1, 3, new Ar(n.length + 1 + r.length));
}
const kZ = 5;
class sC {
  constructor(t, n) {
    this.pos = t, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t, n) {
    if (this.lineStart > -1) {
      let r = Math.min(n, this.lineEnd), i = this.nodes[this.nodes.length - 1];
      i instanceof Ti ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new Ti(r - this.pos, -1)), this.writtenTo = r, n > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = n;
  }
  point(t, n, r) {
    if (t < n || r.heightRelevant) {
      let i = r.widget ? r.widget.estimatedHeight : 0, o = r.widget ? r.widget.lineBreaks : 0;
      i < 0 && (i = this.oracle.lineHeight);
      let s = n - t;
      r.block ? this.addBlock(new Fk(s, i, r)) : (s || o || i >= kZ) && this.addLineDeco(i, o, s);
    } else
      n > t && this.span(t, n);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: t, to: n } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t, this.lineEnd = n, this.writtenTo < t && ((this.writtenTo < t - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, t - 1)), this.nodes.push(null)), this.pos > t && this.nodes.push(new Ti(this.pos - t, -1)), this.writtenTo = this.pos;
  }
  blankContent(t, n) {
    let r = new Ar(n - t);
    return this.oracle.doc.lineAt(t).to == n && (r.flags |= 4), r;
  }
  ensureLine() {
    this.enterLine();
    let t = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t instanceof Ti)
      return t;
    let n = new Ti(0, -1);
    return this.nodes.push(n), n;
  }
  addBlock(t) {
    this.enterLine();
    let n = t.deco;
    n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(t), this.writtenTo = this.pos = this.pos + t.length, n && n.endSide > 0 && (this.covering = t);
  }
  addLineDeco(t, n, r) {
    let i = this.ensureLine();
    i.length += r, i.collapsed += r, i.widgetHeight = Math.max(i.widgetHeight, t), i.breaks += n, this.writtenTo = this.pos = this.pos + r;
  }
  finish(t) {
    let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(n instanceof Ti) && !this.isCovered ? this.nodes.push(new Ti(0, -1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let r = t;
    for (let i of this.nodes)
      i instanceof Ti && i.updateHeight(this.oracle, r), r += i ? i.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(t, n, r, i) {
    let o = new sC(r, t);
    return En.spans(n, r, i, o, 0), o.finish(r);
  }
}
function PZ(e, t, n) {
  let r = new NZ();
  return En.compare(e, t, n, r, 0), r.changes;
}
class NZ {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t, n, r, i) {
    (t < n || r && r.heightRelevant || i && i.heightRelevant) && my(t, n, this.changes, 5);
  }
}
function LZ(e, t) {
  let n = e.getBoundingClientRect(), r = e.ownerDocument, i = r.defaultView || window, o = Math.max(0, n.left), s = Math.min(i.innerWidth, n.right), a = Math.max(0, n.top), l = Math.min(i.innerHeight, n.bottom);
  for (let u = e.parentNode; u && u != r.body; )
    if (u.nodeType == 1) {
      let c = u, d = window.getComputedStyle(c);
      if ((c.scrollHeight > c.clientHeight || c.scrollWidth > c.clientWidth) && d.overflow != "visible") {
        let f = c.getBoundingClientRect();
        o = Math.max(o, f.left), s = Math.min(s, f.right), a = Math.max(a, f.top), l = u == e.parentNode ? f.bottom : Math.min(l, f.bottom);
      }
      u = d.position == "absolute" || d.position == "fixed" ? c.offsetParent : c.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
  return {
    left: o - n.left,
    right: Math.max(o, s) - n.left,
    top: a - (n.top + t),
    bottom: Math.max(a, l) - (n.top + t)
  };
}
function FZ(e, t) {
  let n = e.getBoundingClientRect();
  return {
    left: 0,
    right: n.right - n.left,
    top: t,
    bottom: n.bottom - (n.top + t)
  };
}
class Bv {
  constructor(t, n, r) {
    this.from = t, this.to = n, this.size = r;
  }
  static same(t, n) {
    if (t.length != n.length)
      return !1;
    for (let r = 0; r < t.length; r++) {
      let i = t[r], o = n[r];
      if (i.from != o.from || i.to != o.to || i.size != o.size)
        return !1;
    }
    return !0;
  }
  draw(t, n) {
    return dr.replace({
      widget: new BZ(this.size * (n ? t.scaleY : t.scaleX), n)
    }).range(this.from, this.to);
  }
}
class BZ extends vm {
  constructor(t, n) {
    super(), this.size = t, this.vertical = n;
  }
  eq(t) {
    return t.size == this.size && t.vertical == this.vertical;
  }
  toDOM() {
    let t = document.createElement("div");
    return this.vertical ? t.style.height = this.size + "px" : (t.style.width = this.size + "px", t.style.height = "2px", t.style.display = "inline-block"), t;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class uO {
  constructor(t) {
    this.state = t, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !1, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = dO, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = ar.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let n = t.facet(iC).some((r) => typeof r != "function" && r.class == "cm-lineWrapping");
    this.heightOracle = new RZ(n), this.stateDeco = t.facet(Fd).filter((r) => typeof r != "function"), this.heightMap = ii.empty().applyChanges(this.stateDeco, fn.empty, this.heightOracle.setDoc(t.doc), [new eo(0, 0, 0, t.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = dr.set(this.lineGaps.map((r) => r.draw(this, !1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t = [this.viewport], { main: n } = this.state.selection;
    for (let r = 0; r <= 1; r++) {
      let i = r ? n.head : n.anchor;
      if (!t.some(({ from: o, to: s }) => i >= o && i <= s)) {
        let { from: o, to: s } = this.lineBlockAt(i);
        t.push(new gh(o, s));
      }
    }
    this.viewports = t.sort((r, i) => r.from - i.from), this.scaler = this.heightMap.height <= 7e6 ? dO : new HZ(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (t) => {
      this.viewportLines.push(this.scaler.scale == 1 ? t : ju(t, this.scaler));
    });
  }
  update(t, n = null) {
    this.state = t.state;
    let r = this.stateDeco;
    this.stateDeco = this.state.facet(Fd).filter((c) => typeof c != "function");
    let i = t.changedRanges, o = eo.extendWithRanges(i, PZ(r, this.stateDeco, t ? t.changes : wr.empty(this.state.doc.length))), s = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, t.startState.doc, this.heightOracle.setDoc(this.state.doc), o), this.heightMap.height != s && (t.flags |= 2), a ? (this.scrollAnchorPos = t.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let l = o.length ? this.mapViewport(this.viewport, t.changes) : this.viewport;
    (n && (n.range.head < l.from || n.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, n));
    let u = !t.changes.empty || t.flags & 2 || l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, this.updateForViewport(), u && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t.changes))), t.flags |= this.computeVisibleRanges(), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && t.selectionSet && t.view.lineWrapping && t.state.selection.main.empty && t.state.selection.main.assoc && !t.state.facet(qQ) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(t) {
    let n = t.contentDOM, r = window.getComputedStyle(n), i = this.heightOracle, o = r.whiteSpace;
    this.defaultTextDirection = r.direction == "rtl" ? ar.RTL : ar.LTR;
    let s = this.heightOracle.mustRefreshForWrapping(o), a = n.getBoundingClientRect(), l = s || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let u = 0, c = 0;
    if (a.width && a.height) {
      let { scaleX: w, scaleY: C } = XI(n, a);
      (w > 5e-3 && Math.abs(this.scaleX - w) > 5e-3 || C > 5e-3 && Math.abs(this.scaleY - C) > 5e-3) && (this.scaleX = w, this.scaleY = C, u |= 8, s = l = !0);
    }
    let d = (parseInt(r.paddingTop) || 0) * this.scaleY, f = (parseInt(r.paddingBottom) || 0) * this.scaleY;
    (this.paddingTop != d || this.paddingBottom != f) && (this.paddingTop = d, this.paddingBottom = f, u |= 10), this.editorWidth != t.scrollDOM.clientWidth && (i.lineWrapping && (l = !0), this.editorWidth = t.scrollDOM.clientWidth, u |= 8);
    let h = t.scrollDOM.scrollTop * this.scaleY;
    this.scrollTop != h && (this.scrollAnchorHeight = -1, this.scrollTop = h), this.scrolledToBottom = QI(t.scrollDOM);
    let p = (this.printing ? FZ : LZ)(n, this.paddingTop), g = p.top - this.pixelViewport.top, m = p.bottom - this.pixelViewport.bottom;
    this.pixelViewport = p;
    let v = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (v != this.inView && (this.inView = v, v && (l = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let b = a.width;
    if ((this.contentDOMWidth != b || this.editorHeight != t.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = t.scrollDOM.clientHeight, u |= 8), l) {
      let w = t.docView.measureVisibleLineHeights(this.viewport);
      if (i.mustRefreshForHeights(w) && (s = !0), s || i.lineWrapping && Math.abs(b - this.contentDOMWidth) > i.charWidth) {
        let { lineHeight: C, charWidth: y, textHeight: S } = t.docView.measureTextSize();
        s = C > 0 && i.refresh(o, C, y, S, b / y, w), s && (t.docView.minWidth = 0, u |= 8);
      }
      g > 0 && m > 0 ? c = Math.max(g, m) : g < 0 && m < 0 && (c = Math.min(g, m)), i.heightChanged = !1;
      for (let C of this.viewports) {
        let y = C.from == this.viewport.from ? w : t.docView.measureVisibleLineHeights(C);
        this.heightMap = (s ? ii.empty().applyChanges(this.stateDeco, fn.empty, this.heightOracle, [new eo(0, 0, 0, t.state.doc.length)]) : this.heightMap).updateHeight(i, 0, s, new MZ(C.from, y));
      }
      i.heightChanged && (u |= 2);
    }
    let x = !this.viewportIsAppropriate(this.viewport, c) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return x && (this.viewport = this.getViewport(c, this.scrollTarget)), this.updateForViewport(), (u & 2 || x) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(s ? [] : this.lineGaps, t)), u |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, t.docView.enforceCursorAssoc()), u;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t, n) {
    let r = 0.5 - Math.max(-0.5, Math.min(0.5, t / 1e3 / 2)), i = this.heightMap, o = this.heightOracle, { visibleTop: s, visibleBottom: a } = this, l = new gh(i.lineAt(s - r * 1e3, Rn.ByHeight, o, 0, 0).from, i.lineAt(a + (1 - r) * 1e3, Rn.ByHeight, o, 0, 0).to);
    if (n) {
      let { head: u } = n.range;
      if (u < l.from || u > l.to) {
        let c = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), d = i.lineAt(u, Rn.ByPos, o, 0, 0), f;
        n.y == "center" ? f = (d.top + d.bottom) / 2 - c / 2 : n.y == "start" || n.y == "nearest" && u < l.from ? f = d.top : f = d.bottom - c, l = new gh(i.lineAt(f - 1e3 / 2, Rn.ByHeight, o, 0, 0).from, i.lineAt(f + c + 1e3 / 2, Rn.ByHeight, o, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(t, n) {
    let r = n.mapPos(t.from, -1), i = n.mapPos(t.to, 1);
    return new gh(this.heightMap.lineAt(r, Rn.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, Rn.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: t, to: n }, r = 0) {
    if (!this.inView)
      return !0;
    let { top: i } = this.heightMap.lineAt(t, Rn.ByPos, this.heightOracle, 0, 0), { bottom: o } = this.heightMap.lineAt(n, Rn.ByPos, this.heightOracle, 0, 0), { visibleTop: s, visibleBottom: a } = this;
    return (t == 0 || i <= s - Math.max(10, Math.min(
      -r,
      250
      /* VP.MaxCoverMargin */
    ))) && (n == this.state.doc.length || o >= a + Math.max(10, Math.min(
      r,
      250
      /* VP.MaxCoverMargin */
    ))) && i > s - 2 * 1e3 && o < a + 2 * 1e3;
  }
  mapLineGaps(t, n) {
    if (!t.length || n.empty)
      return t;
    let r = [];
    for (let i of t)
      n.touchesRange(i.from, i.to) || r.push(new Bv(n.mapPos(i.from), n.mapPos(i.to), i.size));
    return r;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(t, n) {
    let r = this.heightOracle.lineWrapping, i = r ? 1e4 : 2e3, o = i >> 1, s = i << 1;
    if (this.defaultTextDirection != ar.LTR && !r)
      return [];
    let a = [], l = (u, c, d, f) => {
      if (c - u < o)
        return;
      let h = this.state.selection.main, p = [h.from];
      h.empty || p.push(h.to);
      for (let m of p)
        if (m > u && m < c) {
          l(u, m - 10, d, f), l(m + 10, c, d, f);
          return;
        }
      let g = zZ(t, (m) => m.from >= d.from && m.to <= d.to && Math.abs(m.from - u) < o && Math.abs(m.to - c) < o && !p.some((v) => m.from < v && m.to > v));
      if (!g) {
        if (c < d.to && n && r && n.visibleRanges.some((m) => m.from <= c && m.to >= c)) {
          let m = n.moveToLineBoundary(st.cursor(c), !1, !0).head;
          m > u && (c = m);
        }
        g = new Bv(u, c, this.gapSize(d, u, c, f));
      }
      a.push(g);
    };
    for (let u of this.viewportLines) {
      if (u.length < s)
        continue;
      let c = jZ(u.from, u.to, this.stateDeco);
      if (c.total < s)
        continue;
      let d = this.scrollTarget ? this.scrollTarget.range.head : null, f, h;
      if (r) {
        let p = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, m;
        if (d != null) {
          let v = vh(c, d), b = ((this.visibleBottom - this.visibleTop) / 2 + p) / u.height;
          g = v - b, m = v + b;
        } else
          g = (this.visibleTop - u.top - p) / u.height, m = (this.visibleBottom - u.top + p) / u.height;
        f = mh(c, g), h = mh(c, m);
      } else {
        let p = c.total * this.heightOracle.charWidth, g = i * this.heightOracle.charWidth, m, v;
        if (d != null) {
          let b = vh(c, d), x = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + g) / p;
          m = b - x, v = b + x;
        } else
          m = (this.pixelViewport.left - g) / p, v = (this.pixelViewport.right + g) / p;
        f = mh(c, m), h = mh(c, v);
      }
      f > u.from && l(u.from, f, u, c), h < u.to && l(h, u.to, u, c);
    }
    return a;
  }
  gapSize(t, n, r, i) {
    let o = vh(i, r) - vh(i, n);
    return this.heightOracle.lineWrapping ? t.height * o : i.total * this.heightOracle.charWidth * o;
  }
  updateLineGaps(t) {
    Bv.same(t, this.lineGaps) || (this.lineGaps = t, this.lineGapDeco = dr.set(t.map((n) => n.draw(this, this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let t = this.stateDeco;
    this.lineGaps.length && (t = t.concat(this.lineGapDeco));
    let n = [];
    En.spans(t, this.viewport.from, this.viewport.to, {
      span(i, o) {
        n.push({ from: i, to: o });
      },
      point() {
      }
    }, 20);
    let r = n.length != this.visibleRanges.length || this.visibleRanges.some((i, o) => i.from != n[o].from || i.to != n[o].to);
    return this.visibleRanges = n, r ? 4 : 0;
  }
  lineBlockAt(t) {
    return t >= this.viewport.from && t <= this.viewport.to && this.viewportLines.find((n) => n.from <= t && n.to >= t) || ju(this.heightMap.lineAt(t, Rn.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t) {
    return ju(this.heightMap.lineAt(this.scaler.fromDOM(t), Rn.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(t) {
    let n = this.lineBlockAtHeight(t + 8);
    return n.from >= this.viewport.from || this.viewportLines[0].top - t > 200 ? n : this.viewportLines[0];
  }
  elementAtHeight(t) {
    return ju(this.heightMap.blockAt(this.scaler.fromDOM(t), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
let gh = class {
  constructor(t, n) {
    this.from = t, this.to = n;
  }
};
function jZ(e, t, n) {
  let r = [], i = e, o = 0;
  return En.spans(n, e, t, {
    span() {
    },
    point(s, a) {
      s > i && (r.push({ from: i, to: s }), o += s - i), i = a;
    }
  }, 20), i < t && (r.push({ from: i, to: t }), o += t - i), { total: o, ranges: r };
}
function mh({ total: e, ranges: t }, n) {
  if (n <= 0)
    return t[0].from;
  if (n >= 1)
    return t[t.length - 1].to;
  let r = Math.floor(e * n);
  for (let i = 0; ; i++) {
    let { from: o, to: s } = t[i], a = s - o;
    if (r <= a)
      return o + r;
    r -= a;
  }
}
function vh(e, t) {
  let n = 0;
  for (let { from: r, to: i } of e.ranges) {
    if (t <= i) {
      n += t - r;
      break;
    }
    n += i - r;
  }
  return n / e.total;
}
function zZ(e, t) {
  for (let n of e)
    if (t(n))
      return n;
}
const dO = {
  toDOM(e) {
    return e;
  },
  fromDOM(e) {
    return e;
  },
  scale: 1
};
class HZ {
  constructor(t, n, r) {
    let i = 0, o = 0, s = 0;
    this.viewports = r.map(({ from: a, to: l }) => {
      let u = n.lineAt(a, Rn.ByPos, t, 0, 0).top, c = n.lineAt(l, Rn.ByPos, t, 0, 0).bottom;
      return i += c - u, { from: a, to: l, top: u, bottom: c, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - i) / (n.height - i);
    for (let a of this.viewports)
      a.domTop = s + (a.top - o) * this.scale, s = a.domBottom = a.domTop + (a.bottom - a.top), o = a.bottom;
  }
  toDOM(t) {
    for (let n = 0, r = 0, i = 0; ; n++) {
      let o = n < this.viewports.length ? this.viewports[n] : null;
      if (!o || t < o.top)
        return i + (t - r) * this.scale;
      if (t <= o.bottom)
        return o.domTop + (t - o.top);
      r = o.bottom, i = o.domBottom;
    }
  }
  fromDOM(t) {
    for (let n = 0, r = 0, i = 0; ; n++) {
      let o = n < this.viewports.length ? this.viewports[n] : null;
      if (!o || t < o.domTop)
        return r + (t - i) / this.scale;
      if (t <= o.domBottom)
        return o.top + (t - o.domTop);
      r = o.bottom, i = o.domBottom;
    }
  }
}
function ju(e, t) {
  if (t.scale == 1)
    return e;
  let n = t.toDOM(e.top), r = t.toDOM(e.bottom);
  return new Vo(e.from, e.length, n, r - n, Array.isArray(e._content) ? e._content.map((i) => ju(i, t)) : e._content);
}
const bh = /* @__PURE__ */ Pt.define({ combine: (e) => e.join(" ") }), xy = /* @__PURE__ */ Pt.define({ combine: (e) => e.indexOf(!0) > -1 }), Ey = /* @__PURE__ */ fa.newName(), Bk = /* @__PURE__ */ fa.newName(), jk = /* @__PURE__ */ fa.newName(), zk = { "&light": "." + Bk, "&dark": "." + jk };
function $y(e, t, n) {
  return new fa(t, {
    finish(r) {
      return /&/.test(r) ? r.replace(/&\w*/, (i) => {
        if (i == "&")
          return e;
        if (!n || !n[i])
          throw new RangeError(`Unsupported selector: ${i}`);
        return n[i];
      }) : e + " " + r;
    }
  });
}
const VZ = /* @__PURE__ */ $y("." + Ey, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    // https://github.com/codemirror/dev/issues/456
    boxSizing: "border-box",
    minHeight: "100%",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    // For IE
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    // For Safari, which doesn't support overflow-wrap: anywhere
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  ".cm-iso": {
    unicodeBidi: "isolate"
  },
  ".cm-announced": {
    position: "fixed",
    top: "-10000px"
  },
  "@media print": {
    ".cm-announced": { display: "none" }
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    // Necessary -- prevents margin collapsing
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, zk), zu = "";
class WZ {
  constructor(t, n) {
    this.points = t, this.text = "", this.lineSeparator = n.facet(hn.lineSeparator);
  }
  append(t) {
    this.text += t;
  }
  lineBreak() {
    this.text += zu;
  }
  readRange(t, n) {
    if (!t)
      return this;
    let r = t.parentNode;
    for (let i = t; ; ) {
      this.findPointBefore(r, i);
      let o = this.text.length;
      this.readNode(i);
      let s = i.nextSibling;
      if (s == n)
        break;
      let a = Cn.get(i), l = Cn.get(s);
      (a && l ? a.breakAfter : (a ? a.breakAfter : Xp(i)) || Xp(s) && (i.nodeName != "BR" || i.cmIgnore) && this.text.length > o) && this.lineBreak(), i = s;
    }
    return this.findPointBefore(r, n), this;
  }
  readTextNode(t) {
    let n = t.nodeValue;
    for (let r of this.points)
      r.node == t && (r.pos = this.text.length + Math.min(r.offset, n.length));
    for (let r = 0, i = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let o = -1, s = 1, a;
      if (this.lineSeparator ? (o = n.indexOf(this.lineSeparator, r), s = this.lineSeparator.length) : (a = i.exec(n)) && (o = a.index, s = a[0].length), this.append(n.slice(r, o < 0 ? n.length : o)), o < 0)
        break;
      if (this.lineBreak(), s > 1)
        for (let l of this.points)
          l.node == t && l.pos > this.text.length && (l.pos -= s - 1);
      r = o + s;
    }
  }
  readNode(t) {
    if (t.cmIgnore)
      return;
    let n = Cn.get(t), r = n && n.overrideDOMText;
    if (r != null) {
      this.findPointInside(t, r.length);
      for (let i = r.iter(); !i.next().done; )
        i.lineBreak ? this.lineBreak() : this.append(i.value);
    } else
      t.nodeType == 3 ? this.readTextNode(t) : t.nodeName == "BR" ? t.nextSibling && this.lineBreak() : t.nodeType == 1 && this.readRange(t.firstChild, null);
  }
  findPointBefore(t, n) {
    for (let r of this.points)
      r.node == t && t.childNodes[r.offset] == n && (r.pos = this.text.length);
  }
  findPointInside(t, n) {
    for (let r of this.points)
      (t.nodeType == 3 ? r.node == t : t.contains(r.node)) && (r.pos = this.text.length + (UZ(t, r.node, r.offset) ? n : 0));
  }
}
function UZ(e, t, n) {
  for (; ; ) {
    if (!t || n < Ds(t))
      return !1;
    if (t == e)
      return !0;
    n = il(t) + 1, t = t.parentNode;
  }
}
class fO {
  constructor(t, n) {
    this.node = t, this.offset = n, this.pos = -1;
  }
}
class GZ {
  constructor(t, n, r, i) {
    this.typeOver = i, this.bounds = null, this.text = "";
    let { impreciseHead: o, impreciseAnchor: s } = t.docView;
    if (t.state.readOnly && n > -1)
      this.newSel = null;
    else if (n > -1 && (this.bounds = t.docView.domBoundsAround(n, r, 0))) {
      let a = o || s ? [] : YZ(t), l = new WZ(a, t.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = qZ(a, this.bounds.from);
    } else {
      let a = t.observer.selectionRange, l = o && o.node == a.focusNode && o.offset == a.focusOffset || !uy(t.contentDOM, a.focusNode) ? t.state.selection.main.head : t.docView.posFromDOM(a.focusNode, a.focusOffset), u = s && s.node == a.anchorNode && s.offset == a.anchorOffset || !uy(t.contentDOM, a.anchorNode) ? t.state.selection.main.anchor : t.docView.posFromDOM(a.anchorNode, a.anchorOffset), c = t.viewport;
      if ((ft.ios || ft.chrome) && t.state.selection.main.empty && l != u && (c.from > 0 || c.to < t.state.doc.length)) {
        let d = Math.min(l, u), f = Math.max(l, u), h = c.from - d, p = c.to - f;
        (h == 0 || h == 1 || d == 0) && (p == 0 || p == -1 || f == t.state.doc.length) && (l = 0, u = t.state.doc.length);
      }
      this.newSel = st.single(u, l);
    }
  }
}
function Hk(e, t) {
  let n, { newSel: r } = t, i = e.state.selection.main, o = e.inputState.lastKeyTime > Date.now() - 100 ? e.inputState.lastKeyCode : -1;
  if (t.bounds) {
    let { from: s, to: a } = t.bounds, l = i.from, u = null;
    (o === 8 || ft.android && t.text.length < a - s) && (l = i.to, u = "end");
    let c = XZ(e.state.doc.sliceString(s, a, zu), t.text, l - s, u);
    c && (ft.chrome && o == 13 && c.toB == c.from + 2 && t.text.slice(c.from, c.toB) == zu + zu && c.toB--, n = {
      from: s + c.from,
      to: s + c.toA,
      insert: fn.of(t.text.slice(c.from, c.toB).split(zu))
    });
  } else
    r && (!e.hasFocus && e.state.facet(bm) || r.main.eq(i)) && (r = null);
  if (!n && !r)
    return !1;
  if (!n && t.typeOver && !i.empty && r && r.main.empty ? n = { from: i.from, to: i.to, insert: e.state.doc.slice(i.from, i.to) } : n && n.from >= i.from && n.to <= i.to && (n.from != i.from || n.to != i.to) && i.to - i.from - (n.to - n.from) <= 4 ? n = {
    from: i.from,
    to: i.to,
    insert: e.state.doc.slice(i.from, n.from).append(n.insert).append(e.state.doc.slice(n.to, i.to))
  } : (ft.mac || ft.android) && n && n.from == n.to && n.from == i.head - 1 && /^\. ?$/.test(n.insert.toString()) && e.contentDOM.getAttribute("autocorrect") == "off" ? (r && n.insert.length == 2 && (r = st.single(r.main.anchor - 1, r.main.head - 1)), n = { from: i.from, to: i.to, insert: fn.of([" "]) }) : ft.chrome && n && n.from == n.to && n.from == i.head && n.insert.toString() == `
 ` && e.lineWrapping && (r && (r = st.single(r.main.anchor - 1, r.main.head - 1)), n = { from: i.from, to: i.to, insert: fn.of([" "]) }), n) {
    if (ft.ios && e.inputState.flushIOSKey(n) || ft.android && (n.to == i.to && // GBoard will sometimes remove a space it just inserted
    // after a completion when you press enter
    (n.from == i.from || n.from == i.from - 1 && e.state.sliceDoc(n.from, i.from) == " ") && n.insert.length == 1 && n.insert.lines == 2 && vc(e.contentDOM, "Enter", 13) || (n.from == i.from - 1 && n.to == i.to && n.insert.length == 0 || o == 8 && n.insert.length < n.to - n.from && n.to > i.head) && vc(e.contentDOM, "Backspace", 8) || n.from == i.from && n.to == i.to + 1 && n.insert.length == 0 && vc(e.contentDOM, "Delete", 46)))
      return !0;
    let s = n.insert.toString();
    e.inputState.composing >= 0 && e.inputState.composing++;
    let a, l = () => a || (a = KZ(e, n, r));
    return e.state.facet(bk).some((u) => u(e, n.from, n.to, s, l)) || e.dispatch(l()), !0;
  } else if (r && !r.main.eq(i)) {
    let s = !1, a = "select";
    return e.inputState.lastSelectionTime > Date.now() - 50 && (e.inputState.lastSelectionOrigin == "select" && (s = !0), a = e.inputState.lastSelectionOrigin), e.dispatch({ selection: r, scrollIntoView: s, userEvent: a }), !0;
  } else
    return !1;
}
function KZ(e, t, n) {
  let r, i = e.state, o = i.selection.main;
  if (t.from >= o.from && t.to <= o.to && t.to - t.from >= (o.to - o.from) / 3 && (!n || n.main.empty && n.main.from == t.from + t.insert.length) && e.inputState.composing < 0) {
    let a = o.from < t.from ? i.sliceDoc(o.from, t.from) : "", l = o.to > t.to ? i.sliceDoc(t.to, o.to) : "";
    r = i.replaceSelection(e.state.toText(a + t.insert.sliceString(0, void 0, e.state.lineBreak) + l));
  } else {
    let a = i.changes(t), l = n && n.main.to <= a.newLength ? n.main : void 0;
    if (i.selection.ranges.length > 1 && e.inputState.composing >= 0 && t.to <= o.to && t.to >= o.to - 10) {
      let u = e.state.sliceDoc(t.from, t.to), c, d = n && Ak(e, n.main.head);
      if (d) {
        let p = t.insert.length - (t.to - t.from);
        c = { from: d.from, to: d.to - p };
      } else
        c = e.state.doc.lineAt(o.head);
      let f = o.to - t.to, h = o.to - o.from;
      r = i.changeByRange((p) => {
        if (p.from == o.from && p.to == o.to)
          return { changes: a, range: l || p.map(a) };
        let g = p.to - f, m = g - u.length;
        if (p.to - p.from != h || e.state.sliceDoc(m, g) != u || // Unfortunately, there's no way to make multiple
        // changes in the same node work without aborting
        // composition, so cursors in the composition range are
        // ignored.
        p.to >= c.from && p.from <= c.to)
          return { range: p };
        let v = i.changes({ from: m, to: g, insert: t.insert }), b = p.to - o.to;
        return {
          changes: v,
          range: l ? st.range(Math.max(0, l.anchor + b), Math.max(0, l.head + b)) : p.map(v)
        };
      });
    } else
      r = {
        changes: a,
        selection: l && i.selection.replaceRange(l)
      };
  }
  let s = "input.type";
  return (e.composing || e.inputState.compositionPendingChange && e.inputState.compositionEndedAt > Date.now() - 50) && (e.inputState.compositionPendingChange = !1, s += ".compose", e.inputState.compositionFirstChange && (s += ".start", e.inputState.compositionFirstChange = !1)), i.update(r, { userEvent: s, scrollIntoView: !0 });
}
function XZ(e, t, n, r) {
  let i = Math.min(e.length, t.length), o = 0;
  for (; o < i && e.charCodeAt(o) == t.charCodeAt(o); )
    o++;
  if (o == i && e.length == t.length)
    return null;
  let s = e.length, a = t.length;
  for (; s > 0 && a > 0 && e.charCodeAt(s - 1) == t.charCodeAt(a - 1); )
    s--, a--;
  if (r == "end") {
    let l = Math.max(0, o - Math.min(s, a));
    n -= s + l - o;
  }
  if (s < o && e.length < t.length) {
    let l = n <= o && n >= s ? o - n : 0;
    o -= l, a = o + (a - s), s = o;
  } else if (a < o) {
    let l = n <= o && n >= a ? o - n : 0;
    o -= l, s = o + (s - a), a = o;
  }
  return { from: o, toA: s, toB: a };
}
function YZ(e) {
  let t = [];
  if (e.root.activeElement != e.contentDOM)
    return t;
  let { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o } = e.observer.selectionRange;
  return n && (t.push(new fO(n, r)), (i != n || o != r) && t.push(new fO(i, o))), t;
}
function qZ(e, t) {
  if (e.length == 0)
    return null;
  let n = e[0].pos, r = e.length == 2 ? e[1].pos : n;
  return n > -1 && r > -1 ? st.single(n + t, r + t) : null;
}
const QZ = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, jv = ft.ie && ft.ie_version <= 11;
class ZZ {
  constructor(t) {
    this.view = t, this.active = !1, this.selectionRange = new IQ(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.printQuery = null, this.parentCheck = -1, this.dom = t.contentDOM, this.observer = new MutationObserver((n) => {
      for (let r of n)
        this.queue.push(r);
      (ft.ie && ft.ie_version <= 11 || ft.ios && t.composing) && n.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), jv && (this.onCharData = (n) => {
      this.queue.push({
        target: n.target,
        type: "characterData",
        oldValue: n.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), window.matchMedia && (this.printQuery = window.matchMedia("print")), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var n;
      ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(t.scrollDOM)), this.addWindowListeners(this.win = t.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((n) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {
      n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(t) {
    this.view.inputState.runHandlers("scroll", t), this.intersecting && this.view.measure();
  }
  onScroll(t) {
    this.intersecting && this.flush(!1), this.onScrollChanged(t);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint(t) {
    t.type == "change" && !t.matches || (this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500));
  }
  updateGaps(t) {
    if (this.gapIntersection && (t.length != this.gaps.length || this.gaps.some((n, r) => n != t[r]))) {
      this.gapIntersection.disconnect();
      for (let n of t)
        this.gapIntersection.observe(n);
      this.gaps = t;
    }
  }
  onSelectionChange(t) {
    let n = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: r } = this, i = this.selectionRange;
    if (r.state.facet(bm) ? r.root.activeElement != this.dom : !dp(r.dom, i))
      return;
    let o = i.anchorNode && r.docView.nearest(i.anchorNode);
    if (o && o.ignoreEvent(t)) {
      n || (this.selectionChanged = !1);
      return;
    }
    (ft.ie && ft.ie_version <= 11 || ft.android && ft.chrome) && !r.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    i.focusNode && od(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: t } = this, n = Kp(t.root);
    if (!n)
      return !1;
    let r = ft.safari && t.root.nodeType == 11 && _Q(this.dom.ownerDocument) == this.dom && JZ(this.view, n) || n;
    if (!r || this.selectionRange.eq(r))
      return !1;
    let i = dp(this.dom, r);
    return i && !this.selectionChanged && t.inputState.lastFocusTime > Date.now() - 200 && t.inputState.lastTouchTime < Date.now() - 300 && PQ(this.dom, r) ? (this.view.inputState.lastFocusTime = 0, t.docView.updateSelection(), !1) : (this.selectionRange.setRange(r), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(t, n) {
    this.selectionRange.set(t.node, t.offset, n.node, n.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t = 0, n = null;
    for (let r = this.dom; r; )
      if (r.nodeType == 1)
        !n && t < this.scrollTargets.length && this.scrollTargets[t] == r ? t++ : n || (n = this.scrollTargets.slice(0, t)), n && n.push(r), r = r.assignedSlot || r.parentNode;
      else if (r.nodeType == 11)
        r = r.host;
      else
        break;
    if (t < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, t)), n) {
      for (let r of this.scrollTargets)
        r.removeEventListener("scroll", this.onScroll);
      for (let r of this.scrollTargets = n)
        r.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t) {
    if (!this.active)
      return t();
    try {
      return this.stop(), t();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, QZ), jv && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), jv && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(t, n) {
    var r;
    if (!this.delayedAndroidKey) {
      let i = () => {
        let o = this.delayedAndroidKey;
        o && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = o.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && o.force && vc(this.dom, o.key, o.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);
    }
    (!this.delayedAndroidKey || t == "Enter") && (this.delayedAndroidKey = {
      key: t,
      keyCode: n,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let t of this.observer.takeRecords())
      this.queue.push(t);
    return this.queue;
  }
  processRecords() {
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let n = -1, r = -1, i = !1;
    for (let o of t) {
      let s = this.readMutation(o);
      s && (s.typeOver && (i = !0), n == -1 ? { from: n, to: r } = s : (n = Math.min(s.from, n), r = Math.max(s.to, r)));
    }
    return { from: n, to: r, typeOver: i };
  }
  readChange() {
    let { from: t, to: n, typeOver: r } = this.processRecords(), i = this.selectionChanged && dp(this.dom, this.selectionRange);
    if (t < 0 && !i)
      return null;
    t > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let o = new GZ(this.view, t, n, r);
    return this.view.docView.domChanged = { newSel: o.newSel ? o.newSel.main : null }, o;
  }
  // Apply pending changes, if any
  flush(t = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    t && this.readSelectionRange();
    let n = this.readChange();
    if (!n)
      return this.view.requestMeasure(), !1;
    let r = this.view.state, i = Hk(this.view, n);
    return this.view.state == r && this.view.update([]), i;
  }
  readMutation(t) {
    let n = this.view.docView.nearest(t.target);
    if (!n || n.ignoreMutation(t))
      return null;
    if (n.markDirty(t.type == "attributes"), t.type == "attributes" && (n.flags |= 4), t.type == "childList") {
      let r = hO(n, t.previousSibling || t.target.previousSibling, -1), i = hO(n, t.nextSibling || t.target.nextSibling, 1);
      return {
        from: r ? n.posAfter(r) : n.posAtStart,
        to: i ? n.posBefore(i) : n.posAtEnd,
        typeOver: !1
      };
    } else
      return t.type == "characterData" ? { from: n.posAtStart, to: n.posAtEnd, typeOver: t.target.nodeValue == t.oldValue } : null;
  }
  setWindow(t) {
    t != this.win && (this.removeWindowListeners(this.win), this.win = t, this.addWindowListeners(this.win));
  }
  addWindowListeners(t) {
    t.addEventListener("resize", this.onResize), this.printQuery ? this.printQuery.addEventListener("change", this.onPrint) : t.addEventListener("beforeprint", this.onPrint), t.addEventListener("scroll", this.onScroll), t.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t) {
    t.removeEventListener("scroll", this.onScroll), t.removeEventListener("resize", this.onResize), this.printQuery ? this.printQuery.removeEventListener("change", this.onPrint) : t.removeEventListener("beforeprint", this.onPrint), t.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var t, n, r;
    this.stop(), (t = this.intersection) === null || t === void 0 || t.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();
    for (let i of this.scrollTargets)
      i.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function hO(e, t, n) {
  for (; t; ) {
    let r = Cn.get(t);
    if (r && r.parent == e)
      return r;
    let i = t.parentNode;
    t = i != e.dom ? i : n > 0 ? t.nextSibling : t.previousSibling;
  }
  return null;
}
function pO(e, t) {
  let n = t.startContainer, r = t.startOffset, i = t.endContainer, o = t.endOffset, s = e.docView.domAtPos(e.state.selection.main.anchor);
  return od(s.node, s.offset, i, o) && ([n, r, i, o] = [i, o, n, r]), { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o };
}
function JZ(e, t) {
  if (t.getComposedRanges) {
    let i = t.getComposedRanges(e.root)[0];
    if (i)
      return pO(e, i);
  }
  let n = null;
  function r(i) {
    i.preventDefault(), i.stopImmediatePropagation(), n = i.getTargetRanges()[0];
  }
  return e.contentDOM.addEventListener("beforeinput", r, !0), e.dom.ownerDocument.execCommand("indent"), e.contentDOM.removeEventListener("beforeinput", r, !0), n ? pO(e, n) : null;
}
class Vt {
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(t = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.className = "cm-announced", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), t.parent && t.parent.appendChild(this.dom);
    let { dispatch: n } = t;
    this.dispatchTransactions = t.dispatchTransactions || n && ((r) => r.forEach((i) => n(i, this))) || ((r) => this.update(r)), this.dispatch = this.dispatch.bind(this), this._root = t.root || kQ(t.parent) || document, this.viewState = new uO(t.state || hn.create(t)), t.scrollTo && t.scrollTo.is(fh) && (this.viewState.scrollTarget = t.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Fu).map((r) => new Nv(r));
    for (let r of this.plugins)
      r.update(this);
    this.observer = new ZZ(this), this.inputState = new pZ(this), this.inputState.ensureHandlers(this.plugins), this.docView = new G$(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();
  }
  dispatch(...t) {
    let n = t.length == 1 && t[0] instanceof Kr ? t : t.length == 1 && Array.isArray(t[0]) ? t[0] : [this.state.update(...t)];
    this.dispatchTransactions(n, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let n = !1, r = !1, i, o = this.state;
    for (let f of t) {
      if (f.startState != o)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      o = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = o;
      return;
    }
    let s = this.hasFocus, a = 0, l = null;
    t.some((f) => f.annotation(Pk)) ? (this.inputState.notifiedFocused = s, a = 1) : s != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = s, l = Nk(o, s), l || (a = 1));
    let u = this.observer.delayedAndroidKey, c = null;
    if (u ? (this.observer.clearDelayedAndroidKey(), c = this.observer.readChange(), (c && !this.state.doc.eq(o.doc) || !this.state.selection.eq(o.selection)) && (c = null)) : this.observer.clear(), o.facet(hn.phrases) != this.state.facet(hn.phrases))
      return this.setState(o);
    i = Yp.create(this, o, t), i.flags |= a;
    let d = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of t) {
        if (d && (d = d.map(f.changes)), f.scrollIntoView) {
          let { main: h } = f.state.selection;
          d = new bc(h.empty ? h : st.cursor(h.head, h.head > h.anchor ? -1 : 1));
        }
        for (let h of f.effects)
          h.is(fh) && (d = h.value.clip(this.state));
      }
      this.viewState.update(i, d), this.bidiCache = qp.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), n = this.docView.update(i), this.state.facet(Bu) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(t), this.docView.updateSelection(n, t.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (i.startState.facet(bh) != i.state.facet(bh) && (this.viewState.mustMeasureContent = !0), (n || r || d || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), n && this.docViewUpdate(), !i.empty)
      for (let f of this.state.facet(wy))
        try {
          f(i);
        } catch (h) {
          bi(this.state, h, "update listener");
        }
    (l || c) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), c && !Hk(this, c) && u.force && vc(this.contentDOM, u.key, u.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t;
      return;
    }
    this.updateState = 2;
    let n = this.hasFocus;
    try {
      for (let r of this.plugins)
        r.destroy(this);
      this.viewState = new uO(t), this.plugins = t.facet(Fu).map((r) => new Nv(r)), this.pluginMap.clear();
      for (let r of this.plugins)
        r.update(this);
      this.docView.destroy(), this.docView = new G$(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    n && this.focus(), this.requestMeasure();
  }
  updatePlugins(t) {
    let n = t.startState.facet(Fu), r = t.state.facet(Fu);
    if (n != r) {
      let i = [];
      for (let o of r) {
        let s = n.indexOf(o);
        if (s < 0)
          i.push(new Nv(o));
        else {
          let a = this.plugins[s];
          a.mustUpdate = t, i.push(a);
        }
      }
      for (let o of this.plugins)
        o.mustUpdate != t && o.destroy(this);
      this.plugins = i, this.pluginMap.clear();
    } else
      for (let i of this.plugins)
        i.mustUpdate = t;
    for (let i = 0; i < this.plugins.length; i++)
      this.plugins[i].update(this);
    n != r && this.inputState.ensureHandlers(this.plugins);
  }
  docViewUpdate() {
    for (let t of this.plugins) {
      let n = t.value;
      if (n && n.docViewUpdate)
        try {
          n.docViewUpdate(this);
        } catch (r) {
          bi(this.state, r, "doc view update listener");
        }
    }
  }
  /**
  @internal
  */
  measure(t = !0) {
    if (this.destroyed)
      return;
    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {
      this.measureScheduled = -1, this.requestMeasure();
      return;
    }
    this.measureScheduled = 0, t && this.observer.forceFlush();
    let n = null, r = this.scrollDOM, i = r.scrollTop * this.scaleY, { scrollAnchorPos: o, scrollAnchorHeight: s } = this.viewState;
    Math.abs(i - this.viewState.scrollTop) > 1 && (s = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let a = 0; ; a++) {
        if (s < 0)
          if (QI(r))
            o = -1, s = this.viewState.heightMap.height;
          else {
            let h = this.viewState.scrollAnchorAt(i);
            o = h.from, s = h.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let u = [];
        l & 4 || ([this.measureRequests, u] = [u, this.measureRequests]);
        let c = u.map((h) => {
          try {
            return h.read(this);
          } catch (p) {
            return bi(this.state, p), gO;
          }
        }), d = Yp.create(this, this.state, []), f = !1;
        d.flags |= l, n ? n.flags |= l : n = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), f = this.docView.update(d), f && this.docViewUpdate());
        for (let h = 0; h < u.length; h++)
          if (c[h] != gO)
            try {
              let p = u[h];
              p.write && p.write(c[h], this);
            } catch (p) {
              bi(this.state, p);
            }
        if (f && this.docView.updateSelection(!0), !d.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, s = -1;
              continue;
            } else {
              let p = (o < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(o).top) - s;
              if (p > 1 || p < -1) {
                i = i + p, r.scrollTop = i / this.scaleY, s = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (n && !n.empty)
      for (let a of this.state.facet(wy))
        a(n);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return Ey + " " + (this.state.facet(xy) ? jk : Bk) + " " + this.state.facet(bh);
  }
  updateAttrs() {
    let t = mO(this, Sk, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), n = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(bm) ? "true" : "false",
      class: "cm-content",
      style: `${ft.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (n["aria-readonly"] = "true"), mO(this, iC, n);
    let r = this.observer.ignore(() => {
      let i = gy(this.contentDOM, this.contentAttrs, n), o = gy(this.dom, this.editorAttrs, t);
      return i || o;
    });
    return this.editorAttrs = t, this.contentAttrs = n, r;
  }
  showAnnouncements(t) {
    let n = !0;
    for (let r of t)
      for (let i of r.effects)
        if (i.is(Vt.announce)) {
          n && (this.announceDOM.textContent = ""), n = !1;
          let o = this.announceDOM.appendChild(document.createElement("div"));
          o.textContent = i.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Bu);
    let t = this.state.facet(Vt.cspNonce);
    fa.mount(this.root, this.styleModules.concat(VZ).reverse(), t ? { nonce: t } : void 0);
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(t) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t) {
      if (this.measureRequests.indexOf(t) > -1)
        return;
      if (t.key != null) {
        for (let n = 0; n < this.measureRequests.length; n++)
          if (this.measureRequests[n].key === t.key) {
            this.measureRequests[n] = t;
            return;
          }
      }
      this.measureRequests.push(t);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(t) {
    let n = this.pluginMap.get(t);
    return (n === void 0 || n && n.spec != t) && this.pluginMap.set(t, n = this.plugins.find((r) => r.spec == t) || null), n && n.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  If the editor is transformed with CSS, this provides the scale
  along the X axis. Otherwise, it will just be 1. Note that
  transforms other than translation and scaling are not supported.
  */
  get scaleX() {
    return this.viewState.scaleX;
  }
  /**
  Provide the CSS transformed scale along the Y axis.
  */
  get scaleY() {
    return this.viewState.scaleY;
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(t) {
    return this.readMeasured(), this.viewState.elementAtHeight(t);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(t) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(t) {
    return this.viewState.lineBlockAt(t);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(t, n, r) {
    return Fv(this, t, Z$(this, t, n, r));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(t, n) {
    return Fv(this, t, Z$(this, t, n, (r) => fZ(this, t.head, r)));
  }
  /**
  Get the cursor position visually at the start or end of a line.
  Note that this may differ from the _logical_ position at its
  start or end (which is simply at `line.from`/`line.to`) if text
  at the start or end goes against the line's base text direction.
  */
  visualLineSide(t, n) {
    let r = this.bidiSpans(t), i = this.textDirectionAt(t.from), o = r[n ? r.length - 1 : 0];
    return st.cursor(o.side(n, i) + t.from, o.forward(!n, i) ? 1 : -1);
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(t, n, r = !0) {
    return dZ(this, t, n, r);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(t, n, r) {
    return Fv(this, t, hZ(this, t, n, r));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(t) {
    return this.docView.domAtPos(t);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(t, n = 0) {
    return this.docView.posFromDOM(t, n);
  }
  posAtCoords(t, n = !0) {
    return this.readMeasured(), Dk(this, t, n);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(t, n = 1) {
    this.readMeasured();
    let r = this.docView.coordsAt(t, n);
    if (!r || r.left == r.right)
      return r;
    let i = this.state.doc.lineAt(t), o = this.bidiSpans(i), s = o[Zs.find(o, t - i.from, -1, n)];
    return gm(r, s.dir == ar.LTR == n > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(t) {
    return this.readMeasured(), this.docView.coordsForChar(t);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(t) {
    return !this.state.facet(wk) || t < this.viewport.from || t > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(t) {
    if (t.length > eJ)
      return fk(t.length);
    let n = this.textDirectionAt(t.from), r;
    for (let o of this.bidiCache)
      if (o.from == t.from && o.dir == n && (o.fresh || dk(o.isolates, r = U$(this, t))))
        return o.order;
    r || (r = U$(this, t));
    let i = KQ(t.text, n, r);
    return this.bidiCache.push(new qp(t.from, t.to, n, r, !0, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var t;
    return (this.dom.ownerDocument.hasFocus() || ft.safari && ((t = this.inputState) === null || t === void 0 ? void 0 : t.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      YI(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(t) {
    this._root != t && (this._root = t, this.observer.setWindow((t.nodeType == 9 ? t : t.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let t of this.plugins)
      t.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(t, n = {}) {
    return fh.of(new bc(typeof t == "number" ? st.cursor(t) : t, n.y, n.x, n.yMargin, n.xMargin));
  }
  /**
  Return an effect that resets the editor to its current (at the
  time this method was called) scroll position. Note that this
  only affects the editor's own scrollable element, not parents.
  See also
  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).
  
  The effect should be used with a document identical to the one
  it was created for. Failing to do so is not an error, but may
  not scroll to the expected position. You can
  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.
  */
  scrollSnapshot() {
    let { scrollTop: t, scrollLeft: n } = this.scrollDOM, r = this.viewState.scrollAnchorAt(t);
    return fh.of(new bc(st.cursor(r.from), "start", "start", r.top - t, n, !0));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(t) {
    return Ao.define(() => ({}), { eventHandlers: t });
  }
  /**
  Create an extension that registers DOM event observers. Contrary
  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),
  observers can't be prevented from running by a higher-precedence
  handler returning true. They also don't prevent other handlers
  and observers from running when they return true, and should not
  call `preventDefault`.
  */
  static domEventObservers(t) {
    return Ao.define(() => ({}), { eventObservers: t });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
  addedneed to be explicitly differentiated by adding an `&` to
  the selector for that elementfor example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(t, n) {
    let r = fa.newName(), i = [bh.of(r), Bu.of($y(`.${r}`, t))];
    return n && n.dark && i.push(xy.of(!0)), i;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(t) {
    return Df.lowest(Bu.of($y("." + Ey, t, zk)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(t) {
    var n;
    let r = t.querySelector(".cm-content"), i = r && Cn.get(r) || Cn.get(t);
    return ((n = i == null ? void 0 : i.rootView) === null || n === void 0 ? void 0 : n.view) || null;
  }
}
Vt.styleModule = Bu;
Vt.inputHandler = bk;
Vt.scrollHandler = Ck;
Vt.focusChangeEffect = yk;
Vt.perLineTextDirection = wk;
Vt.exceptionSink = vk;
Vt.updateListener = wy;
Vt.editable = bm;
Vt.mouseSelectionStyle = mk;
Vt.dragMovesSelection = gk;
Vt.clickAddsSelectionRange = pk;
Vt.decorations = Fd;
Vt.outerDecorations = xk;
Vt.atomicRanges = oC;
Vt.bidiIsolatedRanges = Ek;
Vt.scrollMargins = $k;
Vt.darkTheme = xy;
Vt.cspNonce = /* @__PURE__ */ Pt.define({ combine: (e) => e.length ? e[0] : "" });
Vt.contentAttributes = iC;
Vt.editorAttributes = Sk;
Vt.lineWrapping = /* @__PURE__ */ Vt.contentAttributes.of({ class: "cm-lineWrapping" });
Vt.announce = /* @__PURE__ */ In.define();
const eJ = 4096, gO = {};
class qp {
  constructor(t, n, r, i, o, s) {
    this.from = t, this.to = n, this.dir = r, this.isolates = i, this.fresh = o, this.order = s;
  }
  static update(t, n) {
    if (n.empty && !t.some((o) => o.fresh))
      return t;
    let r = [], i = t.length ? t[t.length - 1].dir : ar.LTR;
    for (let o = Math.max(0, t.length - 10); o < t.length; o++) {
      let s = t[o];
      s.dir == i && !n.touchesRange(s.from, s.to) && r.push(new qp(n.mapPos(s.from, 1), n.mapPos(s.to, -1), s.dir, s.isolates, !1, s.order));
    }
    return r;
  }
}
function mO(e, t, n) {
  for (let r = e.state.facet(t), i = r.length - 1; i >= 0; i--) {
    let o = r[i], s = typeof o == "function" ? o(e) : o;
    s && py(s, n);
  }
  return n;
}
const tJ = ft.mac ? "mac" : ft.windows ? "win" : ft.linux ? "linux" : "key";
function nJ(e, t) {
  const n = e.split(/-(?!$)/);
  let r = n[n.length - 1];
  r == "Space" && (r = " ");
  let i, o, s, a;
  for (let l = 0; l < n.length - 1; ++l) {
    const u = n[l];
    if (/^(cmd|meta|m)$/i.test(u))
      a = !0;
    else if (/^a(lt)?$/i.test(u))
      i = !0;
    else if (/^(c|ctrl|control)$/i.test(u))
      o = !0;
    else if (/^s(hift)?$/i.test(u))
      s = !0;
    else if (/^mod$/i.test(u))
      t == "mac" ? a = !0 : o = !0;
    else
      throw new Error("Unrecognized modifier name: " + u);
  }
  return i && (r = "Alt-" + r), o && (r = "Ctrl-" + r), a && (r = "Meta-" + r), s && (r = "Shift-" + r), r;
}
function yh(e, t, n) {
  return t.altKey && (e = "Alt-" + e), t.ctrlKey && (e = "Ctrl-" + e), t.metaKey && (e = "Meta-" + e), n !== !1 && t.shiftKey && (e = "Shift-" + e), e;
}
const rJ = /* @__PURE__ */ Df.default(/* @__PURE__ */ Vt.domEventHandlers({
  keydown(e, t) {
    return aJ(iJ(t.state), e, t, "editor");
  }
})), aC = /* @__PURE__ */ Pt.define({ enables: rJ }), vO = /* @__PURE__ */ new WeakMap();
function iJ(e) {
  let t = e.facet(aC), n = vO.get(t);
  return n || vO.set(t, n = sJ(t.reduce((r, i) => r.concat(i), []))), n;
}
let Gs = null;
const oJ = 4e3;
function sJ(e, t = tJ) {
  let n = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), i = (s, a) => {
    let l = r[s];
    if (l == null)
      r[s] = a;
    else if (l != a)
      throw new Error("Key binding " + s + " is used both as a regular binding and as a multi-stroke prefix");
  }, o = (s, a, l, u, c) => {
    var d, f;
    let h = n[s] || (n[s] = /* @__PURE__ */ Object.create(null)), p = a.split(/ (?!$)/).map((v) => nJ(v, t));
    for (let v = 1; v < p.length; v++) {
      let b = p.slice(0, v).join(" ");
      i(b, !0), h[b] || (h[b] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(x) => {
          let w = Gs = { view: x, prefix: b, scope: s };
          return setTimeout(() => {
            Gs == w && (Gs = null);
          }, oJ), !0;
        }]
      });
    }
    let g = p.join(" ");
    i(g, !1);
    let m = h[g] || (h[g] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (d = h._any) === null || d === void 0 ? void 0 : d.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    l && m.run.push(l), u && (m.preventDefault = !0), c && (m.stopPropagation = !0);
  };
  for (let s of e) {
    let a = s.scope ? s.scope.split(" ") : ["editor"];
    if (s.any)
      for (let u of a) {
        let c = n[u] || (n[u] = /* @__PURE__ */ Object.create(null));
        c._any || (c._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let d in c)
          c[d].run.push(s.any);
      }
    let l = s[t] || s.key;
    if (l)
      for (let u of a)
        o(u, l, s.run, s.preventDefault, s.stopPropagation), s.shift && o(u, "Shift-" + l, s.shift, s.preventDefault, s.stopPropagation);
  }
  return n;
}
function aJ(e, t, n, r) {
  let i = DQ(t), o = ei(i, 0), s = ho(o) == i.length && i != " ", a = "", l = !1, u = !1, c = !1;
  Gs && Gs.view == n && Gs.scope == r && (a = Gs.prefix + " ", Tk.indexOf(t.keyCode) < 0 && (u = !0, Gs = null));
  let d = /* @__PURE__ */ new Set(), f = (m) => {
    if (m) {
      for (let v of m.run)
        if (!d.has(v) && (d.add(v), v(n, t)))
          return m.stopPropagation && (c = !0), !0;
      m.preventDefault && (m.stopPropagation && (c = !0), u = !0);
    }
    return !1;
  }, h = e[r], p, g;
  return h && (f(h[a + yh(i, t, !s)]) ? l = !0 : s && (t.altKey || t.metaKey || t.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(ft.windows && t.ctrlKey && t.altKey) && (p = ha[t.keyCode]) && p != i ? (f(h[a + yh(p, t, !0)]) || t.shiftKey && (g = Ld[t.keyCode]) != i && g != p && f(h[a + yh(g, t, !1)])) && (l = !0) : s && t.shiftKey && f(h[a + yh(i, t, !0)]) && (l = !0), !l && f(h._any) && (l = !0)), u && (l = !0), l && c && t.stopPropagation(), l;
}
const lJ = !ft.ios, bO = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
lJ && (bO[".cm-line"].caretColor = "transparent !important", bO[".cm-content"] = { caretColor: "transparent !important" });
class cJ extends vm {
  constructor(t) {
    super(), this.content = t;
  }
  toDOM() {
    let t = document.createElement("span");
    return t.className = "cm-placeholder", t.style.pointerEvents = "none", t.appendChild(typeof this.content == "string" ? document.createTextNode(this.content) : this.content), typeof this.content == "string" ? t.setAttribute("aria-label", "placeholder " + this.content) : t.setAttribute("aria-hidden", "true"), t;
  }
  coordsAt(t) {
    let n = t.firstChild ? Fc(t.firstChild) : [];
    if (!n.length)
      return null;
    let r = window.getComputedStyle(t.parentNode), i = gm(n[0], r.direction != "rtl"), o = parseInt(r.lineHeight);
    return i.bottom - i.top > o * 1.5 ? { left: i.left, right: i.right, top: i.top, bottom: i.top + o } : i;
  }
  ignoreEvent() {
    return !1;
  }
}
function yO(e) {
  return Ao.fromClass(class {
    constructor(t) {
      this.view = t, this.placeholder = e ? dr.set([dr.widget({ widget: new cJ(e), side: 1 }).range(0)]) : dr.none;
    }
    get decorations() {
      return this.view.state.doc.length ? dr.none : this.placeholder;
    }
  }, { decorations: (t) => t.decorations });
}
const $u = "-10000px";
class Vk {
  constructor(t, n, r, i) {
    this.facet = n, this.createTooltipView = r, this.removeTooltipView = i, this.input = t.state.facet(n), this.tooltips = this.input.filter((s) => s);
    let o = null;
    this.tooltipViews = this.tooltips.map((s) => o = r(s, o));
  }
  update(t, n) {
    var r;
    let i = t.state.facet(this.facet), o = i.filter((l) => l);
    if (i === this.input) {
      for (let l of this.tooltipViews)
        l.update && l.update(t);
      return !1;
    }
    let s = [], a = n ? [] : null;
    for (let l = 0; l < o.length; l++) {
      let u = o[l], c = -1;
      if (u) {
        for (let d = 0; d < this.tooltips.length; d++) {
          let f = this.tooltips[d];
          f && f.create == u.create && (c = d);
        }
        if (c < 0)
          s[l] = this.createTooltipView(u, l ? s[l - 1] : null), a && (a[l] = !!u.above);
        else {
          let d = s[l] = this.tooltipViews[c];
          a && (a[l] = n[c]), d.update && d.update(t);
        }
      }
    }
    for (let l of this.tooltipViews)
      s.indexOf(l) < 0 && (this.removeTooltipView(l), (r = l.destroy) === null || r === void 0 || r.call(l));
    return n && (a.forEach((l, u) => n[u] = l), n.length = a.length), this.input = i, this.tooltips = o, this.tooltipViews = s, !0;
  }
}
function uJ(e) {
  let { win: t } = e;
  return { top: 0, left: 0, bottom: t.innerHeight, right: t.innerWidth };
}
const zv = /* @__PURE__ */ Pt.define({
  combine: (e) => {
    var t, n, r;
    return {
      position: ft.ios ? "absolute" : ((t = e.find((i) => i.position)) === null || t === void 0 ? void 0 : t.position) || "fixed",
      parent: ((n = e.find((i) => i.parent)) === null || n === void 0 ? void 0 : n.parent) || null,
      tooltipSpace: ((r = e.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || uJ
    };
  }
}), wO = /* @__PURE__ */ new WeakMap(), lC = /* @__PURE__ */ Ao.fromClass(class {
  constructor(e) {
    this.view = e, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;
    let t = e.state.facet(zv);
    this.position = t.position, this.parent = t.parent, this.classes = e.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == "function" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new Vk(e, cC, (n, r) => this.createTooltip(n, r), (n) => {
      this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove();
    }), this.above = this.manager.tooltips.map((n) => !!n.above), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((n) => {
      Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), e.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let e of this.manager.tooltipViews)
        this.intersectionObserver.observe(e.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(e) {
    e.transactions.length && (this.lastTransaction = Date.now());
    let t = this.manager.update(e, this.above);
    t && this.observeIntersection();
    let n = t || e.geometryChanged, r = e.state.facet(zv);
    if (r.position != this.position && !this.madeAbsolute) {
      this.position = r.position;
      for (let i of this.manager.tooltipViews)
        i.dom.style.position = this.position;
      n = !0;
    }
    if (r.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();
      for (let i of this.manager.tooltipViews)
        this.container.appendChild(i.dom);
      n = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    n && this.maybeMeasure();
  }
  createTooltip(e, t) {
    let n = e.create(this.view), r = t ? t.dom : null;
    if (n.dom.classList.add("cm-tooltip"), e.arrow && !n.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let i = document.createElement("div");
      i.className = "cm-tooltip-arrow", n.dom.appendChild(i);
    }
    return n.dom.style.position = this.position, n.dom.style.top = $u, n.dom.style.left = "0px", this.container.insertBefore(n.dom, r), n.mount && n.mount(this.view), this.resizeObserver && this.resizeObserver.observe(n.dom), n;
  }
  destroy() {
    var e, t, n;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let r of this.manager.tooltipViews)
      r.dom.remove(), (e = r.destroy) === null || e === void 0 || e.call(r);
    this.parent && this.container.remove(), (t = this.resizeObserver) === null || t === void 0 || t.disconnect(), (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let e = this.view.dom.getBoundingClientRect(), t = 1, n = 1, r = !1;
    if (this.position == "fixed" && this.manager.tooltipViews.length) {
      let { dom: i } = this.manager.tooltipViews[0];
      if (ft.gecko)
        r = i.offsetParent != this.container.ownerDocument.body;
      else if (i.style.top == $u && i.style.left == "0px") {
        let o = i.getBoundingClientRect();
        r = Math.abs(o.top + 1e4) > 1 || Math.abs(o.left) > 1;
      }
    }
    if (r || this.position == "absolute")
      if (this.parent) {
        let i = this.parent.getBoundingClientRect();
        i.width && i.height && (t = i.width / this.parent.offsetWidth, n = i.height / this.parent.offsetHeight);
      } else
        ({ scaleX: t, scaleY: n } = this.view.viewState);
    return {
      editor: e,
      parent: this.parent ? this.container.getBoundingClientRect() : e,
      pos: this.manager.tooltips.map((i, o) => {
        let s = this.manager.tooltipViews[o];
        return s.getCoords ? s.getCoords(i.pos) : this.view.coordsAtPos(i.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: i }) => i.getBoundingClientRect()),
      space: this.view.state.facet(zv).tooltipSpace(this.view),
      scaleX: t,
      scaleY: n,
      makeAbsolute: r
    };
  }
  writeMeasure(e) {
    var t;
    if (e.makeAbsolute) {
      this.madeAbsolute = !0, this.position = "absolute";
      for (let a of this.manager.tooltipViews)
        a.dom.style.position = "absolute";
    }
    let { editor: n, space: r, scaleX: i, scaleY: o } = e, s = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let l = this.manager.tooltips[a], u = this.manager.tooltipViews[a], { dom: c } = u, d = e.pos[a], f = e.size[a];
      if (!d || d.bottom <= Math.max(n.top, r.top) || d.top >= Math.min(n.bottom, r.bottom) || d.right < Math.max(n.left, r.left) - 0.1 || d.left > Math.min(n.right, r.right) + 0.1) {
        c.style.top = $u;
        continue;
      }
      let h = l.arrow ? u.dom.querySelector(".cm-tooltip-arrow") : null, p = h ? 7 : 0, g = f.right - f.left, m = (t = wO.get(u)) !== null && t !== void 0 ? t : f.bottom - f.top, v = u.offset || fJ, b = this.view.textDirection == ar.LTR, x = f.width > r.right - r.left ? b ? r.left : r.right - f.width : b ? Math.min(d.left - (h ? 14 : 0) + v.x, r.right - g) : Math.max(r.left, d.left - g + (h ? 14 : 0) - v.x), w = this.above[a];
      !l.strictSide && (w ? d.top - (f.bottom - f.top) - v.y < r.top : d.bottom + (f.bottom - f.top) + v.y > r.bottom) && w == r.bottom - d.bottom > d.top - r.top && (w = this.above[a] = !w);
      let C = (w ? d.top - r.top : r.bottom - d.bottom) - p;
      if (C < m && u.resize !== !1) {
        if (C < this.view.defaultLineHeight) {
          c.style.top = $u;
          continue;
        }
        wO.set(u, m), c.style.height = (m = C) / o + "px";
      } else
        c.style.height && (c.style.height = "");
      let y = w ? d.top - m - p - v.y : d.bottom + p + v.y, S = x + g;
      if (u.overlap !== !0)
        for (let A of s)
          A.left < S && A.right > x && A.top < y + m && A.bottom > y && (y = w ? A.top - m - 2 - p : A.bottom + p + 2);
      if (this.position == "absolute" ? (c.style.top = (y - e.parent.top) / o + "px", c.style.left = (x - e.parent.left) / i + "px") : (c.style.top = y / o + "px", c.style.left = x / i + "px"), h) {
        let A = d.left + (b ? v.x : -v.x) - (x + 14 - 7);
        h.style.left = A / i + "px";
      }
      u.overlap !== !0 && s.push({ left: x, top: y, right: S, bottom: y + m }), c.classList.toggle("cm-tooltip-above", w), c.classList.toggle("cm-tooltip-below", !w), u.positioned && u.positioned(e.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let e of this.manager.tooltipViews)
        e.dom.style.top = $u;
  }
}, {
  eventObservers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), dJ = /* @__PURE__ */ Vt.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), fJ = { x: 0, y: 0 }, cC = /* @__PURE__ */ Pt.define({
  enables: [lC, dJ]
}), Qp = /* @__PURE__ */ Pt.define({
  combine: (e) => e.reduce((t, n) => t.concat(n), [])
});
class ym {
  // Needs to be static so that host tooltip instances always match
  static create(t) {
    return new ym(t);
  }
  constructor(t) {
    this.view = t, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new Vk(t, Qp, (n, r) => this.createHostedView(n, r), (n) => n.dom.remove());
  }
  createHostedView(t, n) {
    let r = t.create(this.view);
    return r.dom.classList.add("cm-tooltip-section"), this.dom.insertBefore(r.dom, n ? n.dom.nextSibling : this.dom.firstChild), this.mounted && r.mount && r.mount(this.view), r;
  }
  mount(t) {
    for (let n of this.manager.tooltipViews)
      n.mount && n.mount(t);
    this.mounted = !0;
  }
  positioned(t) {
    for (let n of this.manager.tooltipViews)
      n.positioned && n.positioned(t);
  }
  update(t) {
    this.manager.update(t);
  }
  destroy() {
    var t;
    for (let n of this.manager.tooltipViews)
      (t = n.destroy) === null || t === void 0 || t.call(n);
  }
  passProp(t) {
    let n;
    for (let r of this.manager.tooltipViews) {
      let i = r[t];
      if (i !== void 0) {
        if (n === void 0)
          n = i;
        else if (n !== i)
          return;
      }
    }
    return n;
  }
  get offset() {
    return this.passProp("offset");
  }
  get getCoords() {
    return this.passProp("getCoords");
  }
  get overlap() {
    return this.passProp("overlap");
  }
  get resize() {
    return this.passProp("resize");
  }
}
const hJ = /* @__PURE__ */ cC.compute([Qp], (e) => {
  let t = e.facet(Qp);
  return t.length === 0 ? null : {
    pos: Math.min(...t.map((n) => n.pos)),
    end: Math.max(...t.map((n) => {
      var r;
      return (r = n.end) !== null && r !== void 0 ? r : n.pos;
    })),
    create: ym.create,
    above: t[0].above,
    arrow: t.some((n) => n.arrow)
  };
});
class pJ {
  constructor(t, n, r, i, o) {
    this.view = t, this.source = n, this.field = r, this.setHover = i, this.hoverTime = o, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: t.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), t.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), t.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active.length)
      return;
    let t = Date.now() - this.lastMove.time;
    t < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - t) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { view: t, lastMove: n } = this, r = t.docView.nearest(n.target);
    if (!r)
      return;
    let i, o = 1;
    if (r instanceof Qs)
      i = r.posAtStart;
    else {
      if (i = t.posAtCoords(n), i == null)
        return;
      let a = t.coordsAtPos(i);
      if (!a || n.y < a.top || n.y > a.bottom || n.x < a.left - t.defaultCharacterWidth || n.x > a.right + t.defaultCharacterWidth)
        return;
      let l = t.bidiSpans(t.state.doc.lineAt(i)).find((c) => c.from <= i && c.to >= i), u = l && l.dir == ar.RTL ? -1 : 1;
      o = n.x < a.left ? -u : u;
    }
    let s = this.source(t, i, o);
    if (s != null && s.then) {
      let a = this.pending = { pos: i };
      s.then((l) => {
        this.pending == a && (this.pending = null, l && !(Array.isArray(l) && !l.length) && t.dispatch({ effects: this.setHover.of(Array.isArray(l) ? l : [l]) }));
      }, (l) => bi(t.state, l, "hover tooltip"));
    } else
      s && !(Array.isArray(s) && !s.length) && t.dispatch({ effects: this.setHover.of(Array.isArray(s) ? s : [s]) });
  }
  get tooltip() {
    let t = this.view.plugin(lC), n = t ? t.manager.tooltips.findIndex((r) => r.create == ym.create) : -1;
    return n > -1 ? t.manager.tooltipViews[n] : null;
  }
  mousemove(t) {
    var n, r;
    this.lastMove = { x: t.clientX, y: t.clientY, target: t.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let { active: i, tooltip: o } = this;
    if (i.length && o && !gJ(o.dom, t) || this.pending) {
      let { pos: s } = i[0] || this.pending, a = (r = (n = i[0]) === null || n === void 0 ? void 0 : n.end) !== null && r !== void 0 ? r : s;
      (s == a ? this.view.posAtCoords(this.lastMove) != s : !mJ(this.view, s, a, t.clientX, t.clientY)) && (this.view.dispatch({ effects: this.setHover.of([]) }), this.pending = null);
    }
  }
  mouseleave(t) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1;
    let { active: n } = this;
    if (n.length) {
      let { tooltip: r } = this;
      r && r.dom.contains(t.relatedTarget) ? this.watchTooltipLeave(r.dom) : this.view.dispatch({ effects: this.setHover.of([]) });
    }
  }
  watchTooltipLeave(t) {
    let n = (r) => {
      t.removeEventListener("mouseleave", n), this.active.length && !this.view.dom.contains(r.relatedTarget) && this.view.dispatch({ effects: this.setHover.of([]) });
    };
    t.addEventListener("mouseleave", n);
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
const wh = 4;
function gJ(e, t) {
  let n = e.getBoundingClientRect();
  return t.clientX >= n.left - wh && t.clientX <= n.right + wh && t.clientY >= n.top - wh && t.clientY <= n.bottom + wh;
}
function mJ(e, t, n, r, i, o) {
  let s = e.scrollDOM.getBoundingClientRect(), a = e.documentTop + e.documentPadding.top + e.contentHeight;
  if (s.left > r || s.right < r || s.top > i || Math.min(s.bottom, a) < i)
    return !1;
  let l = e.posAtCoords({ x: r, y: i }, !1);
  return l >= t && l <= n;
}
function vJ(e, t = {}) {
  let n = In.define(), r = Zo.define({
    create() {
      return [];
    },
    update(i, o) {
      if (i.length && (t.hideOnChange && (o.docChanged || o.selection) ? i = [] : t.hideOn && (i = i.filter((s) => !t.hideOn(o, s))), o.docChanged)) {
        let s = [];
        for (let a of i) {
          let l = o.changes.mapPos(a.pos, -1, ni.TrackDel);
          if (l != null) {
            let u = Object.assign(/* @__PURE__ */ Object.create(null), a);
            u.pos = l, u.end != null && (u.end = o.changes.mapPos(u.end)), s.push(u);
          }
        }
        i = s;
      }
      for (let s of o.effects)
        s.is(n) && (i = s.value), s.is(bJ) && (i = []);
      return i;
    },
    provide: (i) => Qp.from(i)
  });
  return [
    r,
    Ao.define((i) => new pJ(
      i,
      e,
      r,
      n,
      t.hoverTime || 300
      /* Hover.Time */
    )),
    hJ
  ];
}
function Wk(e, t) {
  let n = e.plugin(lC);
  if (!n)
    return null;
  let r = n.manager.tooltips.indexOf(t);
  return r < 0 ? null : n.manager.tooltipViews[r];
}
const bJ = /* @__PURE__ */ In.define();
class zc extends rl {
  /**
  @internal
  */
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(t) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(t) {
  }
}
zc.prototype.elementClass = "";
zc.prototype.toDOM = void 0;
zc.prototype.mapMode = ni.TrackBefore;
zc.prototype.startSide = zc.prototype.endSide = -1;
zc.prototype.point = !0;
const Uk = 1024;
let yJ = 0;
class Zi {
  constructor(t, n) {
    this.from = t, this.to = n;
  }
}
class on {
  /**
  Create a new node prop type.
  */
  constructor(t = {}) {
    this.id = yJ++, this.perNode = !!t.perNode, this.deserialize = t.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(t) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof t != "function" && (t = ai.match(t)), (n) => {
      let r = t(n);
      return r === void 0 ? null : [this, r];
    };
  }
}
on.closedBy = new on({ deserialize: (e) => e.split(" ") });
on.openedBy = new on({ deserialize: (e) => e.split(" ") });
on.group = new on({ deserialize: (e) => e.split(" ") });
on.isolate = new on({ deserialize: (e) => {
  if (e && e != "rtl" && e != "ltr" && e != "auto")
    throw new RangeError("Invalid value for isolate: " + e);
  return e || "auto";
} });
on.contextHash = new on({ perNode: !0 });
on.lookAhead = new on({ perNode: !0 });
on.mounted = new on({ perNode: !0 });
class Bd {
  constructor(t, n, r) {
    this.tree = t, this.overlay = n, this.parser = r;
  }
  /**
  @internal
  */
  static get(t) {
    return t && t.props && t.props[on.mounted.id];
  }
}
const wJ = /* @__PURE__ */ Object.create(null);
class ai {
  /**
  @internal
  */
  constructor(t, n, r, i = 0) {
    this.name = t, this.props = n, this.id = r, this.flags = i;
  }
  /**
  Define a node type.
  */
  static define(t) {
    let n = t.props && t.props.length ? /* @__PURE__ */ Object.create(null) : wJ, r = (t.top ? 1 : 0) | (t.skipped ? 2 : 0) | (t.error ? 4 : 0) | (t.name == null ? 8 : 0), i = new ai(t.name || "", n, t.id, r);
    if (t.props) {
      for (let o of t.props)
        if (Array.isArray(o) || (o = o(i)), o) {
          if (o[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          n[o[0].id] = o[1];
        }
    }
    return i;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(t) {
    return this.props[t.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(t) {
    if (typeof t == "string") {
      if (this.name == t)
        return !0;
      let n = this.prop(on.group);
      return n ? n.indexOf(t) > -1 : !1;
    }
    return this.id == t;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(t) {
    let n = /* @__PURE__ */ Object.create(null);
    for (let r in t)
      for (let i of r.split(" "))
        n[i] = t[r];
    return (r) => {
      for (let i = r.prop(on.group), o = -1; o < (i ? i.length : 0); o++) {
        let s = n[o < 0 ? r.name : i[o]];
        if (s)
          return s;
      }
    };
  }
}
ai.none = new ai(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class uC {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(t) {
    this.types = t;
    for (let n = 0; n < t.length; n++)
      if (t[n].id != n)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...t) {
    let n = [];
    for (let r of this.types) {
      let i = null;
      for (let o of t) {
        let s = o(r);
        s && (i || (i = Object.assign({}, r.props)), i[s[0].id] = s[1]);
      }
      n.push(i ? new ai(r.name, i, r.id, r.flags) : r);
    }
    return new uC(n);
  }
}
const Ch = /* @__PURE__ */ new WeakMap(), CO = /* @__PURE__ */ new WeakMap();
var Ln;
(function(e) {
  e[e.ExcludeBuffers = 1] = "ExcludeBuffers", e[e.IncludeAnonymous = 2] = "IncludeAnonymous", e[e.IgnoreMounts = 4] = "IgnoreMounts", e[e.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Ln || (Ln = {}));
class Wn {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(t, n, r, i, o) {
    if (this.type = t, this.children = n, this.positions = r, this.length = i, this.props = null, o && o.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [s, a] of o)
        this.props[typeof s == "number" ? s : s.id] = a;
    }
  }
  /**
  @internal
  */
  toString() {
    let t = Bd.get(this);
    if (t && !t.overlay)
      return t.tree.toString();
    let n = "";
    for (let r of this.children) {
      let i = r.toString();
      i && (n && (n += ","), n += i);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? "(" + n + ")" : "") : n;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(t = 0) {
    return new Zp(this.topNode, t);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(t, n = 0, r = 0) {
    let i = Ch.get(this) || this.topNode, o = new Zp(i);
    return o.moveTo(t, n), Ch.set(this, o._tree), o;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Si(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(t, n = 0) {
    let r = jd(Ch.get(this) || this.topNode, t, n, !1);
    return Ch.set(this, r), r;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(t, n = 0) {
    let r = jd(CO.get(this) || this.topNode, t, n, !0);
    return CO.set(this, r), r;
  }
  /**
  In some situations, it can be useful to iterate through all
  nodes around a position, including those in overlays that don't
  directly cover the position. This method gives you an iterator
  that will produce all nodes, from small to big, around the given
  position.
  */
  resolveStack(t, n = 0) {
    return xJ(this, t, n);
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(t) {
    let { enter: n, leave: r, from: i = 0, to: o = this.length } = t, s = t.mode || 0, a = (s & Ln.IncludeAnonymous) > 0;
    for (let l = this.cursor(s | Ln.IncludeAnonymous); ; ) {
      let u = !1;
      if (l.from <= o && l.to >= i && (!a && l.type.isAnonymous || n(l) !== !1)) {
        if (l.firstChild())
          continue;
        u = !0;
      }
      for (; u && r && (a || !l.type.isAnonymous) && r(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        u = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(t) {
    return t.perNode ? this.props ? this.props[t.id] : void 0 : this.type.prop(t);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let t = [];
    if (this.props)
      for (let n in this.props)
        t.push([+n, this.props[n]]);
    return t;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(t = {}) {
    return this.children.length <= 8 ? this : hC(ai.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, r, i) => new Wn(this.type, n, r, i, this.propValues), t.makeTree || ((n, r, i) => new Wn(ai.none, n, r, i)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(t) {
    return EJ(t);
  }
}
Wn.empty = new Wn(ai.none, [], [], 0);
class dC {
  constructor(t, n) {
    this.buffer = t, this.index = n;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new dC(this.buffer, this.index);
  }
}
class ga {
  /**
  Create a tree buffer.
  */
  constructor(t, n, r) {
    this.buffer = t, this.length = n, this.set = r;
  }
  /**
  @internal
  */
  get type() {
    return ai.none;
  }
  /**
  @internal
  */
  toString() {
    let t = [];
    for (let n = 0; n < this.buffer.length; )
      t.push(this.childString(n)), n = this.buffer[n + 3];
    return t.join(",");
  }
  /**
  @internal
  */
  childString(t) {
    let n = this.buffer[t], r = this.buffer[t + 3], i = this.set.types[n], o = i.name;
    if (/\W/.test(o) && !i.isError && (o = JSON.stringify(o)), t += 4, r == t)
      return o;
    let s = [];
    for (; t < r; )
      s.push(this.childString(t)), t = this.buffer[t + 3];
    return o + "(" + s.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(t, n, r, i, o) {
    let { buffer: s } = this, a = -1;
    for (let l = t; l != n && !(Gk(o, i, s[l + 1], s[l + 2]) && (a = l, r > 0)); l = s[l + 3])
      ;
    return a;
  }
  /**
  @internal
  */
  slice(t, n, r) {
    let i = this.buffer, o = new Uint16Array(n - t), s = 0;
    for (let a = t, l = 0; a < n; ) {
      o[l++] = i[a++], o[l++] = i[a++] - r;
      let u = o[l++] = i[a++] - r;
      o[l++] = i[a++] - t, s = Math.max(s, u);
    }
    return new ga(o, s, this.set);
  }
}
function Gk(e, t, n, r) {
  switch (e) {
    case -2:
      return n < t;
    case -1:
      return r >= t && n < t;
    case 0:
      return n < t && r > t;
    case 1:
      return n <= t && r > t;
    case 2:
      return r > t;
    case 4:
      return !0;
  }
}
function jd(e, t, n, r) {
  for (var i; e.from == e.to || (n < 1 ? e.from >= t : e.from > t) || (n > -1 ? e.to <= t : e.to < t); ) {
    let s = !r && e instanceof Si && e.index < 0 ? null : e.parent;
    if (!s)
      return e;
    e = s;
  }
  let o = r ? 0 : Ln.IgnoreOverlays;
  if (r)
    for (let s = e, a = s.parent; a; s = a, a = s.parent)
      s instanceof Si && s.index < 0 && ((i = a.enter(t, n, o)) === null || i === void 0 ? void 0 : i.from) != s.from && (e = a);
  for (; ; ) {
    let s = e.enter(t, n, o);
    if (!s)
      return e;
    e = s;
  }
}
class Kk {
  cursor(t = 0) {
    return new Zp(this, t);
  }
  getChild(t, n = null, r = null) {
    let i = SO(this, t, n, r);
    return i.length ? i[0] : null;
  }
  getChildren(t, n = null, r = null) {
    return SO(this, t, n, r);
  }
  resolve(t, n = 0) {
    return jd(this, t, n, !1);
  }
  resolveInner(t, n = 0) {
    return jd(this, t, n, !0);
  }
  matchContext(t) {
    return Oy(this, t);
  }
  enterUnfinishedNodesBefore(t) {
    let n = this.childBefore(t), r = this;
    for (; n; ) {
      let i = n.lastChild;
      if (!i || i.to != n.to)
        break;
      i.type.isError && i.from == i.to ? (r = n, n = i.prevSibling) : n = i;
    }
    return r;
  }
  get node() {
    return this;
  }
  get next() {
    return this.parent;
  }
}
class Si extends Kk {
  constructor(t, n, r, i) {
    super(), this._tree = t, this.from = n, this.index = r, this._parent = i;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(t, n, r, i, o = 0) {
    for (let s = this; ; ) {
      for (let { children: a, positions: l } = s._tree, u = n > 0 ? a.length : -1; t != u; t += n) {
        let c = a[t], d = l[t] + s.from;
        if (Gk(i, r, d, d + c.length)) {
          if (c instanceof ga) {
            if (o & Ln.ExcludeBuffers)
              continue;
            let f = c.findChild(0, c.buffer.length, n, r - d, i);
            if (f > -1)
              return new Js(new CJ(s, c, t, d), null, f);
          } else if (o & Ln.IncludeAnonymous || !c.type.isAnonymous || fC(c)) {
            let f;
            if (!(o & Ln.IgnoreMounts) && (f = Bd.get(c)) && !f.overlay)
              return new Si(f.tree, d, t, s);
            let h = new Si(c, d, t, s);
            return o & Ln.IncludeAnonymous || !h.type.isAnonymous ? h : h.nextChild(n < 0 ? c.children.length - 1 : 0, n, r, i);
          }
        }
      }
      if (o & Ln.IncludeAnonymous || !s.type.isAnonymous || (s.index >= 0 ? t = s.index + n : t = n < 0 ? -1 : s._parent._tree.children.length, s = s._parent, !s))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.nextChild(
      0,
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  enter(t, n, r = 0) {
    let i;
    if (!(r & Ln.IgnoreOverlays) && (i = Bd.get(this._tree)) && i.overlay) {
      let o = t - this.from;
      for (let { from: s, to: a } of i.overlay)
        if ((n > 0 ? s <= o : s < o) && (n < 0 ? a >= o : a > o))
          return new Si(i.tree, i.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, t, n, r);
  }
  nextSignificantParent() {
    let t = this;
    for (; t.type.isAnonymous && t._parent; )
      t = t._parent;
    return t;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
}
function SO(e, t, n, r) {
  let i = e.cursor(), o = [];
  if (!i.firstChild())
    return o;
  if (n != null) {
    for (let s = !1; !s; )
      if (s = i.type.is(n), !i.nextSibling())
        return o;
  }
  for (; ; ) {
    if (r != null && i.type.is(r))
      return o;
    if (i.type.is(t) && o.push(i.node), !i.nextSibling())
      return r == null ? o : [];
  }
}
function Oy(e, t, n = t.length - 1) {
  for (let r = e.parent; n >= 0; r = r.parent) {
    if (!r)
      return !1;
    if (!r.type.isAnonymous) {
      if (t[n] && t[n] != r.name)
        return !1;
      n--;
    }
  }
  return !0;
}
class CJ {
  constructor(t, n, r, i) {
    this.parent = t, this.buffer = n, this.index = r, this.start = i;
  }
}
class Js extends Kk {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(t, n, r) {
    super(), this.context = t, this._parent = n, this.index = r, this.type = t.buffer.set.types[t.buffer.buffer[r]];
  }
  child(t, n, r) {
    let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], t, n - this.context.start, r);
    return o < 0 ? null : new Js(this.context, this, o);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(t) {
    return this.child(
      1,
      t,
      2
      /* Side.After */
    );
  }
  childBefore(t) {
    return this.child(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  enter(t, n, r = 0) {
    if (r & Ln.ExcludeBuffers)
      return null;
    let { buffer: i } = this.context, o = i.findChild(this.index + 4, i.buffer[this.index + 3], n > 0 ? 1 : -1, t - this.context.start, n);
    return o < 0 ? null : new Js(this.context, this, o);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(t) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + t,
      t,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: t } = this.context, n = t.buffer[this.index + 3];
    return n < (this._parent ? t.buffer[this._parent.index + 3] : t.buffer.length) ? new Js(this.context, this._parent, n) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: t } = this.context, n = this._parent ? this._parent.index + 4 : 0;
    return this.index == n ? this.externalSibling(-1) : new Js(this.context, this._parent, t.findChild(
      n,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  get tree() {
    return null;
  }
  toTree() {
    let t = [], n = [], { buffer: r } = this.context, i = this.index + 4, o = r.buffer[this.index + 3];
    if (o > i) {
      let s = r.buffer[this.index + 1];
      t.push(r.slice(i, o, s)), n.push(0);
    }
    return new Wn(this.type, t, n, this.to - this.from);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
}
function Xk(e) {
  if (!e.length)
    return null;
  let t = 0, n = e[0];
  for (let o = 1; o < e.length; o++) {
    let s = e[o];
    (s.from > n.from || s.to < n.to) && (n = s, t = o);
  }
  let r = n instanceof Si && n.index < 0 ? null : n.parent, i = e.slice();
  return r ? i[t] = r : i.splice(t, 1), new SJ(i, n);
}
class SJ {
  constructor(t, n) {
    this.heads = t, this.node = n;
  }
  get next() {
    return Xk(this.heads);
  }
}
function xJ(e, t, n) {
  let r = e.resolveInner(t, n), i = null;
  for (let o = r instanceof Si ? r : r.context.parent; o; o = o.parent)
    if (o.index < 0) {
      let s = o.parent;
      (i || (i = [r])).push(s.resolve(t, n)), o = s;
    } else {
      let s = Bd.get(o.tree);
      if (s && s.overlay && s.overlay[0].from <= t && s.overlay[s.overlay.length - 1].to >= t) {
        let a = new Si(s.tree, s.overlay[0].from + o.from, -1, o);
        (i || (i = [r])).push(jd(a, t, n, !1));
      }
    }
  return i ? Xk(i) : r;
}
class Zp {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(t, n = 0) {
    if (this.mode = n, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, t instanceof Si)
      this.yieldNode(t);
    else {
      this._tree = t.context.parent, this.buffer = t.context;
      for (let r = t._parent; r; r = r._parent)
        this.stack.unshift(r.index);
      this.bufferNode = t, this.yieldBuf(t.index);
    }
  }
  yieldNode(t) {
    return t ? (this._tree = t, this.type = t.type, this.from = t.from, this.to = t.to, !0) : !1;
  }
  yieldBuf(t, n) {
    this.index = t;
    let { start: r, buffer: i } = this.buffer;
    return this.type = n || i.set.types[i.buffer[t]], this.from = r + i.buffer[t + 1], this.to = r + i.buffer[t + 2], !0;
  }
  /**
  @internal
  */
  yield(t) {
    return t ? t instanceof Si ? (this.buffer = null, this.yieldNode(t)) : (this.buffer = t.context, this.yieldBuf(t.index, t.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(t, n, r) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(t < 0 ? this._tree._tree.children.length - 1 : 0, t, n, r, this.mode));
    let { buffer: i } = this.buffer, o = i.findChild(this.index + 4, i.buffer[this.index + 3], t, n - this.buffer.start, r);
    return o < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(o));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(t) {
    return this.enterChild(
      1,
      t,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(t) {
    return this.enterChild(
      -1,
      t,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(t, n, r = this.mode) {
    return this.buffer ? r & Ln.ExcludeBuffers ? !1 : this.enterChild(1, t, n) : this.yield(this._tree.enter(t, n, r));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Ln.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let t = this.mode & Ln.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(t);
  }
  /**
  @internal
  */
  sibling(t) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + t, t, 0, 4, this.mode)) : !1;
    let { buffer: n } = this.buffer, r = this.stack.length - 1;
    if (t < 0) {
      let i = r < 0 ? 0 : this.stack[r] + 4;
      if (this.index != i)
        return this.yieldBuf(n.findChild(
          i,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let i = n.buffer[this.index + 3];
      if (i < (r < 0 ? n.buffer.length : n.buffer[this.stack[r] + 3]))
        return this.yieldBuf(i);
    }
    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + t, t, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(t) {
    let n, r, { buffer: i } = this;
    if (i) {
      if (t > 0) {
        if (this.index < i.buffer.buffer.length)
          return !1;
      } else
        for (let o = 0; o < this.index; o++)
          if (i.buffer.buffer[o + 3] < this.index)
            return !1;
      ({ index: n, parent: r } = i);
    } else
      ({ index: n, _parent: r } = this._tree);
    for (; r; { index: n, _parent: r } = r)
      if (n > -1)
        for (let o = n + t, s = t < 0 ? -1 : r._tree.children.length; o != s; o += t) {
          let a = r._tree.children[o];
          if (this.mode & Ln.IncludeAnonymous || a instanceof ga || !a.type.isAnonymous || fC(a))
            return !1;
        }
    return !0;
  }
  move(t, n) {
    if (n && this.enterChild(
      t,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(t))
        return !0;
      if (this.atLastNode(t) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(t = !0) {
    return this.move(1, t);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(t = !0) {
    return this.move(-1, t);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(t, n = 0) {
    for (; (this.from == this.to || (n < 1 ? this.from >= t : this.from > t) || (n > -1 ? this.to <= t : this.to < t)) && this.parent(); )
      ;
    for (; this.enterChild(1, t, n); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let t = this.bufferNode, n = null, r = 0;
    if (t && t.context == this.buffer)
      e:
        for (let i = this.index, o = this.stack.length; o >= 0; ) {
          for (let s = t; s; s = s._parent)
            if (s.index == i) {
              if (i == this.index)
                return s;
              n = s, r = o + 1;
              break e;
            }
          i = this.stack[--o];
        }
    for (let i = r; i < this.stack.length; i++)
      n = new Js(this.buffer, n, this.stack[i]);
    return this.bufferNode = new Js(this.buffer, n, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(t, n) {
    for (let r = 0; ; ) {
      let i = !1;
      if (this.type.isAnonymous || t(this) !== !1) {
        if (this.firstChild()) {
          r++;
          continue;
        }
        this.type.isAnonymous || (i = !0);
      }
      for (; i && n && n(this), i = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!r)
          return;
        this.parent(), r--, i = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(t) {
    if (!this.buffer)
      return Oy(this.node, t);
    let { buffer: n } = this.buffer, { types: r } = n.set;
    for (let i = t.length - 1, o = this.stack.length - 1; i >= 0; o--) {
      if (o < 0)
        return Oy(this.node, t, i);
      let s = r[n.buffer[this.stack[o]]];
      if (!s.isAnonymous) {
        if (t[i] && t[i] != s.name)
          return !1;
        i--;
      }
    }
    return !0;
  }
}
function fC(e) {
  return e.children.some((t) => t instanceof ga || !t.type.isAnonymous || fC(t));
}
function EJ(e) {
  var t;
  let { buffer: n, nodeSet: r, maxBufferLength: i = Uk, reused: o = [], minRepeatType: s = r.types.length } = e, a = Array.isArray(n) ? new dC(n, n.length) : n, l = r.types, u = 0, c = 0;
  function d(C, y, S, A, $, M) {
    let { id: _, start: T, end: D, size: E } = a, R = c;
    for (; E < 0; )
      if (a.next(), E == -1) {
        let N = o[_];
        S.push(N), A.push(T - C);
        return;
      } else if (E == -3) {
        u = _;
        return;
      } else if (E == -4) {
        c = _;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${E}`);
    let I = l[_], k, P, L = T - C;
    if (D - T <= i && (P = m(a.pos - y, $))) {
      let N = new Uint16Array(P.size - P.skip), F = a.pos - P.size, B = N.length;
      for (; a.pos > F; )
        B = v(P.start, N, B);
      k = new ga(N, D - P.start, r), L = P.start - C;
    } else {
      let N = a.pos - E;
      a.next();
      let F = [], B = [], j = _ >= s ? _ : -1, z = 0, H = D;
      for (; a.pos > N; )
        j >= 0 && a.id == j && a.size >= 0 ? (a.end <= H - i && (p(F, B, T, z, a.end, H, j, R), z = F.length, H = a.end), a.next()) : M > 2500 ? f(T, N, F, B) : d(T, N, F, B, j, M + 1);
      if (j >= 0 && z > 0 && z < F.length && p(F, B, T, z, T, H, j, R), F.reverse(), B.reverse(), j > -1 && z > 0) {
        let W = h(I);
        k = hC(I, F, B, 0, F.length, 0, D - T, W, W);
      } else
        k = g(I, F, B, D - T, R - D);
    }
    S.push(k), A.push(L);
  }
  function f(C, y, S, A) {
    let $ = [], M = 0, _ = -1;
    for (; a.pos > y; ) {
      let { id: T, start: D, end: E, size: R } = a;
      if (R > 4)
        a.next();
      else {
        if (_ > -1 && D < _)
          break;
        _ < 0 && (_ = E - i), $.push(T, D, E), M++, a.next();
      }
    }
    if (M) {
      let T = new Uint16Array(M * 4), D = $[$.length - 2];
      for (let E = $.length - 3, R = 0; E >= 0; E -= 3)
        T[R++] = $[E], T[R++] = $[E + 1] - D, T[R++] = $[E + 2] - D, T[R++] = R;
      S.push(new ga(T, $[2] - D, r)), A.push(D - C);
    }
  }
  function h(C) {
    return (y, S, A) => {
      let $ = 0, M = y.length - 1, _, T;
      if (M >= 0 && (_ = y[M]) instanceof Wn) {
        if (!M && _.type == C && _.length == A)
          return _;
        (T = _.prop(on.lookAhead)) && ($ = S[M] + _.length + T);
      }
      return g(C, y, S, A, $);
    };
  }
  function p(C, y, S, A, $, M, _, T) {
    let D = [], E = [];
    for (; C.length > A; )
      D.push(C.pop()), E.push(y.pop() + S - $);
    C.push(g(r.types[_], D, E, M - $, T - M)), y.push($ - S);
  }
  function g(C, y, S, A, $ = 0, M) {
    if (u) {
      let _ = [on.contextHash, u];
      M = M ? [_].concat(M) : [_];
    }
    if ($ > 25) {
      let _ = [on.lookAhead, $];
      M = M ? [_].concat(M) : [_];
    }
    return new Wn(C, y, S, A, M);
  }
  function m(C, y) {
    let S = a.fork(), A = 0, $ = 0, M = 0, _ = S.end - i, T = { size: 0, start: 0, skip: 0 };
    e:
      for (let D = S.pos - C; S.pos > D; ) {
        let E = S.size;
        if (S.id == y && E >= 0) {
          T.size = A, T.start = $, T.skip = M, M += 4, A += 4, S.next();
          continue;
        }
        let R = S.pos - E;
        if (E < 0 || R < D || S.start < _)
          break;
        let I = S.id >= s ? 4 : 0, k = S.start;
        for (S.next(); S.pos > R; ) {
          if (S.size < 0)
            if (S.size == -3)
              I += 4;
            else
              break e;
          else
            S.id >= s && (I += 4);
          S.next();
        }
        $ = k, A += E, M += I;
      }
    return (y < 0 || A == C) && (T.size = A, T.start = $, T.skip = M), T.size > 4 ? T : void 0;
  }
  function v(C, y, S) {
    let { id: A, start: $, end: M, size: _ } = a;
    if (a.next(), _ >= 0 && A < s) {
      let T = S;
      if (_ > 4) {
        let D = a.pos - (_ - 4);
        for (; a.pos > D; )
          S = v(C, y, S);
      }
      y[--S] = T, y[--S] = M - C, y[--S] = $ - C, y[--S] = A;
    } else
      _ == -3 ? u = A : _ == -4 && (c = A);
    return S;
  }
  let b = [], x = [];
  for (; a.pos > 0; )
    d(e.start || 0, e.bufferStart || 0, b, x, -1, 0);
  let w = (t = e.length) !== null && t !== void 0 ? t : b.length ? x[0] + b[0].length : 0;
  return new Wn(l[e.topID], b.reverse(), x.reverse(), w);
}
const xO = /* @__PURE__ */ new WeakMap();
function pp(e, t) {
  if (!e.isAnonymous || t instanceof ga || t.type != e)
    return 1;
  let n = xO.get(t);
  if (n == null) {
    n = 1;
    for (let r of t.children) {
      if (r.type != e || !(r instanceof Wn)) {
        n = 1;
        break;
      }
      n += pp(e, r);
    }
    xO.set(t, n);
  }
  return n;
}
function hC(e, t, n, r, i, o, s, a, l) {
  let u = 0;
  for (let p = r; p < i; p++)
    u += pp(e, t[p]);
  let c = Math.ceil(
    u * 1.5 / 8
    /* Balance.BranchFactor */
  ), d = [], f = [];
  function h(p, g, m, v, b) {
    for (let x = m; x < v; ) {
      let w = x, C = g[x], y = pp(e, p[x]);
      for (x++; x < v; x++) {
        let S = pp(e, p[x]);
        if (y + S >= c)
          break;
        y += S;
      }
      if (x == w + 1) {
        if (y > c) {
          let S = p[w];
          h(S.children, S.positions, 0, S.children.length, g[w] + b);
          continue;
        }
        d.push(p[w]);
      } else {
        let S = g[x - 1] + p[x - 1].length - C;
        d.push(hC(e, p, g, w, x, C, S, null, l));
      }
      f.push(C + b - o);
    }
  }
  return h(t, n, r, i, 0), (a || l)(d, f, s);
}
class ws {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(t, n, r, i, o = !1, s = !1) {
    this.from = t, this.to = n, this.tree = r, this.offset = i, this.open = (o ? 1 : 0) | (s ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(t, n = [], r = !1) {
    let i = [new ws(0, t.length, t, 0, !1, r)];
    for (let o of n)
      o.to > t.length && i.push(o);
    return i;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(t, n, r = 128) {
    if (!n.length)
      return t;
    let i = [], o = 1, s = t.length ? t[0] : null;
    for (let a = 0, l = 0, u = 0; ; a++) {
      let c = a < n.length ? n[a] : null, d = c ? c.fromA : 1e9;
      if (d - l >= r)
        for (; s && s.from < d; ) {
          let f = s;
          if (l >= f.from || d <= f.to || u) {
            let h = Math.max(f.from, l) - u, p = Math.min(f.to, d) - u;
            f = h >= p ? null : new ws(h, p, f.tree, f.offset + u, a > 0, !!c);
          }
          if (f && i.push(f), s.to > d)
            break;
          s = o < t.length ? t[o++] : null;
        }
      if (!c)
        break;
      l = c.toA, u = c.toA - c.toB;
    }
    return i;
  }
}
class Yk {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(t, n, r) {
    return typeof t == "string" && (t = new $J(t)), r = r ? r.length ? r.map((i) => new Zi(i.from, i.to)) : [new Zi(0, 0)] : [new Zi(0, t.length)], this.createParse(t, n || [], r);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(t, n, r) {
    let i = this.startParse(t, n, r);
    for (; ; ) {
      let o = i.advance();
      if (o)
        return o;
    }
  }
}
class $J {
  constructor(t) {
    this.string = t;
  }
  get length() {
    return this.string.length;
  }
  chunk(t) {
    return this.string.slice(t);
  }
  get lineChunks() {
    return !1;
  }
  read(t, n) {
    return this.string.slice(t, n);
  }
}
function OJ(e) {
  return (t, n, r, i) => new DJ(t, e, n, r, i);
}
class EO {
  constructor(t, n, r, i, o) {
    this.parser = t, this.parse = n, this.overlay = r, this.target = i, this.from = o;
  }
}
function $O(e) {
  if (!e.length || e.some((t) => t.from >= t.to))
    throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(e));
}
class AJ {
  constructor(t, n, r, i, o, s, a) {
    this.parser = t, this.predicate = n, this.mounts = r, this.index = i, this.start = o, this.target = s, this.prev = a, this.depth = 0, this.ranges = [];
  }
}
const Ay = new on({ perNode: !0 });
class DJ {
  constructor(t, n, r, i, o) {
    this.nest = n, this.input = r, this.fragments = i, this.ranges = o, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = t;
  }
  advance() {
    if (this.baseParse) {
      let r = this.baseParse.advance();
      if (!r)
        return null;
      if (this.baseParse = null, this.baseTree = r, this.startInner(), this.stoppedAt != null)
        for (let i of this.inner)
          i.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let r = this.baseTree;
      return this.stoppedAt != null && (r = new Wn(r.type, r.children, r.positions, r.length, r.propValues.concat([[Ay, this.stoppedAt]]))), r;
    }
    let t = this.inner[this.innerDone], n = t.parse.advance();
    if (n) {
      this.innerDone++;
      let r = Object.assign(/* @__PURE__ */ Object.create(null), t.target.props);
      r[on.mounted.id] = new Bd(n, t.overlay, t.parser), t.target.props = r;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let t = this.input.length;
    for (let n = this.innerDone; n < this.inner.length; n++)
      this.inner[n].from < t && (t = Math.min(t, this.inner[n].parse.parsedPos));
    return t;
  }
  stopAt(t) {
    if (this.stoppedAt = t, this.baseParse)
      this.baseParse.stopAt(t);
    else
      for (let n = this.innerDone; n < this.inner.length; n++)
        this.inner[n].parse.stopAt(t);
  }
  startInner() {
    let t = new RJ(this.fragments), n = null, r = null, i = new Zp(new Si(this.baseTree, this.ranges[0].from, 0, null), Ln.IncludeAnonymous | Ln.IgnoreMounts);
    e:
      for (let o, s; ; ) {
        let a = !0, l;
        if (this.stoppedAt != null && i.from >= this.stoppedAt)
          a = !1;
        else if (t.hasNode(i)) {
          if (n) {
            let u = n.mounts.find((c) => c.frag.from <= i.from && c.frag.to >= i.to && c.mount.overlay);
            if (u)
              for (let c of u.mount.overlay) {
                let d = c.from + u.pos, f = c.to + u.pos;
                d >= i.from && f <= i.to && !n.ranges.some((h) => h.from < f && h.to > d) && n.ranges.push({ from: d, to: f });
              }
          }
          a = !1;
        } else if (r && (s = _J(r.ranges, i.from, i.to)))
          a = s != 2;
        else if (!i.type.isAnonymous && (o = this.nest(i, this.input)) && (i.from < i.to || !o.overlay)) {
          i.tree || TJ(i);
          let u = t.findMounts(i.from, o.parser);
          if (typeof o.overlay == "function")
            n = new AJ(o.parser, o.overlay, u, this.inner.length, i.from, i.tree, n);
          else {
            let c = DO(this.ranges, o.overlay || (i.from < i.to ? [new Zi(i.from, i.to)] : []));
            c.length && $O(c), (c.length || !o.overlay) && this.inner.push(new EO(o.parser, c.length ? o.parser.startParse(this.input, _O(u, c), c) : o.parser.startParse(""), o.overlay ? o.overlay.map((d) => new Zi(d.from - i.from, d.to - i.from)) : null, i.tree, c.length ? c[0].from : i.from)), o.overlay ? c.length && (r = { ranges: c, depth: 0, prev: r }) : a = !1;
          }
        } else
          n && (l = n.predicate(i)) && (l === !0 && (l = new Zi(i.from, i.to)), l.from < l.to && n.ranges.push(l));
        if (a && i.firstChild())
          n && n.depth++, r && r.depth++;
        else
          for (; !i.nextSibling(); ) {
            if (!i.parent())
              break e;
            if (n && !--n.depth) {
              let u = DO(this.ranges, n.ranges);
              u.length && ($O(u), this.inner.splice(n.index, 0, new EO(n.parser, n.parser.startParse(this.input, _O(n.mounts, u), u), n.ranges.map((c) => new Zi(c.from - n.start, c.to - n.start)), n.target, u[0].from))), n = n.prev;
            }
            r && !--r.depth && (r = r.prev);
          }
      }
  }
}
function _J(e, t, n) {
  for (let r of e) {
    if (r.from >= n)
      break;
    if (r.to > t)
      return r.from <= t && r.to >= n ? 2 : 1;
  }
  return 0;
}
function OO(e, t, n, r, i, o) {
  if (t < n) {
    let s = e.buffer[t + 1];
    r.push(e.slice(t, n, s)), i.push(s - o);
  }
}
function TJ(e) {
  let { node: t } = e, n = [], r = t.context.buffer;
  do
    n.push(e.index), e.parent();
  while (!e.tree);
  let i = e.tree, o = i.children.indexOf(r), s = i.children[o], a = s.buffer, l = [o];
  function u(c, d, f, h, p, g) {
    let m = n[g], v = [], b = [];
    OO(s, c, m, v, b, h);
    let x = a[m + 1], w = a[m + 2];
    l.push(v.length);
    let C = g ? u(m + 4, a[m + 3], s.set.types[a[m]], x, w - x, g - 1) : t.toTree();
    return v.push(C), b.push(x - h), OO(s, a[m + 3], d, v, b, h), new Wn(f, v, b, p);
  }
  i.children[o] = u(0, a.length, ai.none, 0, s.length, n.length - 1);
  for (let c of l) {
    let d = e.tree.children[c], f = e.tree.positions[c];
    e.yield(new Si(d, f + e.from, c, e._tree));
  }
}
class AO {
  constructor(t, n) {
    this.offset = n, this.done = !1, this.cursor = t.cursor(Ln.IncludeAnonymous | Ln.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(t) {
    let { cursor: n } = this, r = t - this.offset;
    for (; !this.done && n.from < r; )
      n.to >= t && n.enter(r, 1, Ln.IgnoreOverlays | Ln.ExcludeBuffers) || n.next(!1) || (this.done = !0);
  }
  hasNode(t) {
    if (this.moveTo(t.from), !this.done && this.cursor.from + this.offset == t.from && this.cursor.tree)
      for (let n = this.cursor.tree; ; ) {
        if (n == t.tree)
          return !0;
        if (n.children.length && n.positions[0] == 0 && n.children[0] instanceof Wn)
          n = n.children[0];
        else
          break;
      }
    return !1;
  }
}
let RJ = class {
  constructor(t) {
    var n;
    if (this.fragments = t, this.curTo = 0, this.fragI = 0, t.length) {
      let r = this.curFrag = t[0];
      this.curTo = (n = r.tree.prop(Ay)) !== null && n !== void 0 ? n : r.to, this.inner = new AO(r.tree, -r.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(t) {
    for (; this.curFrag && t.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= t.from && this.curTo >= t.to && this.inner.hasNode(t);
  }
  nextFrag() {
    var t;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let n = this.curFrag = this.fragments[this.fragI];
      this.curTo = (t = n.tree.prop(Ay)) !== null && t !== void 0 ? t : n.to, this.inner = new AO(n.tree, -n.offset);
    }
  }
  findMounts(t, n) {
    var r;
    let i = [];
    if (this.inner) {
      this.inner.cursor.moveTo(t, 1);
      for (let o = this.inner.cursor.node; o; o = o.parent) {
        let s = (r = o.tree) === null || r === void 0 ? void 0 : r.prop(on.mounted);
        if (s && s.parser == n)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a];
            if (l.from >= o.to)
              break;
            l.tree == this.curFrag.tree && i.push({
              frag: l,
              pos: o.from - l.offset,
              mount: s
            });
          }
      }
    }
    return i;
  }
};
function DO(e, t) {
  let n = null, r = t;
  for (let i = 1, o = 0; i < e.length; i++) {
    let s = e[i - 1].to, a = e[i].from;
    for (; o < r.length; o++) {
      let l = r[o];
      if (l.from >= a)
        break;
      l.to <= s || (n || (r = n = t.slice()), l.from < s ? (n[o] = new Zi(l.from, s), l.to > a && n.splice(o + 1, 0, new Zi(a, l.to))) : l.to > a ? n[o--] = new Zi(a, l.to) : n.splice(o--, 1));
    }
  }
  return r;
}
function MJ(e, t, n, r) {
  let i = 0, o = 0, s = !1, a = !1, l = -1e9, u = [];
  for (; ; ) {
    let c = i == e.length ? 1e9 : s ? e[i].to : e[i].from, d = o == t.length ? 1e9 : a ? t[o].to : t[o].from;
    if (s != a) {
      let f = Math.max(l, n), h = Math.min(c, d, r);
      f < h && u.push(new Zi(f, h));
    }
    if (l = Math.min(c, d), l == 1e9)
      break;
    c == l && (s ? (s = !1, i++) : s = !0), d == l && (a ? (a = !1, o++) : a = !0);
  }
  return u;
}
function _O(e, t) {
  let n = [];
  for (let { pos: r, mount: i, frag: o } of e) {
    let s = r + (i.overlay ? i.overlay[0].from : 0), a = s + i.tree.length, l = Math.max(o.from, s), u = Math.min(o.to, a);
    if (i.overlay) {
      let c = i.overlay.map((f) => new Zi(f.from + r, f.to + r)), d = MJ(t, c, l, u);
      for (let f = 0, h = l; ; f++) {
        let p = f == d.length, g = p ? u : d[f].from;
        if (g > h && n.push(new ws(h, g, i.tree, -s, o.from >= h || o.openStart, o.to <= g || o.openEnd)), p)
          break;
        h = d[f].to;
      }
    } else
      n.push(new ws(l, u, i.tree, -s, o.from >= s || o.openStart, o.to <= a || o.openEnd));
  }
  return n;
}
let IJ = 0;
class zo {
  /**
  @internal
  */
  constructor(t, n, r) {
    this.set = t, this.base = n, this.modified = r, this.id = IJ++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(t) {
    if (t != null && t.base)
      throw new Error("Can not derive from a modified tag");
    let n = new zo([], null, []);
    if (n.set.push(n), t)
      for (let r of t.set)
        n.set.push(r);
    return n;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let t = new Jp();
    return (n) => n.modified.indexOf(t) > -1 ? n : Jp.get(n.base || n, n.modified.concat(t).sort((r, i) => r.id - i.id));
  }
}
let kJ = 0;
class Jp {
  constructor() {
    this.instances = [], this.id = kJ++;
  }
  static get(t, n) {
    if (!n.length)
      return t;
    let r = n[0].instances.find((a) => a.base == t && PJ(n, a.modified));
    if (r)
      return r;
    let i = [], o = new zo(i, t, n);
    for (let a of n)
      a.instances.push(o);
    let s = NJ(n);
    for (let a of t.set)
      if (!a.modified.length)
        for (let l of s)
          i.push(Jp.get(a, l));
    return o;
  }
}
function PJ(e, t) {
  return e.length == t.length && e.every((n, r) => n == t[r]);
}
function NJ(e) {
  let t = [[]];
  for (let n = 0; n < e.length; n++)
    for (let r = 0, i = t.length; r < i; r++)
      t.push(t[r].concat(e[n]));
  return t.sort((n, r) => r.length - n.length);
}
function pC(e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n in e) {
    let r = e[n];
    Array.isArray(r) || (r = [r]);
    for (let i of n.split(" "))
      if (i) {
        let o = [], s = 2, a = i;
        for (let d = 0; ; ) {
          if (a == "..." && d > 0 && d + 3 == i.length) {
            s = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!f)
            throw new RangeError("Invalid path: " + i);
          if (o.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), d += f[0].length, d == i.length)
            break;
          let h = i[d++];
          if (d == i.length && h == "!") {
            s = 0;
            break;
          }
          if (h != "/")
            throw new RangeError("Invalid path: " + i);
          a = i.slice(d);
        }
        let l = o.length - 1, u = o[l];
        if (!u)
          throw new RangeError("Invalid path: " + i);
        let c = new eg(r, s, l > 0 ? o.slice(0, l) : null);
        t[u] = c.sort(t[u]);
      }
  }
  return qk.add(t);
}
const qk = new on();
class eg {
  constructor(t, n, r, i) {
    this.tags = t, this.mode = n, this.context = r, this.next = i;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(t) {
    return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
eg.empty = new eg([], 2, null);
function Qk(e, t) {
  let n = /* @__PURE__ */ Object.create(null);
  for (let o of e)
    if (!Array.isArray(o.tag))
      n[o.tag.id] = o.class;
    else
      for (let s of o.tag)
        n[s.id] = o.class;
  let { scope: r, all: i = null } = t || {};
  return {
    style: (o) => {
      let s = i;
      for (let a of o)
        for (let l of a.set) {
          let u = n[l.id];
          if (u) {
            s = s ? s + " " + u : u;
            break;
          }
        }
      return s;
    },
    scope: r
  };
}
function LJ(e, t) {
  let n = null;
  for (let r of e) {
    let i = r.style(t);
    i && (n = n ? n + " " + i : i);
  }
  return n;
}
function FJ(e, t, n, r = 0, i = e.length) {
  let o = new BJ(r, Array.isArray(t) ? t : [t], n);
  o.highlightRange(e.cursor(), r, i, "", o.highlighters), o.flush(i);
}
class BJ {
  constructor(t, n, r) {
    this.at = t, this.highlighters = n, this.span = r, this.class = "";
  }
  startSpan(t, n) {
    n != this.class && (this.flush(t), t > this.at && (this.at = t), this.class = n);
  }
  flush(t) {
    t > this.at && this.class && this.span(this.at, t, this.class);
  }
  highlightRange(t, n, r, i, o) {
    let { type: s, from: a, to: l } = t;
    if (a >= r || l <= n)
      return;
    s.isTop && (o = this.highlighters.filter((h) => !h.scope || h.scope(s)));
    let u = i, c = jJ(t) || eg.empty, d = LJ(o, c.tags);
    if (d && (u && (u += " "), u += d, c.mode == 1 && (i += (i ? " " : "") + d)), this.startSpan(Math.max(n, a), u), c.opaque)
      return;
    let f = t.tree && t.tree.prop(on.mounted);
    if (f && f.overlay) {
      let h = t.node.enter(f.overlay[0].from + a, 1), p = this.highlighters.filter((m) => !m.scope || m.scope(f.tree.type)), g = t.firstChild();
      for (let m = 0, v = a; ; m++) {
        let b = m < f.overlay.length ? f.overlay[m] : null, x = b ? b.from + a : l, w = Math.max(n, v), C = Math.min(r, x);
        if (w < C && g)
          for (; t.from < C && (this.highlightRange(t, w, C, i, o), this.startSpan(Math.min(C, t.to), u), !(t.to >= x || !t.nextSibling())); )
            ;
        if (!b || x > r)
          break;
        v = b.to + a, v > n && (this.highlightRange(h.cursor(), Math.max(n, b.from + a), Math.min(r, v), "", p), this.startSpan(Math.min(r, v), u));
      }
      g && t.parent();
    } else if (t.firstChild()) {
      f && (i = "");
      do
        if (!(t.to <= n)) {
          if (t.from >= r)
            break;
          this.highlightRange(t, n, r, i, o), this.startSpan(Math.min(r, t.to), u);
        }
      while (t.nextSibling());
      t.parent();
    }
  }
}
function jJ(e) {
  let t = e.type.prop(qk);
  for (; t && t.context && !e.matchContext(t.context); )
    t = t.next;
  return t || null;
}
const Xe = zo.define, Sh = Xe(), zs = Xe(), TO = Xe(zs), RO = Xe(zs), Hs = Xe(), xh = Xe(Hs), Hv = Xe(Hs), Lo = Xe(), xa = Xe(Lo), Po = Xe(), No = Xe(), Dy = Xe(), Ou = Xe(Dy), Eh = Xe(), Ne = {
  /**
  A comment.
  */
  comment: Sh,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: Xe(Sh),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: Xe(Sh),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: Xe(Sh),
  /**
  Any kind of identifier.
  */
  name: zs,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: Xe(zs),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: TO,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: Xe(TO),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: RO,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: Xe(RO),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: Xe(zs),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: Xe(zs),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: Xe(zs),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: Xe(zs),
  /**
  A literal value.
  */
  literal: Hs,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: xh,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: Xe(xh),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: Xe(xh),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: Xe(xh),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: Hv,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: Xe(Hv),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: Xe(Hv),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: Xe(Hs),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: Xe(Hs),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: Xe(Hs),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: Xe(Hs),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: Xe(Hs),
  /**
  A language keyword.
  */
  keyword: Po,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: Xe(Po),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: Xe(Po),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: Xe(Po),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: Xe(Po),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: Xe(Po),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: Xe(Po),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: Xe(Po),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: Xe(Po),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: Xe(Po),
  /**
  An operator.
  */
  operator: No,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: Xe(No),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: Xe(No),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: Xe(No),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: Xe(No),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: Xe(No),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: Xe(No),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: Xe(No),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: Xe(No),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: Xe(No),
  /**
  Program or markup punctuation.
  */
  punctuation: Dy,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: Xe(Dy),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Ou,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: Xe(Ou),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: Xe(Ou),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: Xe(Ou),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: Xe(Ou),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Lo,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: xa,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: Xe(xa),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: Xe(xa),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: Xe(xa),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: Xe(xa),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: Xe(xa),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: Xe(xa),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: Xe(Lo),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: Xe(Lo),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: Xe(Lo),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: Xe(Lo),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: Xe(Lo),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: Xe(Lo),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: Xe(Lo),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: Xe(Lo),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: Xe(),
  /**
  Deleted text.
  */
  deleted: Xe(),
  /**
  Changed text.
  */
  changed: Xe(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: Xe(),
  /**
  Metadata or meta-instruction.
  */
  meta: Eh,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: Xe(Eh),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: Xe(Eh),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: Xe(Eh),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: zo.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: zo.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: zo.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: zo.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: zo.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: zo.defineModifier()
};
Qk([
  { tag: Ne.link, class: "tok-link" },
  { tag: Ne.heading, class: "tok-heading" },
  { tag: Ne.emphasis, class: "tok-emphasis" },
  { tag: Ne.strong, class: "tok-strong" },
  { tag: Ne.keyword, class: "tok-keyword" },
  { tag: Ne.atom, class: "tok-atom" },
  { tag: Ne.bool, class: "tok-bool" },
  { tag: Ne.url, class: "tok-url" },
  { tag: Ne.labelName, class: "tok-labelName" },
  { tag: Ne.inserted, class: "tok-inserted" },
  { tag: Ne.deleted, class: "tok-deleted" },
  { tag: Ne.literal, class: "tok-literal" },
  { tag: Ne.string, class: "tok-string" },
  { tag: Ne.number, class: "tok-number" },
  { tag: [Ne.regexp, Ne.escape, Ne.special(Ne.string)], class: "tok-string2" },
  { tag: Ne.variableName, class: "tok-variableName" },
  { tag: Ne.local(Ne.variableName), class: "tok-variableName tok-local" },
  { tag: Ne.definition(Ne.variableName), class: "tok-variableName tok-definition" },
  { tag: Ne.special(Ne.variableName), class: "tok-variableName2" },
  { tag: Ne.definition(Ne.propertyName), class: "tok-propertyName tok-definition" },
  { tag: Ne.typeName, class: "tok-typeName" },
  { tag: Ne.namespace, class: "tok-namespace" },
  { tag: Ne.className, class: "tok-className" },
  { tag: Ne.macroName, class: "tok-macroName" },
  { tag: Ne.propertyName, class: "tok-propertyName" },
  { tag: Ne.operator, class: "tok-operator" },
  { tag: Ne.comment, class: "tok-comment" },
  { tag: Ne.meta, class: "tok-meta" },
  { tag: Ne.invalid, class: "tok-invalid" },
  { tag: Ne.punctuation, class: "tok-punctuation" }
]);
var Vv;
const sc = /* @__PURE__ */ new on();
function zJ(e) {
  return Pt.define({
    combine: e ? (t) => t.concat(e) : void 0
  });
}
const HJ = /* @__PURE__ */ new on();
class mo {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(t, n, r = [], i = "") {
    this.data = t, this.name = i, hn.prototype.hasOwnProperty("tree") || Object.defineProperty(hn.prototype, "tree", { get() {
      return Ts(this);
    } }), this.parser = n, this.extension = [
      Vc.of(this),
      hn.languageData.of((o, s, a) => {
        let l = MO(o, s, a), u = l.type.prop(sc);
        if (!u)
          return [];
        let c = o.facet(u), d = l.type.prop(HJ);
        if (d) {
          let f = l.resolve(s - l.from, a);
          for (let h of d)
            if (h.test(f, o)) {
              let p = o.facet(h.facet);
              return h.type == "replace" ? p : p.concat(c);
            }
        }
        return c;
      })
    ].concat(r);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(t, n, r = -1) {
    return MO(t, n, r).type.prop(sc) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(t) {
    let n = t.facet(Vc);
    if ((n == null ? void 0 : n.data) == this.data)
      return [{ from: 0, to: t.doc.length }];
    if (!n || !n.allowsNesting)
      return [];
    let r = [], i = (o, s) => {
      if (o.prop(sc) == this.data) {
        r.push({ from: s, to: s + o.length });
        return;
      }
      let a = o.prop(on.mounted);
      if (a) {
        if (a.tree.prop(sc) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              r.push({ from: l.from + s, to: l.to + s });
          else
            r.push({ from: s, to: s + o.length });
          return;
        } else if (a.overlay) {
          let l = r.length;
          if (i(a.tree, a.overlay[0].from + s), r.length > l)
            return;
        }
      }
      for (let l = 0; l < o.children.length; l++) {
        let u = o.children[l];
        u instanceof Wn && i(u, o.positions[l] + s);
      }
    };
    return i(Ts(t), 0), r;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
mo.setState = /* @__PURE__ */ In.define();
function MO(e, t, n) {
  let r = e.facet(Vc), i = Ts(e).topNode;
  if (!r || r.allowsNesting)
    for (let o = i; o; o = o.enter(t, n, Ln.ExcludeBuffers))
      o.type.isTop && (i = o);
  return i;
}
class zd extends mo {
  constructor(t, n, r) {
    super(t, n, [], r), this.parser = n;
  }
  /**
  Define a language from a parser.
  */
  static define(t) {
    let n = zJ(t.languageData);
    return new zd(n, t.parser.configure({
      props: [sc.add((r) => r.isTop ? n : void 0)]
    }), t.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(t, n) {
    return new zd(this.data, this.parser.configure(t), n || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Ts(e) {
  let t = e.field(mo.state, !1);
  return t ? t.tree : Wn.empty;
}
class VJ {
  /**
  Create an input object for the given document.
  */
  constructor(t) {
    this.doc = t, this.cursorPos = 0, this.string = "", this.cursor = t.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(t) {
    return this.string = this.cursor.next(t - this.cursorPos).value, this.cursorPos = t + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(t) {
    return this.syncTo(t), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(t, n) {
    let r = this.cursorPos - this.string.length;
    return t < r || n >= this.cursorPos ? this.doc.sliceString(t, n) : this.string.slice(t - r, n - r);
  }
}
let Au = null;
class tg {
  constructor(t, n, r = [], i, o, s, a, l) {
    this.parser = t, this.state = n, this.fragments = r, this.tree = i, this.treeLen = o, this.viewport = s, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(t, n, r) {
    return new tg(t, n, [], Wn.empty, 0, r, [], null);
  }
  startParse() {
    return this.parser.startParse(new VJ(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(t, n) {
    return n != null && n >= this.state.doc.length && (n = void 0), this.tree != Wn.empty && this.isDone(n ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var r;
      if (typeof t == "number") {
        let i = Date.now() + t;
        t = () => Date.now() > i;
      }
      for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {
        let i = this.parse.advance();
        if (i)
          if (this.fragments = this.withoutTempSkipped(ws.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (n ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (t())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let t, n;
    this.parse && (t = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > t) && this.parse.stopAt(t), this.withContext(() => {
      for (; !(n = this.parse.advance()); )
        ;
    }), this.treeLen = t, this.tree = n, this.fragments = this.withoutTempSkipped(ws.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(t) {
    let n = Au;
    Au = this;
    try {
      return t();
    } finally {
      Au = n;
    }
  }
  withoutTempSkipped(t) {
    for (let n; n = this.tempSkipped.pop(); )
      t = IO(t, n.from, n.to);
    return t;
  }
  /**
  @internal
  */
  changes(t, n) {
    let { fragments: r, tree: i, treeLen: o, viewport: s, skipped: a } = this;
    if (this.takeTree(), !t.empty) {
      let l = [];
      if (t.iterChangedRanges((u, c, d, f) => l.push({ fromA: u, toA: c, fromB: d, toB: f })), r = ws.applyChanges(r, l), i = Wn.empty, o = 0, s = { from: t.mapPos(s.from, -1), to: t.mapPos(s.to, 1) }, this.skipped.length) {
        a = [];
        for (let u of this.skipped) {
          let c = t.mapPos(u.from, 1), d = t.mapPos(u.to, -1);
          c < d && a.push({ from: c, to: d });
        }
      }
    }
    return new tg(this.parser, n, r, i, o, s, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(t) {
    if (this.viewport.from == t.from && this.viewport.to == t.to)
      return !1;
    this.viewport = t;
    let n = this.skipped.length;
    for (let r = 0; r < this.skipped.length; r++) {
      let { from: i, to: o } = this.skipped[r];
      i < t.to && o > t.from && (this.fragments = IO(this.fragments, i, o), this.skipped.splice(r--, 1));
    }
    return this.skipped.length >= n ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(t, n) {
    this.skipped.push({ from: t, to: n });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(t) {
    return new class extends Yk {
      createParse(n, r, i) {
        let o = i[0].from, s = i[i.length - 1].to;
        return {
          parsedPos: o,
          advance() {
            let l = Au;
            if (l) {
              for (let u of i)
                l.tempSkipped.push(u);
              t && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, t]) : t);
            }
            return this.parsedPos = s, new Wn(ai.none, [], [], s - o);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(t) {
    t = Math.min(t, this.state.doc.length);
    let n = this.fragments;
    return this.treeLen >= t && n.length && n[0].from == 0 && n[0].to >= t;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return Au;
  }
}
function IO(e, t, n) {
  return ws.applyChanges(e, [{ fromA: t, toA: n, fromB: t, toB: n }]);
}
class Hc {
  constructor(t) {
    this.context = t, this.tree = t.tree;
  }
  apply(t) {
    if (!t.docChanged && this.tree == this.context.tree)
      return this;
    let n = this.context.changes(t.changes, t.state), r = this.context.treeLen == t.startState.doc.length ? void 0 : Math.max(t.changes.mapPos(this.context.treeLen), n.viewport.to);
    return n.work(20, r) || n.takeTree(), new Hc(n);
  }
  static init(t) {
    let n = Math.min(3e3, t.doc.length), r = tg.create(t.facet(Vc).parser, t, { from: 0, to: n });
    return r.work(20, n) || r.takeTree(), new Hc(r);
  }
}
mo.state = /* @__PURE__ */ Zo.define({
  create: Hc.init,
  update(e, t) {
    for (let n of t.effects)
      if (n.is(mo.setState))
        return n.value;
    return t.startState.facet(Vc) != t.state.facet(Vc) ? Hc.init(t.state) : e.apply(t);
  }
});
let Zk = (e) => {
  let t = setTimeout(
    () => e(),
    500
    /* Work.MaxPause */
  );
  return () => clearTimeout(t);
};
typeof requestIdleCallback < "u" && (Zk = (e) => {
  let t = -1, n = setTimeout(
    () => {
      t = requestIdleCallback(e, {
        timeout: 400
        /* Work.MinPause */
      });
    },
    100
    /* Work.MinPause */
  );
  return () => t < 0 ? clearTimeout(n) : cancelIdleCallback(t);
});
const Wv = typeof navigator < "u" && (!((Vv = navigator.scheduling) === null || Vv === void 0) && Vv.isInputPending) ? () => navigator.scheduling.isInputPending() : null, WJ = /* @__PURE__ */ Ao.fromClass(class {
  constructor(t) {
    this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(t) {
    let n = this.view.state.field(mo.state).context;
    (n.updateViewport(t.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (t.docChanged || t.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: t } = this.view, n = t.field(mo.state);
    (n.tree != n.context.tree || !n.context.isDone(t.doc.length)) && (this.working = Zk(this.work));
  }
  work(t) {
    this.working = null;
    let n = Date.now();
    if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: r, viewport: { to: i } } = this.view, o = r.field(mo.state);
    if (o.tree == o.context.tree && o.context.isDone(
      i + 1e5
      /* Work.MaxParseAhead */
    ))
      return;
    let s = Date.now() + Math.min(this.chunkBudget, 100, t && !Wv ? Math.max(25, t.timeRemaining() - 5) : 1e9), a = o.context.treeLen < i && r.doc.length > i + 1e3, l = o.context.work(() => Wv && Wv() || Date.now() > s, i + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - n, (l || this.chunkBudget <= 0) && (o.context.takeTree(), this.view.dispatch({ effects: mo.setState.of(new Hc(o.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(o.context);
  }
  checkAsyncSchedule(t) {
    t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch((n) => bi(this.view.state, n)).then(() => this.workScheduled--), t.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Vc = /* @__PURE__ */ Pt.define({
  combine(e) {
    return e.length ? e[0] : null;
  },
  enables: (e) => [
    mo.state,
    WJ,
    Vt.contentAttributes.compute([e], (t) => {
      let n = t.facet(e);
      return n && n.name ? { "data-language": n.name } : {};
    })
  ]
});
class Jk {
  /**
  Create a language support object.
  */
  constructor(t, n = []) {
    this.language = t, this.support = n, this.extension = [t, n];
  }
}
class Rf {
  constructor(t, n) {
    this.specs = t;
    let r;
    function i(a) {
      let l = fa.newName();
      return (r || (r = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const o = typeof n.all == "string" ? n.all : n.all ? i(n.all) : void 0, s = n.scope;
    this.scope = s instanceof mo ? (a) => a.prop(sc) == s.data : s ? (a) => a == s : void 0, this.style = Qk(t.map((a) => ({
      tag: a.tag,
      class: a.class || i(Object.assign({}, a, { tag: null }))
    })), {
      all: o
    }).style, this.module = r ? new fa(r) : null, this.themeType = n.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(t, n) {
    return new Rf(t, n || {});
  }
}
const _y = /* @__PURE__ */ Pt.define(), UJ = /* @__PURE__ */ Pt.define({
  combine(e) {
    return e.length ? [e[0]] : null;
  }
});
function Uv(e) {
  let t = e.facet(_y);
  return t.length ? t : e.facet(UJ);
}
function eP(e, t) {
  let n = [KJ], r;
  return e instanceof Rf && (e.module && n.push(Vt.styleModule.of(e.module)), r = e.themeType), r ? n.push(_y.computeN([Vt.darkTheme], (i) => i.facet(Vt.darkTheme) == (r == "dark") ? [e] : [])) : n.push(_y.of(e)), n;
}
class GJ {
  constructor(t) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Ts(t.state), this.decorations = this.buildDeco(t, Uv(t.state)), this.decoratedTo = t.viewport.to;
  }
  update(t) {
    let n = Ts(t.state), r = Uv(t.state), i = r != Uv(t.startState), { viewport: o } = t.view, s = t.changes.mapPos(this.decoratedTo, 1);
    n.length < o.to && !i && n.type == this.tree.type && s >= o.to ? (this.decorations = this.decorations.map(t.changes), this.decoratedTo = s) : (n != this.tree || t.viewportChanged || i) && (this.tree = n, this.decorations = this.buildDeco(t.view, r), this.decoratedTo = o.to);
  }
  buildDeco(t, n) {
    if (!n || !this.tree.length)
      return dr.none;
    let r = new Pd();
    for (let { from: i, to: o } of t.visibleRanges)
      FJ(this.tree, n, (s, a, l) => {
        r.add(s, a, this.markCache[l] || (this.markCache[l] = dr.mark({ class: l })));
      }, i, o);
    return r.finish();
  }
}
const KJ = /* @__PURE__ */ Df.high(/* @__PURE__ */ Ao.fromClass(GJ, {
  decorations: (e) => e.decorations
})), XJ = /* @__PURE__ */ Object.create(null), kO = [ai.none], PO = [], NO = /* @__PURE__ */ Object.create(null), YJ = /* @__PURE__ */ Object.create(null);
for (let [e, t] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  YJ[e] = /* @__PURE__ */ qJ(XJ, t);
function Gv(e, t) {
  PO.indexOf(e) > -1 || (PO.push(e), console.warn(t));
}
function qJ(e, t) {
  let n = [];
  for (let a of t.split(" ")) {
    let l = [];
    for (let u of a.split(".")) {
      let c = e[u] || Ne[u];
      c ? typeof c == "function" ? l.length ? l = l.map(c) : Gv(u, `Modifier ${u} used at start of tag`) : l.length ? Gv(u, `Tag ${u} used as modifier`) : l = Array.isArray(c) ? c : [c] : Gv(u, `Unknown highlighting tag ${u}`);
    }
    for (let u of l)
      n.push(u);
  }
  if (!n.length)
    return 0;
  let r = t.replace(/ /g, "_"), i = r + " " + n.map((a) => a.id), o = NO[i];
  if (o)
    return o.id;
  let s = NO[i] = ai.define({
    id: kO.length,
    name: r,
    props: [pC({ [r]: n })]
  });
  return kO.push(s), s.id;
}
ar.RTL, ar.LTR;
class tP {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesin the editor, the extension will create
  these for you.)
  */
  constructor(t, n, r) {
    this.state = t, this.pos = n, this.explicit = r, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(t) {
    let n = Ts(this.state).resolveInner(this.pos, -1);
    for (; n && t.indexOf(n.name) < 0; )
      n = n.parent;
    return n ? {
      from: n.from,
      to: this.pos,
      text: this.state.sliceDoc(n.from, this.pos),
      type: n.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(t) {
    let n = this.state.doc.lineAt(this.pos), r = Math.max(n.from, this.pos - 250), i = n.text.slice(r - n.from, this.pos - n.from), o = i.search(nP(t, !1));
    return o < 0 ? null : { from: r + o, to: this.pos, text: i.slice(o) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(t, n) {
    t == "abort" && this.abortListeners && this.abortListeners.push(n);
  }
}
function LO(e) {
  let t = Object.keys(e).join(""), n = /\w/.test(t);
  return n && (t = t.replace(/\w/g, "")), `[${n ? "\\w" : ""}${t.replace(/[^\w\s]/g, "\\$&")}]`;
}
function QJ(e) {
  let t = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);
  for (let { label: i } of e) {
    t[i[0]] = !0;
    for (let o = 1; o < i.length; o++)
      n[i[o]] = !0;
  }
  let r = LO(t) + LO(n) + "*$";
  return [new RegExp("^" + r), new RegExp(r)];
}
function ZJ(e) {
  let t = e.map((i) => typeof i == "string" ? { label: i } : i), [n, r] = t.every((i) => /^\w+$/.test(i.label)) ? [/\w*$/, /\w+$/] : QJ(t);
  return (i) => {
    let o = i.matchBefore(r);
    return o || i.explicit ? { from: o ? o.from : i.pos, options: t, validFor: n } : null;
  };
}
class FO {
  constructor(t, n, r, i) {
    this.completion = t, this.source = n, this.match = r, this.score = i;
  }
}
function ra(e) {
  return e.selection.main.from;
}
function nP(e, t) {
  var n;
  let { source: r } = e, i = t && r[0] != "^", o = r[r.length - 1] != "$";
  return !i && !o ? e : new RegExp(`${i ? "^" : ""}(?:${r})${o ? "$" : ""}`, (n = e.flags) !== null && n !== void 0 ? n : e.ignoreCase ? "i" : "");
}
const rP = /* @__PURE__ */ El.define();
function JJ(e, t, n, r) {
  let { main: i } = e.selection, o = n - i.from, s = r - i.from;
  return Object.assign(Object.assign({}, e.changeByRange((a) => a != i && n != r && e.sliceDoc(a.from + o, a.from + s) != e.sliceDoc(n, r) ? { range: a } : {
    changes: { from: a.from + o, to: r == i.from ? a.to : a.from + s, insert: t },
    range: st.cursor(a.from + o + t.length)
  })), { scrollIntoView: !0, userEvent: "input.complete" });
}
const BO = /* @__PURE__ */ new WeakMap();
function eee(e) {
  if (!Array.isArray(e))
    return e;
  let t = BO.get(e);
  return t || BO.set(e, t = ZJ(e)), t;
}
const ng = /* @__PURE__ */ In.define(), Hd = /* @__PURE__ */ In.define();
class tee {
  constructor(t) {
    this.pattern = t, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let n = 0; n < t.length; ) {
      let r = ei(t, n), i = ho(r);
      this.chars.push(r);
      let o = t.slice(n, n + i), s = o.toUpperCase();
      this.folded.push(ei(s == o ? o.toLowerCase() : s, 0)), n += i;
    }
    this.astral = t.length != this.chars.length;
  }
  ret(t, n) {
    return this.score = t, this.matched = n, this;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(t) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (t.length < this.pattern.length)
      return null;
    let { chars: n, folded: r, any: i, precise: o, byWord: s } = this;
    if (n.length == 1) {
      let b = ei(t, 0), x = ho(b), w = x == t.length ? 0 : -100;
      if (b != n[0])
        if (b == r[0])
          w += -200;
        else
          return null;
      return this.ret(w, [0, x]);
    }
    let a = t.indexOf(this.pattern);
    if (a == 0)
      return this.ret(t.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = n.length, u = 0;
    if (a < 0) {
      for (let b = 0, x = Math.min(t.length, 200); b < x && u < l; ) {
        let w = ei(t, b);
        (w == n[u] || w == r[u]) && (i[u++] = b), b += ho(w);
      }
      if (u < l)
        return null;
    }
    let c = 0, d = 0, f = !1, h = 0, p = -1, g = -1, m = /[a-z]/.test(t), v = !0;
    for (let b = 0, x = Math.min(t.length, 200), w = 0; b < x && d < l; ) {
      let C = ei(t, b);
      a < 0 && (c < l && C == n[c] && (o[c++] = b), h < l && (C == n[h] || C == r[h] ? (h == 0 && (p = b), g = b + 1, h++) : h = 0));
      let y, S = C < 255 ? C >= 48 && C <= 57 || C >= 97 && C <= 122 ? 2 : C >= 65 && C <= 90 ? 1 : 0 : (y = kI(C)) != y.toLowerCase() ? 1 : y != y.toUpperCase() ? 2 : 0;
      (!b || S == 1 && m || w == 0 && S != 0) && (n[d] == C || r[d] == C && (f = !0) ? s[d++] = b : s.length && (v = !1)), w = S, b += ho(C);
    }
    return d == l && s[0] == 0 && v ? this.result(-100 + (f ? -200 : 0), s, t) : h == l && p == 0 ? this.ret(-200 - t.length + (g == t.length ? 0 : -100), [0, g]) : a > -1 ? this.ret(-700 - t.length, [a, a + this.pattern.length]) : h == l ? this.ret(-900 - t.length, [p, g]) : d == l ? this.result(-100 + (f ? -200 : 0) + -700 + (v ? 0 : -1100), s, t) : n.length == 2 ? null : this.result((i[0] ? -700 : 0) + -200 + -1100, i, t);
  }
  result(t, n, r) {
    let i = [], o = 0;
    for (let s of n) {
      let a = s + (this.astral ? ho(ei(r, s)) : 1);
      o && i[o - 1] == s ? i[o - 1] = a : (i[o++] = s, i[o++] = a);
    }
    return this.ret(t - r.length, i);
  }
}
class nee {
  constructor(t) {
    this.pattern = t, this.matched = [], this.score = 0, this.folded = t.toLowerCase();
  }
  match(t) {
    if (t.length < this.pattern.length)
      return null;
    let n = t.slice(0, this.pattern.length), r = n == this.pattern ? 0 : n.toLowerCase() == this.folded ? -200 : null;
    return r == null ? null : (this.matched = [0, n.length], this.score = r + (t.length == this.pattern.length ? 0 : -100), this);
  }
}
const Tr = /* @__PURE__ */ Pt.define({
  combine(e) {
    return SQ(e, {
      activateOnTyping: !0,
      activateOnCompletion: () => !1,
      activateOnTypingDelay: 100,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: ree,
      filterStrict: !1,
      compareCompletions: (t, n) => t.label.localeCompare(n.label),
      interactionDelay: 75,
      updateSyncTime: 100
    }, {
      defaultKeymap: (t, n) => t && n,
      closeOnBlur: (t, n) => t && n,
      icons: (t, n) => t && n,
      tooltipClass: (t, n) => (r) => jO(t(r), n(r)),
      optionClass: (t, n) => (r) => jO(t(r), n(r)),
      addToOptions: (t, n) => t.concat(n),
      filterStrict: (t, n) => t || n
    });
  }
});
function jO(e, t) {
  return e ? t ? e + " " + t : e : t;
}
function ree(e, t, n, r, i, o) {
  let s = e.textDirection == ar.RTL, a = s, l = !1, u = "top", c, d, f = t.left - i.left, h = i.right - t.right, p = r.right - r.left, g = r.bottom - r.top;
  if (a && f < Math.min(p, h) ? a = !1 : !a && h < Math.min(p, f) && (a = !0), p <= (a ? f : h))
    c = Math.max(i.top, Math.min(n.top, i.bottom - g)) - t.top, d = Math.min(400, a ? f : h);
  else {
    l = !0, d = Math.min(
      400,
      (s ? t.right : i.right - t.left) - 30
      /* Info.Margin */
    );
    let b = i.bottom - t.bottom;
    b >= g || b > t.top ? c = n.bottom - t.top : (u = "bottom", c = t.bottom - n.top);
  }
  let m = (t.bottom - t.top) / o.offsetHeight, v = (t.right - t.left) / o.offsetWidth;
  return {
    style: `${u}: ${c / m}px; max-width: ${d / v}px`,
    class: "cm-completionInfo-" + (l ? s ? "left-narrow" : "right-narrow" : a ? "left" : "right")
  };
}
function iee(e) {
  let t = e.addToOptions.slice();
  return e.icons && t.push({
    render(n) {
      let r = document.createElement("div");
      return r.classList.add("cm-completionIcon"), n.type && r.classList.add(...n.type.split(/\s+/g).map((i) => "cm-completionIcon-" + i)), r.setAttribute("aria-hidden", "true"), r;
    },
    position: 20
  }), t.push({
    render(n, r, i, o) {
      let s = document.createElement("span");
      s.className = "cm-completionLabel";
      let a = n.displayLabel || n.label, l = 0;
      for (let u = 0; u < o.length; ) {
        let c = o[u++], d = o[u++];
        c > l && s.appendChild(document.createTextNode(a.slice(l, c)));
        let f = s.appendChild(document.createElement("span"));
        f.appendChild(document.createTextNode(a.slice(c, d))), f.className = "cm-completionMatchedText", l = d;
      }
      return l < a.length && s.appendChild(document.createTextNode(a.slice(l))), s;
    },
    position: 50
  }, {
    render(n) {
      if (!n.detail)
        return null;
      let r = document.createElement("span");
      return r.className = "cm-completionDetail", r.textContent = n.detail, r;
    },
    position: 80
  }), t.sort((n, r) => n.position - r.position).map((n) => n.render);
}
function Kv(e, t, n) {
  if (e <= n)
    return { from: 0, to: e };
  if (t < 0 && (t = 0), t <= e >> 1) {
    let i = Math.floor(t / n);
    return { from: i * n, to: (i + 1) * n };
  }
  let r = Math.floor((e - t) / n);
  return { from: e - (r + 1) * n, to: e - r * n };
}
class oee {
  constructor(t, n, r) {
    this.view = t, this.stateField = n, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let i = t.state.field(n), { options: o, selected: s } = i.open, a = t.state.facet(Tr);
    this.optionContent = iee(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = Kv(o.length, s, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(t.state), this.dom.addEventListener("mousedown", (l) => {
      let { options: u } = t.state.field(n).open;
      for (let c = l.target, d; c && c != this.dom; c = c.parentNode)
        if (c.nodeName == "LI" && (d = /-(\d+)$/.exec(c.id)) && +d[1] < u.length) {
          this.applyCompletion(t, u[+d[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let u = t.state.field(this.stateField, !1);
      u && u.tooltip && t.state.facet(Tr).closeOnBlur && l.relatedTarget != t.contentDOM && t.dispatch({ effects: Hd.of(null) });
    }), this.showOptions(o, i.id);
  }
  mount() {
    this.updateSel();
  }
  showOptions(t, n) {
    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t, n, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  update(t) {
    var n;
    let r = t.state.field(this.stateField), i = t.startState.field(this.stateField);
    if (this.updateTooltipClass(t.state), r != i) {
      let { options: o, selected: s, disabled: a } = r.open;
      (!i.open || i.open.options != o) && (this.range = Kv(o.length, s, t.state.facet(Tr).maxRenderedOptions), this.showOptions(o, r.id)), this.updateSel(), a != ((n = i.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!a);
    }
  }
  updateTooltipClass(t) {
    let n = this.tooltipClass(t);
    if (n != this.currentClass) {
      for (let r of this.currentClass.split(" "))
        r && this.dom.classList.remove(r);
      for (let r of n.split(" "))
        r && this.dom.classList.add(r);
      this.currentClass = n;
    }
  }
  positioned(t) {
    this.space = t, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let t = this.view.state.field(this.stateField), n = t.open;
    if ((n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = Kv(n.options.length, n.selected, this.view.state.facet(Tr).maxRenderedOptions), this.showOptions(n.options, t.id)), this.updateSelectedOption(n.selected)) {
      this.destroyInfo();
      let { completion: r } = n.options[n.selected], { info: i } = r;
      if (!i)
        return;
      let o = typeof i == "string" ? document.createTextNode(i) : i(r);
      if (!o)
        return;
      "then" in o ? o.then((s) => {
        s && this.view.state.field(this.stateField, !1) == t && this.addInfoPane(s, r);
      }).catch((s) => bi(this.view.state, s, "completion info")) : this.addInfoPane(o, r);
    }
  }
  addInfoPane(t, n) {
    this.destroyInfo();
    let r = this.info = document.createElement("div");
    if (r.className = "cm-tooltip cm-completionInfo", t.nodeType != null)
      r.appendChild(t), this.infoDestroy = null;
    else {
      let { dom: i, destroy: o } = t;
      r.appendChild(i), this.infoDestroy = o || null;
    }
    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(t) {
    let n = null;
    for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)
      r.nodeName != "LI" || !r.id ? i-- : i == t ? r.hasAttribute("aria-selected") || (r.setAttribute("aria-selected", "true"), n = r) : r.hasAttribute("aria-selected") && r.removeAttribute("aria-selected");
    return n && aee(this.list, n), n;
  }
  measureInfo() {
    let t = this.dom.querySelector("[aria-selected]");
    if (!t || !this.info)
      return null;
    let n = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), i = t.getBoundingClientRect(), o = this.space;
    if (!o) {
      let s = this.dom.ownerDocument.defaultView || window;
      o = { left: 0, top: 0, right: s.innerWidth, bottom: s.innerHeight };
    }
    return i.top > Math.min(o.bottom, n.bottom) - 10 || i.bottom < Math.max(o.top, n.top) + 10 ? null : this.view.state.facet(Tr).positionInfo(this.view, n, i, r, o, this.dom);
  }
  placeInfo(t) {
    this.info && (t ? (t.style && (this.info.style.cssText = t.style), this.info.className = "cm-tooltip cm-completionInfo " + (t.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(t, n, r) {
    const i = document.createElement("ul");
    i.id = n, i.setAttribute("role", "listbox"), i.setAttribute("aria-expanded", "true"), i.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let o = null;
    for (let s = r.from; s < r.to; s++) {
      let { completion: a, match: l } = t[s], { section: u } = a;
      if (u) {
        let f = typeof u == "string" ? u : u.name;
        if (f != o && (s > r.from || r.from == 0))
          if (o = f, typeof u != "string" && u.header)
            i.appendChild(u.header(u));
          else {
            let h = i.appendChild(document.createElement("completion-section"));
            h.textContent = f;
          }
      }
      const c = i.appendChild(document.createElement("li"));
      c.id = n + "-" + s, c.setAttribute("role", "option");
      let d = this.optionClass(a);
      d && (c.className = d);
      for (let f of this.optionContent) {
        let h = f(a, this.view.state, this.view, l);
        h && c.appendChild(h);
      }
    }
    return r.from && i.classList.add("cm-completionListIncompleteTop"), r.to < t.length && i.classList.add("cm-completionListIncompleteBottom"), i;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function see(e, t) {
  return (n) => new oee(n, e, t);
}
function aee(e, t) {
  let n = e.getBoundingClientRect(), r = t.getBoundingClientRect(), i = n.height / e.offsetHeight;
  r.top < n.top ? e.scrollTop -= (n.top - r.top) / i : r.bottom > n.bottom && (e.scrollTop += (r.bottom - n.bottom) / i);
}
function zO(e) {
  return (e.boost || 0) * 100 + (e.apply ? 10 : 0) + (e.info ? 5 : 0) + (e.type ? 1 : 0);
}
function lee(e, t) {
  let n = [], r = null, i = (u) => {
    n.push(u);
    let { section: c } = u.completion;
    if (c) {
      r || (r = []);
      let d = typeof c == "string" ? c : c.name;
      r.some((f) => f.name == d) || r.push(typeof c == "string" ? { name: d } : c);
    }
  }, o = t.facet(Tr);
  for (let u of e)
    if (u.hasResult()) {
      let c = u.result.getMatch;
      if (u.result.filter === !1)
        for (let d of u.result.options)
          i(new FO(d, u.source, c ? c(d) : [], 1e9 - n.length));
      else {
        let d = t.sliceDoc(u.from, u.to), f, h = o.filterStrict ? new nee(d) : new tee(d);
        for (let p of u.result.options)
          if (f = h.match(p.label)) {
            let g = p.displayLabel ? c ? c(p, f.matched) : [] : f.matched;
            i(new FO(p, u.source, g, f.score + (p.boost || 0)));
          }
      }
    }
  if (r) {
    let u = /* @__PURE__ */ Object.create(null), c = 0, d = (f, h) => {
      var p, g;
      return ((p = f.rank) !== null && p !== void 0 ? p : 1e9) - ((g = h.rank) !== null && g !== void 0 ? g : 1e9) || (f.name < h.name ? -1 : 1);
    };
    for (let f of r.sort(d))
      c -= 1e5, u[f.name] = c;
    for (let f of n) {
      let { section: h } = f.completion;
      h && (f.score += u[typeof h == "string" ? h : h.name]);
    }
  }
  let s = [], a = null, l = o.compareCompletions;
  for (let u of n.sort((c, d) => d.score - c.score || l(c.completion, d.completion))) {
    let c = u.completion;
    !a || a.label != c.label || a.detail != c.detail || a.type != null && c.type != null && a.type != c.type || a.apply != c.apply || a.boost != c.boost ? s.push(u) : zO(u.completion) > zO(a) && (s[s.length - 1] = u), a = u.completion;
  }
  return s;
}
class ac {
  constructor(t, n, r, i, o, s) {
    this.options = t, this.attrs = n, this.tooltip = r, this.timestamp = i, this.selected = o, this.disabled = s;
  }
  setSelected(t, n) {
    return t == this.selected || t >= this.options.length ? this : new ac(this.options, HO(n, t), this.tooltip, this.timestamp, t, this.disabled);
  }
  static build(t, n, r, i, o) {
    let s = lee(t, n);
    if (!s.length)
      return i && t.some(
        (l) => l.state == 1
        /* State.Pending */
      ) ? new ac(i.options, i.attrs, i.tooltip, i.timestamp, i.selected, !0) : null;
    let a = n.facet(Tr).selectOnOpen ? 0 : -1;
    if (i && i.selected != a && i.selected != -1) {
      let l = i.options[i.selected].completion;
      for (let u = 0; u < s.length; u++)
        if (s[u].completion == l) {
          a = u;
          break;
        }
    }
    return new ac(s, HO(r, a), {
      pos: t.reduce((l, u) => u.hasResult() ? Math.min(l, u.from) : l, 1e8),
      create: hee,
      above: o.aboveCursor
    }, i ? i.timestamp : Date.now(), a, !1);
  }
  map(t) {
    return new ac(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: t.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class rg {
  constructor(t, n, r) {
    this.active = t, this.id = n, this.open = r;
  }
  static start() {
    return new rg(dee, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(t) {
    let { state: n } = t, r = n.facet(Tr), o = (r.override || n.languageDataAt("autocomplete", ra(n)).map(eee)).map((a) => (this.active.find((u) => u.source == a) || new ti(
      a,
      this.active.some(
        (u) => u.state != 0
        /* State.Inactive */
      ) ? 1 : 0
      /* State.Inactive */
    )).update(t, r));
    o.length == this.active.length && o.every((a, l) => a == this.active[l]) && (o = this.active);
    let s = this.open;
    s && t.docChanged && (s = s.map(t.changes)), t.selection || o.some((a) => a.hasResult() && t.changes.touchesRange(a.from, a.to)) || !cee(o, this.active) ? s = ac.build(o, n, this.id, s, r) : s && s.disabled && !o.some(
      (a) => a.state == 1
      /* State.Pending */
    ) && (s = null), !s && o.every(
      (a) => a.state != 1
      /* State.Pending */
    ) && o.some((a) => a.hasResult()) && (o = o.map((a) => a.hasResult() ? new ti(
      a.source,
      0
      /* State.Inactive */
    ) : a));
    for (let a of t.effects)
      a.is(oP) && (s = s && s.setSelected(a.value, this.id));
    return o == this.active && s == this.open ? this : new rg(o, this.id, s);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : uee;
  }
}
function cee(e, t) {
  if (e == t)
    return !0;
  for (let n = 0, r = 0; ; ) {
    for (; n < e.length && !e[n].hasResult; )
      n++;
    for (; r < t.length && !t[r].hasResult; )
      r++;
    let i = n == e.length, o = r == t.length;
    if (i || o)
      return i == o;
    if (e[n++].result != t[r++].result)
      return !1;
  }
}
const uee = {
  "aria-autocomplete": "list"
};
function HO(e, t) {
  let n = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": e
  };
  return t > -1 && (n["aria-activedescendant"] = e + "-" + t), n;
}
const dee = [];
function Ty(e, t) {
  if (e.isUserEvent("input.complete")) {
    let n = e.annotation(rP);
    if (n && t.activateOnCompletion(n))
      return "input";
  }
  return e.isUserEvent("input.type") ? "input" : e.isUserEvent("delete.backward") ? "delete" : null;
}
class ti {
  constructor(t, n, r = -1) {
    this.source = t, this.state = n, this.explicitPos = r;
  }
  hasResult() {
    return !1;
  }
  update(t, n) {
    let r = Ty(t, n), i = this;
    r ? i = i.handleUserEvent(t, r, n) : t.docChanged ? i = i.handleChange(t) : t.selection && i.state != 0 && (i = new ti(
      i.source,
      0
      /* State.Inactive */
    ));
    for (let o of t.effects)
      if (o.is(ng))
        i = new ti(i.source, 1, o.value ? ra(t.state) : -1);
      else if (o.is(Hd))
        i = new ti(
          i.source,
          0
          /* State.Inactive */
        );
      else if (o.is(iP))
        for (let s of o.value)
          s.source == i.source && (i = s);
    return i;
  }
  handleUserEvent(t, n, r) {
    return n == "delete" || !r.activateOnTyping ? this.map(t.changes) : new ti(
      this.source,
      1
      /* State.Pending */
    );
  }
  handleChange(t) {
    return t.changes.touchesRange(ra(t.startState)) ? new ti(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(t.changes);
  }
  map(t) {
    return t.empty || this.explicitPos < 0 ? this : new ti(this.source, this.state, t.mapPos(this.explicitPos));
  }
}
class yc extends ti {
  constructor(t, n, r, i, o) {
    super(t, 2, n), this.result = r, this.from = i, this.to = o;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(t, n, r) {
    var i;
    let o = this.result;
    o.map && !t.changes.empty && (o = o.map(o, t.changes));
    let s = t.changes.mapPos(this.from), a = t.changes.mapPos(this.to, 1), l = ra(t.state);
    if ((this.explicitPos < 0 ? l <= s : l < this.from) || l > a || !o || n == "delete" && ra(t.startState) == this.from)
      return new ti(
        this.source,
        n == "input" && r.activateOnTyping ? 1 : 0
        /* State.Inactive */
      );
    let u = this.explicitPos < 0 ? -1 : t.changes.mapPos(this.explicitPos);
    return fee(o.validFor, t.state, s, a) ? new yc(this.source, u, o, s, a) : o.update && (o = o.update(o, s, a, new tP(t.state, l, u >= 0))) ? new yc(this.source, u, o, o.from, (i = o.to) !== null && i !== void 0 ? i : ra(t.state)) : new ti(this.source, 1, u);
  }
  handleChange(t) {
    return t.changes.touchesRange(this.from, this.to) ? new ti(
      this.source,
      0
      /* State.Inactive */
    ) : this.map(t.changes);
  }
  map(t) {
    return t.empty ? this : (this.result.map ? this.result.map(this.result, t) : this.result) ? new yc(this.source, this.explicitPos < 0 ? -1 : t.mapPos(this.explicitPos), this.result, t.mapPos(this.from), t.mapPos(this.to, 1)) : new ti(
      this.source,
      0
      /* State.Inactive */
    );
  }
}
function fee(e, t, n, r) {
  if (!e)
    return !1;
  let i = t.sliceDoc(n, r);
  return typeof e == "function" ? e(i, n, r, t) : nP(e, !0).test(i);
}
const iP = /* @__PURE__ */ In.define({
  map(e, t) {
    return e.map((n) => n.map(t));
  }
}), oP = /* @__PURE__ */ In.define(), gi = /* @__PURE__ */ Zo.define({
  create() {
    return rg.start();
  },
  update(e, t) {
    return e.update(t);
  },
  provide: (e) => [
    cC.from(e, (t) => t.tooltip),
    Vt.contentAttributes.from(e, (t) => t.attrs)
  ]
});
function gC(e, t) {
  const n = t.completion.apply || t.completion.label;
  let r = e.state.field(gi).active.find((i) => i.source == t.source);
  return r instanceof yc ? (typeof n == "string" ? e.dispatch(Object.assign(Object.assign({}, JJ(e.state, n, r.from, r.to)), { annotations: rP.of(t.completion) })) : n(e, t.completion, r.from, r.to), !0) : !1;
}
const hee = /* @__PURE__ */ see(gi, gC);
function $h(e, t = "option") {
  return (n) => {
    let r = n.state.field(gi, !1);
    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < n.state.facet(Tr).interactionDelay)
      return !1;
    let i = 1, o;
    t == "page" && (o = Wk(n, r.open.tooltip)) && (i = Math.max(2, Math.floor(o.dom.offsetHeight / o.dom.querySelector("li").offsetHeight) - 1));
    let { length: s } = r.open.options, a = r.open.selected > -1 ? r.open.selected + i * (e ? 1 : -1) : e ? 0 : s - 1;
    return a < 0 ? a = t == "page" ? 0 : s - 1 : a >= s && (a = t == "page" ? s - 1 : 0), n.dispatch({ effects: oP.of(a) }), !0;
  };
}
const pee = (e) => {
  let t = e.state.field(gi, !1);
  return e.state.readOnly || !t || !t.open || t.open.selected < 0 || t.open.disabled || Date.now() - t.open.timestamp < e.state.facet(Tr).interactionDelay ? !1 : gC(e, t.open.options[t.open.selected]);
}, gee = (e) => e.state.field(gi, !1) ? (e.dispatch({ effects: ng.of(!0) }), !0) : !1, mee = (e) => {
  let t = e.state.field(gi, !1);
  return !t || !t.active.some(
    (n) => n.state != 0
    /* State.Inactive */
  ) ? !1 : (e.dispatch({ effects: Hd.of(null) }), !0);
};
class vee {
  constructor(t, n) {
    this.active = t, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const bee = 50, yee = 1e3, wee = /* @__PURE__ */ Ao.fromClass(class {
  constructor(e) {
    this.view = e, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;
    for (let t of e.state.field(gi).active)
      t.state == 1 && this.startQuery(t);
  }
  update(e) {
    let t = e.state.field(gi), n = e.state.facet(Tr);
    if (!e.selectionSet && !e.docChanged && e.startState.field(gi) == t)
      return;
    let r = e.transactions.some((o) => (o.selection || o.docChanged) && !Ty(o, n));
    for (let o = 0; o < this.running.length; o++) {
      let s = this.running[o];
      if (r || s.updates.length + e.transactions.length > bee && Date.now() - s.time > yee) {
        for (let a of s.context.abortListeners)
          try {
            a();
          } catch (l) {
            bi(this.view.state, l);
          }
        s.context.abortListeners = null, this.running.splice(o--, 1);
      } else
        s.updates.push(...e.transactions);
    }
    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), e.transactions.some((o) => o.effects.some((s) => s.is(ng))) && (this.pendingStart = !0);
    let i = this.pendingStart ? 50 : n.activateOnTypingDelay;
    if (this.debounceUpdate = t.active.some((o) => o.state == 1 && !this.running.some((s) => s.active.source == o.source)) ? setTimeout(() => this.startUpdate(), i) : -1, this.composing != 0)
      for (let o of e.transactions)
        Ty(o, n) == "input" ? this.composing = 2 : this.composing == 2 && o.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1, this.pendingStart = !1;
    let { state: e } = this.view, t = e.field(gi);
    for (let n of t.active)
      n.state == 1 && !this.running.some((r) => r.active.source == n.source) && this.startQuery(n);
  }
  startQuery(e) {
    let { state: t } = this.view, n = ra(t), r = new tP(t, n, e.explicitPos == n), i = new vee(e, r);
    this.running.push(i), Promise.resolve(e.source(r)).then((o) => {
      i.context.aborted || (i.done = o || null, this.scheduleAccept());
    }, (o) => {
      this.view.dispatch({ effects: Hd.of(null) }), bi(this.view.state, o);
    });
  }
  scheduleAccept() {
    this.running.every((e) => e.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Tr).updateSyncTime));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var e;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let t = [], n = this.view.state.facet(Tr);
    for (let r = 0; r < this.running.length; r++) {
      let i = this.running[r];
      if (i.done === void 0)
        continue;
      if (this.running.splice(r--, 1), i.done) {
        let s = new yc(i.active.source, i.active.explicitPos, i.done, i.done.from, (e = i.done.to) !== null && e !== void 0 ? e : ra(i.updates.length ? i.updates[0].startState : this.view.state));
        for (let a of i.updates)
          s = s.update(a, n);
        if (s.hasResult()) {
          t.push(s);
          continue;
        }
      }
      let o = this.view.state.field(gi).active.find((s) => s.source == i.active.source);
      if (o && o.state == 1)
        if (i.done == null) {
          let s = new ti(
            i.active.source,
            0
            /* State.Inactive */
          );
          for (let a of i.updates)
            s = s.update(a, n);
          s.state != 1 && t.push(s);
        } else
          this.startQuery(o);
    }
    t.length && this.view.dispatch({ effects: iP.of(t) });
  }
}, {
  eventHandlers: {
    blur(e) {
      let t = this.view.state.field(gi, !1);
      if (t && t.tooltip && this.view.state.facet(Tr).closeOnBlur) {
        let n = t.open && Wk(this.view, t.open.tooltip);
        (!n || !n.dom.contains(e.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Hd.of(null) }), 10);
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: ng.of(!1) }), 20), this.composing = 0;
    }
  }
}), Cee = typeof navigator == "object" && /* @__PURE__ */ /Win/.test(navigator.platform), See = /* @__PURE__ */ Df.highest(/* @__PURE__ */ Vt.domEventHandlers({
  keydown(e, t) {
    let n = t.state.field(gi, !1);
    if (!n || !n.open || n.open.disabled || n.open.selected < 0 || e.key.length > 1 || e.ctrlKey && !(Cee && e.altKey) || e.metaKey)
      return !1;
    let r = n.open.options[n.open.selected], i = n.active.find((s) => s.source == r.source), o = r.completion.commitCharacters || i.result.commitCharacters;
    return o && o.indexOf(e.key) > -1 && gC(t, r), !1;
  }
})), xee = /* @__PURE__ */ Vt.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '""',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "''" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
}), Vd = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, za = /* @__PURE__ */ In.define({
  map(e, t) {
    let n = t.mapPos(e, -1, ni.TrackAfter);
    return n ?? void 0;
  }
}), mC = /* @__PURE__ */ new class extends rl {
}();
mC.startSide = 1;
mC.endSide = -1;
const sP = /* @__PURE__ */ Zo.define({
  create() {
    return En.empty;
  },
  update(e, t) {
    if (e = e.map(t.changes), t.selection) {
      let n = t.state.doc.lineAt(t.selection.main.head);
      e = e.update({ filter: (r) => r >= n.from && r <= n.to });
    }
    for (let n of t.effects)
      n.is(za) && (e = e.update({ add: [mC.range(n.value, n.value + 1)] }));
    return e;
  }
});
function Eee() {
  return [Oee, sP];
}
const Xv = "()[]{}<>";
function aP(e) {
  for (let t = 0; t < Xv.length; t += 2)
    if (Xv.charCodeAt(t) == e)
      return Xv.charAt(t + 1);
  return kI(e < 128 ? e : e + 1);
}
function lP(e, t) {
  return e.languageDataAt("closeBrackets", t)[0] || Vd;
}
const $ee = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), Oee = /* @__PURE__ */ Vt.inputHandler.of((e, t, n, r) => {
  if (($ee ? e.composing : e.compositionStarted) || e.state.readOnly)
    return !1;
  let i = e.state.selection.main;
  if (r.length > 2 || r.length == 2 && ho(ei(r, 0)) == 1 || t != i.from || n != i.to)
    return !1;
  let o = _ee(e.state, r);
  return o ? (e.dispatch(o), !0) : !1;
}), Aee = ({ state: e, dispatch: t }) => {
  if (e.readOnly)
    return !1;
  let r = lP(e, e.selection.main.head).brackets || Vd.brackets, i = null, o = e.changeByRange((s) => {
    if (s.empty) {
      let a = Tee(e.doc, s.head);
      for (let l of r)
        if (l == a && wm(e.doc, s.head) == aP(ei(l, 0)))
          return {
            changes: { from: s.head - l.length, to: s.head + l.length },
            range: st.cursor(s.head - l.length)
          };
    }
    return { range: i = s };
  });
  return i || t(e.update(o, { scrollIntoView: !0, userEvent: "delete.backward" })), !i;
}, Dee = [
  { key: "Backspace", run: Aee }
];
function _ee(e, t) {
  let n = lP(e, e.selection.main.head), r = n.brackets || Vd.brackets;
  for (let i of r) {
    let o = aP(ei(i, 0));
    if (t == i)
      return o == i ? Iee(e, i, r.indexOf(i + i + i) > -1, n) : Ree(e, i, o, n.before || Vd.before);
    if (t == o && cP(e, e.selection.main.from))
      return Mee(e, i, o);
  }
  return null;
}
function cP(e, t) {
  let n = !1;
  return e.field(sP).between(0, e.doc.length, (r) => {
    r == t && (n = !0);
  }), n;
}
function wm(e, t) {
  let n = e.sliceString(t, t + 2);
  return n.slice(0, ho(ei(n, 0)));
}
function Tee(e, t) {
  let n = e.sliceString(t - 2, t);
  return ho(ei(n, 0)) == n.length ? n : n.slice(1);
}
function Ree(e, t, n, r) {
  let i = null, o = e.changeByRange((s) => {
    if (!s.empty)
      return {
        changes: [{ insert: t, from: s.from }, { insert: n, from: s.to }],
        effects: za.of(s.to + t.length),
        range: st.range(s.anchor + t.length, s.head + t.length)
      };
    let a = wm(e.doc, s.head);
    return !a || /\s/.test(a) || r.indexOf(a) > -1 ? {
      changes: { insert: t + n, from: s.head },
      effects: za.of(s.head + t.length),
      range: st.cursor(s.head + t.length)
    } : { range: i = s };
  });
  return i ? null : e.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Mee(e, t, n) {
  let r = null, i = e.changeByRange((o) => o.empty && wm(e.doc, o.head) == n ? {
    changes: { from: o.head, to: o.head + n.length, insert: n },
    range: st.cursor(o.head + n.length)
  } : r = { range: o });
  return r ? null : e.update(i, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Iee(e, t, n, r) {
  let i = r.stringPrefixes || Vd.stringPrefixes, o = null, s = e.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: t, from: a.from }, { insert: t, from: a.to }],
        effects: za.of(a.to + t.length),
        range: st.range(a.anchor + t.length, a.head + t.length)
      };
    let l = a.head, u = wm(e.doc, l), c;
    if (u == t) {
      if (VO(e, l))
        return {
          changes: { insert: t + t, from: l },
          effects: za.of(l + t.length),
          range: st.cursor(l + t.length)
        };
      if (cP(e, l)) {
        let f = n && e.sliceDoc(l, l + t.length * 3) == t + t + t ? t + t + t : t;
        return {
          changes: { from: l, to: l + f.length, insert: f },
          range: st.cursor(l + f.length)
        };
      }
    } else {
      if (n && e.sliceDoc(l - 2 * t.length, l) == t + t && (c = WO(e, l - 2 * t.length, i)) > -1 && VO(e, c))
        return {
          changes: { insert: t + t + t + t, from: l },
          effects: za.of(l + t.length),
          range: st.cursor(l + t.length)
        };
      if (e.charCategorizer(l)(u) != Qi.Word && WO(e, l, i) > -1 && !kee(e, l, t, i))
        return {
          changes: { insert: t + t, from: l },
          effects: za.of(l + t.length),
          range: st.cursor(l + t.length)
        };
    }
    return { range: o = a };
  });
  return o ? null : e.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function VO(e, t) {
  let n = Ts(e).resolveInner(t + 1);
  return n.parent && n.from == t;
}
function kee(e, t, n, r) {
  let i = Ts(e).resolveInner(t, -1), o = r.reduce((s, a) => Math.max(s, a.length), 0);
  for (let s = 0; s < 5; s++) {
    let a = e.sliceDoc(i.from, Math.min(i.to, i.from + n.length + o)), l = a.indexOf(n);
    if (!l || l > -1 && r.indexOf(a.slice(0, l)) > -1) {
      let c = i.firstChild;
      for (; c && c.from == i.from && c.to - c.from > n.length + l; ) {
        if (e.sliceDoc(c.to - n.length, c.to) == n)
          return !1;
        c = c.firstChild;
      }
      return !0;
    }
    let u = i.to == t && i.parent;
    if (!u)
      break;
    i = u;
  }
  return !1;
}
function WO(e, t, n) {
  let r = e.charCategorizer(t);
  if (r(e.sliceDoc(t - 1, t)) != Qi.Word)
    return t;
  for (let i of n) {
    let o = t - i.length;
    if (e.sliceDoc(o, t) == i && r(e.sliceDoc(o - 1, o)) != Qi.Word)
      return o;
  }
  return -1;
}
function Pee(e = {}) {
  return [
    See,
    gi,
    Tr.of(e),
    wee,
    Lee,
    xee
  ];
}
const Nee = [
  { key: "Ctrl-Space", run: gee },
  { key: "Escape", run: mee },
  { key: "ArrowDown", run: /* @__PURE__ */ $h(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ $h(!1) },
  { key: "PageDown", run: /* @__PURE__ */ $h(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ $h(!1, "page") },
  { key: "Enter", run: pee }
], Lee = /* @__PURE__ */ Df.highest(/* @__PURE__ */ aC.computeN([Tr], (e) => e.facet(Tr).defaultKeymap ? [Nee] : []));
let Fee = class Ry {
  /**
  @internal
  */
  constructor(t, n, r, i, o, s, a, l, u, c = 0, d) {
    this.p = t, this.stack = n, this.state = r, this.reducePos = i, this.pos = o, this.score = s, this.buffer = a, this.bufferBase = l, this.curContext = u, this.lookAhead = c, this.parent = d;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((t, n) => n % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(t, n, r = 0) {
    let i = t.parser.context;
    return new Ry(t, [], n, r, r, 0, [], 0, i ? new UO(i, i.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(t, n) {
    this.stack.push(this.state, n, this.bufferBase + this.buffer.length), this.state = t;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(t) {
    var n;
    let r = t >> 19, i = t & 65535, { parser: o } = this.p, s = o.dynamicPrecedence(i);
    if (s && (this.score += s), r == 0) {
      this.pushState(o.getGoto(this.state, i, !0), this.reducePos), i < o.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, 4, !0), this.reduceContext(i, this.reducePos);
      return;
    }
    let a = this.stack.length - (r - 1) * 3 - (t & 262144 ? 6 : 0), l = a ? this.stack[a - 2] : this.p.ranges[0].from, u = this.reducePos - l;
    u >= 2e3 && !(!((n = this.p.parser.nodeSet.types[i]) === null || n === void 0) && n.isAnonymous) && (l == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = u) : this.p.lastBigReductionSize < u && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = l, this.p.lastBigReductionSize = u));
    let c = a ? this.stack[a - 1] : 0, d = this.bufferBase + this.buffer.length - c;
    if (i < o.minRepeatTerm || t & 131072) {
      let f = o.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(i, l, f, d + 4, !0);
    }
    if (t & 262144)
      this.state = this.stack[a];
    else {
      let f = this.stack[a - 3];
      this.state = o.getGoto(f, i, !0);
    }
    for (; this.stack.length > a; )
      this.stack.pop();
    this.reduceContext(i, l);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(t, n, r, i = 4, o = !1) {
    if (t == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let s = this, a = this.buffer.length;
      if (a == 0 && s.parent && (a = s.bufferBase - s.parent.bufferBase, s = s.parent), a > 0 && s.buffer[a - 4] == 0 && s.buffer[a - 1] > -1) {
        if (n == r)
          return;
        if (s.buffer[a - 2] >= n) {
          s.buffer[a - 2] = r;
          return;
        }
      }
    }
    if (!o || this.pos == r)
      this.buffer.push(t, n, r, i);
    else {
      let s = this.buffer.length;
      if (s > 0 && this.buffer[s - 4] != 0)
        for (; s > 0 && this.buffer[s - 2] > r; )
          this.buffer[s] = this.buffer[s - 4], this.buffer[s + 1] = this.buffer[s - 3], this.buffer[s + 2] = this.buffer[s - 2], this.buffer[s + 3] = this.buffer[s - 1], s -= 4, i > 4 && (i -= 4);
      this.buffer[s] = t, this.buffer[s + 1] = n, this.buffer[s + 2] = r, this.buffer[s + 3] = i;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(t, n, r, i) {
    if (t & 131072)
      this.pushState(t & 65535, this.pos);
    else if (t & 262144)
      this.pos = i, this.shiftContext(n, r), n <= this.p.parser.maxNode && this.buffer.push(n, r, i, 4);
    else {
      let o = t, { parser: s } = this.p;
      (i > this.pos || n <= s.maxNode) && (this.pos = i, s.stateFlag(
        o,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = i)), this.pushState(o, r), this.shiftContext(n, r), n <= s.maxNode && this.buffer.push(n, r, i, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(t, n, r, i) {
    t & 65536 ? this.reduce(t) : this.shift(t, n, r, i);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(t, n) {
    let r = this.p.reused.length - 1;
    (r < 0 || this.p.reused[r] != t) && (this.p.reused.push(t), r++);
    let i = this.pos;
    this.reducePos = this.pos = i + t.length, this.pushState(n, i), this.buffer.push(
      r,
      i,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, t, this, this.p.stream.reset(this.pos - t.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let t = this, n = t.buffer.length;
    for (; n > 0 && t.buffer[n - 2] > t.reducePos; )
      n -= 4;
    let r = t.buffer.slice(n), i = t.bufferBase + n;
    for (; t && i == t.bufferBase; )
      t = t.parent;
    return new Ry(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, r, i, this.curContext, this.lookAhead, t);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(t, n) {
    let r = t <= this.p.parser.maxNode;
    r && this.storeNode(t, this.pos, n, 4), this.storeNode(0, this.pos, n, r ? 8 : 4), this.pos = this.reducePos = n, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(t) {
    for (let n = new Bee(this); ; ) {
      let r = this.p.parser.stateSlot(
        n.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(n.state, t);
      if (r == 0)
        return !1;
      if (!(r & 65536))
        return !0;
      n.reduce(r);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(t) {
    if (this.stack.length >= 300)
      return [];
    let n = this.p.parser.nextStates(this.state);
    if (n.length > 8 || this.stack.length >= 120) {
      let i = [];
      for (let o = 0, s; o < n.length; o += 2)
        (s = n[o + 1]) != this.state && this.p.parser.hasAction(s, t) && i.push(n[o], s);
      if (this.stack.length < 120)
        for (let o = 0; i.length < 8 && o < n.length; o += 2) {
          let s = n[o + 1];
          i.some((a, l) => l & 1 && a == s) || i.push(n[o], s);
        }
      n = i;
    }
    let r = [];
    for (let i = 0; i < n.length && r.length < 4; i += 2) {
      let o = n[i + 1];
      if (o == this.state)
        continue;
      let s = this.split();
      s.pushState(o, this.pos), s.storeNode(0, s.pos, s.pos, 4, !0), s.shiftContext(n[i], this.pos), s.reducePos = this.pos, s.score -= 200, r.push(s);
    }
    return r;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: t } = this.p, n = t.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(n & 65536))
      return !1;
    if (!t.validAction(this.state, n)) {
      let r = n >> 19, i = n & 65535, o = this.stack.length - r * 3;
      if (o < 0 || t.getGoto(this.stack[o], i, !1) < 0) {
        let s = this.findForcedReduction();
        if (s == null)
          return !1;
        n = s;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(n), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: t } = this.p, n = [], r = (i, o) => {
      if (!n.includes(i))
        return n.push(i), t.allActions(i, (s) => {
          if (!(s & 393216))
            if (s & 65536) {
              let a = (s >> 19) - o;
              if (a > 1) {
                let l = s & 65535, u = this.stack.length - a * 3;
                if (u >= 0 && t.getGoto(this.stack[u], l, !1) >= 0)
                  return a << 19 | 65536 | l;
              }
            } else {
              let a = r(s, o + 1);
              if (a != null)
                return a;
            }
        });
    };
    return r(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: t } = this.p;
    return t.data[t.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !t.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(t) {
    if (this.state != t.state || this.stack.length != t.stack.length)
      return !1;
    for (let n = 0; n < this.stack.length; n += 3)
      if (this.stack[n] != t.stack[n])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(t) {
    return this.p.parser.dialect.flags[t];
  }
  shiftContext(t, n) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, t, this, this.p.stream.reset(n)));
  }
  reduceContext(t, n) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, t, this, this.p.stream.reset(n)));
  }
  /**
  @internal
  */
  emitContext() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(t) {
    if (t != this.curContext.context) {
      let n = new UO(this.curContext.tracker, t);
      n.hash != this.curContext.hash && this.emitContext(), this.curContext = n;
    }
  }
  /**
  @internal
  */
  setLookAhead(t) {
    t > this.lookAhead && (this.emitLookAhead(), this.lookAhead = t);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
};
class UO {
  constructor(t, n) {
    this.tracker = t, this.context = n, this.hash = t.strict ? t.hash(n) : 0;
  }
}
class Bee {
  constructor(t) {
    this.start = t, this.state = t.state, this.stack = t.stack, this.base = this.stack.length;
  }
  reduce(t) {
    let n = t & 65535, r = t >> 19;
    r == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (r - 1) * 3;
    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], n, !0);
    this.state = i;
  }
}
class ig {
  constructor(t, n, r) {
    this.stack = t, this.pos = n, this.index = r, this.buffer = t.buffer, this.index == 0 && this.maybeNext();
  }
  static create(t, n = t.bufferBase + t.buffer.length) {
    return new ig(t, n, n - t.bufferBase);
  }
  maybeNext() {
    let t = this.stack.parent;
    t != null && (this.index = this.stack.bufferBase - t.bufferBase, this.stack = t, this.buffer = t.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new ig(this.stack, this.pos, this.index);
  }
}
function Oh(e, t = Uint16Array) {
  if (typeof e != "string")
    return e;
  let n = null;
  for (let r = 0, i = 0; r < e.length; ) {
    let o = 0;
    for (; ; ) {
      let s = e.charCodeAt(r++), a = !1;
      if (s == 126) {
        o = 65535;
        break;
      }
      s >= 92 && s--, s >= 34 && s--;
      let l = s - 32;
      if (l >= 46 && (l -= 46, a = !0), o += l, a)
        break;
      o *= 46;
    }
    n ? n[i++] = o : n = new t(o);
  }
  return n;
}
class gp {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const GO = new gp();
class jee {
  /**
  @internal
  */
  constructor(t, n) {
    this.input = t, this.ranges = n, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = GO, this.rangeIndex = 0, this.pos = this.chunkPos = n[0].from, this.range = n[0], this.end = n[n.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(t, n) {
    let r = this.range, i = this.rangeIndex, o = this.pos + t;
    for (; o < r.from; ) {
      if (!i)
        return null;
      let s = this.ranges[--i];
      o -= r.from - s.to, r = s;
    }
    for (; n < 0 ? o > r.to : o >= r.to; ) {
      if (i == this.ranges.length - 1)
        return null;
      let s = this.ranges[++i];
      o += s.from - r.to, r = s;
    }
    return o;
  }
  /**
  @internal
  */
  clipPos(t) {
    if (t >= this.range.from && t < this.range.to)
      return t;
    for (let n of this.ranges)
      if (n.to > t)
        return Math.max(t, n.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingwhen looking forwardor even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(t) {
    let n = this.chunkOff + t, r, i;
    if (n >= 0 && n < this.chunk.length)
      r = this.pos + t, i = this.chunk.charCodeAt(n);
    else {
      let o = this.resolveOffset(t, 1);
      if (o == null)
        return -1;
      if (r = o, r >= this.chunk2Pos && r < this.chunk2Pos + this.chunk2.length)
        i = this.chunk2.charCodeAt(r - this.chunk2Pos);
      else {
        let s = this.rangeIndex, a = this.range;
        for (; a.to <= r; )
          a = this.ranges[++s];
        this.chunk2 = this.input.chunk(this.chunk2Pos = r), r + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - r)), i = this.chunk2.charCodeAt(0);
      }
    }
    return r >= this.token.lookAhead && (this.token.lookAhead = r + 1), i;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(t, n = 0) {
    let r = n ? this.resolveOffset(n, -1) : this.pos;
    if (r == null || r < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = t, this.token.end = r;
  }
  /**
  Accept a token ending at a specific given position.
  */
  acceptTokenTo(t, n) {
    this.token.value = t, this.token.end = n;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: t, chunkPos: n } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = t, this.chunk2Pos = n, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let t = this.input.chunk(this.pos), n = this.pos + t.length;
      this.chunk = n > this.range.to ? t.slice(0, this.range.to - this.pos) : t, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(t = 1) {
    for (this.chunkOff += t; this.pos + t >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      t -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += t, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(t, n) {
    if (n ? (this.token = n, n.start = t, n.lookAhead = t + 1, n.value = n.extended = -1) : this.token = GO, this.pos != t) {
      if (this.pos = t, t == this.end)
        return this.setDone(), this;
      for (; t < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; t >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      t >= this.chunkPos && t < this.chunkPos + this.chunk.length ? this.chunkOff = t - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(t, n) {
    if (t >= this.chunkPos && n <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(t - this.chunkPos, n - this.chunkPos);
    if (t >= this.chunk2Pos && n <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(t - this.chunk2Pos, n - this.chunk2Pos);
    if (t >= this.range.from && n <= this.range.to)
      return this.input.read(t, n);
    let r = "";
    for (let i of this.ranges) {
      if (i.from >= n)
        break;
      i.to > t && (r += this.input.read(Math.max(i.from, t), Math.min(i.to, n)));
    }
    return r;
  }
}
class wc {
  constructor(t, n) {
    this.data = t, this.id = n;
  }
  token(t, n) {
    let { parser: r } = n.p;
    zee(this.data, t, n, this.id, r.data, r.tokenPrecTable);
  }
}
wc.prototype.contextual = wc.prototype.fallback = wc.prototype.extend = !1;
wc.prototype.fallback = wc.prototype.extend = !1;
function zee(e, t, n, r, i, o) {
  let s = 0, a = 1 << r, { dialect: l } = n.p.parser;
  e:
    for (; a & e[s]; ) {
      let u = e[s + 1];
      for (let h = s + 3; h < u; h += 2)
        if ((e[h + 1] & a) > 0) {
          let p = e[h];
          if (l.allows(p) && (t.token.value == -1 || t.token.value == p || Hee(p, t.token.value, i, o))) {
            t.acceptToken(p);
            break;
          }
        }
      let c = t.next, d = 0, f = e[s + 2];
      if (t.next < 0 && f > d && e[u + f * 3 - 3] == 65535) {
        s = e[u + f * 3 - 1];
        continue e;
      }
      for (; d < f; ) {
        let h = d + f >> 1, p = u + h + (h << 1), g = e[p], m = e[p + 1] || 65536;
        if (c < g)
          f = h;
        else if (c >= m)
          d = h + 1;
        else {
          s = e[p + 2], t.advance();
          continue e;
        }
      }
      break;
    }
}
function KO(e, t, n) {
  for (let r = t, i; (i = e[r]) != 65535; r++)
    if (i == n)
      return r - t;
  return -1;
}
function Hee(e, t, n, r) {
  let i = KO(n, r, t);
  return i < 0 || KO(n, r, e) < i;
}
const Di = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let Yv = null;
function XO(e, t, n) {
  let r = e.cursor(Ln.IncludeAnonymous);
  for (r.moveTo(t); ; )
    if (!(n < 0 ? r.childBefore(t) : r.childAfter(t)))
      for (; ; ) {
        if ((n < 0 ? r.to < t : r.from > t) && !r.type.isError)
          return n < 0 ? Math.max(0, Math.min(
            r.to - 1,
            t - 25
            /* Safety.Margin */
          )) : Math.min(e.length, Math.max(
            r.from + 1,
            t + 25
            /* Safety.Margin */
          ));
        if (n < 0 ? r.prevSibling() : r.nextSibling())
          break;
        if (!r.parent())
          return n < 0 ? 0 : e.length;
      }
}
class Vee {
  constructor(t, n) {
    this.fragments = t, this.nodeSet = n, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let t = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (t) {
      for (this.safeFrom = t.openStart ? XO(t.tree, t.from + t.offset, 1) - t.offset : t.from, this.safeTo = t.openEnd ? XO(t.tree, t.to + t.offset, -1) - t.offset : t.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(t.tree), this.start.push(-t.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(t) {
    if (t < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= t; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let n = this.trees.length - 1;
      if (n < 0)
        return this.nextFragment(), null;
      let r = this.trees[n], i = this.index[n];
      if (i == r.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let o = r.children[i], s = this.start[n] + r.positions[i];
      if (s > t)
        return this.nextStart = s, null;
      if (o instanceof Wn) {
        if (s == t) {
          if (s < this.safeFrom)
            return null;
          let a = s + o.length;
          if (a <= this.safeTo) {
            let l = o.prop(on.lookAhead);
            if (!l || a + l < this.fragment.to)
              return o;
          }
        }
        this.index[n]++, s + o.length >= Math.max(this.safeFrom, t) && (this.trees.push(o), this.start.push(s), this.index.push(0));
      } else
        this.index[n]++, this.nextStart = s + o.length;
    }
  }
}
class Wee {
  constructor(t, n) {
    this.stream = n, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = t.tokenizers.map((r) => new gp());
  }
  getActions(t) {
    let n = 0, r = null, { parser: i } = t.p, { tokenizers: o } = i, s = i.stateSlot(
      t.state,
      3
      /* ParseState.TokenizerMask */
    ), a = t.curContext ? t.curContext.hash : 0, l = 0;
    for (let u = 0; u < o.length; u++) {
      if (!(1 << u & s))
        continue;
      let c = o[u], d = this.tokens[u];
      if (!(r && !c.fallback) && ((c.contextual || d.start != t.pos || d.mask != s || d.context != a) && (this.updateCachedToken(d, c, t), d.mask = s, d.context = a), d.lookAhead > d.end + 25 && (l = Math.max(d.lookAhead, l)), d.value != 0)) {
        let f = n;
        if (d.extended > -1 && (n = this.addActions(t, d.extended, d.end, n)), n = this.addActions(t, d.value, d.end, n), !c.extend && (r = d, n > f))
          break;
      }
    }
    for (; this.actions.length > n; )
      this.actions.pop();
    return l && t.setLookAhead(l), !r && t.pos == this.stream.end && (r = new gp(), r.value = t.p.parser.eofTerm, r.start = r.end = t.pos, n = this.addActions(t, r.value, r.end, n)), this.mainToken = r, this.actions;
  }
  getMainToken(t) {
    if (this.mainToken)
      return this.mainToken;
    let n = new gp(), { pos: r, p: i } = t;
    return n.start = r, n.end = Math.min(r + 1, i.stream.end), n.value = r == i.stream.end ? i.parser.eofTerm : 0, n;
  }
  updateCachedToken(t, n, r) {
    let i = this.stream.clipPos(r.pos);
    if (n.token(this.stream.reset(i, t), r), t.value > -1) {
      let { parser: o } = r.p;
      for (let s = 0; s < o.specialized.length; s++)
        if (o.specialized[s] == t.value) {
          let a = o.specializers[s](this.stream.read(t.start, t.end), r);
          if (a >= 0 && r.p.parser.dialect.allows(a >> 1)) {
            a & 1 ? t.extended = a >> 1 : t.value = a >> 1;
            break;
          }
        }
    } else
      t.value = 0, t.end = this.stream.clipPos(i + 1);
  }
  putAction(t, n, r, i) {
    for (let o = 0; o < i; o += 3)
      if (this.actions[o] == t)
        return i;
    return this.actions[i++] = t, this.actions[i++] = n, this.actions[i++] = r, i;
  }
  addActions(t, n, r, i) {
    let { state: o } = t, { parser: s } = t.p, { data: a } = s;
    for (let l = 0; l < 2; l++)
      for (let u = s.stateSlot(
        o,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; u += 3) {
        if (a[u] == 65535)
          if (a[u + 1] == 1)
            u = ds(a, u + 2);
          else {
            i == 0 && a[u + 1] == 2 && (i = this.putAction(ds(a, u + 2), n, r, i));
            break;
          }
        a[u] == n && (i = this.putAction(ds(a, u + 1), n, r, i));
      }
    return i;
  }
}
class Uee {
  constructor(t, n, r, i) {
    this.parser = t, this.input = n, this.ranges = i, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new jee(n, i), this.tokens = new Wee(t, this.stream), this.topTerm = t.top[1];
    let { from: o } = i[0];
    this.stacks = [Fee.start(this, t.top[0], o)], this.fragments = r.length && this.stream.end - o > t.bufferLength * 4 ? new Vee(r, t.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let t = this.stacks, n = this.minStackPos, r = this.stacks = [], i, o;
    if (this.bigReductionCount > 300 && t.length == 1) {
      let [s] = t;
      for (; s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let s = 0; s < t.length; s++) {
      let a = t[s];
      for (; ; ) {
        if (this.tokens.mainToken = null, a.pos > n)
          r.push(a);
        else {
          if (this.advanceStack(a, r, t))
            continue;
          {
            i || (i = [], o = []), i.push(a);
            let l = this.tokens.getMainToken(a);
            o.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!r.length) {
      let s = i && Kee(i);
      if (s)
        return Di && console.log("Finish with " + this.stackID(s)), this.stackToTree(s);
      if (this.parser.strict)
        throw Di && i && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + n);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && i) {
      let s = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, o, r);
      if (s)
        return Di && console.log("Force-finish " + this.stackID(s)), this.stackToTree(s.forceAll());
    }
    if (this.recovering) {
      let s = this.recovering == 1 ? 1 : this.recovering * 3;
      if (r.length > s)
        for (r.sort((a, l) => l.score - a.score); r.length > s; )
          r.pop();
      r.some((a) => a.reducePos > n) && this.recovering--;
    } else if (r.length > 1) {
      e:
        for (let s = 0; s < r.length - 1; s++) {
          let a = r[s];
          for (let l = s + 1; l < r.length; l++) {
            let u = r[l];
            if (a.sameState(u) || a.buffer.length > 500 && u.buffer.length > 500)
              if ((a.score - u.score || a.buffer.length - u.buffer.length) > 0)
                r.splice(l--, 1);
              else {
                r.splice(s--, 1);
                continue e;
              }
          }
        }
      r.length > 12 && r.splice(
        12,
        r.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = r[0].pos;
    for (let s = 1; s < r.length; s++)
      r[s].pos < this.minStackPos && (this.minStackPos = r[s].pos);
    return null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(t, n, r) {
    let i = t.pos, { parser: o } = this, s = Di ? this.stackID(t) + " -> " : "";
    if (this.stoppedAt != null && i > this.stoppedAt)
      return t.forceReduce() ? t : null;
    if (this.fragments) {
      let u = t.curContext && t.curContext.tracker.strict, c = u ? t.curContext.hash : 0;
      for (let d = this.fragments.nodeAt(i); d; ) {
        let f = this.parser.nodeSet.types[d.type.id] == d.type ? o.getGoto(t.state, d.type.id) : -1;
        if (f > -1 && d.length && (!u || (d.prop(on.contextHash) || 0) == c))
          return t.useNode(d, f), Di && console.log(s + this.stackID(t) + ` (via reuse of ${o.getName(d.type.id)})`), !0;
        if (!(d instanceof Wn) || d.children.length == 0 || d.positions[0] > 0)
          break;
        let h = d.children[0];
        if (h instanceof Wn && d.positions[0] == 0)
          d = h;
        else
          break;
      }
    }
    let a = o.stateSlot(
      t.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (a > 0)
      return t.reduce(a), Di && console.log(s + this.stackID(t) + ` (via always-reduce ${o.getName(
        a & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (t.stack.length >= 8400)
      for (; t.stack.length > 6e3 && t.forceReduce(); )
        ;
    let l = this.tokens.getActions(t);
    for (let u = 0; u < l.length; ) {
      let c = l[u++], d = l[u++], f = l[u++], h = u == l.length || !r, p = h ? t : t.split(), g = this.tokens.mainToken;
      if (p.apply(c, d, g ? g.start : p.pos, f), Di && console.log(s + this.stackID(p) + ` (via ${c & 65536 ? `reduce of ${o.getName(
        c & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${o.getName(d)} @ ${i}${p == t ? "" : ", split"})`), h)
        return !0;
      p.pos > i ? n.push(p) : r.push(p);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(t, n) {
    let r = t.pos;
    for (; ; ) {
      if (!this.advanceStack(t, null, null))
        return !1;
      if (t.pos > r)
        return YO(t, n), !0;
    }
  }
  runRecovery(t, n, r) {
    let i = null, o = !1;
    for (let s = 0; s < t.length; s++) {
      let a = t[s], l = n[s << 1], u = n[(s << 1) + 1], c = Di ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (o || (o = !0, a.restart(), Di && console.log(c + this.stackID(a) + " (restarted)"), this.advanceFully(a, r))))
        continue;
      let d = a.split(), f = c;
      for (let h = 0; d.forceReduce() && h < 10 && (Di && console.log(f + this.stackID(d) + " (via force-reduce)"), !this.advanceFully(d, r)); h++)
        Di && (f = this.stackID(d) + " -> ");
      for (let h of a.recoverByInsert(l))
        Di && console.log(c + this.stackID(h) + " (via recover-insert)"), this.advanceFully(h, r);
      this.stream.end > a.pos ? (u == a.pos && (u++, l = 0), a.recoverByDelete(l, u), Di && console.log(c + this.stackID(a) + ` (via recover-delete ${this.parser.getName(l)})`), YO(a, r)) : (!i || i.score < a.score) && (i = a);
    }
    return i;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(t) {
    return t.close(), Wn.build({
      buffer: ig.create(t),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: t.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(t) {
    let n = (Yv || (Yv = /* @__PURE__ */ new WeakMap())).get(t);
    return n || Yv.set(t, n = String.fromCodePoint(this.nextStackID++)), n + t;
  }
}
function YO(e, t) {
  for (let n = 0; n < t.length; n++) {
    let r = t[n];
    if (r.pos == e.pos && r.sameState(e)) {
      t[n].score < e.score && (t[n] = e);
      return;
    }
  }
  t.push(e);
}
class Gee {
  constructor(t, n, r) {
    this.source = t, this.flags = n, this.disabled = r;
  }
  allows(t) {
    return !this.disabled || this.disabled[t] == 0;
  }
}
class Wd extends Yk {
  /**
  @internal
  */
  constructor(t) {
    if (super(), this.wrappers = [], t.version != 14)
      throw new RangeError(`Parser version (${t.version}) doesn't match runtime version (14)`);
    let n = t.nodeNames.split(" ");
    this.minRepeatTerm = n.length;
    for (let a = 0; a < t.repeatNodeCount; a++)
      n.push("");
    let r = Object.keys(t.topRules).map((a) => t.topRules[a][1]), i = [];
    for (let a = 0; a < n.length; a++)
      i.push([]);
    function o(a, l, u) {
      i[a].push([l, l.deserialize(String(u))]);
    }
    if (t.nodeProps)
      for (let a of t.nodeProps) {
        let l = a[0];
        typeof l == "string" && (l = on[l]);
        for (let u = 1; u < a.length; ) {
          let c = a[u++];
          if (c >= 0)
            o(c, l, a[u++]);
          else {
            let d = a[u + -c];
            for (let f = -c; f > 0; f--)
              o(a[u++], l, d);
            u++;
          }
        }
      }
    this.nodeSet = new uC(n.map((a, l) => ai.define({
      name: l >= this.minRepeatTerm ? void 0 : a,
      id: l,
      props: i[l],
      top: r.indexOf(l) > -1,
      error: l == 0,
      skipped: t.skippedNodes && t.skippedNodes.indexOf(l) > -1
    }))), t.propSources && (this.nodeSet = this.nodeSet.extend(...t.propSources)), this.strict = !1, this.bufferLength = Uk;
    let s = Oh(t.tokenData);
    this.context = t.context, this.specializerSpecs = t.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term;
    this.specializers = this.specializerSpecs.map(qO), this.states = Oh(t.states, Uint32Array), this.data = Oh(t.stateData), this.goto = Oh(t.goto), this.maxTerm = t.maxTerm, this.tokenizers = t.tokenizers.map((a) => typeof a == "number" ? new wc(s, a) : a), this.topRules = t.topRules, this.dialects = t.dialects || {}, this.dynamicPrecedences = t.dynamicPrecedences || null, this.tokenPrecTable = t.tokenPrec, this.termNames = t.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(t, n, r) {
    let i = new Uee(this, t, n, r);
    for (let o of this.wrappers)
      i = o(i, t, n, r);
    return i;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(t, n, r = !1) {
    let i = this.goto;
    if (n >= i[0])
      return -1;
    for (let o = i[n + 1]; ; ) {
      let s = i[o++], a = s & 1, l = i[o++];
      if (a && r)
        return l;
      for (let u = o + (s >> 1); o < u; o++)
        if (i[o] == t)
          return l;
      if (a)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(t, n) {
    let r = this.data;
    for (let i = 0; i < 2; i++)
      for (let o = this.stateSlot(
        t,
        i ? 2 : 1
        /* ParseState.Actions */
      ), s; ; o += 3) {
        if ((s = r[o]) == 65535)
          if (r[o + 1] == 1)
            s = r[o = ds(r, o + 2)];
          else {
            if (r[o + 1] == 2)
              return ds(r, o + 2);
            break;
          }
        if (s == n || s == 0)
          return ds(r, o + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(t, n) {
    return this.states[t * 6 + n];
  }
  /**
  @internal
  */
  stateFlag(t, n) {
    return (this.stateSlot(
      t,
      0
      /* ParseState.Flags */
    ) & n) > 0;
  }
  /**
  @internal
  */
  validAction(t, n) {
    return !!this.allActions(t, (r) => r == n ? !0 : null);
  }
  /**
  @internal
  */
  allActions(t, n) {
    let r = this.stateSlot(
      t,
      4
      /* ParseState.DefaultReduce */
    ), i = r ? n(r) : void 0;
    for (let o = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); i == null; o += 3) {
      if (this.data[o] == 65535)
        if (this.data[o + 1] == 1)
          o = ds(this.data, o + 2);
        else
          break;
      i = n(ds(this.data, o + 1));
    }
    return i;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(t) {
    let n = [];
    for (let r = this.stateSlot(
      t,
      1
      /* ParseState.Actions */
    ); ; r += 3) {
      if (this.data[r] == 65535)
        if (this.data[r + 1] == 1)
          r = ds(this.data, r + 2);
        else
          break;
      if (!(this.data[r + 2] & 1)) {
        let i = this.data[r + 1];
        n.some((o, s) => s & 1 && o == i) || n.push(this.data[r], i);
      }
    }
    return n;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(t) {
    let n = Object.assign(Object.create(Wd.prototype), this);
    if (t.props && (n.nodeSet = this.nodeSet.extend(...t.props)), t.top) {
      let r = this.topRules[t.top];
      if (!r)
        throw new RangeError(`Invalid top rule name ${t.top}`);
      n.top = r;
    }
    return t.tokenizers && (n.tokenizers = this.tokenizers.map((r) => {
      let i = t.tokenizers.find((o) => o.from == r);
      return i ? i.to : r;
    })), t.specializers && (n.specializers = this.specializers.slice(), n.specializerSpecs = this.specializerSpecs.map((r, i) => {
      let o = t.specializers.find((a) => a.from == r.external);
      if (!o)
        return r;
      let s = Object.assign(Object.assign({}, r), { external: o.to });
      return n.specializers[i] = qO(s), s;
    })), t.contextTracker && (n.context = t.contextTracker), t.dialect && (n.dialect = this.parseDialect(t.dialect)), t.strict != null && (n.strict = t.strict), t.wrap && (n.wrappers = n.wrappers.concat(t.wrap)), t.bufferLength != null && (n.bufferLength = t.bufferLength), n;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(t) {
    return this.termNames ? this.termNames[t] : String(t <= this.maxNode && this.nodeSet.types[t].name || t);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(t) {
    let n = this.dynamicPrecedences;
    return n == null ? 0 : n[t] || 0;
  }
  /**
  @internal
  */
  parseDialect(t) {
    let n = Object.keys(this.dialects), r = n.map(() => !1);
    if (t)
      for (let o of t.split(" ")) {
        let s = n.indexOf(o);
        s >= 0 && (r[s] = !0);
      }
    let i = null;
    for (let o = 0; o < n.length; o++)
      if (!r[o])
        for (let s = this.dialects[n[o]], a; (a = this.data[s++]) != 65535; )
          (i || (i = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new Gee(t, r, i);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(t) {
    return new Wd(t);
  }
}
function ds(e, t) {
  return e[t] | e[t + 1] << 16;
}
function Kee(e) {
  let t = null;
  for (let n of e) {
    let r = n.p.stoppedAt;
    (n.pos == n.p.stream.end || r != null && n.pos > r) && n.p.parser.stateFlag(
      n.state,
      2
      /* StateFlag.Accepting */
    ) && (!t || t.score < n.score) && (t = n);
  }
  return t;
}
function qO(e) {
  if (e.external) {
    let t = e.extend ? 1 : 0;
    return (n, r) => e.external(n, r) << 1 | t;
  }
  return e.get;
}
const Xee = pC({
  TemplateString: Ne.special(Ne.string),
  BooleanLiteral: Ne.bool,
  null: Ne.null,
  VariableName: Ne.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": Ne.function(Ne.variableName),
  PropertyName: Ne.propertyName,
  "CallExpression/MemberExpression/PropertyName": Ne.function(Ne.propertyName),
  PropertyDefinition: Ne.definition(Ne.propertyName),
  Number: Ne.number,
  String: Ne.string,
  Escape: Ne.escape,
  ArithOp: Ne.arithmeticOperator,
  LogicOp: Ne.logicOperator,
  "and or": Ne.logicOperator,
  CallbackReference: Ne.self,
  CompareOp: Ne.compareOperator,
  ":": Ne.punctuation,
  "( )": Ne.paren,
  "[ ]": Ne.squareBracket,
  "{ }": Ne.brace,
  "InterpolationStart InterpolationEnd": Ne.brace,
  ".": Ne.derefOperator,
  ", ;": Ne.separator
}), Yee = { __proto__: null, true: 12, false: 12, null: 14, and: 58, or: 60 }, uP = Wd.deserialize({
  version: 14,
  states: "*OQVQPOOOzOQO'#C_O!VOSO'#C_OOQO'#Ca'#CaO!bQPO'#CfOVQPO'#ChOVQPO'#CmO#jQPO'#D]OOQO'#D^'#D^OOQO'#D]'#D]OOQO'#DS'#DSQVQPOOOOOO'#DT'#DTO$dOQO,58yOOQO,58y,58yOOOO'#DU'#DUO$oOSO,58yO$zQPO'#DVO%UQPO'#DeO%^QPO'#DeO%hQPO,59QO%mQPO,59SO'dQPO,59XO'iQWO,59YOVQPO,59]OVQPO,59]OVQPO,59]OVQPO,59]OOQO'#C|'#C|OVQPO,59gOOQO,59j,59jO'qQPO'#DQOOQO,59k,59kOVQPO'#DXO'xQPO,59mOVQPO,59]OVQPO,59]OOQO-E7Q-E7QOOOO-E7R-E7ROOQO1G.e1G.eOOOO-E7S-E7SO(yQPO,59qOOQO-E7T-E7TO)TQPO,5:POOQO1G.l1G.lOOQO1G.s1G.sOOQO'#Cp'#CpOOQO1G.t1G.tOVQPO1G.tO*vQPO1G.wO+WQPO1G.wO-XQPO1G.wO-cQPO1G.wO-mQPO1G/RO-tQPO'#DhO.OQPO,59lO.TQPO,59sOOQO-E7V-E7VO0qQPO1G.wO0xQPO1G.wO1PQPO7+$`OVQPO7+$mO1UQPO'#DWO1`QPO,5:SOOQO1G/W1G/WOOQO<<Gz<<GzO1hQPO<<HXO2eQPO,59rOOQO-E7U-E7U",
  stateData: "2u~O!OOS~OQWOSWOUWOVWOXSO]TO^TO`UO!RPO!UQO!WRO~O!R^O!S[O!T^O~O!T^O!U^O!V_O~OZaOW!XP~PVO]nO^iO`oOcgOfhOghOhhOihOjjOkjOlkOmsOntO!ZlO~OZqOQ!PXS!PXU!PXV!PXX!PX|!PX!R!PX!U!PX!W!PX_!PXW!PX~P!lO!RwO!S[O!TwO~O!TwO!UwO!V_O~OWyXZyX~PVOZaOW!XX~OZaOW!XX~P!lOW|O~O`oOcgOQ[aS[aU[aV[aX[aZ[a][a^[af[ag[ah[ai[aj[ak[al[am[an[a|[a!R[a!U[a!W[a!Z[aW[a_[aq[a~O_}O~OX!QO!Y!OO~O_![P~PVOZqOQuaSuaUuaVuaXua]ua^ua`ua|ua!Rua!Uua!Wua_uaWua~OWyaZya~P!lOZaOW!Xa~O]nO`oOcgOQeiSeiUeiVeiXeiZei^eijeikeileimeinei|ei!Rei!Uei!Wei!ZeiWei_eiqei~Ofeigeiheiiei~P)]OfhOghOhhOihO~P)]O]nO^iO`oOcgOfhOghOhhOihOQeiSeiUeiVeiXeiZeileimeinei|ei!Rei!Uei!Wei!ZeiWei_eiqei~Ojeikei~P+hOjjOkjO~P+hOq!_O~P!lOZ!`O_![X~P!lO_!bO~OQ{aS{aU{aV{aX{aZ{a|{a!R{a!U{a!W{a_{aW{a~P!lO]nO^iO`oOcgOfhOghOhhOihOjjOkjOlkOQeiSeiUeiVeiXeiZeinei|ei!Rei!Uei!Wei!ZeiWei_eiqei~Omei~P.}OmsO~P.}OW!cO~OZzX_zX~PVOZ!`O_![a~OQoySoyUoyVoyXoyZoy|oy!Roy!Uoy!WoyWoy_oyqoy~P!lOZza_za~P!lO!O!WQc!Y~",
  goto: "%t!]PPP!^P!^PPPP!^P!^PPPP!^!^P!r!^PPPPPPPPP!^!uP!^!^#P#b#h#n#t#z$U$[PPP$b$lPPPPPP%nPP%quWOSTUZahijkmoqst!Q!_!`R!PgamVcy!V!W!Y!d!eopVcey!R!S!T!U!V!W!Y![!]!d!eXXOUZ!QQZORuZQ]PRv]Q`QRx`QbSSzb{R{cQ!a!WR!f!aQrVR!ZrSYOZQfUR!^!QWVOUZ!QQcSQeTQyaQ!RhQ!SiQ!TjQ!UkQ!VmQ!WoQ!YqQ![sQ!]tQ!d!_R!e!`RdSR!Xo",
  nodeNames: " Standard Number String CallbackReference VariableName BooleanLiteral null ] [ ArrayExpression , UnaryExpression LogicOp ArithOp ) ( ParenthesizedExpression MemberExpression . PropertyName BinaryExpression ArithOp ArithOp ArithOp ArithOp CompareOp CompareOp CompareOp and or ConditionalExpression LogicOp LogicOp PostfixExpression CallExpression ArgList SequenceExpression",
  maxTerm: 58,
  nodeProps: [
    ["group", 1, "autoComplete", -15, 2, 3, 4, 5, 6, 7, 10, 12, 17, 18, 21, 31, 34, 35, 37, "Expression"],
    ["isolate", 3, ""],
    ["openedBy", 8, "[", 15, "("],
    ["closedBy", 9, "]", 16, ")"]
  ],
  propSources: [Xee],
  skippedNodes: [0],
  repeatNodeCount: 6,
  tokenData: "@f_R!WOX$kXY&hYZ)^Z[&h[p$kpq&hqr*Wrs+rst,Ytu,{uv.ivw$kwx/[xy/ryz0ez{1W{|1y|}2l}!O1y!O!P3_!P!Q5V!Q![5x![!]6}!]!^$k!^!_7p!_!`9[!`!a:R!a!b:z!b!c$k!c!},{!}#O;m#O#P$k#P#Q<`#Q#R=R#R#S,{#S#T$k#T#o,{#o$f$k$f$g&h$g#BY,{#BY#BZ=t#BZ$IS,{$IS$I_=t$I_$JT,{$JT$JU=t$JU$KV,{$KV$KW=t$KW&FU,{&FU&FV=t&FV;'S,{;'S;=`.c<%l?HT,{?HT?HU=t?HUO,{U$rW!SQ!VSOY$kZr$krs%[sw$kwx%vx;'S$k;'S;=`&b<%lO$kS%aT!VSOY%[Zw%[x;'S%[;'S;=`%p<%lO%[S%sP;=`<%l%[Q%{T!SQOY%vZr%vs;'S%v;'S;=`&[<%lO%vQ&_P;=`<%l%vU&eP;=`<%l$k_&qk!SQ!VS!OXOX$kXY&hYZ(fZ[&h[p$kpq&hqr$krs%[sw$kwx%vx$f$k$f$g&h$g#BY$k#BY#BZ&h#BZ$IS$k$IS$I_&h$I_$JT$k$JT$JU&h$JU$KV$k$KV$KW&h$KW&FU$k&FU&FV&h&FV;'S$k;'S;=`&b<%l?HT$k?HT?HU&h?HUO$kX(kZ!OXXY(fYZ(fZ[(fpq(f$f$g(f#BY#BZ(f$IS$I_(f$JT$JU(f$KV$KW(f&FU&FV(f?HT?HU(f_)eZ!TU!OXXY(fYZ(fZ[(fpq(f$f$g(f#BY#BZ(f$IS$I_(f$JT$JU(f$KV$KW(f&FU&FV(f?HT?HU(fV*aY]P!SQ!VSOY$kZr$krs%[sw$kwx%vx!_$k!_!`+P!`;'S$k;'S;=`&b<%lO$kV+YWlP!SQ!VSOY$kZr$krs%[sw$kwx%vx;'S$k;'S;=`&b<%lO$kV+yT!RR!VSOY%[Zw%[x;'S%[;'S;=`%p<%lO%[V,cWSP!SQ!VSOY$kZr$krs%[sw$kwx%vx;'S$k;'S;=`&b<%lO$k_-Wc!SQ!VS!WP!YWOY$kZr$krs%[st$ktu,{uw$kwx%vx!Q$k!Q![,{![!c$k!c!},{!}#R$k#R#S,{#S#T$k#T#o,{#o$g$k$g;'S,{;'S;=`.c<%lO,{_.fP;=`<%l,{V.rWgP!SQ!VSOY$kZr$krs%[sw$kwx%vx;'S$k;'S;=`&b<%lO$kV/cT!UT!SQOY%vZr%vs;'S%v;'S;=`&[<%lO%vV/{W`P!SQ!VSOY$kZr$krs%[sw$kwx%vx;'S$k;'S;=`&b<%lO$kV0nW_P!SQ!VSOY$kZr$krs%[sw$kwx%vx;'S$k;'S;=`&b<%lO$kV1aWhP!SQ!VSOY$kZr$krs%[sw$kwx%vx;'S$k;'S;=`&b<%lO$kV2SW^P!SQ!VSOY$kZr$krs%[sw$kwx%vx;'S$k;'S;=`&b<%lO$kV2uWZP!SQ!VSOY$kZr$krs%[sw$kwx%vx;'S$k;'S;=`&b<%lO$kV3hY!SQ!VScPOY$kZr$krs%[sw$kwx%vx!Q$k!Q![4W![;'S$k;'S;=`&b<%lO$kV4a[!SQ!VSQPOY$kZr$krs%[sw$kwx%vx!Q$k!Q![4W![#R$k#R#S4W#S;'S$k;'S;=`&b<%lO$kV5`WfP!SQ!VSOY$kZr$krs%[sw$kwx%vx;'S$k;'S;=`&b<%lO$kV6R^!SQ!VSQPOY$kZr$krs%[sw$kwx%vx!O$k!O!P4W!P!Q$k!Q![5x![#R$k#R#S5x#S;'S$k;'S;=`&b<%lO$kV7WWqP!SQ!VSOY$kZr$krs%[sw$kwx%vx;'S$k;'S;=`&b<%lO$kV7yYjP!SQ!VSOY$kZr$krs%[sw$kwx%vx!_$k!_!`8i!`;'S$k;'S;=`&b<%lO$kV8rWkP!SQ!VSOY$kZr$krs%[sw$kwx%vx;'S$k;'S;=`&b<%lO$kV9cY!SQ!VSOY$kZr$krs%[sw$kwx%vx!_$k!_!`+P!`;'S$k;'S;=`&b<%lO$kV:[YkP!SQ!VSOY$kZr$krs%[sw$kwx%vx!_$k!_!`8i!`;'S$k;'S;=`&b<%lO$kV;TW!ZP!SQ!VSOY$kZr$krs%[sw$kwx%vx;'S$k;'S;=`&b<%lO$k_;vWXX!SQ!VSOY$kZr$krs%[sw$kwx%vx;'S$k;'S;=`&b<%lO$kV<iWWP!SQ!VSOY$kZr$krs%[sw$kwx%vx;'S$k;'S;=`&b<%lO$kV=[WiP!SQ!VSOY$kZr$krs%[sw$kwx%vx;'S$k;'S;=`&b<%lO$k_>Ru!SQ!VS!OX!WP!YWOX$kXY&hYZ(fZ[&h[p$kpq&hqr$krs%[st$ktu,{uw$kwx%vx!Q$k!Q![,{![!c$k!c!},{!}#R$k#R#S,{#S#T$k#T#o,{#o$f$k$f$g&h$g#BY,{#BY#BZ=t#BZ$IS,{$IS$I_=t$I_$JT,{$JT$JU=t$JU$KV,{$KV$KW=t$KW&FU,{&FU&FV=t&FV;'S,{;'S;=`.c<%l?HT,{?HT?HU=t?HUO,{",
  tokenizers: [0, 1, 2, 3],
  topRules: { Standard: [0, 1] },
  specialized: [{ term: 54, get: (e) => Yee[e] || -1 }],
  tokenPrec: 813
}), qee = pC({
  Text: Ne.content,
  "ExpressionOpen ExpressionClose": Ne.special(Ne.brace)
}), Qee = Wd.deserialize({
  version: 14,
  states: "!dOQOPOOOOOO'#C_'#C_OYOPO'#C^OOOO'#Cb'#CbOOOO'#Cc'#CcQQOPOOOOOO'#C`'#C`O_OPO,58xOOOO-E6a-E6aOOOO'#Ca'#CaOOOO1G.d1G.d",
  stateData: "i~OXPOYRO~OYUO~OZXO~OXZYZ~",
  goto: "mWPPX]adXgTSOTTQOTRVQRYVQTORWT",
  nodeNames: " Template Expression ExpressionOpen ExpressionInner ExpressionClose Text",
  maxTerm: 11,
  nodeProps: [
    ["closedBy", 3, "ExpressionClose"],
    ["openedBy", 5, "ExpressionOpen"]
  ],
  propSources: [qee],
  skippedNodes: [0],
  repeatNodeCount: 1,
  tokenData: "!j~RVO#oh#o#p!S#p#qh#q#r!_#r;'Sh;'S;=`|<%lOh~mTY~O#oh#p#qh#r;'Sh;'S;=`|<%lOh~!PP;=`<%lh~!VP#o#p!Y~!_OX~~!bP#q#r!e~!jOZ~",
  tokenizers: [0],
  topRules: { Template: [0, 1] },
  tokenPrec: 20
}), vi = Symbol.for("@ts-pattern/matcher"), dP = Symbol.for("@ts-pattern/isVariadic"), og = "@ts-pattern/anonymous-select-key", My = (e) => !!(e && typeof e == "object"), mp = (e) => e && !!e[vi], Rr = (e, t, n) => {
  if (mp(e)) {
    const r = e[vi](), { matched: i, selections: o } = r.match(t);
    return i && o && Object.keys(o).forEach((s) => n(s, o[s])), i;
  }
  if (My(e)) {
    if (!My(t))
      return !1;
    if (Array.isArray(e)) {
      if (!Array.isArray(t))
        return !1;
      let r = [], i = [], o = [];
      for (const s of e.keys()) {
        const a = e[s];
        mp(a) && a[dP] ? o.push(a) : o.length ? i.push(a) : r.push(a);
      }
      if (o.length) {
        if (o.length > 1)
          throw new Error("Pattern error: Using `...P.array(...)` several times in a single pattern is not allowed.");
        if (t.length < r.length + i.length)
          return !1;
        const s = t.slice(0, r.length), a = i.length === 0 ? [] : t.slice(-i.length), l = t.slice(r.length, i.length === 0 ? 1 / 0 : -i.length);
        return r.every((u, c) => Rr(u, s[c], n)) && i.every((u, c) => Rr(u, a[c], n)) && (o.length === 0 || Rr(o[0], l, n));
      }
      return e.length === t.length && e.every((s, a) => Rr(s, t[a], n));
    }
    return Object.keys(e).every((r) => {
      const i = e[r];
      return (r in t || mp(o = i) && o[vi]().matcherType === "optional") && Rr(i, t[r], n);
      var o;
    });
  }
  return Object.is(t, e);
}, Ii = (e) => {
  var t, n, r;
  return My(e) ? mp(e) ? (t = (n = (r = e[vi]()).getSelectionKeys) == null ? void 0 : n.call(r)) != null ? t : [] : Array.isArray(e) ? Ud(e, Ii) : Ud(Object.values(e), Ii) : [];
}, Ud = (e, t) => e.reduce((n, r) => n.concat(t(r)), []);
function Zee(...e) {
  if (e.length === 1) {
    const [t] = e;
    return (n) => Rr(t, n, () => {
    });
  }
  if (e.length === 2) {
    const [t, n] = e;
    return Rr(t, n, () => {
    });
  }
  throw new Error(`isMatching wasn't given the right number of arguments: expected 1 or 2, received ${e.length}.`);
}
function Mr(e) {
  return Object.assign(e, { optional: () => vC(e), and: (t) => kn(e, t), or: (t) => fP(e, t), select: (t) => t === void 0 ? Gd(e) : Gd(t, e) });
}
function Iy(e) {
  return Object.assign(((t) => Object.assign(t, { [Symbol.iterator]() {
    let n = 0;
    const r = [{ value: Object.assign(t, { [dP]: !0 }), done: !1 }, { done: !0, value: void 0 }];
    return { next: () => {
      var i;
      return (i = r[n++]) != null ? i : r.at(-1);
    } };
  } }))(e), { optional: () => Iy(vC(e)), select: (t) => Iy(t === void 0 ? Gd(e) : Gd(t, e)) });
}
function vC(e) {
  return Mr({ [vi]: () => ({ match: (t) => {
    let n = {};
    const r = (i, o) => {
      n[i] = o;
    };
    return t === void 0 ? (Ii(e).forEach((i) => r(i, void 0)), { matched: !0, selections: n }) : { matched: Rr(e, t, r), selections: n };
  }, getSelectionKeys: () => Ii(e), matcherType: "optional" }) });
}
const Jee = (e, t) => {
  for (const n of e)
    if (!t(n))
      return !1;
  return !0;
}, ete = (e, t) => {
  for (const [n, r] of e.entries())
    if (!t(r, n))
      return !1;
  return !0;
};
function kn(...e) {
  return Mr({ [vi]: () => ({ match: (t) => {
    let n = {};
    const r = (i, o) => {
      n[i] = o;
    };
    return { matched: e.every((i) => Rr(i, t, r)), selections: n };
  }, getSelectionKeys: () => Ud(e, Ii), matcherType: "and" }) });
}
function fP(...e) {
  return Mr({ [vi]: () => ({ match: (t) => {
    let n = {};
    const r = (i, o) => {
      n[i] = o;
    };
    return Ud(e, Ii).forEach((i) => r(i, void 0)), { matched: e.some((i) => Rr(i, t, r)), selections: n };
  }, getSelectionKeys: () => Ud(e, Ii), matcherType: "or" }) });
}
function nn(e) {
  return { [vi]: () => ({ match: (t) => ({ matched: !!e(t) }) }) };
}
function Gd(...e) {
  const t = typeof e[0] == "string" ? e[0] : void 0, n = e.length === 2 ? e[1] : typeof e[0] == "string" ? void 0 : e[0];
  return Mr({ [vi]: () => ({ match: (r) => {
    let i = { [t ?? og]: r };
    return { matched: n === void 0 || Rr(n, r, (o, s) => {
      i[o] = s;
    }), selections: i };
  }, getSelectionKeys: () => [t ?? og].concat(n === void 0 ? [] : Ii(n)) }) });
}
function Fo(e) {
  return typeof e == "number";
}
function _a(e) {
  return typeof e == "string";
}
function Bs(e) {
  return typeof e == "bigint";
}
const hP = Mr(nn(function(e) {
  return !0;
})), tte = hP, Ta = (e) => Object.assign(Mr(e), { startsWith: (t) => {
  return Ta(kn(e, (n = t, nn((r) => _a(r) && r.startsWith(n)))));
  var n;
}, endsWith: (t) => {
  return Ta(kn(e, (n = t, nn((r) => _a(r) && r.endsWith(n)))));
  var n;
}, minLength: (t) => Ta(kn(e, ((n) => nn((r) => _a(r) && r.length >= n))(t))), maxLength: (t) => Ta(kn(e, ((n) => nn((r) => _a(r) && r.length <= n))(t))), includes: (t) => {
  return Ta(kn(e, (n = t, nn((r) => _a(r) && r.includes(n)))));
  var n;
}, regex: (t) => {
  return Ta(kn(e, (n = t, nn((r) => _a(r) && !!r.match(n)))));
  var n;
} }), nte = Ta(nn(_a)), Bo = (e) => Object.assign(Mr(e), { between: (t, n) => Bo(kn(e, ((r, i) => nn((o) => Fo(o) && r <= o && i >= o))(t, n))), lt: (t) => Bo(kn(e, ((n) => nn((r) => Fo(r) && r < n))(t))), gt: (t) => Bo(kn(e, ((n) => nn((r) => Fo(r) && r > n))(t))), lte: (t) => Bo(kn(e, ((n) => nn((r) => Fo(r) && r <= n))(t))), gte: (t) => Bo(kn(e, ((n) => nn((r) => Fo(r) && r >= n))(t))), int: () => Bo(kn(e, nn((t) => Fo(t) && Number.isInteger(t)))), finite: () => Bo(kn(e, nn((t) => Fo(t) && Number.isFinite(t)))), positive: () => Bo(kn(e, nn((t) => Fo(t) && t > 0))), negative: () => Bo(kn(e, nn((t) => Fo(t) && t < 0))) }), rte = Bo(nn(Fo)), js = (e) => Object.assign(Mr(e), { between: (t, n) => js(kn(e, ((r, i) => nn((o) => Bs(o) && r <= o && i >= o))(t, n))), lt: (t) => js(kn(e, ((n) => nn((r) => Bs(r) && r < n))(t))), gt: (t) => js(kn(e, ((n) => nn((r) => Bs(r) && r > n))(t))), lte: (t) => js(kn(e, ((n) => nn((r) => Bs(r) && r <= n))(t))), gte: (t) => js(kn(e, ((n) => nn((r) => Bs(r) && r >= n))(t))), positive: () => js(kn(e, nn((t) => Bs(t) && t > 0))), negative: () => js(kn(e, nn((t) => Bs(t) && t < 0))) }), ite = js(nn(Bs)), ote = Mr(nn(function(e) {
  return typeof e == "boolean";
})), ste = Mr(nn(function(e) {
  return typeof e == "symbol";
})), ate = Mr(nn(function(e) {
  return e == null;
})), lte = Mr(nn(function(e) {
  return e != null;
}));
var mn = { __proto__: null, matcher: vi, optional: vC, array: function(...e) {
  return Iy({ [vi]: () => ({ match: (t) => {
    if (!Array.isArray(t))
      return { matched: !1 };
    if (e.length === 0)
      return { matched: !0 };
    const n = e[0];
    let r = {};
    if (t.length === 0)
      return Ii(n).forEach((o) => {
        r[o] = [];
      }), { matched: !0, selections: r };
    const i = (o, s) => {
      r[o] = (r[o] || []).concat([s]);
    };
    return { matched: t.every((o) => Rr(n, o, i)), selections: r };
  }, getSelectionKeys: () => e.length === 0 ? [] : Ii(e[0]) }) });
}, set: function(...e) {
  return Mr({ [vi]: () => ({ match: (t) => {
    if (!(t instanceof Set))
      return { matched: !1 };
    let n = {};
    if (t.size === 0)
      return { matched: !0, selections: n };
    if (e.length === 0)
      return { matched: !0 };
    const r = (o, s) => {
      n[o] = (n[o] || []).concat([s]);
    }, i = e[0];
    return { matched: Jee(t, (o) => Rr(i, o, r)), selections: n };
  }, getSelectionKeys: () => e.length === 0 ? [] : Ii(e[0]) }) });
}, map: function(...e) {
  return Mr({ [vi]: () => ({ match: (t) => {
    if (!(t instanceof Map))
      return { matched: !1 };
    let n = {};
    if (t.size === 0)
      return { matched: !0, selections: n };
    const r = (a, l) => {
      n[a] = (n[a] || []).concat([l]);
    };
    if (e.length === 0)
      return { matched: !0 };
    var i;
    if (e.length === 1)
      throw new Error(`\`P.map\` wasn't given enough arguments. Expected (key, value), received ${(i = e[0]) == null ? void 0 : i.toString()}`);
    const [o, s] = e;
    return { matched: ete(t, (a, l) => {
      const u = Rr(o, l, r), c = Rr(s, a, r);
      return u && c;
    }), selections: n };
  }, getSelectionKeys: () => e.length === 0 ? [] : [...Ii(e[0]), ...Ii(e[1])] }) });
}, intersection: kn, union: fP, not: function(e) {
  return Mr({ [vi]: () => ({ match: (t) => ({ matched: !Rr(e, t, () => {
  }) }), getSelectionKeys: () => [], matcherType: "not" }) });
}, when: nn, select: Gd, any: hP, _: tte, string: nte, number: rte, bigint: ite, boolean: ote, symbol: ste, nullish: ate, nonNullable: lte, instanceOf: function(e) {
  return Mr(nn(/* @__PURE__ */ function(t) {
    return (n) => n instanceof t;
  }(e)));
}, shape: function(e) {
  return Mr(nn(Zee(e)));
} };
const ky = { matched: !1, value: void 0 };
function yn(e) {
  return new sg(e, ky);
}
class sg {
  constructor(t, n) {
    this.input = void 0, this.state = void 0, this.input = t, this.state = n;
  }
  with(...t) {
    if (this.state.matched)
      return this;
    const n = t[t.length - 1], r = [t[0]];
    let i;
    t.length === 3 && typeof t[1] == "function" ? i = t[1] : t.length > 2 && r.push(...t.slice(1, t.length - 1));
    let o = !1, s = {};
    const a = (u, c) => {
      o = !0, s[u] = c;
    }, l = !r.some((u) => Rr(u, this.input, a)) || i && !i(this.input) ? ky : { matched: !0, value: n(o ? og in s ? s[og] : s : this.input, this.input) };
    return new sg(this.input, l);
  }
  when(t, n) {
    if (this.state.matched)
      return this;
    const r = !!t(this.input);
    return new sg(this.input, r ? { matched: !0, value: n(this.input, this.input) } : ky);
  }
  otherwise(t) {
    return this.state.matched ? this.state.value : t(this.input);
  }
  exhaustive() {
    if (this.state.matched)
      return this.state.value;
    let t;
    try {
      t = JSON.stringify(this.input);
    } catch {
      t = this.input;
    }
    throw new Error(`Pattern matching error: no pattern matches value ${t}`);
  }
  run() {
    return this.exhaustive();
  }
  returnType() {
    return this;
  }
}
const pP = [
  {
    label: "$root",
    type: "variable",
    detail: "Root variable",
    info: ""
  },
  {
    label: "$nodes",
    type: "variable",
    detail: "Nodes variable",
    info: ""
  },
  {
    label: "len",
    type: "function",
    detail: "<T>(var: string | T[]) -> number",
    info: "Returns the length of variable"
  },
  {
    label: "contains",
    type: "function",
    detail: "<T>(haystack: string | T[], needle: string | T) -> boolean",
    info: "Checks if variable contains a needle"
  },
  {
    label: "flatten",
    type: "function",
    detail: "<T>(arr: T[][]) -> T[]",
    info: "Flattens an array"
  },
  {
    label: "upper",
    type: "function",
    detail: "(str: string) -> string",
    info: "Converts all characters in a string to uppercase"
  },
  {
    label: "lower",
    type: "function",
    detail: "(str: string) -> string",
    info: "Converts all characters in a string to lowercase"
  },
  {
    label: "startsWith",
    type: "function",
    detail: "(str: string, prefix: string) -> boolean",
    info: "Returns true if the string starts with the specified prefix"
  },
  {
    label: "endsWith",
    type: "function",
    detail: "(str: string, suffix: string) -> boolean",
    info: "Returns true if the string ends with the specified suffix"
  },
  {
    label: "matches",
    type: "function",
    detail: "(str: string, pattern: string) -> boolean",
    info: "Returns true if the string matches the specified pattern"
  },
  {
    label: "extract",
    type: "function",
    detail: "(str: string, pattern: string) -> string[]",
    info: "Extracts matching substrings according to a pattern"
  },
  {
    label: "abs",
    type: "function",
    detail: "(num: number) -> number",
    info: "Returns the absolute value of a number"
  },
  {
    label: "sum",
    type: "function",
    detail: "(arr: number[]) -> number",
    info: "Returns the sum of all elements in the input array."
  },
  {
    label: "avg",
    type: "function",
    detail: "(arr: number[]) -> number",
    info: "Calculates the average of all elements in the input array."
  },
  {
    label: "min",
    type: "function",
    detail: "(arr: number[]) -> number",
    info: "Returns the smallest of the elements in the input array."
  },
  {
    label: "max",
    type: "function",
    detail: "(arr: number[]) -> number",
    info: "Returns the largest of the elements in the input array."
  },
  {
    label: "rand",
    type: "function",
    detail: "(max: number) -> number",
    info: "Generates a random number between 0 (inclusive) and max (inclusive)."
  },
  {
    label: "median",
    type: "function",
    detail: "(arr: number[]) -> number",
    info: "Calculates the median value of all elements in the input array."
  },
  {
    label: "mode",
    type: "function",
    detail: "(arr: number[]) -> number",
    info: "Finds the mode(s) of the input array, which are the most frequent element(s)."
  },
  {
    label: "floor",
    type: "function",
    detail: "(num: number) -> number",
    info: "Rounds a number down to the nearest integer."
  },
  {
    label: "ceil",
    type: "function",
    detail: "(num: number) -> number",
    info: "Rounds a number up to the nearest integer."
  },
  {
    label: "round",
    type: "function",
    detail: "(num: number) -> number",
    info: "Rounds a number to a specified number of decimal places."
  },
  {
    label: "isNumeric",
    type: "function",
    detail: "(value: any) -> boolean",
    info: "Checks if the given value is of a numeric type."
  },
  {
    label: "string",
    type: "function",
    detail: "(value: any) -> string",
    info: "Converts the given value to a string."
  },
  {
    label: "number",
    type: "function",
    detail: "(value: any) -> number",
    info: "Converts the given value to a number."
  },
  {
    label: "bool",
    type: "function",
    detail: "(value: any) -> boolean",
    info: "Converts the given value to a boolean."
  },
  {
    label: "date",
    type: "function",
    detail: "(timestamp: string | number) -> number",
    info: "Converts a numeric timestamp to a unix timestamp."
  },
  {
    label: "time",
    type: "function",
    detail: "(timestamp: string) -> number",
    info: "Extracts the time from a numeric timestamp and returns it as a seconds from beginning of day."
  },
  {
    label: "duration",
    type: "function",
    detail: "(duration: string) -> Duration",
    info: "e.g. 1h30min"
  },
  {
    label: "year",
    type: "function",
    detail: "(timestamp: number) -> number",
    info: "Extracts the year from a given timestamp."
  },
  {
    label: "dayOfWeek",
    type: "function",
    detail: "(timestamp: number) -> number",
    info: "Gets the day of the week from a given timestamp, where Sunday might be 0."
  },
  {
    label: "dayOfMonth",
    type: "function",
    detail: "(timestamp: number) -> number",
    info: "Extracts the day of the month from a given timestamp."
  },
  {
    label: "dayOfYear",
    type: "function",
    detail: "(timestamp: number) -> number",
    info: "Gets the day of the year from a given timestamp."
  },
  {
    label: "weekOfYear",
    type: "function",
    detail: "(timestamp: number) -> number",
    info: "Calculates the week of the year from a given timestamp."
  },
  {
    label: "monthOfYear",
    type: "function",
    detail: "(timestamp: number) -> number",
    info: "Extracts the month from a given timestamp, typically with January as 1."
  },
  {
    label: "monthString",
    type: "function",
    detail: "(timestamp: number) -> string",
    info: "Converts the month from a given timestamp into its string representation (e.g., 'Jan')."
  },
  {
    label: "dateString",
    type: "function",
    detail: "(timestamp: number) -> string",
    info: "Converts a timestamp to a human-readable date string."
  },
  {
    label: "weekdayString",
    type: "function",
    detail: "(timestamp: number) -> string",
    info: "Converts the day of the week from a given timestamp into its string representation (e.g., 'Mon')."
  },
  {
    label: "startOf",
    type: "function",
    detail: "(timestamp: number, unit: string) -> number",
    info: "Returns the timestamp representing the start of a specified unit (e.g., day, month, year) based on a given timestamp."
  },
  {
    label: "endOf",
    type: "function",
    detail: "(timestamp: number, unit: string) -> number",
    info: "Returns the timestamp representing the end of a specified unit (e.g., day, month, year) based on a given timestamp."
  },
  {
    label: "all",
    type: "function",
    detail: "<T>(array: T[], callback: Callback<T, boolean>) -> boolean",
    info: "Checks if all elements in the array satisfy the condition defined in the callback."
  },
  {
    label: "some",
    type: "function",
    detail: "<T>(array: T[], callback: Callback<T, boolean>) -> boolean",
    info: "Checks if at least one element in the array satisfies the condition defined in the callback."
  },
  {
    label: "none",
    type: "function",
    detail: "<T>(array: T[], callback: Callback<T, boolean>) -> boolean",
    info: "Checks if no elements in the array satisfy the condition defined in the callback."
  },
  {
    label: "filter",
    type: "function",
    detail: "<T>(array: T[], callback: Callback<T, boolean>) -> T[]",
    info: "Creates a new array with all elements that satisfy the condition defined in the callback."
  },
  {
    label: "map",
    type: "function",
    detail: "<T, U>(array: T[], callback: Callback<T, U>) -> U[]",
    info: "Creates a new array populated with the results of calling the provided function on every element in the calling array."
  },
  {
    label: "count",
    type: "function",
    detail: "<T>(array: T[], callback: Callback<T, boolean>) -> number",
    info: "Counts the number of elements in the array that satisfy the condition defined in the callback."
  },
  {
    label: "one",
    type: "function",
    detail: "<T>(array: T[], callback: Callback<T, boolean>) -> boolean",
    info: "Checks if exactly one element in the array satisfies the condition defined in the callback."
  },
  {
    label: "flatMap",
    type: "function",
    detail: "<T, U>(array: T[], callback: Callback<T, U[]>) -> U[]",
    info: "First maps each element using a mapping function, then flattens the result into a new array."
  }
], cte = (e, t, n, r) => {
  const i = yn(t.type).with("function", () => {
    const o = `${t.label}()`;
    return e.state.update({
      changes: { from: n, to: r, insert: o },
      selection: { anchor: n + o.length - 1 }
      // Place the caret inside the parentheses
    });
  }).otherwise(
    () => e.state.update({
      changes: { from: n, to: r, insert: t.label }
    })
  );
  e.dispatch(i);
}, ute = pP.map((e) => ({
  ...e,
  apply: cte
})), gP = (e) => {
  var n;
  return e ? ((n = e == null ? void 0 : e.type.prop(on.group)) == null ? void 0 : n.includes("autoComplete")) || !1 || gP(e == null ? void 0 : e.parent) : !1;
}, dte = () => (e) => {
  const t = Ts(e.state), n = e.state.wordAt(e.pos);
  if (!e.explicit && (!n || n.empty))
    return null;
  const r = t.resolve(e.pos);
  return r.name === "String" || !gP(r) ? null : {
    from: (n == null ? void 0 : n.from) ?? 0,
    options: ute
  };
}, fte = () => Pee({
  override: [dte()]
}), hte = () => vJ((e, t) => {
  const n = e.state.wordAt(t);
  if (!n)
    return null;
  const r = e.state.doc.sliceString(n.from, n.to), i = pP.find((o) => o.label === r);
  return i ? {
    pos: n.from,
    end: n.to,
    above: !0,
    create() {
      const o = document.createElement("div");
      return o.classList.add("grl-ce-hover-tooltip"), o.style.whiteSpace = "pre", o.textContent = `${i.label}: ${i.detail}

${i.info}`, { dom: o };
    }
  } : null;
}), pte = eP(
  Rf.define([
    { tag: [Ne.bracket, Ne.operator, Ne.variableName, Ne.propertyName, Ne.content], color: "#080808" },
    { tag: [Ne.number, Ne.bool], color: "#015cc5" },
    { tag: [Ne.function(Ne.variableName), Ne.keyword, Ne.self, Ne.special(Ne.brace)], color: "#6f42c1" },
    { tag: [Ne.string, Ne.meta, Ne.name, Ne.quote], color: "#077d16" },
    { tag: Ne.invalid, color: "#cb2431" }
  ])
), gte = eP(
  Rf.define([
    { tag: [Ne.bracket, Ne.operator, Ne.variableName, Ne.propertyName, Ne.content], color: "#bdbec4" },
    { tag: [Ne.number, Ne.bool], color: "#57a8f5" },
    { tag: [Ne.function(Ne.variableName), Ne.keyword, Ne.self, Ne.special(Ne.brace)], color: "#c87dbb" },
    { tag: [Ne.string, Ne.meta, Ne.name, Ne.quote], color: "#6aab73" },
    { tag: Ne.invalid, color: "#cb2431" }
  ])
), mte = new Jk(
  zd.define({
    parser: uP,
    name: "zen",
    languageData: {
      closeBrackets: { brackets: ["(", "[", "'", '"'] },
      wordChars: "$"
    }
  })
), vte = new Jk(
  zd.define({
    parser: Qee.configure({
      wrap: OJ((e) => e.name === "ExpressionInner" ? { parser: uP } : null)
    }),
    name: "zenTemplate",
    languageData: {
      closeBrackets: { brackets: ["(", "[", "'", '"', "{"] },
      wordChars: "$"
    }
  })
), QO = ({ type: e }) => [
  e === "standard" ? mte : vte,
  fte(),
  hte(),
  Eee(),
  aC.of(Dee)
], ZO = (e, t) => Vt.updateListener.of((n) => {
  t == null || t(n.state), n.docChanged && (e == null || e(n.state.doc.toString()));
}), JO = (e = !1) => e ? gte : pte, uu = U.forwardRef(
  ({ maxRows: e, disabled: t, value: n, onChange: r, placeholder: i, className: o, onStateChange: s, type: a = "standard", ...l }, u) => {
    const c = he(null), d = he(null), { token: f } = no.useToken(), h = mt(
      () => ({
        zenExtension: new fs(),
        theme: new fs(),
        placeholder: new fs(),
        readOnly: new fs(),
        updateListener: new fs()
      }),
      []
    );
    return Pe(() => {
      if (!c.current)
        return;
      const p = new Vt({
        parent: c.current,
        state: hn.create({
          doc: n,
          extensions: [
            Vt.lineWrapping,
            h.zenExtension.of(QO({ type: a })),
            h.updateListener.of(ZO(r, s)),
            h.theme.of(JO(f.mode === "dark")),
            h.placeholder.of(i ? yO(i) : []),
            h.readOnly.of(Vt.editable.of(!t))
          ]
        })
      });
      return d.current = p, () => {
        p.destroy(), d.current = null;
      };
    }, []), Pe(() => {
      if (!d.current || n === void 0)
        return;
      const p = d.current;
      p.state.doc.eq(fn.of(n.split(`
`))) || p.dispatch({
        changes: {
          from: 0,
          to: p.state.doc.length,
          insert: n
        }
      });
    }, [n]), Pe(() => {
      d.current && d.current.dispatch({
        effects: h.theme.reconfigure(JO(f.mode === "dark"))
      });
    }, [f.mode]), Pe(() => {
      d.current && d.current.dispatch({
        effects: h.placeholder.reconfigure(i ? yO(i) : [])
      });
    }, [i]), Pe(() => {
      d.current && d.current.dispatch({
        effects: h.readOnly.reconfigure(Vt.editable.of(!t))
      });
    }, [t]), Pe(() => {
      d.current && d.current.dispatch({
        effects: h.updateListener.reconfigure(ZO(r, s))
      });
    }, [r, s]), Pe(() => {
      d.current && d.current.dispatch({
        effects: h.zenExtension.reconfigure(QO({ type: a }))
      });
    }, [a]), /* @__PURE__ */ V.jsx(
      "div",
      {
        ref: DI(c, u),
        className: wn("grl-ce", e && "grl-ce--max-rows", o),
        style: { "--editorMaxRows": e },
        ...l
      }
    );
  }
), bte = (e) => {
  const { isOpen: t, onDismiss: n, onSuccess: r, schema: i, getContainer: o } = e, [s] = Pn.useForm(), a = Pn.useWatch("type", s);
  return Pe(() => {
    t && s.resetFields();
  }, [t, s]), /* @__PURE__ */ V.jsx(
    pr,
    {
      title: "Add a column",
      open: t,
      destroyOnClose: !0,
      onCancel: n,
      width: 360,
      okText: "Add",
      okButtonProps: {
        form: "field-add-dialog",
        htmlType: "submit"
      },
      getContainer: o,
      children: /* @__PURE__ */ V.jsxs(
        Pn,
        {
          id: "field-add-dialog",
          requiredMark: !1,
          form: s,
          layout: "vertical",
          initialValues: { type: "expression" },
          onFinish: ({ type: l, field: u, name: c, defaultValue: d }) => {
            var f, h, p;
            r == null || r({
              id: crypto.randomUUID(),
              type: l || "expression",
              field: ((p = (h = (f = u || "") == null ? void 0 : f.trim) == null ? void 0 : h.call(f)) == null ? void 0 : p.length) > 0 ? u : void 0,
              name: c,
              defaultValue: d
            });
          },
          children: [
            i && /* @__PURE__ */ V.jsx(Pn.Item, { label: "Choose from list", children: /* @__PURE__ */ V.jsx(
              ya,
              {
                fieldNames: { label: "name", value: "field", children: "items" },
                options: i,
                onChange: (l) => {
                  const u = q1(l, i);
                  u && s.setFieldsValue({
                    name: u == null ? void 0 : u.name,
                    field: u == null ? void 0 : u.field
                  });
                }
              }
            ) }),
            /* @__PURE__ */ V.jsx(Pn.Item, { name: "name", label: "Label", rules: [{ required: !0 }], children: /* @__PURE__ */ V.jsx($o, { autoComplete: "off" }) }),
            /* @__PURE__ */ V.jsx(
              Pn.Item,
              {
                name: "field",
                label: a === "expression" ? "Selector" : "Field",
                rules: [{ required: e.columnType === "outputs" }],
                children: e.columnType === "inputs" ? /* @__PURE__ */ V.jsx(uu, {}) : /* @__PURE__ */ V.jsx(Q1, { maxRows: 3 })
              }
            ),
            /* @__PURE__ */ V.jsx(Pn.Item, { name: "defaultValue", label: "Default Value", children: /* @__PURE__ */ V.jsx($o, { autoComplete: "off" }) })
          ]
        }
      )
    }
  );
}, yte = (e) => {
  const { isOpen: t, onDismiss: n, onSuccess: r, field: i, schema: o, getContainer: s } = e, [a] = Pn.useForm(), [l, u] = ht();
  return Pe(() => {
    t && (a.resetFields(), a.setFieldsValue({
      name: i == null ? void 0 : i.name,
      field: i == null ? void 0 : i.field,
      defaultValue: i == null ? void 0 : i.defaultValue
    }), u(OI(i == null ? void 0 : i.field, o)));
  }, [t, a, i, o]), /* @__PURE__ */ V.jsx(
    pr,
    {
      title: "Update column",
      open: t,
      onCancel: n,
      destroyOnClose: !0,
      okText: "Update",
      okButtonProps: {
        form: "field-update-dialog",
        htmlType: "submit"
      },
      width: 360,
      getContainer: s,
      children: /* @__PURE__ */ V.jsxs(
        Pn,
        {
          id: "field-update-dialog",
          form: a,
          layout: "vertical",
          requiredMark: !1,
          initialValues: {
            name: i == null ? void 0 : i.name,
            field: i == null ? void 0 : i.field,
            defaultValue: i == null ? void 0 : i.defaultValue
          },
          onFinish: (c) => {
            var d, f, h;
            r == null || r({
              ...i,
              ...c,
              field: ((h = (f = (d = c == null ? void 0 : c.field) == null ? void 0 : d.trim) == null ? void 0 : f.call(d)) == null ? void 0 : h.length) > 0 ? c == null ? void 0 : c.field : void 0
            });
          },
          children: [
            o && /* @__PURE__ */ V.jsx(Pn.Item, { label: "Choose from list", children: /* @__PURE__ */ V.jsx(
              ya,
              {
                fieldNames: { label: "name", value: "field", children: "items" },
                options: o,
                value: l,
                onChange: (c) => {
                  u(c);
                  const d = q1(c, o);
                  d && a.setFieldsValue({
                    name: d == null ? void 0 : d.name,
                    field: d == null ? void 0 : d.field
                  });
                }
              }
            ) }),
            /* @__PURE__ */ V.jsx(Pn.Item, { name: "name", label: "Label", rules: [{ required: !0 }], children: /* @__PURE__ */ V.jsx($o, {}) }),
            /* @__PURE__ */ V.jsx(Pn.Item, { name: "field", label: "Selector", rules: [{ required: e.columnType === "outputs" }], children: e.columnType === "inputs" ? /* @__PURE__ */ V.jsx(uu, {}) : /* @__PURE__ */ V.jsx(Q1, { maxRows: 3 }) }),
            /* @__PURE__ */ V.jsx(Pn.Item, { name: "defaultValue", label: "Default Value", children: /* @__PURE__ */ V.jsx($o, { autoComplete: "off" }) })
          ]
        }
      )
    }
  );
}, qr = (e) => {
  const {
    horizontal: t,
    reversed: n,
    verticalAlign: r = "start",
    horizontalAlign: i = "start",
    gap: o = 8,
    height: s = "auto",
    width: a = "100%",
    grow: l,
    style: u,
    ...c
  } = e, d = mt(() => t ? n ? "row-reverse" : "row" : n ? "column-reverse" : "column", [t, n]);
  return /* @__PURE__ */ V.jsx(
    "div",
    {
      style: {
        display: "flex",
        flexDirection: d,
        justifyContent: t ? i : r,
        alignItems: t ? r : i,
        height: s,
        width: a,
        gap: o,
        flexGrow: l ? 1 : void 0,
        ...u
      },
      ...c
    }
  );
}, wte = ({ col: e, index: t, moveCard: n }) => {
  const r = he(null), [, i] = G1({
    accept: "col",
    collect(a) {
      return {
        handlerId: a.getHandlerId()
      };
    },
    hover(a, l) {
      var g;
      if (!r.current)
        return;
      const u = a.index, c = t;
      if (u === c)
        return;
      const d = (g = r.current) == null ? void 0 : g.getBoundingClientRect(), f = (d.bottom - d.top) / 2, p = l.getClientOffset().y - d.top;
      u < c && p < f || u > c && p > f || (n(u, c), a.index = c);
    }
  }), [{ isDragging: o }, s] = U1({
    type: "col",
    item: () => ({ id: e.id, index: t }),
    collect: (a) => ({
      isDragging: a.isDragging()
    })
  });
  return s(i(r)), /* @__PURE__ */ V.jsx(nm, { ref: r, style: { opacity: o ? 0 : 1 }, bodyStyle: { padding: "0.5rem" }, children: /* @__PURE__ */ V.jsx("div", { className: "grl-dt__fields-reorder__item", children: /* @__PURE__ */ V.jsxs(qr, { horizontal: !0, verticalAlign: "center", children: [
    /* @__PURE__ */ V.jsx("div", { className: "grl-dt__fields-reorder__handle", children: "=" }),
    /* @__PURE__ */ V.jsxs(qr, { grow: !0, gap: 0, children: [
      /* @__PURE__ */ V.jsx(Bt.Text, { children: e.name }),
      /* @__PURE__ */ V.jsx(Bt.Text, { type: "secondary", style: { fontSize: 12 }, children: e.field })
    ] })
  ] }) }) });
}, Cte = (e) => {
  const { isOpen: t, onDismiss: n, onSuccess: r, fields: i, getContainer: o } = e, [s, a] = ht([]);
  Pe(() => {
    t && a([...i || []]);
  }, [t, i]);
  const l = (u, c) => {
    if (c === void 0)
      return;
    const d = [...s], f = d.splice(u, 1)[0];
    d.splice(c, 0, f), a(d);
  };
  return /* @__PURE__ */ V.jsx(
    pr,
    {
      title: "Reorder fields",
      open: t,
      onCancel: n,
      width: 360,
      destroyOnClose: !0,
      bodyStyle: { paddingTop: 17 },
      okText: "Update",
      okButtonProps: {
        htmlType: "submit",
        form: "fields-reorder-dialog"
      },
      getContainer: o,
      children: /* @__PURE__ */ V.jsx(Pn, { id: "fields-reorder-dialog", onFinish: () => r == null ? void 0 : r(s), children: /* @__PURE__ */ V.jsx(qr, { gap: 8, horizontalAlign: "stretch", children: s.map((u, c) => /* @__PURE__ */ V.jsx(wte, { col: u, index: c, moveCard: l }, u.id)) }) })
    }
  );
}, Ste = () => {
  const { dialog: e, setDialog: t, isDialogActive: n, getContainer: r } = Of(), i = "test", o = Qo(), { decisionTableFields: s, inputsSchema: a, outputsSchema: l } = io(
    ({ decisionTable: u, inputsSchema: c, outputsSchema: d }) => ({
      decisionTableFields: e != null && e.columnType ? u[e.columnType] : void 0,
      inputsSchema: c,
      outputsSchema: d
    })
  );
  return /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
    /* @__PURE__ */ V.jsx(
      bte,
      {
        id: i,
        columnType: e == null ? void 0 : e.columnType,
        isOpen: n("add"),
        schema: (e == null ? void 0 : e.columnType) === "inputs" ? a : l,
        onDismiss: () => t(void 0),
        onSuccess: (u) => {
          e && (o.addColumn(e.columnType, u), t(void 0));
        },
        getContainer: r
      }
    ),
    /* @__PURE__ */ V.jsx(
      yte,
      {
        id: i,
        columnType: e == null ? void 0 : e.columnType,
        isOpen: n("edit"),
        schema: (e == null ? void 0 : e.columnType) === "inputs" ? a : l,
        field: e == null ? void 0 : e.item,
        onDismiss: () => t(void 0),
        onSuccess: (u) => {
          e && (o.updateColumn(e.columnType, u.id, u), t(void 0));
        },
        getContainer: r
      }
    ),
    /* @__PURE__ */ V.jsx(
      Cte,
      {
        isOpen: n("reorder"),
        fields: s,
        onDismiss: () => t(void 0),
        onSuccess: (u) => {
          e && (o.reorderColumns(e.columnType, u), t(void 0));
        },
        getContainer: r
      }
    )
  ] });
};
var xte = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M832 64H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V96c0-17.7-14.3-32-32-32zm-260 72h96v209.9L621.5 312 572 347.4V136zm220 752H232V136h280v296.9c0 3.3 1 6.6 3 9.3a15.9 15.9 0 0022.3 3.7l83.8-59.9 81.4 59.4c2.7 2 6 3.1 9.4 3.1 8.8 0 16-7.2 16-16V136h64v752z" } }] }, name: "book", theme: "outlined" }, Ete = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: xte
  }));
}, ag = /* @__PURE__ */ O.forwardRef(Ete);
process.env.NODE_ENV !== "production" && (ag.displayName = "BookOutlined");
var $te = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M740 161c-61.8 0-112 50.2-112 112 0 50.1 33.1 92.6 78.5 106.9v95.9L320 602.4V318.1c44.2-15 76-56.9 76-106.1 0-61.8-50.2-112-112-112s-112 50.2-112 112c0 49.2 31.8 91 76 106.1V706c-44.2 15-76 56.9-76 106.1 0 61.8 50.2 112 112 112s112-50.2 112-112c0-49.2-31.8-91-76-106.1v-27.8l423.5-138.7a50.52 50.52 0 0034.9-48.2V378.2c42.9-15.8 73.6-57 73.6-105.2 0-61.8-50.2-112-112-112zm-504 51a48.01 48.01 0 0196 0 48.01 48.01 0 01-96 0zm96 600a48.01 48.01 0 01-96 0 48.01 48.01 0 0196 0zm408-491a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "branches", theme: "outlined" }, Ote = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: $te
  }));
}, mP = /* @__PURE__ */ O.forwardRef(Ote);
process.env.NODE_ENV !== "production" && (mP.displayName = "BranchesOutlined");
var Ate = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M899.1 869.6l-53-305.6H864c14.4 0 26-11.6 26-26V346c0-14.4-11.6-26-26-26H618V138c0-14.4-11.6-26-26-26H432c-14.4 0-26 11.6-26 26v182H160c-14.4 0-26 11.6-26 26v192c0 14.4 11.6 26 26 26h17.9l-53 305.6a25.95 25.95 0 0025.6 30.4h723c1.5 0 3-.1 4.4-.4a25.88 25.88 0 0021.2-30zM204 390h272V182h72v208h272v104H204V390zm468 440V674c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v156H416V674c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v156H202.8l45.1-260H776l45.1 260H672z" } }] }, name: "clear", theme: "outlined" }, Dte = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: Ate
  }));
}, vP = /* @__PURE__ */ O.forwardRef(Dte);
process.env.NODE_ENV !== "production" && (vP.displayName = "ClearOutlined");
var _te = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M624 706.3h-74.1V464c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v242.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.7a8 8 0 0012.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9z" } }, { tag: "path", attrs: { d: "M811.4 366.7C765.6 245.9 648.9 160 512.2 160S258.8 245.8 213 366.6C127.3 389.1 64 467.2 64 560c0 110.5 89.5 200 199.9 200H304c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8h-40.1c-33.7 0-65.4-13.4-89-37.7-23.5-24.2-36-56.8-34.9-90.6.9-26.4 9.9-51.2 26.2-72.1 16.7-21.3 40.1-36.8 66.1-43.7l37.9-9.9 13.9-36.6c8.6-22.8 20.6-44.1 35.7-63.4a245.6 245.6 0 0152.4-49.9c41.1-28.9 89.5-44.2 140-44.2s98.9 15.3 140 44.2c19.9 14 37.5 30.8 52.4 49.9 15.1 19.3 27.1 40.7 35.7 63.4l13.8 36.5 37.8 10C846.1 454.5 884 503.8 884 560c0 33.1-12.9 64.3-36.3 87.7a123.07 123.07 0 01-87.6 36.3H720c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h40.1C870.5 760 960 670.5 960 560c0-92.7-63.1-170.7-148.6-193.3z" } }] }, name: "cloud-download", theme: "outlined" }, Tte = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: _te
  }));
}, bP = /* @__PURE__ */ O.forwardRef(Tte);
process.env.NODE_ENV !== "production" && (bP.displayName = "CloudDownloadOutlined");
var Rte = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M518.3 459a8 8 0 00-12.6 0l-112 141.7a7.98 7.98 0 006.3 12.9h73.9V856c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V613.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 459z" } }, { tag: "path", attrs: { d: "M811.4 366.7C765.6 245.9 648.9 160 512.2 160S258.8 245.8 213 366.6C127.3 389.1 64 467.2 64 560c0 110.5 89.5 200 199.9 200H304c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8h-40.1c-33.7 0-65.4-13.4-89-37.7-23.5-24.2-36-56.8-34.9-90.6.9-26.4 9.9-51.2 26.2-72.1 16.7-21.3 40.1-36.8 66.1-43.7l37.9-9.9 13.9-36.6c8.6-22.8 20.6-44.1 35.7-63.4a245.6 245.6 0 0152.4-49.9c41.1-28.9 89.5-44.2 140-44.2s98.9 15.3 140 44.2c19.9 14 37.5 30.8 52.4 49.9 15.1 19.3 27.1 40.7 35.7 63.4l13.8 36.5 37.8 10C846.1 454.5 884 503.8 884 560c0 33.1-12.9 64.3-36.3 87.7a123.07 123.07 0 01-87.6 36.3H720c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h40.1C870.5 760 960 670.5 960 560c0-92.7-63.1-170.7-148.6-193.3z" } }] }, name: "cloud-upload", theme: "outlined" }, Mte = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: Rte
  }));
}, yP = /* @__PURE__ */ O.forwardRef(Mte);
process.env.NODE_ENV !== "production" && (yP.displayName = "CloudUploadOutlined");
var Ite = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M888.3 693.2c-42.5-24.6-94.3-18-129.2 12.8l-53-30.7V523.6c0-15.7-8.4-30.3-22-38.1l-136-78.3v-67.1c44.2-15 76-56.8 76-106.1 0-61.9-50.1-112-112-112s-112 50.1-112 112c0 49.3 31.8 91.1 76 106.1v67.1l-136 78.3c-13.6 7.8-22 22.4-22 38.1v151.6l-53 30.7c-34.9-30.8-86.8-37.4-129.2-12.8-53.5 31-71.7 99.4-41 152.9 30.8 53.5 98.9 71.9 152.2 41 42.5-24.6 62.7-73 53.6-118.8l48.7-28.3 140.6 81c6.8 3.9 14.4 5.9 22 5.9s15.2-2 22-5.9L674.5 740l48.7 28.3c-9.1 45.7 11.2 94.2 53.6 118.8 53.3 30.9 121.5 12.6 152.2-41 30.8-53.6 12.6-122-40.7-152.9zm-673 138.4a47.6 47.6 0 01-65.2-17.6c-13.2-22.9-5.4-52.3 17.5-65.5a47.6 47.6 0 0165.2 17.6c13.2 22.9 5.4 52.3-17.5 65.5zM522 463.8zM464 234a48.01 48.01 0 0196 0 48.01 48.01 0 01-96 0zm170 446.2l-122 70.3-122-70.3V539.8l122-70.3 122 70.3v140.4zm239.9 133.9c-13.2 22.9-42.4 30.8-65.2 17.6-22.8-13.2-30.7-42.6-17.5-65.5s42.4-30.8 65.2-17.6c22.9 13.2 30.7 42.5 17.5 65.5z" } }] }, name: "deployment-unit", theme: "outlined" }, kte = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: Ite
  }));
}, wP = /* @__PURE__ */ O.forwardRef(kte);
process.env.NODE_ENV !== "production" && (wP.displayName = "DeploymentUnitOutlined");
var Pte = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M880 912H144c-17.7 0-32-14.3-32-32V144c0-17.7 14.3-32 32-32h360c4.4 0 8 3.6 8 8v56c0 4.4-3.6 8-8 8H184v656h656V520c0-4.4 3.6-8 8-8h56c4.4 0 8 3.6 8 8v360c0 17.7-14.3 32-32 32zM770.87 199.13l-52.2-52.2a8.01 8.01 0 014.7-13.6l179.4-21c5.1-.6 9.5 3.7 8.9 8.9l-21 179.4c-.8 6.6-8.9 9.4-13.6 4.7l-52.4-52.4-256.2 256.2a8.03 8.03 0 01-11.3 0l-42.4-42.4a8.03 8.03 0 010-11.3l256.1-256.3z" } }] }, name: "export", theme: "outlined" }, Nte = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: Pte
  }));
}, CP = /* @__PURE__ */ O.forwardRef(Nte);
process.env.NODE_ENV !== "production" && (CP.displayName = "ExportOutlined");
var Lte = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M840 192h-56v-72c0-13.3-10.7-24-24-24H168c-13.3 0-24 10.7-24 24v272c0 13.3 10.7 24 24 24h592c13.3 0 24-10.7 24-24V256h32v200H465c-22.1 0-40 17.9-40 40v136h-44c-4.4 0-8 3.6-8 8v228c0 .6.1 1.3.2 1.9A83.99 83.99 0 00457 960c46.4 0 84-37.6 84-84 0-2.1-.1-4.1-.2-6.1.1-.6.2-1.2.2-1.9V640c0-4.4-3.6-8-8-8h-44V520h351c22.1 0 40-17.9 40-40V232c0-22.1-17.9-40-40-40zM720 352H208V160h512v192zM477 876c0 11-9 20-20 20s-20-9-20-20V696h40v180z" } }] }, name: "format-painter", theme: "outlined" }, Fte = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: Lte
  }));
}, bC = /* @__PURE__ */ O.forwardRef(Fte);
process.env.NODE_ENV !== "production" && (bC.displayName = "FormatPainterOutlined");
var Bte = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M841 370c3-3.3 2.7-8.3-.6-11.3a8.24 8.24 0 00-5.3-2.1h-72.6c-2.4 0-4.6 1-6.1 2.8L633.5 504.6a7.96 7.96 0 01-13.4-1.9l-63.5-141.3a7.9 7.9 0 00-7.3-4.7H380.7l.9-4.7 8-42.3c10.5-55.4 38-81.4 85.8-81.4 18.6 0 35.5 1.7 48.8 4.7l14.1-66.8c-22.6-4.7-35.2-6.1-54.9-6.1-103.3 0-156.4 44.3-175.9 147.3l-9.4 49.4h-97.6c-3.8 0-7.1 2.7-7.8 6.4L181.9 415a8.07 8.07 0 007.8 9.7H284l-89 429.9a8.07 8.07 0 007.8 9.7H269c3.8 0 7.1-2.7 7.8-6.4l89.7-433.1h135.8l68.2 139.1c1.4 2.9 1 6.4-1.2 8.8l-180.6 203c-2.9 3.3-2.6 8.4.7 11.3 1.5 1.3 3.4 2 5.3 2h72.7c2.4 0 4.6-1 6.1-2.8l123.7-146.7c2.8-3.4 7.9-3.8 11.3-1 .9.8 1.6 1.7 2.1 2.8L676.4 784c1.3 2.8 4.1 4.7 7.3 4.7h64.6a8.02 8.02 0 007.2-11.5l-95.2-198.9c-1.4-2.9-.9-6.4 1.3-8.8L841 370z" } }] }, name: "function", theme: "outlined" }, jte = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: Bte
  }));
}, SP = /* @__PURE__ */ O.forwardRef(jte);
process.env.NODE_ENV !== "production" && (SP.displayName = "FunctionOutlined");
var zte = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M880 912H144c-17.7 0-32-14.3-32-32V144c0-17.7 14.3-32 32-32h360c4.4 0 8 3.6 8 8v56c0 4.4-3.6 8-8 8H184v656h656V520c0-4.4 3.6-8 8-8h56c4.4 0 8 3.6 8 8v360c0 17.7-14.3 32-32 32zM653.3 424.6l52.2 52.2a8.01 8.01 0 01-4.7 13.6l-179.4 21c-5.1.6-9.5-3.7-8.9-8.9l21-179.4c.8-6.6 8.9-9.4 13.6-4.7l52.4 52.4 256.2-256.2c3.1-3.1 8.2-3.1 11.3 0l42.4 42.4c3.1 3.1 3.1 8.2 0 11.3L653.3 424.6z" } }] }, name: "import", theme: "outlined" }, Hte = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: zte
  }));
}, xP = /* @__PURE__ */ O.forwardRef(Hte);
process.env.NODE_ENV !== "production" && (xP.displayName = "ImportOutlined");
var Vte = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M521.7 82c-152.5-.4-286.7 78.5-363.4 197.7-3.4 5.3.4 12.3 6.7 12.3h70.3c4.8 0 9.3-2.1 12.3-5.8 7-8.5 14.5-16.7 22.4-24.5 32.6-32.5 70.5-58.1 112.7-75.9 43.6-18.4 90-27.8 137.9-27.8 47.9 0 94.3 9.3 137.9 27.8 42.2 17.8 80.1 43.4 112.7 75.9 32.6 32.5 58.1 70.4 76 112.5C865.7 417.8 875 464.1 875 512c0 47.9-9.4 94.2-27.8 137.8-17.8 42.1-43.4 80-76 112.5s-70.5 58.1-112.7 75.9A352.8 352.8 0 01520.6 866c-47.9 0-94.3-9.4-137.9-27.8A353.84 353.84 0 01270 762.3c-7.9-7.9-15.3-16.1-22.4-24.5-3-3.7-7.6-5.8-12.3-5.8H165c-6.3 0-10.2 7-6.7 12.3C234.9 863.2 368.5 942 520.6 942c236.2 0 428-190.1 430.4-425.6C953.4 277.1 761.3 82.6 521.7 82zM395.02 624v-76h-314c-4.4 0-8-3.6-8-8v-56c0-4.4 3.6-8 8-8h314v-76c0-6.7 7.8-10.5 13-6.3l141.9 112a8 8 0 010 12.6l-141.9 112c-5.2 4.1-13 .4-13-6.3z" } }] }, name: "login", theme: "outlined" }, Wte = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: Vte
  }));
}, EP = /* @__PURE__ */ O.forwardRef(Wte);
process.env.NODE_ENV !== "production" && (EP.displayName = "LoginOutlined");
var Ute = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M868 732h-70.3c-4.8 0-9.3 2.1-12.3 5.8-7 8.5-14.5 16.7-22.4 24.5a353.84 353.84 0 01-112.7 75.9A352.8 352.8 0 01512.4 866c-47.9 0-94.3-9.4-137.9-27.8a353.84 353.84 0 01-112.7-75.9 353.28 353.28 0 01-76-112.5C167.3 606.2 158 559.9 158 512s9.4-94.2 27.8-137.8c17.8-42.1 43.4-80 76-112.5s70.5-58.1 112.7-75.9c43.6-18.4 90-27.8 137.9-27.8 47.9 0 94.3 9.3 137.9 27.8 42.2 17.8 80.1 43.4 112.7 75.9 7.9 7.9 15.3 16.1 22.4 24.5 3 3.7 7.6 5.8 12.3 5.8H868c6.3 0 10.2-7 6.7-12.3C798 160.5 663.8 81.6 511.3 82 271.7 82.6 79.6 277.1 82 516.4 84.4 751.9 276.2 942 512.4 942c152.1 0 285.7-78.8 362.3-197.7 3.4-5.3-.4-12.3-6.7-12.3zm88.9-226.3L815 393.7c-5.3-4.2-13-.4-13 6.3v76H488c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h314v76c0 6.7 7.8 10.5 13 6.3l141.9-112a8 8 0 000-12.6z" } }] }, name: "logout", theme: "outlined" }, Gte = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: Ute
  }));
}, $P = /* @__PURE__ */ O.forwardRef(Gte);
process.env.NODE_ENV !== "production" && ($P.displayName = "LogoutOutlined");
var Kte = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z" } }] }, name: "menu", theme: "outlined" }, Xte = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: Kte
  }));
}, OP = /* @__PURE__ */ O.forwardRef(Xte);
process.env.NODE_ENV !== "production" && (OP.displayName = "MenuOutlined");
var Yte = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M456 231a56 56 0 10112 0 56 56 0 10-112 0zm0 280a56 56 0 10112 0 56 56 0 10-112 0zm0 280a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "more", theme: "outlined" }, qte = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: Yte
  }));
}, Cm = /* @__PURE__ */ O.forwardRef(qte);
process.env.NODE_ENV !== "production" && (Cm.displayName = "MoreOutlined");
var Qte = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M872 394c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8H708V152c0-4.4-3.6-8-8-8h-64c-4.4 0-8 3.6-8 8v166H400V152c0-4.4-3.6-8-8-8h-64c-4.4 0-8 3.6-8 8v166H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h168v236H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h168v166c0 4.4 3.6 8 8 8h64c4.4 0 8-3.6 8-8V706h228v166c0 4.4 3.6 8 8 8h64c4.4 0 8-3.6 8-8V706h164c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8H708V394h164zM628 630H400V394h228v236z" } }] }, name: "number", theme: "outlined" }, Zte = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: Qte
  }));
}, AP = /* @__PURE__ */ O.forwardRef(Zte);
process.env.NODE_ENV !== "production" && (AP.displayName = "NumberOutlined");
var Jte = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M719.4 499.1l-296.1-215A15.9 15.9 0 00398 297v430c0 13.1 14.8 20.5 25.3 12.9l296.1-215a15.9 15.9 0 000-25.8zm-257.6 134V390.9L628.5 512 461.8 633.1z" } }] }, name: "play-circle", theme: "outlined" }, ene = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: Jte
  }));
}, yC = /* @__PURE__ */ O.forwardRef(ene);
process.env.NODE_ENV !== "production" && (yC.displayName = "PlayCircleOutlined");
var tne = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M696 480H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8z" } }, { tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, name: "plus-circle", theme: "outlined" }, nne = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: tne
  }));
}, DP = /* @__PURE__ */ O.forwardRef(nne);
process.env.NODE_ENV !== "production" && (DP.displayName = "PlusCircleOutlined");
var rne = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 208H676V232h212v136zm0 224H676V432h212v160zM412 432h200v160H412V432zm200-64H412V232h200v136zm-476 64h212v160H136V432zm0-200h212v136H136V232zm0 424h212v136H136V656zm276 0h200v136H412V656zm476 136H676V656h212v136z" } }] }, name: "table", theme: "outlined" }, ine = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: rne
  }));
}, _P = /* @__PURE__ */ O.forwardRef(ine);
process.env.NODE_ENV !== "production" && (_P.displayName = "TableOutlined");
var one = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M464 720a48 48 0 1096 0 48 48 0 10-96 0zm16-304v184c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V416c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8zm475.7 440l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48zm-783.5-27.9L512 239.9l339.8 588.2H172.2z" } }] }, name: "warning", theme: "outlined" }, sne = function(t, n) {
  return /* @__PURE__ */ O.createElement(kt, we({}, t, {
    ref: n,
    icon: one
  }));
}, TP = /* @__PURE__ */ O.forwardRef(sne);
process.env.NODE_ENV !== "production" && (TP.displayName = "WarningOutlined");
var Fn = /* @__PURE__ */ ((e) => (e.Input = "inputNode", e.Output = "outputNode", e.DecisionTable = "decisionTableNode", e.Function = "functionNode", e.Expression = "expressionNode", e.Switch = "switchNode", e))(Fn || {});
const ane = (e, t) => {
  const n = document.createElement("a");
  n.download = e, n.href = URL.createObjectURL(t), n.style.display = "none", document.body.appendChild(n), n.click(), n.remove();
}, RP = async (e, t) => {
  const n = await import("./exceljs.min-JsnRtNwa.js").then((s) => s.e), r = new n.Workbook();
  t.forEach((s) => {
    let a = s.name, l = 0;
    if (r.getWorksheet(a))
      do
        l++, a = `${s.name} (${l})`;
      while (r.getWorksheet(a));
    const u = r.addWorksheet(a), c = [
      ...s.inputs.map((C) => ({
        title: C.name,
        meta: { id: C.id, name: C.field, type: "input" }
      })),
      ...s.outputs.map((C) => ({
        title: C.name,
        meta: { id: C.id, name: C.field, type: "output" }
      })),
      { title: "DESCRIPTION", meta: null },
      { title: "Rule ID", meta: null }
    ], d = [...s.inputs, ...s.outputs], f = s.rules.map((C) => {
      const y = [];
      return d.forEach((S) => {
        const A = C == null ? void 0 : C[S.id || ""], $ = typeof A == "object" && A !== null ? JSON.stringify(A) : A;
        y.push($ || "");
      }), y.push((C == null ? void 0 : C._description) || ""), y.push((C == null ? void 0 : C._id) || ""), y;
    }), h = c.filter((C) => {
      var y;
      return ((y = C.meta) == null ? void 0 : y.type.toLowerCase()) === "input";
    }).length, p = c.filter((C) => {
      var y;
      return ((y = C.meta) == null ? void 0 : y.type.toLowerCase()) === "output";
    }).length;
    u.mergeCells(1, 1, 1, h + p + 2);
    const g = u.getCell(1, 1);
    g.value = s.id, g.alignment = { horizontal: "center", vertical: "middle" }, u.mergeCells(2, 1, 2, h);
    const m = u.getCell(2, 1);
    m.value = "Inputs", m.alignment = { horizontal: "center", vertical: "middle" }, m.font = { bold: !0, color: { argb: "FFFFFF" } }, m.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "5e6476" }
    }, u.mergeCells(2, h + 1, 2, h + p);
    const v = u.getCell(2, h + 1);
    v.value = "Outputs", v.alignment = { horizontal: "center", vertical: "middle" }, v.font = { bold: !0, color: { argb: "FFFFFF" } }, v.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "63546c" }
    };
    const b = u.getCell(2, h + p + 1);
    b.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "63546c" }
    };
    const x = u.getCell(2, h + p + 2);
    x.fill = {
      type: "pattern",
      pattern: "solid",
      fgColor: { argb: "63546c" }
    }, u.addRow(c.map((C) => C.title)).eachCell((C) => {
      var A;
      const y = (A = c.find(($) => $.title === C.value)) == null ? void 0 : A.meta, S = (y == null ? void 0 : y.type.toLowerCase()) === "input" ? "5e6476" : "63546c";
      C.font = { bold: !0, color: { argb: "FFFFFF" } }, C.fill = { type: "pattern", pattern: "solid", fgColor: { argb: S } }, y && (C.note = {
        texts: [{ text: JSON.stringify(y, void 0, 2) }]
      });
    }), f == null || f.forEach((C) => {
      u.addRow(Object.values(C));
    }), u.columns.forEach((C, y) => {
      let S = 15;
      const A = u.getColumn(y + 1);
      A.eachCell({ includeEmpty: !1 }, ($) => {
        const M = $.value ? $.value.toString().length : 0;
        S = M > S ? M : S, $.border = {
          top: { style: "thin" },
          left: { style: "thin" },
          bottom: { style: "thin" },
          right: { style: "thin" }
        };
      }), A.width = S;
    }), u.views = [{ state: "frozen", xSplit: 0, ySplit: 3 }];
  });
  const i = await r.xlsx.writeBuffer(), o = new Blob([i], { type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" });
  ane(`${e}.xlsx`, o);
}, lne = (e) => {
  const n = e.splice(0, 3)[2].map((s) => {
    if (s.value.toLowerCase() === "description")
      return {
        name: s.value,
        id: "_description"
      };
    if (s.value.toLowerCase() === "rule id")
      return {
        name: s.value,
        id: "_id"
      };
    let a = {
      name: "",
      type: "",
      id: ""
    };
    try {
      a = JSON.parse(s.note);
    } catch {
      Cr.error("Header note can not be parsed!");
    }
    return {
      name: s.value,
      field: a == null ? void 0 : a.name,
      _type: a == null ? void 0 : a.type,
      type: "expression",
      id: a == null ? void 0 : a.id,
      defaultValue: ""
    };
  }), r = n.filter((s) => {
    var a;
    return ((a = s._type) == null ? void 0 : a.toLowerCase()) === "input";
  }).map((s) => ({
    id: s.id,
    name: s == null ? void 0 : s.name,
    field: s == null ? void 0 : s.field,
    type: s == null ? void 0 : s.type,
    defaultValue: s == null ? void 0 : s.defaultValue
  })), i = n.filter((s) => {
    var a;
    return ((a = s._type) == null ? void 0 : a.toLowerCase()) === "output";
  }).map((s) => ({
    id: s.id,
    name: s == null ? void 0 : s.name,
    field: s == null ? void 0 : s.field,
    type: s == null ? void 0 : s.type,
    defaultValue: s == null ? void 0 : s.defaultValue
  })), o = e.map((s) => {
    const a = {
      _id: crypto.randomUUID()
    };
    return n.forEach((l, u) => {
      var c;
      a[l.id] = yn((c = s == null ? void 0 : s[u]) == null ? void 0 : c.value).with(mn.string, (d) => d.trim()).with(mn.nullish, () => "").otherwise((d) => d.toString());
    }), a;
  });
  return Id({
    inputs: r,
    outputs: i,
    rules: o,
    hitPolicy: "first"
  });
}, MP = async (e) => {
  const t = await import("./exceljs.min-JsnRtNwa.js").then((o) => o.e), r = await new t.Workbook().xlsx.load(e), i = [];
  return r.eachSheet((o) => {
    const s = [], a = o.name;
    o.eachRow((u) => {
      var d;
      const c = [];
      for (let f = 1; f <= u.cellCount; f++) {
        const h = u.getCell(f), p = h.note ? typeof h.note == "object" ? (d = h.note.texts) == null ? void 0 : d.map((g) => g.text).join("") : h.note : null;
        c.push({ value: h.value, note: p });
      }
      s.push(c);
    });
    const l = s[0][0].value;
    i.push({
      id: l,
      name: a,
      type: Fn.DecisionTable,
      content: lne(s),
      position: { x: 0, y: 0 }
    });
  }), i;
}, cne = () => {
  const e = Qo(), { disableHitPolicy: t, disabled: n, configurable: r, hitPolicy: i } = io(
    ({ disableHitPolicy: d, disabled: f, configurable: h, decisionTable: p }) => ({
      disableHitPolicy: d,
      disabled: f,
      configurable: h,
      hitPolicy: p.hitPolicy
    })
  ), { listenerStore: o, stateStore: s } = $I(), a = he(null), l = async (d) => {
    const { name: f } = d;
    try {
      const h = s.getState().decisionTable;
      await RP(f, [{ ...h, name: "decision table", id: crypto.randomUUID() }]), Cr.success("Excel file has been downloaded successfully!");
    } catch {
      Cr.error("Failed to download Excel file!");
    }
  }, u = () => {
    var d, f;
    (f = (d = a == null ? void 0 : a.current) == null ? void 0 : d.click) == null || f.call(d);
  }, c = async (d) => {
    var p;
    const f = (p = d == null ? void 0 : d.target) == null ? void 0 : p.files[0], h = new FileReader();
    try {
      h.readAsArrayBuffer(f), h.onload = async () => {
        var b, x;
        const g = h.result;
        if (!g)
          return;
        const v = (await MP(g))[0].content;
        e.setDecisionTable(v), (x = (b = o.getState()).onChange) == null || x.call(b, v);
      }, Cr.success("Excel file has been uploaded successfully!");
    } catch {
      Cr.error("Failed to upload Excel!");
    }
  };
  return /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
    /* @__PURE__ */ V.jsxs(qr, { horizontal: !0, horizontalAlign: "space-between", verticalAlign: "center", className: "grl-dt__command-bar", children: [
      /* @__PURE__ */ V.jsxs(qr, { gap: 8, horizontal: !0, className: "full-width", children: [
        /* @__PURE__ */ V.jsx(
          Ut,
          {
            type: "text",
            size: "small",
            color: "secondary",
            icon: /* @__PURE__ */ V.jsx(CP, {}),
            onClick: () => l({ name: "table" }),
            children: "Export Excel"
          }
        ),
        /* @__PURE__ */ V.jsx(
          Ut,
          {
            type: "text",
            size: "small",
            color: "secondary",
            disabled: n,
            icon: /* @__PURE__ */ V.jsx(xP, {}),
            onClick: () => u(),
            children: "Import Excel"
          }
        )
      ] }),
      /* @__PURE__ */ V.jsx(
        Sl,
        {
          style: { width: 140 },
          size: "small",
          disabled: n || !r || t,
          value: i,
          onSelect: (d) => e.updateHitPolicy(d),
          options: [
            {
              key: "first",
              label: "First",
              value: "first"
            },
            {
              key: "collect",
              label: "Collect",
              value: "collect"
            }
          ]
        }
      )
    ] }),
    /* @__PURE__ */ V.jsx(
      "input",
      {
        multiple: !0,
        hidden: !0,
        accept: ".xlsx",
        type: "file",
        ref: a,
        onChange: c,
        onClick: (d) => {
          d.target.value = null;
        }
      }
    )
  ] });
};
function Sm(e, t, n) {
  var r = this, i = he(null), o = he(0), s = he(null), a = he([]), l = he(), u = he(), c = he(e), d = he(!0);
  c.current = e;
  var f = typeof window < "u", h = !t && t !== 0 && f;
  if (typeof e != "function")
    throw new TypeError("Expected a function");
  t = +t || 0;
  var p = !!(n = n || {}).leading, g = !("trailing" in n) || !!n.trailing, m = "maxWait" in n, v = "debounceOnServer" in n && !!n.debounceOnServer, b = m ? Math.max(+n.maxWait || 0, t) : null;
  Pe(function() {
    return d.current = !0, function() {
      d.current = !1;
    };
  }, []);
  var x = mt(function() {
    var w = function(M) {
      var _ = a.current, T = l.current;
      return a.current = l.current = null, o.current = M, u.current = c.current.apply(T, _);
    }, C = function(M, _) {
      h && cancelAnimationFrame(s.current), s.current = h ? requestAnimationFrame(M) : setTimeout(M, _);
    }, y = function(M) {
      if (!d.current)
        return !1;
      var _ = M - i.current;
      return !i.current || _ >= t || _ < 0 || m && M - o.current >= b;
    }, S = function(M) {
      return s.current = null, g && a.current ? w(M) : (a.current = l.current = null, u.current);
    }, A = function M() {
      var _ = Date.now();
      if (y(_))
        return S(_);
      if (d.current) {
        var T = t - (_ - i.current), D = m ? Math.min(T, b - (_ - o.current)) : T;
        C(M, D);
      }
    }, $ = function() {
      if (f || v) {
        var M = Date.now(), _ = y(M);
        if (a.current = [].slice.call(arguments), l.current = r, i.current = M, _) {
          if (!s.current && d.current)
            return o.current = i.current, C(A, t), p ? w(i.current) : u.current;
          if (m)
            return C(A, t), w(i.current);
        }
        return s.current || C(A, t), u.current;
      }
    };
    return $.cancel = function() {
      s.current && (h ? cancelAnimationFrame(s.current) : clearTimeout(s.current)), o.current = 0, a.current = i.current = l.current = s.current = null;
    }, $.isPending = function() {
      return !!s.current;
    }, $.flush = function() {
      return s.current ? S(Date.now()) : u.current;
    }, $;
  }, [p, m, t, b, g, h, f, v]);
  return x;
}
function une(e, t, n) {
  var r = n === void 0 ? {} : n, i = r.leading, o = r.trailing;
  return Sm(e, t, { maxWait: t, leading: i === void 0 || i, trailing: o === void 0 || o });
}
const dne = ({
  id: e,
  defaultValue: t,
  value: n,
  disabled: r = !1,
  configurable: i = !0,
  disableHitPolicy: o = !1,
  activeRules: s,
  inputsSchema: a,
  outputsSchema: l,
  colWidth: u,
  minColWidth: c,
  cellRenderer: d,
  onChange: f
}) => {
  const h = he(!1), { stateStore: p, listenerStore: g } = $I(), m = Qo(), { decisionTable: v } = io(({ decisionTable: x }) => ({
    decisionTable: x
  })), b = Sm((x) => {
    f == null || f(x);
  }, 100);
  return Pe(() => {
    p.setState({
      id: e,
      disabled: r,
      configurable: i,
      disableHitPolicy: o,
      activeRules: s,
      inputsSchema: a,
      outputsSchema: l,
      colWidth: u || 200,
      minColWidth: c || 150
    });
  }, [e, r, i, o, s, a, c, u, l]), Pe(() => {
    g.setState({
      cellRenderer: d,
      onChange: b
    });
  }, [d, b]), Pe(() => {
    h.current && n !== void 0 && !ro(n, v) && m.setDecisionTable(Id(n));
  }, [n]), Pe(() => {
    m.setDecisionTable(Id(n === void 0 ? t : n)), h.current = !0;
  }, []), null;
};
/**
   * table-core
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
function ea(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Bi(e, t) {
  return (n) => {
    t.setState((r) => ({
      ...r,
      [e]: ea(n, r[e])
    }));
  };
}
function xm(e) {
  return e instanceof Function;
}
function fne(e) {
  return Array.isArray(e) && e.every((t) => typeof t == "number");
}
function hne(e, t) {
  const n = [], r = (i) => {
    i.forEach((o) => {
      n.push(o);
      const s = t(o);
      s != null && s.length && r(s);
    });
  };
  return r(e), n;
}
function Mt(e, t, n) {
  let r = [], i;
  return (o) => {
    let s;
    n.key && n.debug && (s = Date.now());
    const a = e(o);
    if (!(a.length !== r.length || a.some((c, d) => r[d] !== c)))
      return i;
    r = a;
    let u;
    if (n.key && n.debug && (u = Date.now()), i = t(...a), n == null || n.onChange == null || n.onChange(i), n.key && n.debug && n != null && n.debug()) {
      const c = Math.round((Date.now() - s) * 100) / 100, d = Math.round((Date.now() - u) * 100) / 100, f = d / 16, h = (p, g) => {
        for (p = String(p); p.length < g; )
          p = " " + p;
        return p;
      };
      console.info(`%c ${h(d, 5)} /${h(c, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * f, 120))}deg 100% 31%);`, n == null ? void 0 : n.key);
    }
    return i;
  };
}
function It(e, t, n, r) {
  return {
    debug: () => {
      var i;
      return (i = e == null ? void 0 : e.debugAll) != null ? i : e[t];
    },
    key: process.env.NODE_ENV === "development" && n,
    onChange: r
  };
}
function pne(e, t, n, r) {
  const i = () => {
    var s;
    return (s = o.getValue()) != null ? s : e.options.renderFallbackValue;
  }, o = {
    id: `${t.id}_${n.id}`,
    row: t,
    column: n,
    getValue: () => t.getValue(r),
    renderValue: i,
    getContext: Mt(() => [e, n, t, o], (s, a, l, u) => ({
      table: s,
      column: a,
      row: l,
      cell: u,
      getValue: u.getValue,
      renderValue: u.renderValue
    }), It(e.options, "debugCells", "cell.getContext"))
  };
  return e._features.forEach((s) => {
    s.createCell == null || s.createCell(o, n, t, e);
  }, {}), o;
}
function gne(e, t, n, r) {
  var i, o;
  const a = {
    ...e._getDefaultColumnDef(),
    ...t
  }, l = a.accessorKey;
  let u = (i = (o = a.id) != null ? o : l ? l.replace(".", "_") : void 0) != null ? i : typeof a.header == "string" ? a.header : void 0, c;
  if (a.accessorFn ? c = a.accessorFn : l && (l.includes(".") ? c = (f) => {
    let h = f;
    for (const g of l.split(".")) {
      var p;
      h = (p = h) == null ? void 0 : p[g], process.env.NODE_ENV !== "production" && h === void 0 && console.warn(`"${g}" in deeply nested key "${l}" returned undefined.`);
    }
    return h;
  } : c = (f) => f[a.accessorKey]), !u)
    throw process.env.NODE_ENV !== "production" ? new Error(a.accessorFn ? "Columns require an id when using an accessorFn" : "Columns require an id when using a non-string header") : new Error();
  let d = {
    id: `${String(u)}`,
    accessorFn: c,
    parent: r,
    depth: n,
    columnDef: a,
    columns: [],
    getFlatColumns: Mt(() => [!0], () => {
      var f;
      return [d, ...(f = d.columns) == null ? void 0 : f.flatMap((h) => h.getFlatColumns())];
    }, It(e.options, "debugColumns", "column.getFlatColumns")),
    getLeafColumns: Mt(() => [e._getOrderColumnsFn()], (f) => {
      var h;
      if ((h = d.columns) != null && h.length) {
        let p = d.columns.flatMap((g) => g.getLeafColumns());
        return f(p);
      }
      return [d];
    }, It(e.options, "debugColumns", "column.getLeafColumns"))
  };
  for (const f of e._features)
    f.createColumn == null || f.createColumn(d, e);
  return d;
}
const Vr = "debugHeaders";
function e2(e, t, n) {
  var r;
  let o = {
    id: (r = n.id) != null ? r : t.id,
    column: t,
    index: n.index,
    isPlaceholder: !!n.isPlaceholder,
    placeholderId: n.placeholderId,
    depth: n.depth,
    subHeaders: [],
    colSpan: 0,
    rowSpan: 0,
    headerGroup: null,
    getLeafHeaders: () => {
      const s = [], a = (l) => {
        l.subHeaders && l.subHeaders.length && l.subHeaders.map(a), s.push(l);
      };
      return a(o), s;
    },
    getContext: () => ({
      table: e,
      header: o,
      column: t
    })
  };
  return e._features.forEach((s) => {
    s.createHeader == null || s.createHeader(o, e);
  }), o;
}
const mne = {
  createTable: (e) => {
    e.getHeaderGroups = Mt(() => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.left, e.getState().columnPinning.right], (t, n, r, i) => {
      var o, s;
      const a = (o = r == null ? void 0 : r.map((d) => n.find((f) => f.id === d)).filter(Boolean)) != null ? o : [], l = (s = i == null ? void 0 : i.map((d) => n.find((f) => f.id === d)).filter(Boolean)) != null ? s : [], u = n.filter((d) => !(r != null && r.includes(d.id)) && !(i != null && i.includes(d.id)));
      return Ah(t, [...a, ...u, ...l], e);
    }, It(e.options, Vr, "getHeaderGroups")), e.getCenterHeaderGroups = Mt(() => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.left, e.getState().columnPinning.right], (t, n, r, i) => (n = n.filter((o) => !(r != null && r.includes(o.id)) && !(i != null && i.includes(o.id))), Ah(t, n, e, "center")), It(e.options, Vr, "getCenterHeaderGroups")), e.getLeftHeaderGroups = Mt(() => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.left], (t, n, r) => {
      var i;
      const o = (i = r == null ? void 0 : r.map((s) => n.find((a) => a.id === s)).filter(Boolean)) != null ? i : [];
      return Ah(t, o, e, "left");
    }, It(e.options, Vr, "getLeftHeaderGroups")), e.getRightHeaderGroups = Mt(() => [e.getAllColumns(), e.getVisibleLeafColumns(), e.getState().columnPinning.right], (t, n, r) => {
      var i;
      const o = (i = r == null ? void 0 : r.map((s) => n.find((a) => a.id === s)).filter(Boolean)) != null ? i : [];
      return Ah(t, o, e, "right");
    }, It(e.options, Vr, "getRightHeaderGroups")), e.getFooterGroups = Mt(() => [e.getHeaderGroups()], (t) => [...t].reverse(), It(e.options, Vr, "getFooterGroups")), e.getLeftFooterGroups = Mt(() => [e.getLeftHeaderGroups()], (t) => [...t].reverse(), It(e.options, Vr, "getLeftFooterGroups")), e.getCenterFooterGroups = Mt(() => [e.getCenterHeaderGroups()], (t) => [...t].reverse(), It(e.options, Vr, "getCenterFooterGroups")), e.getRightFooterGroups = Mt(() => [e.getRightHeaderGroups()], (t) => [...t].reverse(), It(e.options, Vr, "getRightFooterGroups")), e.getFlatHeaders = Mt(() => [e.getHeaderGroups()], (t) => t.map((n) => n.headers).flat(), It(e.options, Vr, "getFlatHeaders")), e.getLeftFlatHeaders = Mt(() => [e.getLeftHeaderGroups()], (t) => t.map((n) => n.headers).flat(), It(e.options, Vr, "getLeftFlatHeaders")), e.getCenterFlatHeaders = Mt(() => [e.getCenterHeaderGroups()], (t) => t.map((n) => n.headers).flat(), It(e.options, Vr, "getCenterFlatHeaders")), e.getRightFlatHeaders = Mt(() => [e.getRightHeaderGroups()], (t) => t.map((n) => n.headers).flat(), It(e.options, Vr, "getRightFlatHeaders")), e.getCenterLeafHeaders = Mt(() => [e.getCenterFlatHeaders()], (t) => t.filter((n) => {
      var r;
      return !((r = n.subHeaders) != null && r.length);
    }), It(e.options, Vr, "getCenterLeafHeaders")), e.getLeftLeafHeaders = Mt(() => [e.getLeftFlatHeaders()], (t) => t.filter((n) => {
      var r;
      return !((r = n.subHeaders) != null && r.length);
    }), It(e.options, Vr, "getLeftLeafHeaders")), e.getRightLeafHeaders = Mt(() => [e.getRightFlatHeaders()], (t) => t.filter((n) => {
      var r;
      return !((r = n.subHeaders) != null && r.length);
    }), It(e.options, Vr, "getRightLeafHeaders")), e.getLeafHeaders = Mt(() => [e.getLeftHeaderGroups(), e.getCenterHeaderGroups(), e.getRightHeaderGroups()], (t, n, r) => {
      var i, o, s, a, l, u;
      return [...(i = (o = t[0]) == null ? void 0 : o.headers) != null ? i : [], ...(s = (a = n[0]) == null ? void 0 : a.headers) != null ? s : [], ...(l = (u = r[0]) == null ? void 0 : u.headers) != null ? l : []].map((c) => c.getLeafHeaders()).flat();
    }, It(e.options, Vr, "getLeafHeaders"));
  }
};
function Ah(e, t, n, r) {
  var i, o;
  let s = 0;
  const a = function(f, h) {
    h === void 0 && (h = 1), s = Math.max(s, h), f.filter((p) => p.getIsVisible()).forEach((p) => {
      var g;
      (g = p.columns) != null && g.length && a(p.columns, h + 1);
    }, 0);
  };
  a(e);
  let l = [];
  const u = (f, h) => {
    const p = {
      depth: h,
      id: [r, `${h}`].filter(Boolean).join("_"),
      headers: []
    }, g = [];
    f.forEach((m) => {
      const v = [...g].reverse()[0], b = m.column.depth === p.depth;
      let x, w = !1;
      if (b && m.column.parent ? x = m.column.parent : (x = m.column, w = !0), v && (v == null ? void 0 : v.column) === x)
        v.subHeaders.push(m);
      else {
        const C = e2(n, x, {
          id: [r, h, x.id, m == null ? void 0 : m.id].filter(Boolean).join("_"),
          isPlaceholder: w,
          placeholderId: w ? `${g.filter((y) => y.column === x).length}` : void 0,
          depth: h,
          index: g.length
        });
        C.subHeaders.push(m), g.push(C);
      }
      p.headers.push(m), m.headerGroup = p;
    }), l.push(p), h > 0 && u(g, h - 1);
  }, c = t.map((f, h) => e2(n, f, {
    depth: s,
    index: h
  }));
  u(c, s - 1), l.reverse();
  const d = (f) => f.filter((p) => p.column.getIsVisible()).map((p) => {
    let g = 0, m = 0, v = [0];
    p.subHeaders && p.subHeaders.length ? (v = [], d(p.subHeaders).forEach((x) => {
      let {
        colSpan: w,
        rowSpan: C
      } = x;
      g += w, v.push(C);
    })) : g = 1;
    const b = Math.min(...v);
    return m = m + b, p.colSpan = g, p.rowSpan = m, {
      colSpan: g,
      rowSpan: m
    };
  });
  return d((i = (o = l[0]) == null ? void 0 : o.headers) != null ? i : []), l;
}
const vne = (e, t, n, r, i, o, s) => {
  let a = {
    id: t,
    index: r,
    original: n,
    depth: i,
    parentId: s,
    _valuesCache: {},
    _uniqueValuesCache: {},
    getValue: (l) => {
      if (a._valuesCache.hasOwnProperty(l))
        return a._valuesCache[l];
      const u = e.getColumn(l);
      if (u != null && u.accessorFn)
        return a._valuesCache[l] = u.accessorFn(a.original, r), a._valuesCache[l];
    },
    getUniqueValues: (l) => {
      if (a._uniqueValuesCache.hasOwnProperty(l))
        return a._uniqueValuesCache[l];
      const u = e.getColumn(l);
      if (u != null && u.accessorFn)
        return u.columnDef.getUniqueValues ? (a._uniqueValuesCache[l] = u.columnDef.getUniqueValues(a.original, r), a._uniqueValuesCache[l]) : (a._uniqueValuesCache[l] = [a.getValue(l)], a._uniqueValuesCache[l]);
    },
    renderValue: (l) => {
      var u;
      return (u = a.getValue(l)) != null ? u : e.options.renderFallbackValue;
    },
    subRows: [],
    getLeafRows: () => hne(a.subRows, (l) => l.subRows),
    getParentRow: () => a.parentId ? e.getRow(a.parentId, !0) : void 0,
    getParentRows: () => {
      let l = [], u = a;
      for (; ; ) {
        const c = u.getParentRow();
        if (!c)
          break;
        l.push(c), u = c;
      }
      return l.reverse();
    },
    getAllCells: Mt(() => [e.getAllLeafColumns()], (l) => l.map((u) => pne(e, a, u, u.id)), It(e.options, "debugRows", "getAllCells")),
    _getAllCellsByColumnId: Mt(() => [a.getAllCells()], (l) => l.reduce((u, c) => (u[c.column.id] = c, u), {}), It(e.options, "debugRows", "getAllCellsByColumnId"))
  };
  for (let l = 0; l < e._features.length; l++) {
    const u = e._features[l];
    u == null || u.createRow == null || u.createRow(a, e);
  }
  return a;
}, bne = {
  createColumn: (e, t) => {
    e._getFacetedRowModel = t.options.getFacetedRowModel && t.options.getFacetedRowModel(t, e.id), e.getFacetedRowModel = () => e._getFacetedRowModel ? e._getFacetedRowModel() : t.getPreFilteredRowModel(), e._getFacetedUniqueValues = t.options.getFacetedUniqueValues && t.options.getFacetedUniqueValues(t, e.id), e.getFacetedUniqueValues = () => e._getFacetedUniqueValues ? e._getFacetedUniqueValues() : /* @__PURE__ */ new Map(), e._getFacetedMinMaxValues = t.options.getFacetedMinMaxValues && t.options.getFacetedMinMaxValues(t, e.id), e.getFacetedMinMaxValues = () => {
      if (e._getFacetedMinMaxValues)
        return e._getFacetedMinMaxValues();
    };
  }
}, IP = (e, t, n) => {
  var r;
  const i = n.toLowerCase();
  return !!(!((r = e.getValue(t)) == null || (r = r.toString()) == null || (r = r.toLowerCase()) == null) && r.includes(i));
};
IP.autoRemove = (e) => Co(e);
const kP = (e, t, n) => {
  var r;
  return !!(!((r = e.getValue(t)) == null || (r = r.toString()) == null) && r.includes(n));
};
kP.autoRemove = (e) => Co(e);
const PP = (e, t, n) => {
  var r;
  return ((r = e.getValue(t)) == null || (r = r.toString()) == null ? void 0 : r.toLowerCase()) === (n == null ? void 0 : n.toLowerCase());
};
PP.autoRemove = (e) => Co(e);
const NP = (e, t, n) => {
  var r;
  return (r = e.getValue(t)) == null ? void 0 : r.includes(n);
};
NP.autoRemove = (e) => Co(e) || !(e != null && e.length);
const LP = (e, t, n) => !n.some((r) => {
  var i;
  return !((i = e.getValue(t)) != null && i.includes(r));
});
LP.autoRemove = (e) => Co(e) || !(e != null && e.length);
const FP = (e, t, n) => n.some((r) => {
  var i;
  return (i = e.getValue(t)) == null ? void 0 : i.includes(r);
});
FP.autoRemove = (e) => Co(e) || !(e != null && e.length);
const BP = (e, t, n) => e.getValue(t) === n;
BP.autoRemove = (e) => Co(e);
const jP = (e, t, n) => e.getValue(t) == n;
jP.autoRemove = (e) => Co(e);
const wC = (e, t, n) => {
  let [r, i] = n;
  const o = e.getValue(t);
  return o >= r && o <= i;
};
wC.resolveFilterValue = (e) => {
  let [t, n] = e, r = typeof t != "number" ? parseFloat(t) : t, i = typeof n != "number" ? parseFloat(n) : n, o = t === null || Number.isNaN(r) ? -1 / 0 : r, s = n === null || Number.isNaN(i) ? 1 / 0 : i;
  if (o > s) {
    const a = o;
    o = s, s = a;
  }
  return [o, s];
};
wC.autoRemove = (e) => Co(e) || Co(e[0]) && Co(e[1]);
const cs = {
  includesString: IP,
  includesStringSensitive: kP,
  equalsString: PP,
  arrIncludes: NP,
  arrIncludesAll: LP,
  arrIncludesSome: FP,
  equals: BP,
  weakEquals: jP,
  inNumberRange: wC
};
function Co(e) {
  return e == null || e === "";
}
const yne = {
  getDefaultColumnDef: () => ({
    filterFn: "auto"
  }),
  getInitialState: (e) => ({
    columnFilters: [],
    ...e
  }),
  getDefaultOptions: (e) => ({
    onColumnFiltersChange: Bi("columnFilters", e),
    filterFromLeafRows: !1,
    maxLeafRowFilterDepth: 100
  }),
  createColumn: (e, t) => {
    e.getAutoFilterFn = () => {
      const n = t.getCoreRowModel().flatRows[0], r = n == null ? void 0 : n.getValue(e.id);
      return typeof r == "string" ? cs.includesString : typeof r == "number" ? cs.inNumberRange : typeof r == "boolean" || r !== null && typeof r == "object" ? cs.equals : Array.isArray(r) ? cs.arrIncludes : cs.weakEquals;
    }, e.getFilterFn = () => {
      var n, r;
      return xm(e.columnDef.filterFn) ? e.columnDef.filterFn : e.columnDef.filterFn === "auto" ? e.getAutoFilterFn() : (
        // @ts-ignore
        (n = (r = t.options.filterFns) == null ? void 0 : r[e.columnDef.filterFn]) != null ? n : cs[e.columnDef.filterFn]
      );
    }, e.getCanFilter = () => {
      var n, r, i;
      return ((n = e.columnDef.enableColumnFilter) != null ? n : !0) && ((r = t.options.enableColumnFilters) != null ? r : !0) && ((i = t.options.enableFilters) != null ? i : !0) && !!e.accessorFn;
    }, e.getIsFiltered = () => e.getFilterIndex() > -1, e.getFilterValue = () => {
      var n;
      return (n = t.getState().columnFilters) == null || (n = n.find((r) => r.id === e.id)) == null ? void 0 : n.value;
    }, e.getFilterIndex = () => {
      var n, r;
      return (n = (r = t.getState().columnFilters) == null ? void 0 : r.findIndex((i) => i.id === e.id)) != null ? n : -1;
    }, e.setFilterValue = (n) => {
      t.setColumnFilters((r) => {
        const i = e.getFilterFn(), o = r == null ? void 0 : r.find((c) => c.id === e.id), s = ea(n, o ? o.value : void 0);
        if (t2(i, s, e)) {
          var a;
          return (a = r == null ? void 0 : r.filter((c) => c.id !== e.id)) != null ? a : [];
        }
        const l = {
          id: e.id,
          value: s
        };
        if (o) {
          var u;
          return (u = r == null ? void 0 : r.map((c) => c.id === e.id ? l : c)) != null ? u : [];
        }
        return r != null && r.length ? [...r, l] : [l];
      });
    };
  },
  createRow: (e, t) => {
    e.columnFilters = {}, e.columnFiltersMeta = {};
  },
  createTable: (e) => {
    e.setColumnFilters = (t) => {
      const n = e.getAllLeafColumns(), r = (i) => {
        var o;
        return (o = ea(t, i)) == null ? void 0 : o.filter((s) => {
          const a = n.find((l) => l.id === s.id);
          if (a) {
            const l = a.getFilterFn();
            if (t2(l, s.value, a))
              return !1;
          }
          return !0;
        });
      };
      e.options.onColumnFiltersChange == null || e.options.onColumnFiltersChange(r);
    }, e.resetColumnFilters = (t) => {
      var n, r;
      e.setColumnFilters(t ? [] : (n = (r = e.initialState) == null ? void 0 : r.columnFilters) != null ? n : []);
    }, e.getPreFilteredRowModel = () => e.getCoreRowModel(), e.getFilteredRowModel = () => (!e._getFilteredRowModel && e.options.getFilteredRowModel && (e._getFilteredRowModel = e.options.getFilteredRowModel(e)), e.options.manualFiltering || !e._getFilteredRowModel ? e.getPreFilteredRowModel() : e._getFilteredRowModel());
  }
};
function t2(e, t, n) {
  return (e && e.autoRemove ? e.autoRemove(t, n) : !1) || typeof t > "u" || typeof t == "string" && !t;
}
const wne = (e, t, n) => n.reduce((r, i) => {
  const o = i.getValue(e);
  return r + (typeof o == "number" ? o : 0);
}, 0), Cne = (e, t, n) => {
  let r;
  return n.forEach((i) => {
    const o = i.getValue(e);
    o != null && (r > o || r === void 0 && o >= o) && (r = o);
  }), r;
}, Sne = (e, t, n) => {
  let r;
  return n.forEach((i) => {
    const o = i.getValue(e);
    o != null && (r < o || r === void 0 && o >= o) && (r = o);
  }), r;
}, xne = (e, t, n) => {
  let r, i;
  return n.forEach((o) => {
    const s = o.getValue(e);
    s != null && (r === void 0 ? s >= s && (r = i = s) : (r > s && (r = s), i < s && (i = s)));
  }), [r, i];
}, Ene = (e, t) => {
  let n = 0, r = 0;
  if (t.forEach((i) => {
    let o = i.getValue(e);
    o != null && (o = +o) >= o && (++n, r += o);
  }), n)
    return r / n;
}, $ne = (e, t) => {
  if (!t.length)
    return;
  const n = t.map((o) => o.getValue(e));
  if (!fne(n))
    return;
  if (n.length === 1)
    return n[0];
  const r = Math.floor(n.length / 2), i = n.sort((o, s) => o - s);
  return n.length % 2 !== 0 ? i[r] : (i[r - 1] + i[r]) / 2;
}, One = (e, t) => Array.from(new Set(t.map((n) => n.getValue(e))).values()), Ane = (e, t) => new Set(t.map((n) => n.getValue(e))).size, Dne = (e, t) => t.length, qv = {
  sum: wne,
  min: Cne,
  max: Sne,
  extent: xne,
  mean: Ene,
  median: $ne,
  unique: One,
  uniqueCount: Ane,
  count: Dne
}, _ne = {
  getDefaultColumnDef: () => ({
    aggregatedCell: (e) => {
      var t, n;
      return (t = (n = e.getValue()) == null || n.toString == null ? void 0 : n.toString()) != null ? t : null;
    },
    aggregationFn: "auto"
  }),
  getInitialState: (e) => ({
    grouping: [],
    ...e
  }),
  getDefaultOptions: (e) => ({
    onGroupingChange: Bi("grouping", e),
    groupedColumnMode: "reorder"
  }),
  createColumn: (e, t) => {
    e.toggleGrouping = () => {
      t.setGrouping((n) => n != null && n.includes(e.id) ? n.filter((r) => r !== e.id) : [...n ?? [], e.id]);
    }, e.getCanGroup = () => {
      var n, r;
      return ((n = e.columnDef.enableGrouping) != null ? n : !0) && ((r = t.options.enableGrouping) != null ? r : !0) && (!!e.accessorFn || !!e.columnDef.getGroupingValue);
    }, e.getIsGrouped = () => {
      var n;
      return (n = t.getState().grouping) == null ? void 0 : n.includes(e.id);
    }, e.getGroupedIndex = () => {
      var n;
      return (n = t.getState().grouping) == null ? void 0 : n.indexOf(e.id);
    }, e.getToggleGroupingHandler = () => {
      const n = e.getCanGroup();
      return () => {
        n && e.toggleGrouping();
      };
    }, e.getAutoAggregationFn = () => {
      const n = t.getCoreRowModel().flatRows[0], r = n == null ? void 0 : n.getValue(e.id);
      if (typeof r == "number")
        return qv.sum;
      if (Object.prototype.toString.call(r) === "[object Date]")
        return qv.extent;
    }, e.getAggregationFn = () => {
      var n, r;
      if (!e)
        throw new Error();
      return xm(e.columnDef.aggregationFn) ? e.columnDef.aggregationFn : e.columnDef.aggregationFn === "auto" ? e.getAutoAggregationFn() : (n = (r = t.options.aggregationFns) == null ? void 0 : r[e.columnDef.aggregationFn]) != null ? n : qv[e.columnDef.aggregationFn];
    };
  },
  createTable: (e) => {
    e.setGrouping = (t) => e.options.onGroupingChange == null ? void 0 : e.options.onGroupingChange(t), e.resetGrouping = (t) => {
      var n, r;
      e.setGrouping(t ? [] : (n = (r = e.initialState) == null ? void 0 : r.grouping) != null ? n : []);
    }, e.getPreGroupedRowModel = () => e.getFilteredRowModel(), e.getGroupedRowModel = () => (!e._getGroupedRowModel && e.options.getGroupedRowModel && (e._getGroupedRowModel = e.options.getGroupedRowModel(e)), e.options.manualGrouping || !e._getGroupedRowModel ? e.getPreGroupedRowModel() : e._getGroupedRowModel());
  },
  createRow: (e, t) => {
    e.getIsGrouped = () => !!e.groupingColumnId, e.getGroupingValue = (n) => {
      if (e._groupingValuesCache.hasOwnProperty(n))
        return e._groupingValuesCache[n];
      const r = t.getColumn(n);
      return r != null && r.columnDef.getGroupingValue ? (e._groupingValuesCache[n] = r.columnDef.getGroupingValue(e.original), e._groupingValuesCache[n]) : e.getValue(n);
    }, e._groupingValuesCache = {};
  },
  createCell: (e, t, n, r) => {
    e.getIsGrouped = () => t.getIsGrouped() && t.id === n.groupingColumnId, e.getIsPlaceholder = () => !e.getIsGrouped() && t.getIsGrouped(), e.getIsAggregated = () => {
      var i;
      return !e.getIsGrouped() && !e.getIsPlaceholder() && !!((i = n.subRows) != null && i.length);
    };
  }
};
function Tne(e, t, n) {
  if (!(t != null && t.length) || !n)
    return e;
  const r = e.filter((o) => !t.includes(o.id));
  return n === "remove" ? r : [...t.map((o) => e.find((s) => s.id === o)).filter(Boolean), ...r];
}
const Rne = {
  getInitialState: (e) => ({
    columnOrder: [],
    ...e
  }),
  getDefaultOptions: (e) => ({
    onColumnOrderChange: Bi("columnOrder", e)
  }),
  createColumn: (e, t) => {
    e.getIndex = Mt((n) => [ad(t, n)], (n) => n.findIndex((r) => r.id === e.id), It(t.options, "debugColumns", "getIndex")), e.getIsFirstColumn = (n) => {
      var r;
      return ((r = ad(t, n)[0]) == null ? void 0 : r.id) === e.id;
    }, e.getIsLastColumn = (n) => {
      var r;
      const i = ad(t, n);
      return ((r = i[i.length - 1]) == null ? void 0 : r.id) === e.id;
    };
  },
  createTable: (e) => {
    e.setColumnOrder = (t) => e.options.onColumnOrderChange == null ? void 0 : e.options.onColumnOrderChange(t), e.resetColumnOrder = (t) => {
      var n;
      e.setColumnOrder(t ? [] : (n = e.initialState.columnOrder) != null ? n : []);
    }, e._getOrderColumnsFn = Mt(() => [e.getState().columnOrder, e.getState().grouping, e.options.groupedColumnMode], (t, n, r) => (i) => {
      let o = [];
      if (!(t != null && t.length))
        o = i;
      else {
        const s = [...t], a = [...i];
        for (; a.length && s.length; ) {
          const l = s.shift(), u = a.findIndex((c) => c.id === l);
          u > -1 && o.push(a.splice(u, 1)[0]);
        }
        o = [...o, ...a];
      }
      return Tne(o, n, r);
    }, It(e.options, "debugTable", "_getOrderColumnsFn"));
  }
}, Qv = () => ({
  left: [],
  right: []
}), Mne = {
  getInitialState: (e) => ({
    columnPinning: Qv(),
    ...e
  }),
  getDefaultOptions: (e) => ({
    onColumnPinningChange: Bi("columnPinning", e)
  }),
  createColumn: (e, t) => {
    e.pin = (n) => {
      const r = e.getLeafColumns().map((i) => i.id).filter(Boolean);
      t.setColumnPinning((i) => {
        var o, s;
        if (n === "right") {
          var a, l;
          return {
            left: ((a = i == null ? void 0 : i.left) != null ? a : []).filter((d) => !(r != null && r.includes(d))),
            right: [...((l = i == null ? void 0 : i.right) != null ? l : []).filter((d) => !(r != null && r.includes(d))), ...r]
          };
        }
        if (n === "left") {
          var u, c;
          return {
            left: [...((u = i == null ? void 0 : i.left) != null ? u : []).filter((d) => !(r != null && r.includes(d))), ...r],
            right: ((c = i == null ? void 0 : i.right) != null ? c : []).filter((d) => !(r != null && r.includes(d)))
          };
        }
        return {
          left: ((o = i == null ? void 0 : i.left) != null ? o : []).filter((d) => !(r != null && r.includes(d))),
          right: ((s = i == null ? void 0 : i.right) != null ? s : []).filter((d) => !(r != null && r.includes(d)))
        };
      });
    }, e.getCanPin = () => e.getLeafColumns().some((r) => {
      var i, o, s;
      return ((i = r.columnDef.enablePinning) != null ? i : !0) && ((o = (s = t.options.enableColumnPinning) != null ? s : t.options.enablePinning) != null ? o : !0);
    }), e.getIsPinned = () => {
      const n = e.getLeafColumns().map((a) => a.id), {
        left: r,
        right: i
      } = t.getState().columnPinning, o = n.some((a) => r == null ? void 0 : r.includes(a)), s = n.some((a) => i == null ? void 0 : i.includes(a));
      return o ? "left" : s ? "right" : !1;
    }, e.getPinnedIndex = () => {
      var n, r;
      const i = e.getIsPinned();
      return i ? (n = (r = t.getState().columnPinning) == null || (r = r[i]) == null ? void 0 : r.indexOf(e.id)) != null ? n : -1 : 0;
    };
  },
  createRow: (e, t) => {
    e.getCenterVisibleCells = Mt(() => [e._getAllVisibleCells(), t.getState().columnPinning.left, t.getState().columnPinning.right], (n, r, i) => {
      const o = [...r ?? [], ...i ?? []];
      return n.filter((s) => !o.includes(s.column.id));
    }, It(t.options, "debugRows", "getCenterVisibleCells")), e.getLeftVisibleCells = Mt(() => [e._getAllVisibleCells(), t.getState().columnPinning.left], (n, r) => (r ?? []).map((o) => n.find((s) => s.column.id === o)).filter(Boolean).map((o) => ({
      ...o,
      position: "left"
    })), It(t.options, "debugRows", "getLeftVisibleCells")), e.getRightVisibleCells = Mt(() => [e._getAllVisibleCells(), t.getState().columnPinning.right], (n, r) => (r ?? []).map((o) => n.find((s) => s.column.id === o)).filter(Boolean).map((o) => ({
      ...o,
      position: "right"
    })), It(t.options, "debugRows", "getRightVisibleCells"));
  },
  createTable: (e) => {
    e.setColumnPinning = (t) => e.options.onColumnPinningChange == null ? void 0 : e.options.onColumnPinningChange(t), e.resetColumnPinning = (t) => {
      var n, r;
      return e.setColumnPinning(t ? Qv() : (n = (r = e.initialState) == null ? void 0 : r.columnPinning) != null ? n : Qv());
    }, e.getIsSomeColumnsPinned = (t) => {
      var n;
      const r = e.getState().columnPinning;
      if (!t) {
        var i, o;
        return !!((i = r.left) != null && i.length || (o = r.right) != null && o.length);
      }
      return !!((n = r[t]) != null && n.length);
    }, e.getLeftLeafColumns = Mt(() => [e.getAllLeafColumns(), e.getState().columnPinning.left], (t, n) => (n ?? []).map((r) => t.find((i) => i.id === r)).filter(Boolean), It(e.options, "debugColumns", "getLeftLeafColumns")), e.getRightLeafColumns = Mt(() => [e.getAllLeafColumns(), e.getState().columnPinning.right], (t, n) => (n ?? []).map((r) => t.find((i) => i.id === r)).filter(Boolean), It(e.options, "debugColumns", "getRightLeafColumns")), e.getCenterLeafColumns = Mt(() => [e.getAllLeafColumns(), e.getState().columnPinning.left, e.getState().columnPinning.right], (t, n, r) => {
      const i = [...n ?? [], ...r ?? []];
      return t.filter((o) => !i.includes(o.id));
    }, It(e.options, "debugColumns", "getCenterLeafColumns"));
  }
}, Dh = {
  size: 150,
  minSize: 20,
  maxSize: Number.MAX_SAFE_INTEGER
}, Zv = () => ({
  startOffset: null,
  startSize: null,
  deltaOffset: null,
  deltaPercentage: null,
  isResizingColumn: !1,
  columnSizingStart: []
}), Ine = {
  getDefaultColumnDef: () => Dh,
  getInitialState: (e) => ({
    columnSizing: {},
    columnSizingInfo: Zv(),
    ...e
  }),
  getDefaultOptions: (e) => ({
    columnResizeMode: "onEnd",
    columnResizeDirection: "ltr",
    onColumnSizingChange: Bi("columnSizing", e),
    onColumnSizingInfoChange: Bi("columnSizingInfo", e)
  }),
  createColumn: (e, t) => {
    e.getSize = () => {
      var n, r, i;
      const o = t.getState().columnSizing[e.id];
      return Math.min(Math.max((n = e.columnDef.minSize) != null ? n : Dh.minSize, (r = o ?? e.columnDef.size) != null ? r : Dh.size), (i = e.columnDef.maxSize) != null ? i : Dh.maxSize);
    }, e.getStart = Mt((n) => [n, ad(t, n), t.getState().columnSizing], (n, r) => r.slice(0, e.getIndex(n)).reduce((i, o) => i + o.getSize(), 0), It(t.options, "debugColumns", "getStart")), e.getAfter = Mt((n) => [n, ad(t, n), t.getState().columnSizing], (n, r) => r.slice(e.getIndex(n) + 1).reduce((i, o) => i + o.getSize(), 0), It(t.options, "debugColumns", "getAfter")), e.resetSize = () => {
      t.setColumnSizing((n) => {
        let {
          [e.id]: r,
          ...i
        } = n;
        return i;
      });
    }, e.getCanResize = () => {
      var n, r;
      return ((n = e.columnDef.enableResizing) != null ? n : !0) && ((r = t.options.enableColumnResizing) != null ? r : !0);
    }, e.getIsResizing = () => t.getState().columnSizingInfo.isResizingColumn === e.id;
  },
  createHeader: (e, t) => {
    e.getSize = () => {
      let n = 0;
      const r = (i) => {
        if (i.subHeaders.length)
          i.subHeaders.forEach(r);
        else {
          var o;
          n += (o = i.column.getSize()) != null ? o : 0;
        }
      };
      return r(e), n;
    }, e.getStart = () => {
      if (e.index > 0) {
        const n = e.headerGroup.headers[e.index - 1];
        return n.getStart() + n.getSize();
      }
      return 0;
    }, e.getResizeHandler = (n) => {
      const r = t.getColumn(e.column.id), i = r == null ? void 0 : r.getCanResize();
      return (o) => {
        if (!r || !i || (o.persist == null || o.persist(), Jv(o) && o.touches && o.touches.length > 1))
          return;
        const s = e.getSize(), a = e ? e.getLeafHeaders().map((v) => [v.column.id, v.column.getSize()]) : [[r.id, r.getSize()]], l = Jv(o) ? Math.round(o.touches[0].clientX) : o.clientX, u = {}, c = (v, b) => {
          typeof b == "number" && (t.setColumnSizingInfo((x) => {
            var w, C;
            const y = t.options.columnResizeDirection === "rtl" ? -1 : 1, S = (b - ((w = x == null ? void 0 : x.startOffset) != null ? w : 0)) * y, A = Math.max(S / ((C = x == null ? void 0 : x.startSize) != null ? C : 0), -0.999999);
            return x.columnSizingStart.forEach(($) => {
              let [M, _] = $;
              u[M] = Math.round(Math.max(_ + _ * A, 0) * 100) / 100;
            }), {
              ...x,
              deltaOffset: S,
              deltaPercentage: A
            };
          }), (t.options.columnResizeMode === "onChange" || v === "end") && t.setColumnSizing((x) => ({
            ...x,
            ...u
          })));
        }, d = (v) => c("move", v), f = (v) => {
          c("end", v), t.setColumnSizingInfo((b) => ({
            ...b,
            isResizingColumn: !1,
            startOffset: null,
            startSize: null,
            deltaOffset: null,
            deltaPercentage: null,
            columnSizingStart: []
          }));
        }, h = n || typeof document < "u" ? document : null, p = {
          moveHandler: (v) => d(v.clientX),
          upHandler: (v) => {
            h == null || h.removeEventListener("mousemove", p.moveHandler), h == null || h.removeEventListener("mouseup", p.upHandler), f(v.clientX);
          }
        }, g = {
          moveHandler: (v) => (v.cancelable && (v.preventDefault(), v.stopPropagation()), d(v.touches[0].clientX), !1),
          upHandler: (v) => {
            var b;
            h == null || h.removeEventListener("touchmove", g.moveHandler), h == null || h.removeEventListener("touchend", g.upHandler), v.cancelable && (v.preventDefault(), v.stopPropagation()), f((b = v.touches[0]) == null ? void 0 : b.clientX);
          }
        }, m = kne() ? {
          passive: !1
        } : !1;
        Jv(o) ? (h == null || h.addEventListener("touchmove", g.moveHandler, m), h == null || h.addEventListener("touchend", g.upHandler, m)) : (h == null || h.addEventListener("mousemove", p.moveHandler, m), h == null || h.addEventListener("mouseup", p.upHandler, m)), t.setColumnSizingInfo((v) => ({
          ...v,
          startOffset: l,
          startSize: s,
          deltaOffset: 0,
          deltaPercentage: 0,
          columnSizingStart: a,
          isResizingColumn: r.id
        }));
      };
    };
  },
  createTable: (e) => {
    e.setColumnSizing = (t) => e.options.onColumnSizingChange == null ? void 0 : e.options.onColumnSizingChange(t), e.setColumnSizingInfo = (t) => e.options.onColumnSizingInfoChange == null ? void 0 : e.options.onColumnSizingInfoChange(t), e.resetColumnSizing = (t) => {
      var n;
      e.setColumnSizing(t ? {} : (n = e.initialState.columnSizing) != null ? n : {});
    }, e.resetHeaderSizeInfo = (t) => {
      var n;
      e.setColumnSizingInfo(t ? Zv() : (n = e.initialState.columnSizingInfo) != null ? n : Zv());
    }, e.getTotalSize = () => {
      var t, n;
      return (t = (n = e.getHeaderGroups()[0]) == null ? void 0 : n.headers.reduce((r, i) => r + i.getSize(), 0)) != null ? t : 0;
    }, e.getLeftTotalSize = () => {
      var t, n;
      return (t = (n = e.getLeftHeaderGroups()[0]) == null ? void 0 : n.headers.reduce((r, i) => r + i.getSize(), 0)) != null ? t : 0;
    }, e.getCenterTotalSize = () => {
      var t, n;
      return (t = (n = e.getCenterHeaderGroups()[0]) == null ? void 0 : n.headers.reduce((r, i) => r + i.getSize(), 0)) != null ? t : 0;
    }, e.getRightTotalSize = () => {
      var t, n;
      return (t = (n = e.getRightHeaderGroups()[0]) == null ? void 0 : n.headers.reduce((r, i) => r + i.getSize(), 0)) != null ? t : 0;
    };
  }
};
let _h = null;
function kne() {
  if (typeof _h == "boolean")
    return _h;
  let e = !1;
  try {
    const t = {
      get passive() {
        return e = !0, !1;
      }
    }, n = () => {
    };
    window.addEventListener("test", n, t), window.removeEventListener("test", n);
  } catch {
    e = !1;
  }
  return _h = e, _h;
}
function Jv(e) {
  return e.type === "touchstart";
}
const Pne = {
  getInitialState: (e) => ({
    columnVisibility: {},
    ...e
  }),
  getDefaultOptions: (e) => ({
    onColumnVisibilityChange: Bi("columnVisibility", e)
  }),
  createColumn: (e, t) => {
    e.toggleVisibility = (n) => {
      e.getCanHide() && t.setColumnVisibility((r) => ({
        ...r,
        [e.id]: n ?? !e.getIsVisible()
      }));
    }, e.getIsVisible = () => {
      var n, r;
      const i = e.columns;
      return (n = i.length ? i.some((o) => o.getIsVisible()) : (r = t.getState().columnVisibility) == null ? void 0 : r[e.id]) != null ? n : !0;
    }, e.getCanHide = () => {
      var n, r;
      return ((n = e.columnDef.enableHiding) != null ? n : !0) && ((r = t.options.enableHiding) != null ? r : !0);
    }, e.getToggleVisibilityHandler = () => (n) => {
      e.toggleVisibility == null || e.toggleVisibility(n.target.checked);
    };
  },
  createRow: (e, t) => {
    e._getAllVisibleCells = Mt(() => [e.getAllCells(), t.getState().columnVisibility], (n) => n.filter((r) => r.column.getIsVisible()), It(t.options, "debugRows", "_getAllVisibleCells")), e.getVisibleCells = Mt(() => [e.getLeftVisibleCells(), e.getCenterVisibleCells(), e.getRightVisibleCells()], (n, r, i) => [...n, ...r, ...i], It(t.options, "debugRows", "getVisibleCells"));
  },
  createTable: (e) => {
    const t = (n, r) => Mt(() => [r(), r().filter((i) => i.getIsVisible()).map((i) => i.id).join("_")], (i) => i.filter((o) => o.getIsVisible == null ? void 0 : o.getIsVisible()), It(e.options, "debugColumns", n));
    e.getVisibleFlatColumns = t("getVisibleFlatColumns", () => e.getAllFlatColumns()), e.getVisibleLeafColumns = t("getVisibleLeafColumns", () => e.getAllLeafColumns()), e.getLeftVisibleLeafColumns = t("getLeftVisibleLeafColumns", () => e.getLeftLeafColumns()), e.getRightVisibleLeafColumns = t("getRightVisibleLeafColumns", () => e.getRightLeafColumns()), e.getCenterVisibleLeafColumns = t("getCenterVisibleLeafColumns", () => e.getCenterLeafColumns()), e.setColumnVisibility = (n) => e.options.onColumnVisibilityChange == null ? void 0 : e.options.onColumnVisibilityChange(n), e.resetColumnVisibility = (n) => {
      var r;
      e.setColumnVisibility(n ? {} : (r = e.initialState.columnVisibility) != null ? r : {});
    }, e.toggleAllColumnsVisible = (n) => {
      var r;
      n = (r = n) != null ? r : !e.getIsAllColumnsVisible(), e.setColumnVisibility(e.getAllLeafColumns().reduce((i, o) => ({
        ...i,
        [o.id]: n || !(o.getCanHide != null && o.getCanHide())
      }), {}));
    }, e.getIsAllColumnsVisible = () => !e.getAllLeafColumns().some((n) => !(n.getIsVisible != null && n.getIsVisible())), e.getIsSomeColumnsVisible = () => e.getAllLeafColumns().some((n) => n.getIsVisible == null ? void 0 : n.getIsVisible()), e.getToggleAllColumnsVisibilityHandler = () => (n) => {
      var r;
      e.toggleAllColumnsVisible((r = n.target) == null ? void 0 : r.checked);
    };
  }
};
function ad(e, t) {
  return t ? t === "center" ? e.getCenterVisibleLeafColumns() : t === "left" ? e.getLeftVisibleLeafColumns() : e.getRightVisibleLeafColumns() : e.getVisibleLeafColumns();
}
const Nne = {
  createTable: (e) => {
    e._getGlobalFacetedRowModel = e.options.getFacetedRowModel && e.options.getFacetedRowModel(e, "__global__"), e.getGlobalFacetedRowModel = () => e.options.manualFiltering || !e._getGlobalFacetedRowModel ? e.getPreFilteredRowModel() : e._getGlobalFacetedRowModel(), e._getGlobalFacetedUniqueValues = e.options.getFacetedUniqueValues && e.options.getFacetedUniqueValues(e, "__global__"), e.getGlobalFacetedUniqueValues = () => e._getGlobalFacetedUniqueValues ? e._getGlobalFacetedUniqueValues() : /* @__PURE__ */ new Map(), e._getGlobalFacetedMinMaxValues = e.options.getFacetedMinMaxValues && e.options.getFacetedMinMaxValues(e, "__global__"), e.getGlobalFacetedMinMaxValues = () => {
      if (e._getGlobalFacetedMinMaxValues)
        return e._getGlobalFacetedMinMaxValues();
    };
  }
}, Lne = {
  getInitialState: (e) => ({
    globalFilter: void 0,
    ...e
  }),
  getDefaultOptions: (e) => ({
    onGlobalFilterChange: Bi("globalFilter", e),
    globalFilterFn: "auto",
    getColumnCanGlobalFilter: (t) => {
      var n;
      const r = (n = e.getCoreRowModel().flatRows[0]) == null || (n = n._getAllCellsByColumnId()[t.id]) == null ? void 0 : n.getValue();
      return typeof r == "string" || typeof r == "number";
    }
  }),
  createColumn: (e, t) => {
    e.getCanGlobalFilter = () => {
      var n, r, i, o;
      return ((n = e.columnDef.enableGlobalFilter) != null ? n : !0) && ((r = t.options.enableGlobalFilter) != null ? r : !0) && ((i = t.options.enableFilters) != null ? i : !0) && ((o = t.options.getColumnCanGlobalFilter == null ? void 0 : t.options.getColumnCanGlobalFilter(e)) != null ? o : !0) && !!e.accessorFn;
    };
  },
  createTable: (e) => {
    e.getGlobalAutoFilterFn = () => cs.includesString, e.getGlobalFilterFn = () => {
      var t, n;
      const {
        globalFilterFn: r
      } = e.options;
      return xm(r) ? r : r === "auto" ? e.getGlobalAutoFilterFn() : (t = (n = e.options.filterFns) == null ? void 0 : n[r]) != null ? t : cs[r];
    }, e.setGlobalFilter = (t) => {
      e.options.onGlobalFilterChange == null || e.options.onGlobalFilterChange(t);
    }, e.resetGlobalFilter = (t) => {
      e.setGlobalFilter(t ? void 0 : e.initialState.globalFilter);
    };
  }
}, Fne = {
  getInitialState: (e) => ({
    expanded: {},
    ...e
  }),
  getDefaultOptions: (e) => ({
    onExpandedChange: Bi("expanded", e),
    paginateExpandedRows: !0
  }),
  createTable: (e) => {
    let t = !1, n = !1;
    e._autoResetExpanded = () => {
      var r, i;
      if (!t) {
        e._queue(() => {
          t = !0;
        });
        return;
      }
      if ((r = (i = e.options.autoResetAll) != null ? i : e.options.autoResetExpanded) != null ? r : !e.options.manualExpanding) {
        if (n)
          return;
        n = !0, e._queue(() => {
          e.resetExpanded(), n = !1;
        });
      }
    }, e.setExpanded = (r) => e.options.onExpandedChange == null ? void 0 : e.options.onExpandedChange(r), e.toggleAllRowsExpanded = (r) => {
      r ?? !e.getIsAllRowsExpanded() ? e.setExpanded(!0) : e.setExpanded({});
    }, e.resetExpanded = (r) => {
      var i, o;
      e.setExpanded(r ? {} : (i = (o = e.initialState) == null ? void 0 : o.expanded) != null ? i : {});
    }, e.getCanSomeRowsExpand = () => e.getPrePaginationRowModel().flatRows.some((r) => r.getCanExpand()), e.getToggleAllRowsExpandedHandler = () => (r) => {
      r.persist == null || r.persist(), e.toggleAllRowsExpanded();
    }, e.getIsSomeRowsExpanded = () => {
      const r = e.getState().expanded;
      return r === !0 || Object.values(r).some(Boolean);
    }, e.getIsAllRowsExpanded = () => {
      const r = e.getState().expanded;
      return typeof r == "boolean" ? r === !0 : !(!Object.keys(r).length || e.getRowModel().flatRows.some((i) => !i.getIsExpanded()));
    }, e.getExpandedDepth = () => {
      let r = 0;
      return (e.getState().expanded === !0 ? Object.keys(e.getRowModel().rowsById) : Object.keys(e.getState().expanded)).forEach((o) => {
        const s = o.split(".");
        r = Math.max(r, s.length);
      }), r;
    }, e.getPreExpandedRowModel = () => e.getSortedRowModel(), e.getExpandedRowModel = () => (!e._getExpandedRowModel && e.options.getExpandedRowModel && (e._getExpandedRowModel = e.options.getExpandedRowModel(e)), e.options.manualExpanding || !e._getExpandedRowModel ? e.getPreExpandedRowModel() : e._getExpandedRowModel());
  },
  createRow: (e, t) => {
    e.toggleExpanded = (n) => {
      t.setExpanded((r) => {
        var i;
        const o = r === !0 ? !0 : !!(r != null && r[e.id]);
        let s = {};
        if (r === !0 ? Object.keys(t.getRowModel().rowsById).forEach((a) => {
          s[a] = !0;
        }) : s = r, n = (i = n) != null ? i : !o, !o && n)
          return {
            ...s,
            [e.id]: !0
          };
        if (o && !n) {
          const {
            [e.id]: a,
            ...l
          } = s;
          return l;
        }
        return r;
      });
    }, e.getIsExpanded = () => {
      var n;
      const r = t.getState().expanded;
      return !!((n = t.options.getIsRowExpanded == null ? void 0 : t.options.getIsRowExpanded(e)) != null ? n : r === !0 || r != null && r[e.id]);
    }, e.getCanExpand = () => {
      var n, r, i;
      return (n = t.options.getRowCanExpand == null ? void 0 : t.options.getRowCanExpand(e)) != null ? n : ((r = t.options.enableExpanding) != null ? r : !0) && !!((i = e.subRows) != null && i.length);
    }, e.getIsAllParentsExpanded = () => {
      let n = !0, r = e;
      for (; n && r.parentId; )
        r = t.getRow(r.parentId, !0), n = r.getIsExpanded();
      return n;
    }, e.getToggleExpandedHandler = () => {
      const n = e.getCanExpand();
      return () => {
        n && e.toggleExpanded();
      };
    };
  }
}, Py = 0, Ny = 10, e0 = () => ({
  pageIndex: Py,
  pageSize: Ny
}), Bne = {
  getInitialState: (e) => ({
    ...e,
    pagination: {
      ...e0(),
      ...e == null ? void 0 : e.pagination
    }
  }),
  getDefaultOptions: (e) => ({
    onPaginationChange: Bi("pagination", e)
  }),
  createTable: (e) => {
    let t = !1, n = !1;
    e._autoResetPageIndex = () => {
      var r, i;
      if (!t) {
        e._queue(() => {
          t = !0;
        });
        return;
      }
      if ((r = (i = e.options.autoResetAll) != null ? i : e.options.autoResetPageIndex) != null ? r : !e.options.manualPagination) {
        if (n)
          return;
        n = !0, e._queue(() => {
          e.resetPageIndex(), n = !1;
        });
      }
    }, e.setPagination = (r) => {
      const i = (o) => ea(r, o);
      return e.options.onPaginationChange == null ? void 0 : e.options.onPaginationChange(i);
    }, e.resetPagination = (r) => {
      var i;
      e.setPagination(r ? e0() : (i = e.initialState.pagination) != null ? i : e0());
    }, e.setPageIndex = (r) => {
      e.setPagination((i) => {
        let o = ea(r, i.pageIndex);
        const s = typeof e.options.pageCount > "u" || e.options.pageCount === -1 ? Number.MAX_SAFE_INTEGER : e.options.pageCount - 1;
        return o = Math.max(0, Math.min(o, s)), {
          ...i,
          pageIndex: o
        };
      });
    }, e.resetPageIndex = (r) => {
      var i, o;
      e.setPageIndex(r ? Py : (i = (o = e.initialState) == null || (o = o.pagination) == null ? void 0 : o.pageIndex) != null ? i : Py);
    }, e.resetPageSize = (r) => {
      var i, o;
      e.setPageSize(r ? Ny : (i = (o = e.initialState) == null || (o = o.pagination) == null ? void 0 : o.pageSize) != null ? i : Ny);
    }, e.setPageSize = (r) => {
      e.setPagination((i) => {
        const o = Math.max(1, ea(r, i.pageSize)), s = i.pageSize * i.pageIndex, a = Math.floor(s / o);
        return {
          ...i,
          pageIndex: a,
          pageSize: o
        };
      });
    }, e.setPageCount = (r) => e.setPagination((i) => {
      var o;
      let s = ea(r, (o = e.options.pageCount) != null ? o : -1);
      return typeof s == "number" && (s = Math.max(-1, s)), {
        ...i,
        pageCount: s
      };
    }), e.getPageOptions = Mt(() => [e.getPageCount()], (r) => {
      let i = [];
      return r && r > 0 && (i = [...new Array(r)].fill(null).map((o, s) => s)), i;
    }, It(e.options, "debugTable", "getPageOptions")), e.getCanPreviousPage = () => e.getState().pagination.pageIndex > 0, e.getCanNextPage = () => {
      const {
        pageIndex: r
      } = e.getState().pagination, i = e.getPageCount();
      return i === -1 ? !0 : i === 0 ? !1 : r < i - 1;
    }, e.previousPage = () => e.setPageIndex((r) => r - 1), e.nextPage = () => e.setPageIndex((r) => r + 1), e.firstPage = () => e.setPageIndex(0), e.lastPage = () => e.setPageIndex(e.getPageCount() - 1), e.getPrePaginationRowModel = () => e.getExpandedRowModel(), e.getPaginationRowModel = () => (!e._getPaginationRowModel && e.options.getPaginationRowModel && (e._getPaginationRowModel = e.options.getPaginationRowModel(e)), e.options.manualPagination || !e._getPaginationRowModel ? e.getPrePaginationRowModel() : e._getPaginationRowModel()), e.getPageCount = () => {
      var r;
      return (r = e.options.pageCount) != null ? r : Math.ceil(e.getRowCount() / e.getState().pagination.pageSize);
    }, e.getRowCount = () => {
      var r;
      return (r = e.options.rowCount) != null ? r : e.getPrePaginationRowModel().rows.length;
    };
  }
}, t0 = () => ({
  top: [],
  bottom: []
}), jne = {
  getInitialState: (e) => ({
    rowPinning: t0(),
    ...e
  }),
  getDefaultOptions: (e) => ({
    onRowPinningChange: Bi("rowPinning", e)
  }),
  createRow: (e, t) => {
    e.pin = (n, r, i) => {
      const o = r ? e.getLeafRows().map((l) => {
        let {
          id: u
        } = l;
        return u;
      }) : [], s = i ? e.getParentRows().map((l) => {
        let {
          id: u
        } = l;
        return u;
      }) : [], a = /* @__PURE__ */ new Set([...s, e.id, ...o]);
      t.setRowPinning((l) => {
        var u, c;
        if (n === "bottom") {
          var d, f;
          return {
            top: ((d = l == null ? void 0 : l.top) != null ? d : []).filter((g) => !(a != null && a.has(g))),
            bottom: [...((f = l == null ? void 0 : l.bottom) != null ? f : []).filter((g) => !(a != null && a.has(g))), ...Array.from(a)]
          };
        }
        if (n === "top") {
          var h, p;
          return {
            top: [...((h = l == null ? void 0 : l.top) != null ? h : []).filter((g) => !(a != null && a.has(g))), ...Array.from(a)],
            bottom: ((p = l == null ? void 0 : l.bottom) != null ? p : []).filter((g) => !(a != null && a.has(g)))
          };
        }
        return {
          top: ((u = l == null ? void 0 : l.top) != null ? u : []).filter((g) => !(a != null && a.has(g))),
          bottom: ((c = l == null ? void 0 : l.bottom) != null ? c : []).filter((g) => !(a != null && a.has(g)))
        };
      });
    }, e.getCanPin = () => {
      var n;
      const {
        enableRowPinning: r,
        enablePinning: i
      } = t.options;
      return typeof r == "function" ? r(e) : (n = r ?? i) != null ? n : !0;
    }, e.getIsPinned = () => {
      const n = [e.id], {
        top: r,
        bottom: i
      } = t.getState().rowPinning, o = n.some((a) => r == null ? void 0 : r.includes(a)), s = n.some((a) => i == null ? void 0 : i.includes(a));
      return o ? "top" : s ? "bottom" : !1;
    }, e.getPinnedIndex = () => {
      var n, r;
      const i = e.getIsPinned();
      if (!i)
        return -1;
      const o = (n = t._getPinnedRows(i)) == null ? void 0 : n.map((s) => {
        let {
          id: a
        } = s;
        return a;
      });
      return (r = o == null ? void 0 : o.indexOf(e.id)) != null ? r : -1;
    };
  },
  createTable: (e) => {
    e.setRowPinning = (t) => e.options.onRowPinningChange == null ? void 0 : e.options.onRowPinningChange(t), e.resetRowPinning = (t) => {
      var n, r;
      return e.setRowPinning(t ? t0() : (n = (r = e.initialState) == null ? void 0 : r.rowPinning) != null ? n : t0());
    }, e.getIsSomeRowsPinned = (t) => {
      var n;
      const r = e.getState().rowPinning;
      if (!t) {
        var i, o;
        return !!((i = r.top) != null && i.length || (o = r.bottom) != null && o.length);
      }
      return !!((n = r[t]) != null && n.length);
    }, e._getPinnedRows = Mt((t) => [e.getRowModel().rows, e.getState().rowPinning[t], t], (t, n, r) => {
      var i;
      return ((i = e.options.keepPinnedRows) == null || i ? (
        //get all rows that are pinned even if they would not be otherwise visible
        //account for expanded parent rows, but not pagination or filtering
        (n ?? []).map((s) => {
          const a = e.getRow(s, !0);
          return a.getIsAllParentsExpanded() ? a : null;
        })
      ) : (
        //else get only visible rows that are pinned
        (n ?? []).map((s) => t.find((a) => a.id === s))
      )).filter(Boolean).map((s) => ({
        ...s,
        position: r
      }));
    }, It(e.options, "debugRows", "_getPinnedRows")), e.getTopRows = () => e._getPinnedRows("top"), e.getBottomRows = () => e._getPinnedRows("bottom"), e.getCenterRows = Mt(() => [e.getRowModel().rows, e.getState().rowPinning.top, e.getState().rowPinning.bottom], (t, n, r) => {
      const i = /* @__PURE__ */ new Set([...n ?? [], ...r ?? []]);
      return t.filter((o) => !i.has(o.id));
    }, It(e.options, "debugRows", "getCenterRows"));
  }
}, zne = {
  getInitialState: (e) => ({
    rowSelection: {},
    ...e
  }),
  getDefaultOptions: (e) => ({
    onRowSelectionChange: Bi("rowSelection", e),
    enableRowSelection: !0,
    enableMultiRowSelection: !0,
    enableSubRowSelection: !0
    // enableGroupingRowSelection: false,
    // isAdditiveSelectEvent: (e: unknown) => !!e.metaKey,
    // isInclusiveSelectEvent: (e: unknown) => !!e.shiftKey,
  }),
  createTable: (e) => {
    e.setRowSelection = (t) => e.options.onRowSelectionChange == null ? void 0 : e.options.onRowSelectionChange(t), e.resetRowSelection = (t) => {
      var n;
      return e.setRowSelection(t ? {} : (n = e.initialState.rowSelection) != null ? n : {});
    }, e.toggleAllRowsSelected = (t) => {
      e.setRowSelection((n) => {
        t = typeof t < "u" ? t : !e.getIsAllRowsSelected();
        const r = {
          ...n
        }, i = e.getPreGroupedRowModel().flatRows;
        return t ? i.forEach((o) => {
          o.getCanSelect() && (r[o.id] = !0);
        }) : i.forEach((o) => {
          delete r[o.id];
        }), r;
      });
    }, e.toggleAllPageRowsSelected = (t) => e.setRowSelection((n) => {
      const r = typeof t < "u" ? t : !e.getIsAllPageRowsSelected(), i = {
        ...n
      };
      return e.getRowModel().rows.forEach((o) => {
        Ly(i, o.id, r, !0, e);
      }), i;
    }), e.getPreSelectedRowModel = () => e.getCoreRowModel(), e.getSelectedRowModel = Mt(() => [e.getState().rowSelection, e.getCoreRowModel()], (t, n) => Object.keys(t).length ? n0(e, n) : {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, It(e.options, "debugTable", "getSelectedRowModel")), e.getFilteredSelectedRowModel = Mt(() => [e.getState().rowSelection, e.getFilteredRowModel()], (t, n) => Object.keys(t).length ? n0(e, n) : {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, It(e.options, "debugTable", "getFilteredSelectedRowModel")), e.getGroupedSelectedRowModel = Mt(() => [e.getState().rowSelection, e.getSortedRowModel()], (t, n) => Object.keys(t).length ? n0(e, n) : {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, It(e.options, "debugTable", "getGroupedSelectedRowModel")), e.getIsAllRowsSelected = () => {
      const t = e.getFilteredRowModel().flatRows, {
        rowSelection: n
      } = e.getState();
      let r = !!(t.length && Object.keys(n).length);
      return r && t.some((i) => i.getCanSelect() && !n[i.id]) && (r = !1), r;
    }, e.getIsAllPageRowsSelected = () => {
      const t = e.getPaginationRowModel().flatRows.filter((i) => i.getCanSelect()), {
        rowSelection: n
      } = e.getState();
      let r = !!t.length;
      return r && t.some((i) => !n[i.id]) && (r = !1), r;
    }, e.getIsSomeRowsSelected = () => {
      var t;
      const n = Object.keys((t = e.getState().rowSelection) != null ? t : {}).length;
      return n > 0 && n < e.getFilteredRowModel().flatRows.length;
    }, e.getIsSomePageRowsSelected = () => {
      const t = e.getPaginationRowModel().flatRows;
      return e.getIsAllPageRowsSelected() ? !1 : t.filter((n) => n.getCanSelect()).some((n) => n.getIsSelected() || n.getIsSomeSelected());
    }, e.getToggleAllRowsSelectedHandler = () => (t) => {
      e.toggleAllRowsSelected(t.target.checked);
    }, e.getToggleAllPageRowsSelectedHandler = () => (t) => {
      e.toggleAllPageRowsSelected(t.target.checked);
    };
  },
  createRow: (e, t) => {
    e.toggleSelected = (n, r) => {
      const i = e.getIsSelected();
      t.setRowSelection((o) => {
        var s;
        if (n = typeof n < "u" ? n : !i, e.getCanSelect() && i === n)
          return o;
        const a = {
          ...o
        };
        return Ly(a, e.id, n, (s = r == null ? void 0 : r.selectChildren) != null ? s : !0, t), a;
      });
    }, e.getIsSelected = () => {
      const {
        rowSelection: n
      } = t.getState();
      return CC(e, n);
    }, e.getIsSomeSelected = () => {
      const {
        rowSelection: n
      } = t.getState();
      return Fy(e, n) === "some";
    }, e.getIsAllSubRowsSelected = () => {
      const {
        rowSelection: n
      } = t.getState();
      return Fy(e, n) === "all";
    }, e.getCanSelect = () => {
      var n;
      return typeof t.options.enableRowSelection == "function" ? t.options.enableRowSelection(e) : (n = t.options.enableRowSelection) != null ? n : !0;
    }, e.getCanSelectSubRows = () => {
      var n;
      return typeof t.options.enableSubRowSelection == "function" ? t.options.enableSubRowSelection(e) : (n = t.options.enableSubRowSelection) != null ? n : !0;
    }, e.getCanMultiSelect = () => {
      var n;
      return typeof t.options.enableMultiRowSelection == "function" ? t.options.enableMultiRowSelection(e) : (n = t.options.enableMultiRowSelection) != null ? n : !0;
    }, e.getToggleSelectedHandler = () => {
      const n = e.getCanSelect();
      return (r) => {
        var i;
        n && e.toggleSelected((i = r.target) == null ? void 0 : i.checked);
      };
    };
  }
}, Ly = (e, t, n, r, i) => {
  var o;
  const s = i.getRow(t, !0);
  n ? (s.getCanMultiSelect() || Object.keys(e).forEach((a) => delete e[a]), s.getCanSelect() && (e[t] = !0)) : delete e[t], r && (o = s.subRows) != null && o.length && s.getCanSelectSubRows() && s.subRows.forEach((a) => Ly(e, a.id, n, r, i));
};
function n0(e, t) {
  const n = e.getState().rowSelection, r = [], i = {}, o = function(s, a) {
    return s.map((l) => {
      var u;
      const c = CC(l, n);
      if (c && (r.push(l), i[l.id] = l), (u = l.subRows) != null && u.length && (l = {
        ...l,
        subRows: o(l.subRows)
      }), c)
        return l;
    }).filter(Boolean);
  };
  return {
    rows: o(t.rows),
    flatRows: r,
    rowsById: i
  };
}
function CC(e, t) {
  var n;
  return (n = t[e.id]) != null ? n : !1;
}
function Fy(e, t, n) {
  var r;
  if (!((r = e.subRows) != null && r.length))
    return !1;
  let i = !0, o = !1;
  return e.subRows.forEach((s) => {
    if (!(o && !i) && (s.getCanSelect() && (CC(s, t) ? o = !0 : i = !1), s.subRows && s.subRows.length)) {
      const a = Fy(s, t);
      a === "all" ? o = !0 : (a === "some" && (o = !0), i = !1);
    }
  }), i ? "all" : o ? "some" : !1;
}
const By = /([0-9]+)/gm, Hne = (e, t, n) => zP(ma(e.getValue(n)).toLowerCase(), ma(t.getValue(n)).toLowerCase()), Vne = (e, t, n) => zP(ma(e.getValue(n)), ma(t.getValue(n))), Wne = (e, t, n) => SC(ma(e.getValue(n)).toLowerCase(), ma(t.getValue(n)).toLowerCase()), Une = (e, t, n) => SC(ma(e.getValue(n)), ma(t.getValue(n))), Gne = (e, t, n) => {
  const r = e.getValue(n), i = t.getValue(n);
  return r > i ? 1 : r < i ? -1 : 0;
}, Kne = (e, t, n) => SC(e.getValue(n), t.getValue(n));
function SC(e, t) {
  return e === t ? 0 : e > t ? 1 : -1;
}
function ma(e) {
  return typeof e == "number" ? isNaN(e) || e === 1 / 0 || e === -1 / 0 ? "" : String(e) : typeof e == "string" ? e : "";
}
function zP(e, t) {
  const n = e.split(By).filter(Boolean), r = t.split(By).filter(Boolean);
  for (; n.length && r.length; ) {
    const i = n.shift(), o = r.shift(), s = parseInt(i, 10), a = parseInt(o, 10), l = [s, a].sort();
    if (isNaN(l[0])) {
      if (i > o)
        return 1;
      if (o > i)
        return -1;
      continue;
    }
    if (isNaN(l[1]))
      return isNaN(s) ? -1 : 1;
    if (s > a)
      return 1;
    if (a > s)
      return -1;
  }
  return n.length - r.length;
}
const Du = {
  alphanumeric: Hne,
  alphanumericCaseSensitive: Vne,
  text: Wne,
  textCaseSensitive: Une,
  datetime: Gne,
  basic: Kne
}, Xne = {
  getInitialState: (e) => ({
    sorting: [],
    ...e
  }),
  getDefaultColumnDef: () => ({
    sortingFn: "auto",
    sortUndefined: 1
  }),
  getDefaultOptions: (e) => ({
    onSortingChange: Bi("sorting", e),
    isMultiSortEvent: (t) => t.shiftKey
  }),
  createColumn: (e, t) => {
    e.getAutoSortingFn = () => {
      const n = t.getFilteredRowModel().flatRows.slice(10);
      let r = !1;
      for (const i of n) {
        const o = i == null ? void 0 : i.getValue(e.id);
        if (Object.prototype.toString.call(o) === "[object Date]")
          return Du.datetime;
        if (typeof o == "string" && (r = !0, o.split(By).length > 1))
          return Du.alphanumeric;
      }
      return r ? Du.text : Du.basic;
    }, e.getAutoSortDir = () => {
      const n = t.getFilteredRowModel().flatRows[0];
      return typeof (n == null ? void 0 : n.getValue(e.id)) == "string" ? "asc" : "desc";
    }, e.getSortingFn = () => {
      var n, r;
      if (!e)
        throw new Error();
      return xm(e.columnDef.sortingFn) ? e.columnDef.sortingFn : e.columnDef.sortingFn === "auto" ? e.getAutoSortingFn() : (n = (r = t.options.sortingFns) == null ? void 0 : r[e.columnDef.sortingFn]) != null ? n : Du[e.columnDef.sortingFn];
    }, e.toggleSorting = (n, r) => {
      const i = e.getNextSortingOrder(), o = typeof n < "u" && n !== null;
      t.setSorting((s) => {
        const a = s == null ? void 0 : s.find((h) => h.id === e.id), l = s == null ? void 0 : s.findIndex((h) => h.id === e.id);
        let u = [], c, d = o ? n : i === "desc";
        if (s != null && s.length && e.getCanMultiSort() && r ? a ? c = "toggle" : c = "add" : s != null && s.length && l !== s.length - 1 ? c = "replace" : a ? c = "toggle" : c = "replace", c === "toggle" && (o || i || (c = "remove")), c === "add") {
          var f;
          u = [...s, {
            id: e.id,
            desc: d
          }], u.splice(0, u.length - ((f = t.options.maxMultiSortColCount) != null ? f : Number.MAX_SAFE_INTEGER));
        } else
          c === "toggle" ? u = s.map((h) => h.id === e.id ? {
            ...h,
            desc: d
          } : h) : c === "remove" ? u = s.filter((h) => h.id !== e.id) : u = [{
            id: e.id,
            desc: d
          }];
        return u;
      });
    }, e.getFirstSortDir = () => {
      var n, r;
      return ((n = (r = e.columnDef.sortDescFirst) != null ? r : t.options.sortDescFirst) != null ? n : e.getAutoSortDir() === "desc") ? "desc" : "asc";
    }, e.getNextSortingOrder = (n) => {
      var r, i;
      const o = e.getFirstSortDir(), s = e.getIsSorted();
      return s ? s !== o && ((r = t.options.enableSortingRemoval) == null || r) && // If enableSortRemove, enable in general
      (!(n && (i = t.options.enableMultiRemove) != null) || i) ? !1 : s === "desc" ? "asc" : "desc" : o;
    }, e.getCanSort = () => {
      var n, r;
      return ((n = e.columnDef.enableSorting) != null ? n : !0) && ((r = t.options.enableSorting) != null ? r : !0) && !!e.accessorFn;
    }, e.getCanMultiSort = () => {
      var n, r;
      return (n = (r = e.columnDef.enableMultiSort) != null ? r : t.options.enableMultiSort) != null ? n : !!e.accessorFn;
    }, e.getIsSorted = () => {
      var n;
      const r = (n = t.getState().sorting) == null ? void 0 : n.find((i) => i.id === e.id);
      return r ? r.desc ? "desc" : "asc" : !1;
    }, e.getSortIndex = () => {
      var n, r;
      return (n = (r = t.getState().sorting) == null ? void 0 : r.findIndex((i) => i.id === e.id)) != null ? n : -1;
    }, e.clearSorting = () => {
      t.setSorting((n) => n != null && n.length ? n.filter((r) => r.id !== e.id) : []);
    }, e.getToggleSortingHandler = () => {
      const n = e.getCanSort();
      return (r) => {
        n && (r.persist == null || r.persist(), e.toggleSorting == null || e.toggleSorting(void 0, e.getCanMultiSort() ? t.options.isMultiSortEvent == null ? void 0 : t.options.isMultiSortEvent(r) : !1));
      };
    };
  },
  createTable: (e) => {
    e.setSorting = (t) => e.options.onSortingChange == null ? void 0 : e.options.onSortingChange(t), e.resetSorting = (t) => {
      var n, r;
      e.setSorting(t ? [] : (n = (r = e.initialState) == null ? void 0 : r.sorting) != null ? n : []);
    }, e.getPreSortedRowModel = () => e.getGroupedRowModel(), e.getSortedRowModel = () => (!e._getSortedRowModel && e.options.getSortedRowModel && (e._getSortedRowModel = e.options.getSortedRowModel(e)), e.options.manualSorting || !e._getSortedRowModel ? e.getPreSortedRowModel() : e._getSortedRowModel());
  }
}, Yne = [
  mne,
  Pne,
  Rne,
  Mne,
  bne,
  yne,
  Nne,
  //depends on ColumnFaceting
  Lne,
  //depends on ColumnFiltering
  Xne,
  _ne,
  //depends on RowSorting
  Fne,
  Bne,
  jne,
  zne,
  Ine
];
function qne(e) {
  var t, n;
  process.env.NODE_ENV !== "production" && (e.debugAll || e.debugTable) && console.info("Creating Table Instance...");
  const r = [...Yne, ...(t = e._features) != null ? t : []];
  let i = {
    _features: r
  };
  const o = i._features.reduce((f, h) => Object.assign(f, h.getDefaultOptions == null ? void 0 : h.getDefaultOptions(i)), {}), s = (f) => i.options.mergeOptions ? i.options.mergeOptions(o, f) : {
    ...o,
    ...f
  };
  let l = {
    ...{},
    ...(n = e.initialState) != null ? n : {}
  };
  i._features.forEach((f) => {
    var h;
    l = (h = f.getInitialState == null ? void 0 : f.getInitialState(l)) != null ? h : l;
  });
  const u = [];
  let c = !1;
  const d = {
    _features: r,
    options: {
      ...o,
      ...e
    },
    initialState: l,
    _queue: (f) => {
      u.push(f), c || (c = !0, Promise.resolve().then(() => {
        for (; u.length; )
          u.shift()();
        c = !1;
      }).catch((h) => setTimeout(() => {
        throw h;
      })));
    },
    reset: () => {
      i.setState(i.initialState);
    },
    setOptions: (f) => {
      const h = ea(f, i.options);
      i.options = s(h);
    },
    getState: () => i.options.state,
    setState: (f) => {
      i.options.onStateChange == null || i.options.onStateChange(f);
    },
    _getRowId: (f, h, p) => {
      var g;
      return (g = i.options.getRowId == null ? void 0 : i.options.getRowId(f, h, p)) != null ? g : `${p ? [p.id, h].join(".") : h}`;
    },
    getCoreRowModel: () => (i._getCoreRowModel || (i._getCoreRowModel = i.options.getCoreRowModel(i)), i._getCoreRowModel()),
    // The final calls start at the bottom of the model,
    // expanded rows, which then work their way up
    getRowModel: () => i.getPaginationRowModel(),
    //in next version, we should just pass in the row model as the optional 2nd arg
    getRow: (f, h) => {
      let p = (h ? i.getPrePaginationRowModel() : i.getRowModel()).rowsById[f];
      if (!p && (p = i.getCoreRowModel().rowsById[f], !p))
        throw process.env.NODE_ENV !== "production" ? new Error(`getRow could not find row with ID: ${f}`) : new Error();
      return p;
    },
    _getDefaultColumnDef: Mt(() => [i.options.defaultColumn], (f) => {
      var h;
      return f = (h = f) != null ? h : {}, {
        header: (p) => {
          const g = p.header.column.columnDef;
          return g.accessorKey ? g.accessorKey : g.accessorFn ? g.id : null;
        },
        // footer: props => props.header.column.id,
        cell: (p) => {
          var g, m;
          return (g = (m = p.renderValue()) == null || m.toString == null ? void 0 : m.toString()) != null ? g : null;
        },
        ...i._features.reduce((p, g) => Object.assign(p, g.getDefaultColumnDef == null ? void 0 : g.getDefaultColumnDef()), {}),
        ...f
      };
    }, It(e, "debugColumns", "_getDefaultColumnDef")),
    _getColumnDefs: () => i.options.columns,
    getAllColumns: Mt(() => [i._getColumnDefs()], (f) => {
      const h = function(p, g, m) {
        return m === void 0 && (m = 0), p.map((v) => {
          const b = gne(i, v, m, g), x = v;
          return b.columns = x.columns ? h(x.columns, b, m + 1) : [], b;
        });
      };
      return h(f);
    }, It(e, "debugColumns", "getAllColumns")),
    getAllFlatColumns: Mt(() => [i.getAllColumns()], (f) => f.flatMap((h) => h.getFlatColumns()), It(e, "debugColumns", "getAllFlatColumns")),
    _getAllFlatColumnsById: Mt(() => [i.getAllFlatColumns()], (f) => f.reduce((h, p) => (h[p.id] = p, h), {}), It(e, "debugColumns", "getAllFlatColumnsById")),
    getAllLeafColumns: Mt(() => [i.getAllColumns(), i._getOrderColumnsFn()], (f, h) => {
      let p = f.flatMap((g) => g.getLeafColumns());
      return h(p);
    }, It(e, "debugColumns", "getAllLeafColumns")),
    getColumn: (f) => {
      const h = i._getAllFlatColumnsById()[f];
      return process.env.NODE_ENV !== "production" && !h && console.error(`[Table] Column with id '${f}' does not exist.`), h;
    }
  };
  Object.assign(i, d);
  for (let f = 0; f < i._features.length; f++) {
    const h = i._features[f];
    h == null || h.createTable == null || h.createTable(i);
  }
  return i;
}
function Qne() {
  return (e) => Mt(() => [e.options.data], (t) => {
    const n = {
      rows: [],
      flatRows: [],
      rowsById: {}
    }, r = function(i, o, s) {
      o === void 0 && (o = 0);
      const a = [];
      for (let u = 0; u < i.length; u++) {
        const c = vne(e, e._getRowId(i[u], u, s), i[u], u, o, void 0, s == null ? void 0 : s.id);
        if (n.flatRows.push(c), n.rowsById[c.id] = c, a.push(c), e.options.getSubRows) {
          var l;
          c.originalSubRows = e.options.getSubRows(i[u], u), (l = c.originalSubRows) != null && l.length && (c.subRows = r(c.originalSubRows, o + 1, c));
        }
      }
      return a;
    };
    return n.rows = r(t), n;
  }, It(e.options, "debugTable", "getRowModel", () => e._autoResetPageIndex()));
}
/**
   * react-table
   *
   * Copyright (c) TanStack
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   */
function HP(e, t) {
  return e ? Zne(e) ? /* @__PURE__ */ O.createElement(e, t) : e : null;
}
function Zne(e) {
  return Jne(e) || typeof e == "function" || ere(e);
}
function Jne(e) {
  return typeof e == "function" && (() => {
    const t = Object.getPrototypeOf(e);
    return t.prototype && t.prototype.isReactComponent;
  })();
}
function ere(e) {
  return typeof e == "object" && typeof e.$$typeof == "symbol" && ["react.memo", "react.forward_ref"].includes(e.$$typeof.description);
}
function tre(e) {
  const t = {
    state: {},
    // Dummy state
    onStateChange: () => {
    },
    // noop
    renderFallbackValue: null,
    ...e
  }, [n] = O.useState(() => ({
    current: qne(t)
  })), [r, i] = O.useState(() => n.current.initialState);
  return n.current.setOptions((o) => ({
    ...o,
    ...e,
    state: {
      ...r,
      ...e.state
    },
    // Similarly, we'll maintain both our internal state and any user-provided
    // state.
    onStateChange: (s) => {
      i(s), e.onStateChange == null || e.onStateChange(s);
    }
  })), n.current;
}
function _u(e, t, n) {
  let r = n.initialDeps ?? [], i;
  return () => {
    var o, s, a, l;
    let u;
    n.key && ((o = n.debug) != null && o.call(n)) && (u = Date.now());
    const c = e();
    if (!(c.length !== r.length || c.some((h, p) => r[p] !== h)))
      return i;
    r = c;
    let f;
    if (n.key && ((s = n.debug) != null && s.call(n)) && (f = Date.now()), i = t(...c), n.key && ((a = n.debug) != null && a.call(n))) {
      const h = Math.round((Date.now() - u) * 100) / 100, p = Math.round((Date.now() - f) * 100) / 100, g = p / 16, m = (v, b) => {
        for (v = String(v); v.length < b; )
          v = " " + v;
        return v;
      };
      console.info(
        `%c ${m(p, 5)} /${m(h, 5)} ms`,
        `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(
          0,
          Math.min(120 - 120 * g, 120)
        )}deg 100% 31%);`,
        n == null ? void 0 : n.key
      );
    }
    return (l = n == null ? void 0 : n.onChange) == null || l.call(n, i), i;
  };
}
function r0(e, t) {
  if (e === void 0)
    throw new Error("Unexpected undefined");
  return e;
}
const nre = (e, t) => Math.abs(e - t) < 1, rre = (e, t) => {
  let n;
  return function(...r) {
    clearTimeout(n), n = setTimeout(() => e.apply(this, r), t);
  };
}, ire = (e) => e, ore = (e) => {
  const t = Math.max(e.startIndex - e.overscan, 0), n = Math.min(e.endIndex + e.overscan, e.count - 1), r = [];
  for (let i = t; i <= n; i++)
    r.push(i);
  return r;
}, sre = (e, t) => {
  const n = e.scrollElement;
  if (!n)
    return;
  const r = (o) => {
    const { width: s, height: a } = o;
    t({ width: Math.round(s), height: Math.round(a) });
  };
  if (r(n.getBoundingClientRect()), typeof ResizeObserver > "u")
    return () => {
    };
  const i = new ResizeObserver((o) => {
    const s = o[0];
    if (s != null && s.borderBoxSize) {
      const a = s.borderBoxSize[0];
      if (a) {
        r({ width: a.inlineSize, height: a.blockSize });
        return;
      }
    }
    r(n.getBoundingClientRect());
  });
  return i.observe(n, { box: "border-box" }), () => {
    i.unobserve(n);
  };
}, n2 = {
  passive: !0
}, are = typeof window > "u" ? !0 : "onscrollend" in window, lre = (e, t) => {
  const n = e.scrollElement;
  if (!n)
    return;
  let r = 0;
  const i = are ? () => {
  } : rre(() => {
    t(r, !1);
  }, 150), o = (l) => () => {
    r = n[e.options.horizontal ? "scrollLeft" : "scrollTop"], i(), t(r, l);
  }, s = o(!0), a = o(!1);
  return a(), n.addEventListener("scroll", s, n2), n.addEventListener("scrollend", a, n2), () => {
    n.removeEventListener("scroll", s), n.removeEventListener("scrollend", a);
  };
}, cre = (e, t, n) => {
  if (t != null && t.borderBoxSize) {
    const r = t.borderBoxSize[0];
    if (r)
      return Math.round(
        r[n.options.horizontal ? "inlineSize" : "blockSize"]
      );
  }
  return Math.round(
    e.getBoundingClientRect()[n.options.horizontal ? "width" : "height"]
  );
}, ure = (e, {
  adjustments: t = 0,
  behavior: n
}, r) => {
  var i, o;
  const s = e + t;
  (o = (i = r.scrollElement) == null ? void 0 : i.scrollTo) == null || o.call(i, {
    [r.options.horizontal ? "left" : "top"]: s,
    behavior: n
  });
};
class dre {
  constructor(t) {
    this.unsubs = [], this.scrollElement = null, this.isScrolling = !1, this.scrollToIndexTimeoutId = null, this.measurementsCache = [], this.itemSizeCache = /* @__PURE__ */ new Map(), this.pendingMeasuredCacheIndexes = [], this.scrollDirection = null, this.scrollAdjustments = 0, this.measureElementCache = /* @__PURE__ */ new Map(), this.observer = /* @__PURE__ */ (() => {
      let n = null;
      const r = () => n || (typeof ResizeObserver < "u" ? n = new ResizeObserver((i) => {
        i.forEach((o) => {
          this._measureElement(o.target, o);
        });
      }) : null);
      return {
        disconnect: () => {
          var i;
          return (i = r()) == null ? void 0 : i.disconnect();
        },
        observe: (i) => {
          var o;
          return (o = r()) == null ? void 0 : o.observe(i, { box: "border-box" });
        },
        unobserve: (i) => {
          var o;
          return (o = r()) == null ? void 0 : o.unobserve(i);
        }
      };
    })(), this.range = null, this.setOptions = (n) => {
      Object.entries(n).forEach(([r, i]) => {
        typeof i > "u" && delete n[r];
      }), this.options = {
        debug: !1,
        initialOffset: 0,
        overscan: 1,
        paddingStart: 0,
        paddingEnd: 0,
        scrollPaddingStart: 0,
        scrollPaddingEnd: 0,
        horizontal: !1,
        getItemKey: ire,
        rangeExtractor: ore,
        onChange: () => {
        },
        measureElement: cre,
        initialRect: { width: 0, height: 0 },
        scrollMargin: 0,
        gap: 0,
        indexAttribute: "data-index",
        initialMeasurementsCache: [],
        lanes: 1,
        ...n
      };
    }, this.notify = (n, r) => {
      var i, o;
      const { startIndex: s, endIndex: a } = this.range ?? {
        startIndex: void 0,
        endIndex: void 0
      }, l = this.calculateRange();
      (n || s !== (l == null ? void 0 : l.startIndex) || a !== (l == null ? void 0 : l.endIndex)) && ((o = (i = this.options).onChange) == null || o.call(i, this, r));
    }, this.cleanup = () => {
      this.unsubs.filter(Boolean).forEach((n) => n()), this.unsubs = [], this.scrollElement = null;
    }, this._didMount = () => (this.measureElementCache.forEach(this.observer.observe), () => {
      this.observer.disconnect(), this.cleanup();
    }), this._willUpdate = () => {
      const n = this.options.getScrollElement();
      this.scrollElement !== n && (this.cleanup(), this.scrollElement = n, this._scrollToOffset(this.scrollOffset, {
        adjustments: void 0,
        behavior: void 0
      }), this.unsubs.push(
        this.options.observeElementRect(this, (r) => {
          this.scrollRect = r, this.notify(!1, !1);
        })
      ), this.unsubs.push(
        this.options.observeElementOffset(this, (r, i) => {
          this.scrollAdjustments = 0, this.scrollDirection = i ? this.scrollOffset < r ? "forward" : "backward" : null, this.scrollOffset = r;
          const o = this.isScrolling;
          this.isScrolling = i, this.notify(o !== i, i);
        })
      ));
    }, this.getSize = () => this.scrollRect[this.options.horizontal ? "width" : "height"], this.getMeasurementOptions = _u(
      () => [
        this.options.count,
        this.options.paddingStart,
        this.options.scrollMargin,
        this.options.getItemKey
      ],
      (n, r, i, o) => (this.pendingMeasuredCacheIndexes = [], {
        count: n,
        paddingStart: r,
        scrollMargin: i,
        getItemKey: o
      }),
      {
        key: !1
      }
    ), this.getFurthestMeasurement = (n, r) => {
      const i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
      for (let s = r - 1; s >= 0; s--) {
        const a = n[s];
        if (i.has(a.lane))
          continue;
        const l = o.get(
          a.lane
        );
        if (l == null || a.end > l.end ? o.set(a.lane, a) : a.end < l.end && i.set(a.lane, !0), i.size === this.options.lanes)
          break;
      }
      return o.size === this.options.lanes ? Array.from(o.values()).sort((s, a) => s.end === a.end ? s.index - a.index : s.end - a.end)[0] : void 0;
    }, this.getMeasurements = _u(
      () => [this.getMeasurementOptions(), this.itemSizeCache],
      ({ count: n, paddingStart: r, scrollMargin: i, getItemKey: o }, s) => {
        const a = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0;
        this.pendingMeasuredCacheIndexes = [];
        const l = this.measurementsCache.slice(0, a);
        for (let u = a; u < n; u++) {
          const c = o(u), d = this.options.lanes === 1 ? l[u - 1] : this.getFurthestMeasurement(l, u), f = d ? d.end + this.options.gap : r + i, h = s.get(c), p = typeof h == "number" ? h : this.options.estimateSize(u), g = f + p, m = d ? d.lane : u % this.options.lanes;
          l[u] = {
            index: u,
            start: f,
            size: p,
            end: g,
            key: c,
            lane: m
          };
        }
        return this.measurementsCache = l, l;
      },
      {
        key: process.env.NODE_ENV !== "production" && "getMeasurements",
        debug: () => this.options.debug
      }
    ), this.calculateRange = _u(
      () => [this.getMeasurements(), this.getSize(), this.scrollOffset],
      (n, r, i) => this.range = n.length > 0 && r > 0 ? fre({
        measurements: n,
        outerSize: r,
        scrollOffset: i
      }) : null,
      {
        key: process.env.NODE_ENV !== "production" && "calculateRange",
        debug: () => this.options.debug
      }
    ), this.getIndexes = _u(
      () => [
        this.options.rangeExtractor,
        this.calculateRange(),
        this.options.overscan,
        this.options.count
      ],
      (n, r, i, o) => r === null ? [] : n({
        startIndex: r.startIndex,
        endIndex: r.endIndex,
        overscan: i,
        count: o
      }),
      {
        key: process.env.NODE_ENV !== "production" && "getIndexes",
        debug: () => this.options.debug
      }
    ), this.indexFromElement = (n) => {
      const r = this.options.indexAttribute, i = n.getAttribute(r);
      return i ? parseInt(i, 10) : (console.warn(
        `Missing attribute name '${r}={index}' on measured element.`
      ), -1);
    }, this._measureElement = (n, r) => {
      const i = this.measurementsCache[this.indexFromElement(n)];
      if (!i || !n.isConnected) {
        this.measureElementCache.forEach((a, l) => {
          a === n && (this.observer.unobserve(n), this.measureElementCache.delete(l));
        });
        return;
      }
      const o = this.measureElementCache.get(i.key);
      o !== n && (o && this.observer.unobserve(o), this.observer.observe(n), this.measureElementCache.set(i.key, n));
      const s = this.options.measureElement(n, r, this);
      this.resizeItem(i, s);
    }, this.resizeItem = (n, r) => {
      const i = this.itemSizeCache.get(n.key) ?? n.size, o = r - i;
      o !== 0 && ((this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(n, o, this) : n.start < this.scrollOffset + this.scrollAdjustments) && (process.env.NODE_ENV !== "production" && this.options.debug && console.info("correction", o), this._scrollToOffset(this.scrollOffset, {
        adjustments: this.scrollAdjustments += o,
        behavior: void 0
      })), this.pendingMeasuredCacheIndexes.push(n.index), this.itemSizeCache = new Map(this.itemSizeCache.set(n.key, r)), this.notify(!0, !1));
    }, this.measureElement = (n) => {
      n && this._measureElement(n, void 0);
    }, this.getVirtualItems = _u(
      () => [this.getIndexes(), this.getMeasurements()],
      (n, r) => {
        const i = [];
        for (let o = 0, s = n.length; o < s; o++) {
          const a = n[o], l = r[a];
          i.push(l);
        }
        return i;
      },
      {
        key: process.env.NODE_ENV !== "production" && "getIndexes",
        debug: () => this.options.debug
      }
    ), this.getVirtualItemForOffset = (n) => {
      const r = this.getMeasurements();
      return r0(
        r[VP(
          0,
          r.length - 1,
          (i) => r0(r[i]).start,
          n
        )]
      );
    }, this.getOffsetForAlignment = (n, r) => {
      const i = this.getSize();
      r === "auto" && (n <= this.scrollOffset ? r = "start" : n >= this.scrollOffset + i ? r = "end" : r = "start"), r === "start" ? n = n : r === "end" ? n = n - i : r === "center" && (n = n - i / 2);
      const o = this.options.horizontal ? "scrollWidth" : "scrollHeight", a = (this.scrollElement ? "document" in this.scrollElement ? this.scrollElement.document.documentElement[o] : this.scrollElement[o] : 0) - this.getSize();
      return Math.max(Math.min(a, n), 0);
    }, this.getOffsetForIndex = (n, r = "auto") => {
      n = Math.max(0, Math.min(n, this.options.count - 1));
      const i = r0(this.getMeasurements()[n]);
      if (r === "auto")
        if (i.end >= this.scrollOffset + this.getSize() - this.options.scrollPaddingEnd)
          r = "end";
        else if (i.start <= this.scrollOffset + this.options.scrollPaddingStart)
          r = "start";
        else
          return [this.scrollOffset, r];
      const o = r === "end" ? i.end + this.options.scrollPaddingEnd : i.start - this.options.scrollPaddingStart;
      return [this.getOffsetForAlignment(o, r), r];
    }, this.isDynamicMode = () => this.measureElementCache.size > 0, this.cancelScrollToIndex = () => {
      this.scrollToIndexTimeoutId !== null && (clearTimeout(this.scrollToIndexTimeoutId), this.scrollToIndexTimeoutId = null);
    }, this.scrollToOffset = (n, { align: r = "start", behavior: i } = {}) => {
      this.cancelScrollToIndex(), i === "smooth" && this.isDynamicMode() && console.warn(
        "The `smooth` scroll behavior is not fully supported with dynamic size."
      ), this._scrollToOffset(this.getOffsetForAlignment(n, r), {
        adjustments: void 0,
        behavior: i
      });
    }, this.scrollToIndex = (n, { align: r = "auto", behavior: i } = {}) => {
      n = Math.max(0, Math.min(n, this.options.count - 1)), this.cancelScrollToIndex(), i === "smooth" && this.isDynamicMode() && console.warn(
        "The `smooth` scroll behavior is not fully supported with dynamic size."
      );
      const [o, s] = this.getOffsetForIndex(n, r);
      this._scrollToOffset(o, { adjustments: void 0, behavior: i }), i !== "smooth" && this.isDynamicMode() && (this.scrollToIndexTimeoutId = setTimeout(() => {
        if (this.scrollToIndexTimeoutId = null, this.measureElementCache.has(
          this.options.getItemKey(n)
        )) {
          const [l] = this.getOffsetForIndex(n, s);
          nre(l, this.scrollOffset) || this.scrollToIndex(n, { align: s, behavior: i });
        } else
          this.scrollToIndex(n, { align: s, behavior: i });
      }));
    }, this.scrollBy = (n, { behavior: r } = {}) => {
      this.cancelScrollToIndex(), r === "smooth" && this.isDynamicMode() && console.warn(
        "The `smooth` scroll behavior is not fully supported with dynamic size."
      ), this._scrollToOffset(this.scrollOffset + n, {
        adjustments: void 0,
        behavior: r
      });
    }, this.getTotalSize = () => {
      var n;
      const r = this.getMeasurements();
      let i;
      return r.length === 0 ? i = this.options.paddingStart : i = this.options.lanes === 1 ? ((n = r[r.length - 1]) == null ? void 0 : n.end) ?? 0 : Math.max(
        ...r.slice(-this.options.lanes).map((o) => o.end)
      ), i - this.options.scrollMargin + this.options.paddingEnd;
    }, this._scrollToOffset = (n, {
      adjustments: r,
      behavior: i
    }) => {
      this.options.scrollToFn(n, { behavior: i, adjustments: r }, this);
    }, this.measure = () => {
      var n, r;
      this.itemSizeCache = /* @__PURE__ */ new Map(), (r = (n = this.options).onChange) == null || r.call(n, this, !1);
    }, this.setOptions(t), this.scrollRect = this.options.initialRect, this.scrollOffset = typeof this.options.initialOffset == "function" ? this.options.initialOffset() : this.options.initialOffset, this.measurementsCache = this.options.initialMeasurementsCache, this.measurementsCache.forEach((n) => {
      this.itemSizeCache.set(n.key, n.size);
    }), this.notify(!1, !1);
  }
}
const VP = (e, t, n, r) => {
  for (; e <= t; ) {
    const i = (e + t) / 2 | 0, o = n(i);
    if (o < r)
      e = i + 1;
    else if (o > r)
      t = i - 1;
    else
      return i;
  }
  return e > 0 ? e - 1 : 0;
};
function fre({
  measurements: e,
  outerSize: t,
  scrollOffset: n
}) {
  const r = e.length - 1, o = VP(0, r, (a) => e[a].start, n);
  let s = o;
  for (; s < r && e[s].end < n + t; )
    s++;
  return { startIndex: o, endIndex: s };
}
const hre = typeof document < "u" ? O.useLayoutEffect : O.useEffect;
function pre(e) {
  const t = O.useReducer(() => ({}), {})[1], n = {
    ...e,
    onChange: (i, o) => {
      var s;
      o ? Cp(t) : t(), (s = e.onChange) == null || s.call(e, i, o);
    }
  }, [r] = O.useState(
    () => new dre(n)
  );
  return r.setOptions(n), O.useEffect(() => r._didMount(), []), hre(() => r._willUpdate()), r;
}
function gre(e) {
  return pre({
    observeElementRect: sre,
    observeElementOffset: lre,
    scrollToFn: ure,
    ...e
  });
}
const mre = navigator.platform.includes("Mac"), r2 = {
  Ctrl: "",
  Backspace: "",
  Alt: ""
}, Ga = {
  shortcut: (e) => mre ? Object.keys(r2).reduce((t, n) => t.replaceAll(n, r2[n]), e) : e
}, Ka = ({ left: e, right: t, gap: n = 16 }) => /* @__PURE__ */ V.jsxs(qr, { gap: n, horizontal: !0, horizontalAlign: "space-between", children: [
  /* @__PURE__ */ V.jsx(Bt.Text, { style: { color: "inherit" }, children: e }),
  /* @__PURE__ */ V.jsx(Bt.Text, { style: { color: "inherit" }, children: t })
] }), vre = (e) => {
  const { children: t } = e, n = Qo(), { cursor: r, disabled: i } = io(({ cursor: o, disabled: s }) => ({
    cursor: o,
    disabled: s
  }));
  return /* @__PURE__ */ V.jsx(
    da,
    {
      destroyPopupOnHide: !0,
      transitionName: "",
      disabled: i,
      overlayStyle: {
        minWidth: 270
      },
      menu: {
        items: [
          {
            key: "addRowAbove",
            label: /* @__PURE__ */ V.jsx(Ka, { left: "Add row above", right: Ga.shortcut("Ctrl + Up") }),
            onClick: () => {
              r && n.addRowAbove(r == null ? void 0 : r.y);
            }
          },
          {
            key: "addRowBelow",
            label: /* @__PURE__ */ V.jsx(Ka, { left: "Add row below", right: Ga.shortcut("Ctrl + Down") }),
            onClick: () => {
              r && n.addRowBelow(r == null ? void 0 : r.y);
            }
          },
          {
            type: "divider"
          },
          {
            key: "remove",
            label: /* @__PURE__ */ V.jsx(Ka, { left: "Remove row", right: Ga.shortcut("Ctrl + Backspace") }),
            onClick: () => {
              r && n.removeRow(r == null ? void 0 : r.y);
            }
          }
        ]
      },
      trigger: ["contextMenu"],
      children: t
    }
  );
}, bre = U.memo(vre), yre = Sn(({ context: e, ...t }) => {
  var f, h;
  const {
    row: { index: n },
    column: { id: r },
    table: i
  } = e, o = Qo(), { disabled: s, value: a } = io(({ decisionTable: p, disabled: g }) => {
    var m, v;
    return {
      value: (v = (m = p == null ? void 0 : p.rules) == null ? void 0 : m[n]) == null ? void 0 : v[r],
      disabled: g
    };
  }), l = io(
    sQ(r),
    (p, g) => (p == null ? void 0 : p.id) !== void 0 && (g == null ? void 0 : g.id) !== void 0 && (p == null ? void 0 : p.id) === (g == null ? void 0 : g.id)
  ), [u, c] = ht(a);
  Eg(() => {
    u !== a && c(a);
  }, [a]);
  const d = Kt(
    (p) => {
      c(p), o.commitData(p, { x: r, y: n });
    },
    [o, c]
  );
  return /* @__PURE__ */ V.jsx(
    "div",
    {
      className: "cell-wrapper",
      onFocus: () => o.setCursor({ x: r, y: n }),
      onContextMenu: () => o.setCursor({ x: r, y: n }),
      ...t,
      children: ((h = (f = i.options.meta) == null ? void 0 : f.getCell) == null ? void 0 : h.call(f, {
        disabled: s,
        column: l,
        value: u,
        onChange: d
      })) || /* @__PURE__ */ V.jsx(wre, { disabled: s, column: l, value: u, onChange: d })
    }
  );
}), wre = ({ column: e, value: t, onChange: n, disabled: r }) => {
  const i = mt(() => crypto.randomUUID(), []), o = he(null);
  return Pe(() => {
    if (!o.current)
      return;
    const s = o.current.closest("div.cell-wrapper"), a = (l) => {
      l.target === o.current || !o.current || ("selectionStart" in o.current ? (o.current.focus(), o.current.selectionStart = o.current.value.length) : o.current.querySelector(".cm-editor").focus());
    };
    return s.style.cursor = "text", s.addEventListener("click", a), () => {
      s.style.cursor = "", s.removeEventListener("click", a);
    };
  }, []), e ? /* @__PURE__ */ V.jsx(
    uu,
    {
      id: i,
      ref: o,
      className: "grl-dt__cell__input",
      maxRows: 3,
      value: t,
      disabled: r,
      onChange: n
    }
  ) : /* @__PURE__ */ V.jsx(
    Q1,
    {
      id: i,
      ref: o,
      className: "grl-dt__cell__input",
      maxRows: 3,
      value: t,
      disabled: r,
      spellCheck: !1,
      onChange: (s) => n(s.target.value)
    }
  );
}, Cre = ({ configurable: e, disabled: t }) => {
  const n = io((i) => {
    var o;
    return (o = i.decisionTable) == null ? void 0 : o.inputs;
  }), { setDialog: r } = Of();
  return /* @__PURE__ */ V.jsxs(qr, { horizontal: !0, horizontalAlign: "space-between", verticalAlign: "center", children: [
    /* @__PURE__ */ V.jsx(qr, { gap: 0, className: "text-wrapper", verticalAlign: "center", children: /* @__PURE__ */ V.jsx(Bt.Text, { className: "span-overflow grl-dt-text-primary", children: "Inputs" }) }),
    e && /* @__PURE__ */ V.jsxs("div", { className: "cta-wrapper", children: [
      (n == null ? void 0 : n.length) > 1 && /* @__PURE__ */ V.jsx(lr, { title: "Reorder fields", children: /* @__PURE__ */ V.jsx(
        Ut,
        {
          className: "grl-dt-text-secondary",
          icon: /* @__PURE__ */ V.jsx(k1, {}),
          size: "small",
          type: "text",
          disabled: t,
          onClick: () => {
            r({
              type: "reorder",
              columnType: "inputs",
              item: null
            });
          }
        }
      ) }),
      /* @__PURE__ */ V.jsx(lr, { title: "Add input", children: /* @__PURE__ */ V.jsx(
        Ut,
        {
          className: "grl-dt-text-secondary",
          size: "small",
          type: "text",
          icon: /* @__PURE__ */ V.jsx(ou, {}),
          disabled: t,
          onClick: () => {
            r({
              type: "add",
              columnType: "inputs",
              item: null
            });
          }
        }
      ) })
    ] })
  ] });
}, Sre = ({ configurable: e, disabled: t }) => {
  const n = io((i) => {
    var o;
    return (o = i.decisionTable) == null ? void 0 : o.outputs;
  }), { setDialog: r } = Of();
  return /* @__PURE__ */ V.jsxs(qr, { horizontal: !0, horizontalAlign: "space-between", verticalAlign: "center", children: [
    /* @__PURE__ */ V.jsx(qr, { gap: 0, className: "text-wrapper", verticalAlign: "center", children: /* @__PURE__ */ V.jsx(Bt.Text, { className: "span-overflow grl-dt-text-primary", children: "Outputs" }) }),
    e && /* @__PURE__ */ V.jsxs("div", { className: "cta-wrapper", children: [
      (n == null ? void 0 : n.length) > 1 && /* @__PURE__ */ V.jsx(lr, { title: "Reorder fields", children: /* @__PURE__ */ V.jsx(
        Ut,
        {
          className: "grl-dt-text-secondary",
          icon: /* @__PURE__ */ V.jsx(k1, {}),
          size: "small",
          type: "text",
          disabled: t,
          onClick: () => {
            r({
              type: "reorder",
              columnType: "outputs",
              item: null
            });
          }
        }
      ) }),
      /* @__PURE__ */ V.jsx(lr, { title: "Add output", children: /* @__PURE__ */ V.jsx(
        Ut,
        {
          className: "grl-dt-text-secondary",
          size: "small",
          type: "text",
          icon: /* @__PURE__ */ V.jsx(ou, {}),
          disabled: t,
          onClick: () => {
            r({
              type: "add",
              columnType: "outputs",
              item: null
            });
          }
        }
      ) })
    ] })
  ] });
}, xre = ({ configurable: e, disabled: t, schema: n }) => {
  const { setDialog: r, getContainer: i } = Of(), o = Qo();
  return /* @__PURE__ */ V.jsxs(qr, { horizontal: !0, horizontalAlign: "space-between", verticalAlign: "center", children: [
    /* @__PURE__ */ V.jsxs(qr, { gap: 0, className: "text-wrapper", children: [
      /* @__PURE__ */ V.jsx(Bt.Text, { className: "span-overflow grl-dt-text-primary", children: n.name }),
      /* @__PURE__ */ V.jsx(Bt.Text, { className: "span-overflow grl-dt-text-secondary", type: "secondary", style: { fontSize: 12 }, children: n.field })
    ] }),
    e && /* @__PURE__ */ V.jsx("div", { children: /* @__PURE__ */ V.jsx(
      da,
      {
        trigger: ["click"],
        overlayStyle: { minWidth: 140 },
        disabled: t,
        menu: {
          items: [
            {
              key: "edit",
              label: "Edit column",
              onClick: () => {
                r({
                  type: "edit",
                  columnType: "inputs",
                  item: n
                });
              }
            },
            {
              key: "remove",
              label: "Remove column",
              onClick: () => {
                pr.confirm({
                  title: "Remove column",
                  icon: !1,
                  getContainer: i,
                  content: /* @__PURE__ */ V.jsxs(Bt.Paragraph, { children: [
                    "You are about to delete ",
                    /* @__PURE__ */ V.jsx("strong", { children: n.name }),
                    " column."
                  ] }),
                  okText: "Remove",
                  okButtonProps: { danger: !0 },
                  onOk: () => o.removeColumn("inputs", n.id)
                });
              }
            }
          ]
        },
        children: /* @__PURE__ */ V.jsx(lr, { title: "Settings", children: /* @__PURE__ */ V.jsx(Ut, { className: "grl-dt-text-secondary", type: "text", size: "small", icon: /* @__PURE__ */ V.jsx(Cm, {}) }) })
      }
    ) })
  ] });
}, Ere = ({ configurable: e, disabled: t, schema: n }) => {
  const { setDialog: r, getContainer: i } = Of(), o = Qo();
  return /* @__PURE__ */ V.jsxs(qr, { horizontal: !0, horizontalAlign: "space-between", verticalAlign: "center", children: [
    /* @__PURE__ */ V.jsxs(qr, { gap: 0, className: "text-wrapper", verticalAlign: "center", children: [
      /* @__PURE__ */ V.jsx(Bt.Text, { className: "span-overflow grl-dt-text-primary", children: n.name }),
      /* @__PURE__ */ V.jsx(Bt.Text, { className: "span-overflow grl-dt-text-secondary", type: "secondary", style: { fontSize: 12 }, children: n.field })
    ] }),
    e && /* @__PURE__ */ V.jsx("div", { children: /* @__PURE__ */ V.jsx(
      da,
      {
        trigger: ["click"],
        overlayStyle: { minWidth: 140 },
        disabled: t,
        menu: {
          items: [
            {
              key: "edit",
              label: "Edit column",
              onClick: () => {
                r({
                  type: "edit",
                  columnType: "outputs",
                  item: n
                });
              }
            },
            {
              key: "remove",
              label: "Remove column",
              onClick: () => {
                pr.confirm({
                  title: "Remove column",
                  content: /* @__PURE__ */ V.jsxs(Bt.Paragraph, { children: [
                    "You are about to delete ",
                    /* @__PURE__ */ V.jsx("strong", { children: n.name }),
                    " column."
                  ] }),
                  getContainer: i,
                  icon: !1,
                  okText: "Remove",
                  okButtonProps: {
                    danger: !0
                  },
                  onOk: () => o.removeColumn("outputs", n.id)
                });
              }
            }
          ]
        },
        children: /* @__PURE__ */ V.jsx(lr, { title: "Settings", children: /* @__PURE__ */ V.jsx(Ut, { className: "grl-dt-text-secondary", type: "text", size: "small", icon: /* @__PURE__ */ V.jsx(Cm, {}) }) })
      }
    ) })
  ] });
}, i2 = ({ headerGroup: e }) => /* @__PURE__ */ V.jsxs("tr", { children: [
  /* @__PURE__ */ V.jsx("th", { colSpan: 1, style: { width: 72 } }),
  e.headers.map((t) => {
    var s;
    const n = t.getContext(), r = (s = n.header.column.parent) == null ? void 0 : s.id, i = yn(r).with("inputs", () => "input").with("outputs", () => "output").otherwise(() => {
    }), o = yn(n.column.id).with("inputs", () => "input").with("outputs", () => "output").with("_description", () => "description").otherwise(() => {
    });
    return /* @__PURE__ */ V.jsxs(
      "th",
      {
        colSpan: t.colSpan,
        "data-self": o,
        "data-parent": i,
        style: {
          width: t.getSize()
        },
        children: [
          !t.isPlaceholder && HP(t.column.columnDef.header, n),
          t.column.getCanResize() && /* @__PURE__ */ V.jsx(
            "div",
            {
              className: wn("resizer", t.column.getIsResizing() && "isResizing"),
              onMouseDown: t.getResizeHandler(),
              onTouchStart: t.getResizeHandler()
            }
          )
        ]
      },
      t.id
    );
  })
] }, e.id), $re = ({ row: e, disabled: t, virtualItem: n, onResize: r }) => {
  const i = he(null), o = Qo(), { cursor: s, isActive: a } = io(({ cursor: p, activeRules: g }) => ({
    cursor: p,
    isActive: Array.isArray(g) && g.includes(e.id)
  })), [{ isDropping: l, direction: u }, c] = G1({
    accept: "row",
    collect: (p) => {
      var g;
      return {
        isDropping: p.isOver({ shallow: !0 }),
        direction: (((g = p.getDifferenceFromInitialOffset()) == null ? void 0 : g.y) || 0) > 0 ? "down" : "up"
      };
    },
    drop: (p) => o.swapRows(p.index, e.index)
  }), [{ isDragging: d }, f, h] = U1({
    collect: (p) => ({
      isDragging: p.isDragging()
    }),
    item: () => e,
    type: "row"
  });
  return h(c(i)), Pe(() => {
    if (!i.current)
      return;
    r == null || r(i.current);
    const p = new ResizeObserver((g) => {
      g.forEach((m) => {
        m.target.hasAttribute("data-virtual-index") && (r == null || r(m.target));
      });
    });
    return p.observe(i.current), () => {
      p.disconnect();
    };
  }, []), /* @__PURE__ */ V.jsxs(
    "tr",
    {
      ref: i,
      className: wn(
        "table-row",
        l && u === "down" && "dropping-down",
        l && u === "up" && "dropping-up",
        a && "active",
        t && "disabled",
        (s == null ? void 0 : s.y) === n.index && !t && "selected"
      ),
      style: {
        opacity: d ? 0.5 : 1
      },
      "data-virtual-index": n.index,
      children: [
        /* @__PURE__ */ V.jsx(
          "td",
          {
            className: wn("sort-handler", !t && "draggable"),
            ref: t ? void 0 : f,
            onContextMenuCapture: () => o.setCursor({ x: "id", y: n.index }),
            children: /* @__PURE__ */ V.jsx("div", { className: "text", children: /* @__PURE__ */ V.jsx(Bt, { children: n.index + 1 }) })
          }
        ),
        e.getVisibleCells().map((p) => /* @__PURE__ */ V.jsx(
          "td",
          {
            className: wn(!t && (s == null ? void 0 : s.x) === p.column.id && (s == null ? void 0 : s.y) === n.index && "selected"),
            style: { width: p.column.getSize() },
            children: HP(p.column.columnDef.cell, p.getContext())
          },
          p.id
        ))
      ]
    }
  );
}, Ore = ({ maxHeight: e }) => {
  const { token: t } = no.useToken(), n = Qo(), { cellRenderer: r } = oQ(({ cellRenderer: p }) => ({ cellRenderer: p })), { configurable: i, disabled: o, inputs: s, outputs: a, colWidth: l, minColWidth: u } = io(
    ({ configurable: p, disabled: g, minColWidth: m, colWidth: v, decisionTable: b }) => ({
      configurable: p,
      disabled: g,
      minColWidth: m,
      colWidth: v,
      inputs: b.inputs,
      outputs: b.outputs
    })
  ), { rules: c } = io(
    ({ decisionTable: p }) => ({
      rules: p.rules
    }),
    (p, g) => ro(
      p.rules.map((m) => m == null ? void 0 : m._id),
      g.rules.map((m) => m == null ? void 0 : m._id)
    )
  ), d = U.useMemo(
    () => [
      {
        id: "inputs",
        minSize: u,
        size: l,
        enableResizing: !0,
        header: () => /* @__PURE__ */ V.jsx(Cre, { configurable: i, disabled: o }),
        columns: [
          ...(s || []).map((p) => ({
            accessorKey: p.id,
            id: p.id,
            minSize: u,
            size: l,
            header: () => /* @__PURE__ */ V.jsx(xre, { schema: p, configurable: i, disabled: o })
          }))
        ]
      },
      {
        id: "outputs",
        minSize: u,
        size: u,
        header: () => /* @__PURE__ */ V.jsx(Sre, { disabled: o, configurable: i }),
        columns: [
          ...(a || []).map((p) => ({
            accessorKey: p.id,
            minSize: u,
            size: l,
            header: () => /* @__PURE__ */ V.jsx(Ere, { schema: p, configurable: i, disabled: o })
          }))
        ]
      },
      {
        id: "_description",
        accessorKey: "_description",
        header: () => /* @__PURE__ */ V.jsx(Bt.Text, { className: "grl-dt-text-primary", children: "Description" }),
        minSize: u,
        size: l
      }
    ],
    [i, o, s, a]
  ), f = tre({
    data: c,
    columnResizeMode: "onChange",
    getRowId: (p) => p._id,
    columns: d,
    getCoreRowModel: Qne(),
    defaultColumn: {
      cell: (p) => /* @__PURE__ */ V.jsx(yre, { context: p })
    },
    meta: {
      getCell: r
    }
  }), h = he(null);
  return Pe(() => {
    if (!h.current)
      return;
    const p = new ResizeObserver((g) => {
      for (const m of g)
        m.target instanceof HTMLDivElement && m.target.style.setProperty("--dt-container-width", `${m.contentRect.width}px`);
    });
    return p.observe(h.current), () => {
      p.disconnect();
    };
  }, []), /* @__PURE__ */ V.jsxs(
    "div",
    {
      ref: h,
      className: "grl-dt__container",
      style: { maxHeight: e, overflowY: "auto" },
      "data-theme": t.mode,
      children: [
        /* @__PURE__ */ V.jsx(o2, { width: f.getCenterTotalSize(), children: /* @__PURE__ */ V.jsx("thead", { children: f.getHeaderGroups().filter((p, g) => g === 0).map((p) => /* @__PURE__ */ V.jsx(i2, { headerGroup: p }, p.id)) }) }),
        /* @__PURE__ */ V.jsxs(o2, { width: f.getCenterTotalSize(), children: [
          /* @__PURE__ */ V.jsx("thead", { children: f.getHeaderGroups().filter((p, g) => g === 1).map((p) => /* @__PURE__ */ V.jsx(i2, { headerGroup: p }, p.id)) }),
          /* @__PURE__ */ V.jsx(bre, { children: /* @__PURE__ */ V.jsx(Are, { tableContainerRef: h, table: f }) }),
          /* @__PURE__ */ V.jsx("tfoot", { children: /* @__PURE__ */ V.jsx("tr", { children: /* @__PURE__ */ V.jsx("td", { colSpan: s.length + a.length + 2, children: /* @__PURE__ */ V.jsx(
            Ut,
            {
              className: "grl-dt__add-row",
              type: "text",
              disabled: o,
              icon: /* @__PURE__ */ V.jsx(ou, {}),
              onClick: () => n.addRowBelow()
            }
          ) }) }) })
        ] })
      ]
    }
  );
}, Are = U.forwardRef(
  ({ table: e, tableContainerRef: t, ...n }, r) => {
    var p, g;
    const i = Qo(), { disabled: o, cursor: s } = io(({ disabled: m, cursor: v }) => ({
      disabled: m,
      cursor: v
    })), { rows: a } = e.getRowModel(), l = gre({
      getScrollElement: () => t.current,
      estimateSize: () => 38,
      indexAttribute: "data-virtual-index",
      count: a.length,
      overscan: 5
    }), u = l.getVirtualItems(), c = l.getTotalSize(), d = u.length > 0 && ((p = u == null ? void 0 : u[0]) == null ? void 0 : p.start) || 0, f = u.length > 0 ? c - (((g = u == null ? void 0 : u[u.length - 1]) == null ? void 0 : g.end) || 0) : 0, h = Kt((m) => {
      o || (m.code === "ArrowUp" && (m.metaKey || m.altKey) && s && i.addRowAbove(s.y), m.code === "ArrowDown" && (m.metaKey || m.altKey) && s && i.addRowBelow(s.y), m.code === "Backspace" && (m.metaKey || m.altKey) && s && i.removeRow(s.y));
    }, []);
    return /* @__PURE__ */ V.jsxs("tbody", { ref: r, ...n, onKeyDown: h, children: [
      d > 0 && /* @__PURE__ */ V.jsx("tr", { children: /* @__PURE__ */ V.jsx("td", { style: { height: `${d}px` } }) }),
      u.map((m) => {
        const v = a[m.index];
        return /* @__PURE__ */ V.jsx(
          $re,
          {
            virtualItem: m,
            row: v,
            disabled: o,
            onResize: (b) => l.measureElement(b)
          },
          m.key
        );
      }),
      f > 0 && /* @__PURE__ */ V.jsx("tr", { children: /* @__PURE__ */ V.jsx("td", { style: { height: `${f}px` } }) })
    ] });
  }
), o2 = ({
  style: e,
  className: t,
  width: n,
  ...r
}) => /* @__PURE__ */ V.jsx("table", { className: wn("table", t), style: { width: n, ...e }, ...r }), Dre = ({
  tableHeight: e,
  mountDialogsOnBody: t = !1,
  manager: n,
  ...r
}) => {
  const { token: i } = no.useToken(), [o, s] = ht(!1), a = he(null);
  Pe(() => {
    s(!0);
  }, []);
  const l = () => a.current, u = mt(() => n ? {
    manager: n
  } : {
    backend: K1,
    options: {
      rootElement: a.current
    }
  }, [a.current, n]);
  return /* @__PURE__ */ V.jsx("div", { ref: a, className: "grl-dt", style: { background: i.colorBgElevated }, children: a.current && /* @__PURE__ */ V.jsx(nI, { ...u, children: /* @__PURE__ */ V.jsx(iQ, { children: /* @__PURE__ */ V.jsxs(Pq, { getContainer: t === !0 ? void 0 : l, children: [
    /* @__PURE__ */ V.jsx(cne, {}),
    /* @__PURE__ */ V.jsx(Ore, { maxHeight: e }),
    /* @__PURE__ */ V.jsx(Ste, {}),
    /* @__PURE__ */ V.jsx(dne, { ...r })
  ] }) }) }) });
};
var Wc = {}, xC = {}, WP = { exports: {} };
(function(e, t) {
  (function() {
    var n = "ace", r = /* @__PURE__ */ function() {
      return this;
    }();
    !r && typeof window < "u" && (r = window);
    var i = function(c, d, f) {
      if (typeof c != "string") {
        i.original ? i.original.apply(this, arguments) : (console.error("dropping module because define wasn't a string."), console.trace());
        return;
      }
      arguments.length == 2 && (f = d), i.modules[c] || (i.payloads[c] = f, i.modules[c] = null);
    };
    i.modules = {}, i.payloads = {};
    var o = function(c, d, f) {
      if (typeof d == "string") {
        var h = l(c, d);
        if (h != null)
          return f && f(), h;
      } else if (Object.prototype.toString.call(d) === "[object Array]") {
        for (var p = [], g = 0, m = d.length; g < m; ++g) {
          var v = l(c, d[g]);
          if (v == null && s.original)
            return;
          p.push(v);
        }
        return f && f.apply(null, p) || !0;
      }
    }, s = function(c, d) {
      var f = o("", c, d);
      return f == null && s.original ? s.original.apply(this, arguments) : f;
    }, a = function(c, d) {
      if (d.indexOf("!") !== -1) {
        var f = d.split("!");
        return a(c, f[0]) + "!" + a(c, f[1]);
      }
      if (d.charAt(0) == ".") {
        var h = c.split("/").slice(0, -1).join("/");
        for (d = h + "/" + d; d.indexOf(".") !== -1 && p != d; ) {
          var p = d;
          d = d.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
        }
      }
      return d;
    }, l = function(c, d) {
      d = a(c, d);
      var f = i.modules[d];
      if (!f) {
        if (f = i.payloads[d], typeof f == "function") {
          var h = {}, p = {
            id: d,
            uri: "",
            exports: h,
            packaged: !0
          }, g = function(v, b) {
            return o(d, v, b);
          }, m = f(g, h, p);
          h = m || p.exports, i.modules[d] = h, delete i.payloads[d];
        }
        f = i.modules[d] = h || f;
      }
      return f;
    };
    function u(c) {
      var d = r;
      r[c] || (r[c] = {}), d = r[c], (!d.define || !d.define.packaged) && (i.original = d.define, d.define = i, d.define.packaged = !0), (!d.require || !d.require.packaged) && (s.original = d.require, d.require = s, d.require.packaged = !0);
    }
    u(n);
  })(), ace.define("ace/lib/es6-shim", ["require", "exports", "module"], function(n, r, i) {
    function o(s, a, l) {
      Object.defineProperty(s, a, {
        value: l,
        enumerable: !1,
        writable: !0,
        configurable: !0
      });
    }
    String.prototype.startsWith || o(String.prototype, "startsWith", function(s, a) {
      return a = a || 0, this.lastIndexOf(s, a) === a;
    }), String.prototype.endsWith || o(String.prototype, "endsWith", function(s, a) {
      var l = this;
      (a === void 0 || a > l.length) && (a = l.length), a -= s.length;
      var u = l.indexOf(s, a);
      return u !== -1 && u === a;
    }), String.prototype.repeat || o(String.prototype, "repeat", function(s) {
      for (var a = "", l = this; s > 0; )
        s & 1 && (a += l), (s >>= 1) && (l += l);
      return a;
    }), String.prototype.includes || o(String.prototype, "includes", function(s, a) {
      return this.indexOf(s, a) != -1;
    }), Object.assign || (Object.assign = function(s) {
      if (s == null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var a = Object(s), l = 1; l < arguments.length; l++) {
        var u = arguments[l];
        u != null && Object.keys(u).forEach(function(c) {
          a[c] = u[c];
        });
      }
      return a;
    }), Object.values || (Object.values = function(s) {
      return Object.keys(s).map(function(a) {
        return s[a];
      });
    }), Array.prototype.find || o(Array.prototype, "find", function(s) {
      for (var a = this.length, l = arguments[1], u = 0; u < a; u++) {
        var c = this[u];
        if (s.call(l, c, u, this))
          return c;
      }
    }), Array.prototype.findIndex || o(Array.prototype, "findIndex", function(s) {
      for (var a = this.length, l = arguments[1], u = 0; u < a; u++) {
        var c = this[u];
        if (s.call(l, c, u, this))
          return u;
      }
    }), Array.prototype.includes || o(Array.prototype, "includes", function(s, a) {
      return this.indexOf(s, a) != -1;
    }), Array.prototype.fill || o(Array.prototype, "fill", function(s) {
      for (var a = this, l = a.length >>> 0, u = arguments[1], c = u >> 0, d = c < 0 ? Math.max(l + c, 0) : Math.min(c, l), f = arguments[2], h = f === void 0 ? l : f >> 0, p = h < 0 ? Math.max(l + h, 0) : Math.min(h, l); d < p; )
        a[d] = s, d++;
      return a;
    }), Array.of || o(Array, "of", function() {
      return Array.prototype.slice.call(arguments);
    });
  }), ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module", "ace/lib/es6-shim"], function(n, r, i) {
    n("./es6-shim");
  }), ace.define("ace/lib/deep_copy", ["require", "exports", "module"], function(n, r, i) {
    r.deepCopy = function o(s) {
      if (typeof s != "object" || !s)
        return s;
      var a;
      if (Array.isArray(s)) {
        a = [];
        for (var l = 0; l < s.length; l++)
          a[l] = o(s[l]);
        return a;
      }
      if (Object.prototype.toString.call(s) !== "[object Object]")
        return s;
      a = {};
      for (var l in s)
        a[l] = o(s[l]);
      return a;
    };
  }), ace.define("ace/lib/lang", ["require", "exports", "module", "ace/lib/deep_copy"], function(n, r, i) {
    r.last = function(a) {
      return a[a.length - 1];
    }, r.stringReverse = function(a) {
      return a.split("").reverse().join("");
    }, r.stringRepeat = function(a, l) {
      for (var u = ""; l > 0; )
        l & 1 && (u += a), (l >>= 1) && (a += a);
      return u;
    };
    var o = /^\s\s*/, s = /\s\s*$/;
    r.stringTrimLeft = function(a) {
      return a.replace(o, "");
    }, r.stringTrimRight = function(a) {
      return a.replace(s, "");
    }, r.copyObject = function(a) {
      var l = {};
      for (var u in a)
        l[u] = a[u];
      return l;
    }, r.copyArray = function(a) {
      for (var l = [], u = 0, c = a.length; u < c; u++)
        a[u] && typeof a[u] == "object" ? l[u] = this.copyObject(a[u]) : l[u] = a[u];
      return l;
    }, r.deepCopy = n("./deep_copy").deepCopy, r.arrayToMap = function(a) {
      for (var l = {}, u = 0; u < a.length; u++)
        l[a[u]] = 1;
      return l;
    }, r.createMap = function(a) {
      var l = /* @__PURE__ */ Object.create(null);
      for (var u in a)
        l[u] = a[u];
      return l;
    }, r.arrayRemove = function(a, l) {
      for (var u = 0; u <= a.length; u++)
        l === a[u] && a.splice(u, 1);
    }, r.escapeRegExp = function(a) {
      return a.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
    }, r.escapeHTML = function(a) {
      return ("" + a).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
    }, r.getMatchOffsets = function(a, l) {
      var u = [];
      return a.replace(l, function(c) {
        u.push({
          offset: arguments[arguments.length - 2],
          length: c.length
        });
      }), u;
    }, r.deferredCall = function(a) {
      var l = null, u = function() {
        l = null, a();
      }, c = function(d) {
        return c.cancel(), l = setTimeout(u, d || 0), c;
      };
      return c.schedule = c, c.call = function() {
        return this.cancel(), a(), c;
      }, c.cancel = function() {
        return clearTimeout(l), l = null, c;
      }, c.isPending = function() {
        return l;
      }, c;
    }, r.delayedCall = function(a, l) {
      var u = null, c = function() {
        u = null, a();
      }, d = function(f) {
        u == null && (u = setTimeout(c, f || l));
      };
      return d.delay = function(f) {
        u && clearTimeout(u), u = setTimeout(c, f || l);
      }, d.schedule = d, d.call = function() {
        this.cancel(), a();
      }, d.cancel = function() {
        u && clearTimeout(u), u = null;
      }, d.isPending = function() {
        return u;
      }, d;
    }, r.supportsLookbehind = function() {
      try {
        new RegExp("(?<=.)");
      } catch {
        return !1;
      }
      return !0;
    }, r.skipEmptyMatch = function(a, l, u) {
      return u && a.codePointAt(l) > 65535 ? 2 : 1;
    };
  }), ace.define("ace/lib/useragent", ["require", "exports", "module"], function(n, r, i) {
    r.OS = {
      LINUX: "LINUX",
      MAC: "MAC",
      WINDOWS: "WINDOWS"
    }, r.getOS = function() {
      return r.isMac ? r.OS.MAC : r.isLinux ? r.OS.LINUX : r.OS.WINDOWS;
    };
    var o = typeof navigator == "object" ? navigator : {}, s = (/mac|win|linux/i.exec(o.platform) || ["other"])[0].toLowerCase(), a = o.userAgent || "", l = o.appName || "";
    r.isWin = s == "win", r.isMac = s == "mac", r.isLinux = s == "linux", r.isIE = l == "Microsoft Internet Explorer" || l.indexOf("MSAppHost") >= 0 ? parseFloat((a.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((a.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]), r.isOldIE = r.isIE && r.isIE < 9, r.isGecko = r.isMozilla = a.match(/ Gecko\/\d+/), r.isOpera = typeof opera == "object" && Object.prototype.toString.call(window.opera) == "[object Opera]", r.isWebKit = parseFloat(a.split("WebKit/")[1]) || void 0, r.isChrome = parseFloat(a.split(" Chrome/")[1]) || void 0, r.isSafari = parseFloat(a.split(" Safari/")[1]) && !r.isChrome || void 0, r.isEdge = parseFloat(a.split(" Edge/")[1]) || void 0, r.isAIR = a.indexOf("AdobeAIR") >= 0, r.isAndroid = a.indexOf("Android") >= 0, r.isChromeOS = a.indexOf(" CrOS ") >= 0, r.isIOS = /iPad|iPhone|iPod/.test(a) && !window.MSStream, r.isIOS && (r.isMac = !0), r.isMobile = r.isIOS || r.isAndroid;
  }), ace.define("ace/lib/dom", ["require", "exports", "module", "ace/lib/useragent"], function(n, r, i) {
    var o = n("./useragent"), s = "http://www.w3.org/1999/xhtml";
    r.buildDom = function f(h, p, g) {
      if (typeof h == "string" && h) {
        var m = document.createTextNode(h);
        return p && p.appendChild(m), m;
      }
      if (!Array.isArray(h))
        return h && h.appendChild && p && p.appendChild(h), h;
      if (typeof h[0] != "string" || !h[0]) {
        for (var v = [], b = 0; b < h.length; b++) {
          var x = f(h[b], p, g);
          x && v.push(x);
        }
        return v;
      }
      var w = document.createElement(h[0]), C = h[1], y = 1;
      C && typeof C == "object" && !Array.isArray(C) && (y = 2);
      for (var b = y; b < h.length; b++)
        f(h[b], w, g);
      return y == 2 && Object.keys(C).forEach(function(S) {
        var A = C[S];
        S === "class" ? w.className = Array.isArray(A) ? A.join(" ") : A : typeof A == "function" || S == "value" || S[0] == "$" ? w[S] = A : S === "ref" ? g && (g[A] = w) : S === "style" ? typeof A == "string" && (w.style.cssText = A) : A != null && w.setAttribute(S, A);
      }), p && p.appendChild(w), w;
    }, r.getDocumentHead = function(f) {
      return f || (f = document), f.head || f.getElementsByTagName("head")[0] || f.documentElement;
    }, r.createElement = function(f, h) {
      return document.createElementNS ? document.createElementNS(h || s, f) : document.createElement(f);
    }, r.removeChildren = function(f) {
      f.innerHTML = "";
    }, r.createTextNode = function(f, h) {
      var p = h ? h.ownerDocument : document;
      return p.createTextNode(f);
    }, r.createFragment = function(f) {
      var h = f ? f.ownerDocument : document;
      return h.createDocumentFragment();
    }, r.hasCssClass = function(f, h) {
      var p = (f.className + "").split(/\s+/g);
      return p.indexOf(h) !== -1;
    }, r.addCssClass = function(f, h) {
      r.hasCssClass(f, h) || (f.className += " " + h);
    }, r.removeCssClass = function(f, h) {
      for (var p = f.className.split(/\s+/g); ; ) {
        var g = p.indexOf(h);
        if (g == -1)
          break;
        p.splice(g, 1);
      }
      f.className = p.join(" ");
    }, r.toggleCssClass = function(f, h) {
      for (var p = f.className.split(/\s+/g), g = !0; ; ) {
        var m = p.indexOf(h);
        if (m == -1)
          break;
        g = !1, p.splice(m, 1);
      }
      return g && p.push(h), f.className = p.join(" "), g;
    }, r.setCssClass = function(f, h, p) {
      p ? r.addCssClass(f, h) : r.removeCssClass(f, h);
    }, r.hasCssString = function(f, h) {
      var p = 0, g;
      if (h = h || document, g = h.querySelectorAll("style")) {
        for (; p < g.length; )
          if (g[p++].id === f)
            return !0;
      }
    }, r.removeElementById = function(f, h) {
      h = h || document, h.getElementById(f) && h.getElementById(f).remove();
    };
    var a, l = [];
    r.useStrictCSP = function(f) {
      a = f, f == !1 ? u() : l || (l = []);
    };
    function u() {
      var f = l;
      l = null, f && f.forEach(function(h) {
        c(h[0], h[1]);
      });
    }
    function c(f, h, p) {
      if (!(typeof document > "u")) {
        if (l) {
          if (p)
            u();
          else if (p === !1)
            return l.push([f, h]);
        }
        if (!a) {
          var g = p;
          !p || !p.getRootNode ? g = document : (g = p.getRootNode(), (!g || g == p) && (g = document));
          var m = g.ownerDocument || g;
          if (h && r.hasCssString(h, g))
            return null;
          h && (f += `
/*# sourceURL=ace/css/` + h + " */");
          var v = r.createElement("style");
          v.appendChild(m.createTextNode(f)), h && (v.id = h), g == m && (g = r.getDocumentHead(m)), g.insertBefore(v, g.firstChild);
        }
      }
    }
    if (r.importCssString = c, r.importCssStylsheet = function(f, h) {
      r.buildDom(["link", { rel: "stylesheet", href: f }], r.getDocumentHead(h));
    }, r.scrollbarWidth = function(f) {
      var h = r.createElement("ace_inner");
      h.style.width = "100%", h.style.minWidth = "0px", h.style.height = "200px", h.style.display = "block";
      var p = r.createElement("ace_outer"), g = p.style;
      g.position = "absolute", g.left = "-10000px", g.overflow = "hidden", g.width = "200px", g.minWidth = "0px", g.height = "150px", g.display = "block", p.appendChild(h);
      var m = f && f.documentElement || document && document.documentElement;
      if (!m)
        return 0;
      m.appendChild(p);
      var v = h.offsetWidth;
      g.overflow = "scroll";
      var b = h.offsetWidth;
      return v === b && (b = p.clientWidth), m.removeChild(p), v - b;
    }, r.computedStyle = function(f, h) {
      return window.getComputedStyle(f, "") || {};
    }, r.setStyle = function(f, h, p) {
      f[h] !== p && (f[h] = p);
    }, r.HAS_CSS_ANIMATION = !1, r.HAS_CSS_TRANSFORMS = !1, r.HI_DPI = o.isWin ? typeof window < "u" && window.devicePixelRatio >= 1.5 : !0, o.isChromeOS && (r.HI_DPI = !1), typeof document < "u") {
      var d = document.createElement("div");
      r.HI_DPI && d.style.transform !== void 0 && (r.HAS_CSS_TRANSFORMS = !0), !o.isEdge && typeof d.style.animationName < "u" && (r.HAS_CSS_ANIMATION = !0), d = null;
    }
    r.HAS_CSS_TRANSFORMS ? r.translate = function(f, h, p) {
      f.style.transform = "translate(" + Math.round(h) + "px, " + Math.round(p) + "px)";
    } : r.translate = function(f, h, p) {
      f.style.top = Math.round(p) + "px", f.style.left = Math.round(h) + "px";
    };
  }), ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function(n, r, i) {
    /*
    * based on code from:
    *
    * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
    * Available via the MIT or new BSD license.
    * see: http://github.com/jrburke/requirejs for details
    */
    var o = n("./dom");
    r.get = function(s, a) {
      var l = new XMLHttpRequest();
      l.open("GET", s, !0), l.onreadystatechange = function() {
        l.readyState === 4 && a(l.responseText);
      }, l.send(null);
    }, r.loadScript = function(s, a) {
      var l = o.getDocumentHead(), u = document.createElement("script");
      u.src = s, l.appendChild(u), u.onload = u.onreadystatechange = function(c, d) {
        (d || !u.readyState || u.readyState == "loaded" || u.readyState == "complete") && (u = u.onload = u.onreadystatechange = null, d || a());
      };
    }, r.qualifyURL = function(s) {
      var a = document.createElement("a");
      return a.href = s, a.href;
    };
  }), ace.define("ace/lib/oop", ["require", "exports", "module"], function(n, r, i) {
    r.inherits = function(o, s) {
      o.super_ = s, o.prototype = Object.create(s.prototype, {
        constructor: {
          value: o,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      });
    }, r.mixin = function(o, s) {
      for (var a in s)
        o[a] = s[a];
      return o;
    }, r.implement = function(o, s) {
      r.mixin(o, s);
    };
  }), ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function(n, r, i) {
    var o = {}, s = function() {
      this.propagationStopped = !0;
    }, a = function() {
      this.defaultPrevented = !0;
    };
    o._emit = o._dispatchEvent = function(l, u) {
      this._eventRegistry || (this._eventRegistry = {}), this._defaultHandlers || (this._defaultHandlers = {});
      var c = this._eventRegistry[l] || [], d = this._defaultHandlers[l];
      if (!(!c.length && !d)) {
        (typeof u != "object" || !u) && (u = {}), u.type || (u.type = l), u.stopPropagation || (u.stopPropagation = s), u.preventDefault || (u.preventDefault = a), c = c.slice();
        for (var f = 0; f < c.length && (c[f](u, this), !u.propagationStopped); f++)
          ;
        if (d && !u.defaultPrevented)
          return d(u, this);
      }
    }, o._signal = function(l, u) {
      var c = (this._eventRegistry || {})[l];
      if (c) {
        c = c.slice();
        for (var d = 0; d < c.length; d++)
          c[d](u, this);
      }
    }, o.once = function(l, u) {
      var c = this;
      if (this.on(l, function d() {
        c.off(l, d), u.apply(null, arguments);
      }), !u)
        return new Promise(function(d) {
          u = d;
        });
    }, o.setDefaultHandler = function(l, u) {
      var c = this._defaultHandlers;
      if (c || (c = this._defaultHandlers = { _disabled_: {} }), c[l]) {
        var d = c[l], f = c._disabled_[l];
        f || (c._disabled_[l] = f = []), f.push(d);
        var h = f.indexOf(u);
        h != -1 && f.splice(h, 1);
      }
      c[l] = u;
    }, o.removeDefaultHandler = function(l, u) {
      var c = this._defaultHandlers;
      if (c) {
        var d = c._disabled_[l];
        if (c[l] == u)
          d && this.setDefaultHandler(l, d.pop());
        else if (d) {
          var f = d.indexOf(u);
          f != -1 && d.splice(f, 1);
        }
      }
    }, o.on = o.addEventListener = function(l, u, c) {
      this._eventRegistry = this._eventRegistry || {};
      var d = this._eventRegistry[l];
      return d || (d = this._eventRegistry[l] = []), d.indexOf(u) == -1 && d[c ? "unshift" : "push"](u), u;
    }, o.off = o.removeListener = o.removeEventListener = function(l, u) {
      this._eventRegistry = this._eventRegistry || {};
      var c = this._eventRegistry[l];
      if (c) {
        var d = c.indexOf(u);
        d !== -1 && c.splice(d, 1);
      }
    }, o.removeAllListeners = function(l) {
      l || (this._eventRegistry = this._defaultHandlers = void 0), this._eventRegistry && (this._eventRegistry[l] = void 0), this._defaultHandlers && (this._defaultHandlers[l] = void 0);
    }, r.EventEmitter = o;
  }), ace.define("ace/lib/report_error", ["require", "exports", "module"], function(n, r, i) {
    r.reportError = function(s, a) {
      var l = new Error(s);
      l.data = a, typeof console == "object" && console.error && console.error(l), setTimeout(function() {
        throw l;
      });
    };
  }), ace.define("ace/lib/default_english_messages", ["require", "exports", "module"], function(n, r, i) {
    var o = {
      "autocomplete.popup.aria-roledescription": "Autocomplete suggestions",
      "autocomplete.popup.aria-label": "Autocomplete suggestions",
      "autocomplete.popup.item.aria-roledescription": "item",
      "autocomplete.loading": "Loading...",
      "editor.scroller.aria-roledescription": "editor",
      "editor.scroller.aria-label": "Editor content, press Enter to start editing, press Escape to exit",
      "editor.gutter.aria-roledescription": "editor",
      "editor.gutter.aria-label": "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit",
      "error-marker.good-state": "Looks good!",
      "prompt.recently-used": "Recently used",
      "prompt.other-commands": "Other commands",
      "prompt.no-matching-commands": "No matching commands",
      "search-box.find.placeholder": "Search for",
      "search-box.find-all.text": "All",
      "search-box.replace.placeholder": "Replace with",
      "search-box.replace-next.text": "Replace",
      "search-box.replace-all.text": "All",
      "search-box.toggle-replace.title": "Toggle Replace mode",
      "search-box.toggle-regexp.title": "RegExp Search",
      "search-box.toggle-case.title": "CaseSensitive Search",
      "search-box.toggle-whole-word.title": "Whole Word Search",
      "search-box.toggle-in-selection.title": "Search In Selection",
      "search-box.search-counter": "$0 of $1",
      "text-input.aria-roledescription": "editor",
      "text-input.aria-label": "Cursor at row $0",
      "gutter.code-folding.range.aria-label": "Toggle code folding, rows $0 through $1",
      "gutter.code-folding.closed.aria-label": "Toggle code folding, rows $0 through $1",
      "gutter.code-folding.open.aria-label": "Toggle code folding, row $0",
      "gutter.code-folding.closed.title": "Unfold code",
      "gutter.code-folding.open.title": "Fold code",
      "gutter.annotation.aria-label.error": "Error, read annotations row $0",
      "gutter.annotation.aria-label.warning": "Warning, read annotations row $0",
      "gutter.annotation.aria-label.info": "Info, read annotations row $0",
      "inline-fold.closed.title": "Unfold code",
      "gutter-tooltip.aria-label.error.singular": "error",
      "gutter-tooltip.aria-label.error.plural": "errors",
      "gutter-tooltip.aria-label.warning.singular": "warning",
      "gutter-tooltip.aria-label.warning.plural": "warnings",
      "gutter-tooltip.aria-label.info.singular": "information message",
      "gutter-tooltip.aria-label.info.plural": "information messages"
    };
    r.defaultEnglishMessages = o;
  }), ace.define("ace/lib/app_config", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter", "ace/lib/report_error", "ace/lib/default_english_messages"], function(n, r, i) {
    "no use strict";
    var o = n("./oop"), s = n("./event_emitter").EventEmitter, a = n("./report_error").reportError, l = n("./default_english_messages").defaultEnglishMessages, u = {
      setOptions: function(h) {
        Object.keys(h).forEach(function(p) {
          this.setOption(p, h[p]);
        }, this);
      },
      getOptions: function(h) {
        var p = {};
        if (h)
          Array.isArray(h) || (p = h, h = Object.keys(p));
        else {
          var g = this.$options;
          h = Object.keys(g).filter(function(m) {
            return !g[m].hidden;
          });
        }
        return h.forEach(function(m) {
          p[m] = this.getOption(m);
        }, this), p;
      },
      setOption: function(h, p) {
        if (this["$" + h] !== p) {
          var g = this.$options[h];
          if (!g)
            return c('misspelled option "' + h + '"');
          if (g.forwardTo)
            return this[g.forwardTo] && this[g.forwardTo].setOption(h, p);
          g.handlesSet || (this["$" + h] = p), g && g.set && g.set.call(this, p);
        }
      },
      getOption: function(h) {
        var p = this.$options[h];
        return p ? p.forwardTo ? this[p.forwardTo] && this[p.forwardTo].getOption(h) : p && p.get ? p.get.call(this) : this["$" + h] : c('misspelled option "' + h + '"');
      }
    };
    function c(h) {
      typeof console < "u" && console.warn && console.warn.apply(console, arguments);
    }
    var d, f = (
      /** @class */
      function() {
        function h() {
          this.$defaultOptions = {}, d = l;
        }
        return h.prototype.defineOptions = function(p, g, m) {
          return p.$options || (this.$defaultOptions[g] = p.$options = {}), Object.keys(m).forEach(function(v) {
            var b = m[v];
            typeof b == "string" && (b = { forwardTo: b }), b.name || (b.name = v), p.$options[b.name] = b, "initialValue" in b && (p["$" + b.name] = b.initialValue);
          }), o.implement(p, u), this;
        }, h.prototype.resetOptions = function(p) {
          Object.keys(p.$options).forEach(function(g) {
            var m = p.$options[g];
            "value" in m && p.setOption(g, m.value);
          });
        }, h.prototype.setDefaultValue = function(p, g, m) {
          if (!p) {
            for (p in this.$defaultOptions)
              if (this.$defaultOptions[p][g])
                break;
            if (!this.$defaultOptions[p][g])
              return !1;
          }
          var v = this.$defaultOptions[p] || (this.$defaultOptions[p] = {});
          v[g] && (v.forwardTo ? this.setDefaultValue(v.forwardTo, g, m) : v[g].value = m);
        }, h.prototype.setDefaultValues = function(p, g) {
          Object.keys(g).forEach(function(m) {
            this.setDefaultValue(p, m, g[m]);
          }, this);
        }, h.prototype.setMessages = function(p) {
          d = p;
        }, h.prototype.nls = function(p, g, m) {
          d[p] || (c("No message found for the key '" + p + "' in the provided messages, trying to find a translation for the default string '" + g + "'."), d[g] || c("No message found for the default string '" + g + "' in the provided messages. Falling back to the default English message."));
          var v = d[p] || d[g] || g;
          return m && (v = v.replace(/\$(\$|[\d]+)/g, function(b, x) {
            return x == "$" ? "$" : m[x];
          })), v;
        }, h;
      }()
    );
    f.prototype.warn = c, f.prototype.reportError = a, o.implement(f.prototype, s), r.AppConfig = f;
  }), ace.define("ace/theme/textmate-css", ["require", "exports", "module"], function(n, r, i) {
    i.exports = `.ace-tm .ace_gutter {
  background: #f0f0f0;
  color: #333;
}

.ace-tm .ace_print-margin {
  width: 1px;
  background: #e8e8e8;
}

.ace-tm .ace_fold {
    background-color: #6B72E6;
}

.ace-tm {
  background-color: #FFFFFF;
  color: black;
}

.ace-tm .ace_cursor {
  color: black;
}
        
.ace-tm .ace_invisible {
  color: rgb(191, 191, 191);
}

.ace-tm .ace_storage,
.ace-tm .ace_keyword {
  color: blue;
}

.ace-tm .ace_constant {
  color: rgb(197, 6, 11);
}

.ace-tm .ace_constant.ace_buildin {
  color: rgb(88, 72, 246);
}

.ace-tm .ace_constant.ace_language {
  color: rgb(88, 92, 246);
}

.ace-tm .ace_constant.ace_library {
  color: rgb(6, 150, 14);
}

.ace-tm .ace_invalid {
  background-color: rgba(255, 0, 0, 0.1);
  color: red;
}

.ace-tm .ace_support.ace_function {
  color: rgb(60, 76, 114);
}

.ace-tm .ace_support.ace_constant {
  color: rgb(6, 150, 14);
}

.ace-tm .ace_support.ace_type,
.ace-tm .ace_support.ace_class {
  color: rgb(109, 121, 222);
}

.ace-tm .ace_keyword.ace_operator {
  color: rgb(104, 118, 135);
}

.ace-tm .ace_string {
  color: rgb(3, 106, 7);
}

.ace-tm .ace_comment {
  color: rgb(76, 136, 107);
}

.ace-tm .ace_comment.ace_doc {
  color: rgb(0, 102, 255);
}

.ace-tm .ace_comment.ace_doc.ace_tag {
  color: rgb(128, 159, 191);
}

.ace-tm .ace_constant.ace_numeric {
  color: rgb(0, 0, 205);
}

.ace-tm .ace_variable {
  color: rgb(49, 132, 149);
}

.ace-tm .ace_xml-pe {
  color: rgb(104, 104, 91);
}

.ace-tm .ace_entity.ace_name.ace_function {
  color: #0000A2;
}


.ace-tm .ace_heading {
  color: rgb(12, 7, 255);
}

.ace-tm .ace_list {
  color:rgb(185, 6, 144);
}

.ace-tm .ace_meta.ace_tag {
  color:rgb(0, 22, 142);
}

.ace-tm .ace_string.ace_regex {
  color: rgb(255, 0, 0)
}

.ace-tm .ace_marker-layer .ace_selection {
  background: rgb(181, 213, 255);
}
.ace-tm.ace_multiselect .ace_selection.ace_start {
  box-shadow: 0 0 3px 0px white;
}
.ace-tm .ace_marker-layer .ace_step {
  background: rgb(252, 255, 0);
}

.ace-tm .ace_marker-layer .ace_stack {
  background: rgb(164, 229, 101);
}

.ace-tm .ace_marker-layer .ace_bracket {
  margin: -1px 0 0 -1px;
  border: 1px solid rgb(192, 192, 192);
}

.ace-tm .ace_marker-layer .ace_active-line {
  background: rgba(0, 0, 0, 0.07);
}

.ace-tm .ace_gutter-active-line {
    background-color : #dcdcdc;
}

.ace-tm .ace_marker-layer .ace_selected-word {
  background: rgb(250, 250, 255);
  border: 1px solid rgb(200, 200, 250);
}

.ace-tm .ace_indent-guide {
  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;
}

.ace-tm .ace_indent-guide-active {
  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;
}
`;
  }), ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/theme/textmate-css", "ace/lib/dom"], function(n, r, i) {
    r.isDark = !1, r.cssClass = "ace-tm", r.cssText = n("./textmate-css"), r.$id = "ace/theme/textmate";
    var o = n("../lib/dom");
    o.importCssString(r.cssText, r.cssClass, !1);
  }), ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/net", "ace/lib/dom", "ace/lib/app_config", "ace/theme/textmate"], function(n, r, i) {
    "no use strict";
    var o = n("./lib/lang"), s = n("./lib/net"), a = n("./lib/dom"), l = n("./lib/app_config").AppConfig;
    i.exports = r = new l();
    var u = {
      packaged: !1,
      workerPath: null,
      modePath: null,
      themePath: null,
      basePath: "",
      suffix: ".js",
      $moduleUrls: {},
      loadWorkerFromBlob: !0,
      sharedPopups: !1,
      useStrictCSP: null
    };
    r.get = function(h) {
      if (!u.hasOwnProperty(h))
        throw new Error("Unknown config key: " + h);
      return u[h];
    }, r.set = function(h, p) {
      if (u.hasOwnProperty(h))
        u[h] = p;
      else if (this.setDefaultValue("", h, p) == !1)
        throw new Error("Unknown config key: " + h);
      h == "useStrictCSP" && a.useStrictCSP(p);
    }, r.all = function() {
      return o.copyObject(u);
    }, r.$modes = {}, r.moduleUrl = function(h, p) {
      if (u.$moduleUrls[h])
        return u.$moduleUrls[h];
      var g = h.split("/");
      p = p || g[g.length - 2] || "";
      var m = p == "snippets" ? "/" : "-", v = g[g.length - 1];
      if (p == "worker" && m == "-") {
        var b = new RegExp("^" + p + "[\\-_]|[\\-_]" + p + "$", "g");
        v = v.replace(b, "");
      }
      (!v || v == p) && g.length > 1 && (v = g[g.length - 2]);
      var x = u[p + "Path"];
      return x == null ? x = u.basePath : m == "/" && (p = m = ""), x && x.slice(-1) != "/" && (x += "/"), x + p + m + v + this.get("suffix");
    }, r.setModuleUrl = function(h, p) {
      return u.$moduleUrls[h] = p;
    };
    var c = function(h, p) {
      if (h === "ace/theme/textmate" || h === "./theme/textmate")
        return p(null, n("./theme/textmate"));
      if (d)
        return d(h, p);
      console.error("loader is not configured");
    }, d;
    r.setLoader = function(h) {
      d = h;
    }, r.dynamicModules = /* @__PURE__ */ Object.create(null), r.$loading = {}, r.$loaded = {}, r.loadModule = function(h, p) {
      var g;
      if (Array.isArray(h))
        var m = h[0], v = h[1];
      else if (typeof h == "string")
        var v = h;
      var b = function(x) {
        if (x && !r.$loading[v])
          return p && p(x);
        if (r.$loading[v] || (r.$loading[v] = []), r.$loading[v].push(p), !(r.$loading[v].length > 1)) {
          var w = function() {
            c(v, function(C, y) {
              y && (r.$loaded[v] = y), r._emit("load.module", { name: v, module: y });
              var S = r.$loading[v];
              r.$loading[v] = null, S.forEach(function(A) {
                A && A(y);
              });
            });
          };
          if (!r.get("packaged"))
            return w();
          s.loadScript(r.moduleUrl(v, m), w), f();
        }
      };
      if (r.dynamicModules[v])
        r.dynamicModules[v]().then(function(x) {
          x.default ? b(x.default) : b(x);
        });
      else {
        try {
          g = this.$require(v);
        } catch {
        }
        b(g || r.$loaded[v]);
      }
    }, r.$require = function(h) {
      if (typeof i.require == "function") {
        var p = "require";
        return i[p](h);
      }
    }, r.setModuleLoader = function(h, p) {
      r.dynamicModules[h] = p;
    };
    var f = function() {
      !u.basePath && !u.workerPath && !u.modePath && !u.themePath && !Object.keys(u.$moduleUrls).length && (console.error("Unable to infer path to ace from script src,", "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes", "or with webpack use ace/webpack-resolver"), f = function() {
      });
    };
    r.version = "1.33.1";
  }), ace.define("ace/loader_build", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/config"], function(n, r, i) {
    n("./lib/fixoldbrowsers");
    var o = n("./config");
    o.setLoader(function(u, c) {
      n([u], function(d) {
        c(null, d);
      });
    });
    var s = /* @__PURE__ */ function() {
      return this || typeof window < "u" && window;
    }();
    i.exports = function(u) {
      o.init = a, o.$require = n, u.require = n;
    }, a(!0);
    function a(u) {
      if (!(!s || !s.document)) {
        o.set("packaged", u || n.packaged || i.packaged || s.define && (void 0).packaged);
        var c = {}, d = "", f = document.currentScript || document._currentScript, h = f && f.ownerDocument || document;
        f && f.src && (d = f.src.split(/[?#]/)[0].split("/").slice(0, -1).join("/") || "");
        for (var p = h.getElementsByTagName("script"), g = 0; g < p.length; g++) {
          var m = p[g], v = m.src || m.getAttribute("src");
          if (v) {
            for (var b = m.attributes, x = 0, w = b.length; x < w; x++) {
              var C = b[x];
              C.name.indexOf("data-ace-") === 0 && (c[l(C.name.replace(/^data-ace-/, ""))] = C.value);
            }
            var y = v.match(/^(.*)\/ace([\-.]\w+)?\.js(\?|$)/);
            y && (d = y[1]);
          }
        }
        d && (c.base = c.base || d, c.packaged = !0), c.basePath = c.base, c.workerPath = c.workerPath || c.base, c.modePath = c.modePath || c.base, c.themePath = c.themePath || c.base, delete c.base;
        for (var S in c)
          typeof c[S] < "u" && o.set(S, c[S]);
      }
    }
    function l(u) {
      return u.replace(/-(.)/g, function(c, d) {
        return d.toUpperCase();
      });
    }
  }), ace.define("ace/range", ["require", "exports", "module"], function(n, r, i) {
    var o = (
      /** @class */
      function() {
        function s(a, l, u, c) {
          this.start = {
            row: a,
            column: l
          }, this.end = {
            row: u,
            column: c
          };
        }
        return s.prototype.isEqual = function(a) {
          return this.start.row === a.start.row && this.end.row === a.end.row && this.start.column === a.start.column && this.end.column === a.end.column;
        }, s.prototype.toString = function() {
          return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
        }, s.prototype.contains = function(a, l) {
          return this.compare(a, l) == 0;
        }, s.prototype.compareRange = function(a) {
          var l, u = a.end, c = a.start;
          return l = this.compare(u.row, u.column), l == 1 ? (l = this.compare(c.row, c.column), l == 1 ? 2 : l == 0 ? 1 : 0) : l == -1 ? -2 : (l = this.compare(c.row, c.column), l == -1 ? -1 : l == 1 ? 42 : 0);
        }, s.prototype.comparePoint = function(a) {
          return this.compare(a.row, a.column);
        }, s.prototype.containsRange = function(a) {
          return this.comparePoint(a.start) == 0 && this.comparePoint(a.end) == 0;
        }, s.prototype.intersects = function(a) {
          var l = this.compareRange(a);
          return l == -1 || l == 0 || l == 1;
        }, s.prototype.isEnd = function(a, l) {
          return this.end.row == a && this.end.column == l;
        }, s.prototype.isStart = function(a, l) {
          return this.start.row == a && this.start.column == l;
        }, s.prototype.setStart = function(a, l) {
          typeof a == "object" ? (this.start.column = a.column, this.start.row = a.row) : (this.start.row = a, this.start.column = l);
        }, s.prototype.setEnd = function(a, l) {
          typeof a == "object" ? (this.end.column = a.column, this.end.row = a.row) : (this.end.row = a, this.end.column = l);
        }, s.prototype.inside = function(a, l) {
          return this.compare(a, l) == 0 ? !(this.isEnd(a, l) || this.isStart(a, l)) : !1;
        }, s.prototype.insideStart = function(a, l) {
          return this.compare(a, l) == 0 ? !this.isEnd(a, l) : !1;
        }, s.prototype.insideEnd = function(a, l) {
          return this.compare(a, l) == 0 ? !this.isStart(a, l) : !1;
        }, s.prototype.compare = function(a, l) {
          return !this.isMultiLine() && a === this.start.row ? l < this.start.column ? -1 : l > this.end.column ? 1 : 0 : a < this.start.row ? -1 : a > this.end.row ? 1 : this.start.row === a ? l >= this.start.column ? 0 : -1 : this.end.row === a ? l <= this.end.column ? 0 : 1 : 0;
        }, s.prototype.compareStart = function(a, l) {
          return this.start.row == a && this.start.column == l ? -1 : this.compare(a, l);
        }, s.prototype.compareEnd = function(a, l) {
          return this.end.row == a && this.end.column == l ? 1 : this.compare(a, l);
        }, s.prototype.compareInside = function(a, l) {
          return this.end.row == a && this.end.column == l ? 1 : this.start.row == a && this.start.column == l ? -1 : this.compare(a, l);
        }, s.prototype.clipRows = function(a, l) {
          if (this.end.row > l)
            var u = { row: l + 1, column: 0 };
          else if (this.end.row < a)
            var u = { row: a, column: 0 };
          if (this.start.row > l)
            var c = { row: l + 1, column: 0 };
          else if (this.start.row < a)
            var c = { row: a, column: 0 };
          return s.fromPoints(c || this.start, u || this.end);
        }, s.prototype.extend = function(a, l) {
          var u = this.compare(a, l);
          if (u == 0)
            return this;
          if (u == -1)
            var c = { row: a, column: l };
          else
            var d = { row: a, column: l };
          return s.fromPoints(c || this.start, d || this.end);
        }, s.prototype.isEmpty = function() {
          return this.start.row === this.end.row && this.start.column === this.end.column;
        }, s.prototype.isMultiLine = function() {
          return this.start.row !== this.end.row;
        }, s.prototype.clone = function() {
          return s.fromPoints(this.start, this.end);
        }, s.prototype.collapseRows = function() {
          return this.end.column == 0 ? new s(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0) : new s(this.start.row, 0, this.end.row, 0);
        }, s.prototype.toScreenRange = function(a) {
          var l = a.documentToScreenPosition(this.start), u = a.documentToScreenPosition(this.end);
          return new s(l.row, l.column, u.row, u.column);
        }, s.prototype.moveBy = function(a, l) {
          this.start.row += a, this.start.column += l, this.end.row += a, this.end.column += l;
        }, s;
      }()
    );
    o.fromPoints = function(s, a) {
      return new o(s.row, s.column, a.row, a.column);
    }, o.comparePoints = function(s, a) {
      return s.row - a.row || s.column - a.column;
    }, r.Range = o;
  }), ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/oop"], function(n, r, i) {
    /*! @license
    	==========================================================================
    	SproutCore -- JavaScript Application Framework
    	copyright 2006-2009, Sprout Systems Inc., Apple Inc. and contributors.
    
    	Permission is hereby granted, free of charge, to any person obtaining a
    	copy of this software and associated documentation files (the "Software"),
    	to deal in the Software without restriction, including without limitation
    	the rights to use, copy, modify, merge, publish, distribute, sublicense,
    	and/or sell copies of the Software, and to permit persons to whom the
    	Software is furnished to do so, subject to the following conditions:
    
    	The above copyright notice and this permission notice shall be included in
    	all copies or substantial portions of the Software.
    
    	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    	DEALINGS IN THE SOFTWARE.
    
    	SproutCore and the SproutCore logo are trademarks of Sprout Systems, Inc.
    
    	For more information about SproutCore, visit http://www.sproutcore.com
    
    
    	==========================================================================
    	@license */
    var o = n("./oop"), s = function() {
      var a = {
        MODIFIER_KEYS: {
          16: "Shift",
          17: "Ctrl",
          18: "Alt",
          224: "Meta",
          91: "MetaLeft",
          92: "MetaRight",
          93: "ContextMenu"
        },
        KEY_MODS: {
          ctrl: 1,
          alt: 2,
          option: 2,
          shift: 4,
          super: 8,
          meta: 8,
          command: 8,
          cmd: 8,
          control: 1
        },
        FUNCTION_KEYS: {
          8: "Backspace",
          9: "Tab",
          13: "Return",
          19: "Pause",
          27: "Esc",
          32: "Space",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "Left",
          38: "Up",
          39: "Right",
          40: "Down",
          44: "Print",
          45: "Insert",
          46: "Delete",
          96: "Numpad0",
          97: "Numpad1",
          98: "Numpad2",
          99: "Numpad3",
          100: "Numpad4",
          101: "Numpad5",
          102: "Numpad6",
          103: "Numpad7",
          104: "Numpad8",
          105: "Numpad9",
          "-13": "NumpadEnter",
          112: "F1",
          113: "F2",
          114: "F3",
          115: "F4",
          116: "F5",
          117: "F6",
          118: "F7",
          119: "F8",
          120: "F9",
          121: "F10",
          122: "F11",
          123: "F12",
          144: "Numlock",
          145: "Scrolllock"
        },
        PRINTABLE_KEYS: {
          32: " ",
          48: "0",
          49: "1",
          50: "2",
          51: "3",
          52: "4",
          53: "5",
          54: "6",
          55: "7",
          56: "8",
          57: "9",
          59: ";",
          61: "=",
          65: "a",
          66: "b",
          67: "c",
          68: "d",
          69: "e",
          70: "f",
          71: "g",
          72: "h",
          73: "i",
          74: "j",
          75: "k",
          76: "l",
          77: "m",
          78: "n",
          79: "o",
          80: "p",
          81: "q",
          82: "r",
          83: "s",
          84: "t",
          85: "u",
          86: "v",
          87: "w",
          88: "x",
          89: "y",
          90: "z",
          107: "+",
          109: "-",
          110: ".",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'",
          111: "/",
          106: "*"
        }
      };
      a.PRINTABLE_KEYS[173] = "-";
      var l, u;
      for (u in a.FUNCTION_KEYS)
        l = a.FUNCTION_KEYS[u].toLowerCase(), a[l] = parseInt(u, 10);
      for (u in a.PRINTABLE_KEYS)
        l = a.PRINTABLE_KEYS[u].toLowerCase(), a[l] = parseInt(u, 10);
      return o.mixin(a, a.MODIFIER_KEYS), o.mixin(a, a.PRINTABLE_KEYS), o.mixin(a, a.FUNCTION_KEYS), a.enter = a.return, a.escape = a.esc, a.del = a.delete, function() {
        for (var c = ["cmd", "ctrl", "alt", "shift"], d = Math.pow(2, c.length); d--; )
          a.KEY_MODS[d] = c.filter(function(f) {
            return d & a.KEY_MODS[f];
          }).join("-") + "-";
      }(), a.KEY_MODS[0] = "", a.KEY_MODS[-1] = "input-", a;
    }();
    o.mixin(r, s), r.default = r, r.keyCodeToString = function(a) {
      var l = s[a];
      return typeof l != "string" && (l = String.fromCharCode(a)), l.toLowerCase();
    };
  }), ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(n, r, i) {
    var o = n("./keys"), s = n("./useragent"), a = null, l = 0, u;
    function c() {
      u = !1;
      try {
        document.createComment("").addEventListener("test", function() {
        }, {
          get passive() {
            return u = { passive: !1 }, !0;
          }
        });
      } catch {
      }
    }
    function d() {
      return u == null && c(), u;
    }
    function f(x, w, C) {
      this.elem = x, this.type = w, this.callback = C;
    }
    f.prototype.destroy = function() {
      p(this.elem, this.type, this.callback), this.elem = this.type = this.callback = void 0;
    };
    var h = r.addListener = function(x, w, C, y) {
      x.addEventListener(w, C, d()), y && y.$toDestroy.push(new f(x, w, C));
    }, p = r.removeListener = function(x, w, C) {
      x.removeEventListener(w, C, d());
    };
    r.stopEvent = function(x) {
      return r.stopPropagation(x), r.preventDefault(x), !1;
    }, r.stopPropagation = function(x) {
      x.stopPropagation && x.stopPropagation();
    }, r.preventDefault = function(x) {
      x.preventDefault && x.preventDefault();
    }, r.getButton = function(x) {
      return x.type == "dblclick" ? 0 : x.type == "contextmenu" || s.isMac && x.ctrlKey && !x.altKey && !x.shiftKey ? 2 : x.button;
    }, r.capture = function(x, w, C) {
      var y = x && x.ownerDocument || document;
      function S(A) {
        w && w(A), C && C(A), p(y, "mousemove", w), p(y, "mouseup", S), p(y, "dragstart", S);
      }
      return h(y, "mousemove", w), h(y, "mouseup", S), h(y, "dragstart", S), S;
    }, r.addMouseWheelListener = function(x, w, C) {
      h(x, "wheel", function(y) {
        var S = 0.15, A = y.deltaX || 0, $ = y.deltaY || 0;
        switch (y.deltaMode) {
          case y.DOM_DELTA_PIXEL:
            y.wheelX = A * S, y.wheelY = $ * S;
            break;
          case y.DOM_DELTA_LINE:
            var M = 15;
            y.wheelX = A * M, y.wheelY = $ * M;
            break;
          case y.DOM_DELTA_PAGE:
            var _ = 150;
            y.wheelX = A * _, y.wheelY = $ * _;
            break;
        }
        w(y);
      }, C);
    }, r.addMultiMouseDownListener = function(x, w, C, y, S) {
      var A = 0, $, M, _, T = {
        2: "dblclick",
        3: "tripleclick",
        4: "quadclick"
      };
      function D(E) {
        if (r.getButton(E) !== 0 ? A = 0 : E.detail > 1 ? (A++, A > 4 && (A = 1)) : A = 1, s.isIE) {
          var R = Math.abs(E.clientX - $) > 5 || Math.abs(E.clientY - M) > 5;
          (!_ || R) && (A = 1), _ && clearTimeout(_), _ = setTimeout(function() {
            _ = null;
          }, w[A - 1] || 600), A == 1 && ($ = E.clientX, M = E.clientY);
        }
        if (E._clicks = A, C[y]("mousedown", E), A > 4)
          A = 0;
        else if (A > 1)
          return C[y](T[A], E);
      }
      Array.isArray(x) || (x = [x]), x.forEach(function(E) {
        h(E, "mousedown", D, S);
      });
    };
    function g(x) {
      return 0 | (x.ctrlKey ? 1 : 0) | (x.altKey ? 2 : 0) | (x.shiftKey ? 4 : 0) | (x.metaKey ? 8 : 0);
    }
    r.getModifierString = function(x) {
      return o.KEY_MODS[g(x)];
    };
    function m(x, w, C) {
      var y = g(w);
      if (!s.isMac && a) {
        if (w.getModifierState && (w.getModifierState("OS") || w.getModifierState("Win")) && (y |= 8), a.altGr)
          if ((3 & y) != 3)
            a.altGr = 0;
          else
            return;
        if (C === 18 || C === 17) {
          var S = w.location;
          if (C === 17 && S === 1)
            a[C] == 1 && (l = w.timeStamp);
          else if (C === 18 && y === 3 && S === 2) {
            var A = w.timeStamp - l;
            A < 50 && (a.altGr = !0);
          }
        }
      }
      if (C in o.MODIFIER_KEYS && (C = -1), !(!y && C === 13 && w.location === 3 && (x(w, y, -C), w.defaultPrevented))) {
        if (s.isChromeOS && y & 8) {
          if (x(w, y, C), w.defaultPrevented)
            return;
          y &= -9;
        }
        return !y && !(C in o.FUNCTION_KEYS) && !(C in o.PRINTABLE_KEYS) ? !1 : x(w, y, C);
      }
    }
    r.addCommandKeyListener = function(x, w, C) {
      var y = null;
      h(x, "keydown", function(S) {
        a[S.keyCode] = (a[S.keyCode] || 0) + 1;
        var A = m(w, S, S.keyCode);
        return y = S.defaultPrevented, A;
      }, C), h(x, "keypress", function(S) {
        y && (S.ctrlKey || S.altKey || S.shiftKey || S.metaKey) && (r.stopEvent(S), y = null);
      }, C), h(x, "keyup", function(S) {
        a[S.keyCode] = null;
      }, C), a || (v(), h(window, "focus", v));
    };
    function v() {
      a = /* @__PURE__ */ Object.create(null);
    }
    if (typeof window == "object" && window.postMessage && !s.isOldIE) {
      var b = 1;
      r.nextTick = function(x, w) {
        w = w || window;
        var C = "zero-timeout-message-" + b++, y = function(S) {
          S.data == C && (r.stopPropagation(S), p(w, "message", y), x());
        };
        h(w, "message", y), w.postMessage(C, "*");
      };
    }
    r.$idleBlocked = !1, r.onIdle = function(x, w) {
      return setTimeout(function C() {
        r.$idleBlocked ? setTimeout(C, 100) : x();
      }, w);
    }, r.$idleBlockId = null, r.blockIdle = function(x) {
      r.$idleBlockId && clearTimeout(r.$idleBlockId), r.$idleBlocked = !0, r.$idleBlockId = setTimeout(function() {
        r.$idleBlocked = !1;
      }, x || 100);
    }, r.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame), r.nextFrame ? r.nextFrame = r.nextFrame.bind(window) : r.nextFrame = function(x) {
      setTimeout(x, 17);
    };
  }), ace.define("ace/clipboard", ["require", "exports", "module"], function(n, r, i) {
    var o;
    i.exports = {
      lineMode: !1,
      pasteCancelled: function() {
        return o && o > Date.now() - 50 ? !0 : o = !1;
      },
      cancel: function() {
        o = Date.now();
      }
    };
  }), ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/config", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang", "ace/clipboard", "ace/lib/keys"], function(n, r, i) {
    var o = n("../lib/event"), s = n("../config").nls, a = n("../lib/useragent"), l = n("../lib/dom"), u = n("../lib/lang"), c = n("../clipboard"), d = a.isChrome < 18, f = a.isIE, h = a.isChrome > 63, p = 400, g = n("../lib/keys"), m = g.KEY_MODS, v = a.isIOS, b = v ? /\s/ : /\n/, x = a.isMobile, w;
    w = function(C, y) {
      var S = l.createElement("textarea");
      S.className = "ace_text-input", S.setAttribute("wrap", "off"), S.setAttribute("autocorrect", "off"), S.setAttribute("autocapitalize", "off"), S.setAttribute("spellcheck", "false"), S.style.opacity = "0", C.insertBefore(S, C.firstChild);
      var A = !1, $ = !1, M = !1, _ = !1, T = "";
      x || (S.style.fontSize = "1px");
      var D = !1, E = !1, R = "", I = 0, k = 0, P = 0, L = Number.MAX_SAFE_INTEGER, N = Number.MIN_SAFE_INTEGER, F = 0;
      try {
        var B = document.activeElement === S;
      } catch {
      }
      this.setNumberOfExtraLines = function(oe) {
        if (L = Number.MAX_SAFE_INTEGER, N = Number.MIN_SAFE_INTEGER, oe < 0) {
          F = 0;
          return;
        }
        F = oe;
      }, this.setAriaOptions = function(oe) {
        if (oe.activeDescendant ? (S.setAttribute("aria-haspopup", "true"), S.setAttribute("aria-autocomplete", oe.inline ? "both" : "list"), S.setAttribute("aria-activedescendant", oe.activeDescendant)) : (S.setAttribute("aria-haspopup", "false"), S.setAttribute("aria-autocomplete", "both"), S.removeAttribute("aria-activedescendant")), oe.role && S.setAttribute("role", oe.role), oe.setLabel && (S.setAttribute("aria-roledescription", s("text-input.aria-roledescription", "editor")), y.session)) {
          var Ce = y.session.selection.cursor.row;
          S.setAttribute("aria-label", s("text-input.aria-label", "Cursor at row $0", [Ce + 1]));
        }
      }, this.setAriaOptions({ role: "textbox" }), o.addListener(S, "blur", function(oe) {
        E || (y.onBlur(oe), B = !1);
      }, y), o.addListener(S, "focus", function(oe) {
        if (!E) {
          if (B = !0, a.isEdge)
            try {
              if (!document.hasFocus())
                return;
            } catch {
            }
          y.onFocus(oe), a.isEdge ? setTimeout(z) : z();
        }
      }, y), this.$focusScroll = !1, this.focus = function() {
        if (this.setAriaOptions({
          setLabel: y.renderer.enableKeyboardAccessibility
        }), T || h || this.$focusScroll == "browser")
          return S.focus({ preventScroll: !0 });
        var oe = S.style.top;
        S.style.position = "fixed", S.style.top = "0px";
        try {
          var Ce = S.getBoundingClientRect().top != 0;
        } catch {
          return;
        }
        var ge = [];
        if (Ce)
          for (var ve = S.parentElement; ve && ve.nodeType == 1; )
            ge.push(ve), ve.setAttribute("ace_nocontext", "true"), !ve.parentElement && ve.getRootNode ? ve = ve.getRootNode().host : ve = ve.parentElement;
        S.focus({ preventScroll: !0 }), Ce && ge.forEach(function(me) {
          me.removeAttribute("ace_nocontext");
        }), setTimeout(function() {
          S.style.position = "", S.style.top == "0px" && (S.style.top = oe);
        }, 0);
      }, this.blur = function() {
        S.blur();
      }, this.isFocused = function() {
        return B;
      }, y.on("beforeEndOperation", function() {
        var oe = y.curOp, Ce = oe && oe.command && oe.command.name;
        if (Ce != "insertstring") {
          var ge = Ce && (oe.docChanged || oe.selectionChanged);
          M && ge && (R = S.value = "", de()), z();
        }
      });
      var j = function(oe, Ce) {
        for (var ge = Ce, ve = 1; ve <= oe - L && ve < 2 * F + 1; ve++)
          ge += y.session.getLine(oe - ve).length + 1;
        return ge;
      }, z = v ? function(oe) {
        if (!(!B || A && !oe || _)) {
          oe || (oe = "");
          var Ce = `
 ab` + oe + `cde fg
`;
          Ce != S.value && (S.value = R = Ce);
          var ge = 4, ve = 4 + (oe.length || (y.selection.isEmpty() ? 0 : 1));
          (I != ge || k != ve) && S.setSelectionRange(ge, ve), I = ge, k = ve;
        }
      } : function() {
        if (!(M || _) && !(!B && !K)) {
          M = !0;
          var oe = 0, Ce = 0, ge = "";
          if (y.session) {
            var ve = y.selection, me = ve.getRange(), Fe = ve.cursor.row;
            Fe === N + 1 ? (L = N + 1, N = L + 2 * F) : Fe === L - 1 ? (N = L - 1, L = N - 2 * F) : (Fe < L - 1 || Fe > N + 1) && (L = Fe > F ? Fe - F : 0, N = Fe > F ? Fe + F : 2 * F);
            for (var Be = [], qe = L; qe <= N; qe++)
              Be.push(y.session.getLine(qe));
            if (ge = Be.join(`
`), oe = j(me.start.row, me.start.column), Ce = j(me.end.row, me.end.column), me.start.row < L) {
              var Ve = y.session.getLine(L - 1);
              oe = me.start.row < L - 1 ? 0 : oe, Ce += Ve.length + 1, ge = Ve + `
` + ge;
            } else if (me.end.row > N) {
              var We = y.session.getLine(N + 1);
              Ce = me.end.row > N + 1 ? We.length : me.end.column, Ce += ge.length + 1, ge = ge + `
` + We;
            } else
              x && Fe > 0 && (ge = `
` + ge, Ce += 1, oe += 1);
            ge.length > p && (oe < p && Ce < p ? ge = ge.slice(0, p) : (ge = `
`, oe == Ce ? oe = Ce = 0 : (oe = 0, Ce = 1)));
            var Ge = ge + `

`;
            Ge != R && (S.value = R = Ge, I = k = Ge.length);
          }
          if (K && (I = S.selectionStart, k = S.selectionEnd), k != Ce || I != oe || S.selectionEnd != k)
            try {
              S.setSelectionRange(oe, Ce), I = oe, k = Ce;
            } catch {
            }
          M = !1;
        }
      };
      this.resetSelection = z, B && y.onFocus();
      var H = function(oe) {
        return oe.selectionStart === 0 && oe.selectionEnd >= R.length && oe.value === R && R && oe.selectionEnd !== k;
      }, W = function(oe) {
        M || (A ? A = !1 : H(S) ? (y.selectAll(), z()) : x && S.selectionStart != I && z());
      }, G = null;
      this.setInputHandler = function(oe) {
        G = oe;
      }, this.getInputHandler = function() {
        return G;
      };
      var K = !1, Y = function(oe, Ce) {
        if (K && (K = !1), $)
          return z(), oe && y.onPaste(oe), $ = !1, "";
        for (var ge = S.selectionStart, ve = S.selectionEnd, me = I, Fe = R.length - k, Be = oe, qe = oe.length - ge, Ve = oe.length - ve, We = 0; me > 0 && R[We] == oe[We]; )
          We++, me--;
        for (Be = Be.slice(We), We = 1; Fe > 0 && R.length - We > I - 1 && R[R.length - We] == oe[oe.length - We]; )
          We++, Fe--;
        qe -= We - 1, Ve -= We - 1;
        var Ge = Be.length - We + 1;
        if (Ge < 0 && (me = -Ge, Ge = 0), Be = Be.slice(0, Ge), !Ce && !Be && !qe && !me && !Fe && !Ve)
          return "";
        _ = !0;
        var $e = !1;
        return a.isAndroid && Be == ". " && (Be = "  ", $e = !0), Be && !me && !Fe && !qe && !Ve || D ? y.onTextInput(Be) : y.onTextInput(Be, {
          extendLeft: me,
          extendRight: Fe,
          restoreStart: qe,
          restoreEnd: Ve
        }), _ = !1, R = oe, I = ge, k = ve, P = Ve, $e ? `
` : Be;
      }, X = function(oe) {
        if (M)
          return Se();
        if (oe && oe.inputType) {
          if (oe.inputType == "historyUndo")
            return y.execCommand("undo");
          if (oe.inputType == "historyRedo")
            return y.execCommand("redo");
        }
        var Ce = S.value, ge = Y(Ce, !0);
        (Ce.length > p + 100 || b.test(ge) || x && I < 1 && I == k) && z();
      }, Z = function(oe, Ce, ge) {
        var ve = oe.clipboardData || window.clipboardData;
        if (!(!ve || d)) {
          var me = f || ge ? "Text" : "text/plain";
          try {
            return Ce ? ve.setData(me, Ce) !== !1 : ve.getData(me);
          } catch (Fe) {
            if (!ge)
              return Z(Fe, Ce, !0);
          }
        }
      }, Q = function(oe, Ce) {
        var ge = y.getCopyText();
        if (!ge)
          return o.preventDefault(oe);
        Z(oe, ge) ? (v && (z(ge), A = ge, setTimeout(function() {
          A = !1;
        }, 10)), Ce ? y.onCut() : y.onCopy(), o.preventDefault(oe)) : (A = !0, S.value = ge, S.select(), setTimeout(function() {
          A = !1, z(), Ce ? y.onCut() : y.onCopy();
        }));
      }, ne = function(oe) {
        Q(oe, !0);
      }, q = function(oe) {
        Q(oe, !1);
      }, te = function(oe) {
        var Ce = Z(oe);
        c.pasteCancelled() || (typeof Ce == "string" ? (Ce && y.onPaste(Ce, oe), a.isIE && setTimeout(z), o.preventDefault(oe)) : (S.value = "", $ = !0));
      };
      o.addCommandKeyListener(S, function(oe, Ce, ge) {
        if (!M)
          return y.onCommandKey(oe, Ce, ge);
      }, y), o.addListener(S, "select", W, y), o.addListener(S, "input", X, y), o.addListener(S, "cut", ne, y), o.addListener(S, "copy", q, y), o.addListener(S, "paste", te, y), (!("oncut" in S) || !("oncopy" in S) || !("onpaste" in S)) && o.addListener(C, "keydown", function(oe) {
        if (!(a.isMac && !oe.metaKey || !oe.ctrlKey))
          switch (oe.keyCode) {
            case 67:
              q(oe);
              break;
            case 86:
              te(oe);
              break;
            case 88:
              ne(oe);
              break;
          }
      }, y);
      var fe = function(oe) {
        if (!(M || !y.onCompositionStart || y.$readOnly) && (M = {}, !D)) {
          oe.data && (M.useTextareaForIME = !1), setTimeout(Se, 0), y._signal("compositionStart"), y.on("mousedown", ce);
          var Ce = y.getSelectionRange();
          Ce.end.row = Ce.start.row, Ce.end.column = Ce.start.column, M.markerRange = Ce, M.selectionStart = I, y.onCompositionStart(M), M.useTextareaForIME ? (R = S.value = "", I = 0, k = 0) : (S.msGetInputContext && (M.context = S.msGetInputContext()), S.getInputContext && (M.context = S.getInputContext()));
        }
      }, Se = function() {
        if (!(!M || !y.onCompositionUpdate || y.$readOnly)) {
          if (D)
            return ce();
          if (M.useTextareaForIME)
            y.onCompositionUpdate(S.value);
          else {
            var oe = S.value;
            Y(oe), M.markerRange && (M.context && (M.markerRange.start.column = M.selectionStart = M.context.compositionStartOffset), M.markerRange.end.column = M.markerRange.start.column + k - M.selectionStart + P);
          }
        }
      }, de = function(oe) {
        !y.onCompositionEnd || y.$readOnly || (M = !1, y.onCompositionEnd(), y.off("mousedown", ce), oe && X());
      };
      function ce() {
        E = !0, S.blur(), S.focus(), E = !1;
      }
      var pe = u.delayedCall(Se, 50).schedule.bind(null, null);
      function Oe(oe) {
        oe.keyCode == 27 && S.value.length < S.selectionStart && (M || (R = S.value), I = k = -1, z()), pe();
      }
      o.addListener(S, "compositionstart", fe, y), o.addListener(S, "compositionupdate", Se, y), o.addListener(S, "keyup", Oe, y), o.addListener(S, "keydown", pe, y), o.addListener(S, "compositionend", de, y), this.getElement = function() {
        return S;
      }, this.setCommandMode = function(oe) {
        D = oe, S.readOnly = !1;
      }, this.setReadOnly = function(oe) {
        D || (S.readOnly = oe);
      }, this.setCopyWithEmptySelection = function(oe) {
      }, this.onContextMenu = function(oe) {
        K = !0, z(), y._emit("nativecontextmenu", { target: y, domEvent: oe }), this.moveToMouse(oe, !0);
      }, this.moveToMouse = function(oe, Ce) {
        T || (T = S.style.cssText), S.style.cssText = (Ce ? "z-index:100000;" : "") + (a.isIE ? "opacity:0.1;" : "") + "text-indent: -" + (I + k) * y.renderer.characterWidth * 0.5 + "px;";
        var ge = y.container.getBoundingClientRect(), ve = l.computedStyle(y.container), me = ge.top + (parseInt(ve.borderTopWidth) || 0), Fe = ge.left + (parseInt(ge.borderLeftWidth) || 0), Be = ge.bottom - me - S.clientHeight - 2, qe = function(Ve) {
          l.translate(S, Ve.clientX - Fe - 2, Math.min(Ve.clientY - me - 2, Be));
        };
        qe(oe), oe.type == "mousedown" && (y.renderer.$isMousePressed = !0, clearTimeout(Re), a.isWin && o.capture(y.container, qe, De));
      }, this.onContextMenuClose = De;
      var Re;
      function De() {
        clearTimeout(Re), Re = setTimeout(function() {
          T && (S.style.cssText = T, T = ""), y.renderer.$isMousePressed = !1, y.renderer.$keepTextAreaAtCursor && y.renderer.$moveTextAreaToCursor();
        }, 0);
      }
      var Me = function(oe) {
        y.textInput.onContextMenu(oe), De();
      };
      o.addListener(S, "mouseup", Me, y), o.addListener(S, "mousedown", function(oe) {
        oe.preventDefault(), De();
      }, y), o.addListener(y.renderer.scroller, "contextmenu", Me, y), o.addListener(S, "contextmenu", Me, y), v && Ue(C, y, S);
      function Ue(oe, Ce, ge) {
        var ve = null, me = !1;
        ge.addEventListener("keydown", function(Be) {
          ve && clearTimeout(ve), me = !0;
        }, !0), ge.addEventListener("keyup", function(Be) {
          ve = setTimeout(function() {
            me = !1;
          }, 100);
        }, !0);
        var Fe = function(Be) {
          if (document.activeElement === ge && !(me || M || Ce.$mouseHandler.isMousePressed) && !A) {
            var qe = ge.selectionStart, Ve = ge.selectionEnd, We = null, Ge = 0;
            if (qe == 0 ? We = g.up : qe == 1 ? We = g.home : Ve > k && R[Ve] == `
` ? We = g.end : qe < I && R[qe - 1] == " " ? (We = g.left, Ge = m.option) : qe < I || qe == I && k != I && qe == Ve ? We = g.left : Ve > k && R.slice(0, Ve).split(`
`).length > 2 ? We = g.down : Ve > k && R[Ve - 1] == " " ? (We = g.right, Ge = m.option) : (Ve > k || Ve == k && k != I && qe == Ve) && (We = g.right), qe !== Ve && (Ge |= m.shift), We) {
              var $e = Ce.onCommandKey({}, Ge, We);
              if (!$e && Ce.commands) {
                We = g.keyCodeToString(We);
                var ze = Ce.commands.findKeyCommand(Ge, We);
                ze && Ce.execCommand(ze);
              }
              I = qe, k = Ve, z("");
            }
          }
        };
        document.addEventListener("selectionchange", Fe), Ce.on("destroy", function() {
          document.removeEventListener("selectionchange", Fe);
        });
      }
      this.destroy = function() {
        S.parentElement && S.parentElement.removeChild(S);
      };
    }, r.TextInput = w, r.$setUserAgentForTests = function(C, y) {
      x = C, v = y;
    };
  }), ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/useragent"], function(n, r, i) {
    var o = n("../lib/useragent"), s = 0, a = 550, l = (
      /** @class */
      function() {
        function d(f) {
          f.$clickSelection = null;
          var h = f.editor;
          h.setDefaultHandler("mousedown", this.onMouseDown.bind(f)), h.setDefaultHandler("dblclick", this.onDoubleClick.bind(f)), h.setDefaultHandler("tripleclick", this.onTripleClick.bind(f)), h.setDefaultHandler("quadclick", this.onQuadClick.bind(f)), h.setDefaultHandler("mousewheel", this.onMouseWheel.bind(f));
          var p = [
            "select",
            "startSelect",
            "selectEnd",
            "selectAllEnd",
            "selectByWordsEnd",
            "selectByLinesEnd",
            "dragWait",
            "dragWaitEnd",
            "focusWait"
          ];
          p.forEach(function(g) {
            f[g] = this[g];
          }, this), f.selectByLines = this.extendSelectionBy.bind(f, "getLineRange"), f.selectByWords = this.extendSelectionBy.bind(f, "getWordRange");
        }
        return d.prototype.onMouseDown = function(f) {
          var h = f.inSelection(), p = f.getDocumentPosition();
          this.mousedownEvent = f;
          var g = this.editor, m = f.getButton();
          if (m !== 0) {
            var v = g.getSelectionRange(), b = v.isEmpty();
            (b || m == 1) && g.selection.moveToPosition(p), m == 2 && (g.textInput.onContextMenu(f.domEvent), o.isMozilla || f.preventDefault());
            return;
          }
          if (this.mousedownEvent.time = Date.now(), h && !g.isFocused() && (g.focus(), this.$focusTimeout && !this.$clickSelection && !g.inMultiSelectMode)) {
            this.setState("focusWait"), this.captureMouse(f);
            return;
          }
          return this.captureMouse(f), this.startSelect(p, f.domEvent._clicks > 1), f.preventDefault();
        }, d.prototype.startSelect = function(f, h) {
          f = f || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
          var p = this.editor;
          this.mousedownEvent && (this.mousedownEvent.getShiftKey() ? p.selection.selectToPosition(f) : h || p.selection.moveToPosition(f), h || this.select(), p.setStyle("ace_selecting"), this.setState("select"));
        }, d.prototype.select = function() {
          var f, h = this.editor, p = h.renderer.screenToTextCoordinates(this.x, this.y);
          if (this.$clickSelection) {
            var g = this.$clickSelection.comparePoint(p);
            if (g == -1)
              f = this.$clickSelection.end;
            else if (g == 1)
              f = this.$clickSelection.start;
            else {
              var m = c(this.$clickSelection, p);
              p = m.cursor, f = m.anchor;
            }
            h.selection.setSelectionAnchor(f.row, f.column);
          }
          h.selection.selectToPosition(p), h.renderer.scrollCursorIntoView();
        }, d.prototype.extendSelectionBy = function(f) {
          var h, p = this.editor, g = p.renderer.screenToTextCoordinates(this.x, this.y), m = p.selection[f](g.row, g.column);
          if (this.$clickSelection) {
            var v = this.$clickSelection.comparePoint(m.start), b = this.$clickSelection.comparePoint(m.end);
            if (v == -1 && b <= 0)
              h = this.$clickSelection.end, (m.end.row != g.row || m.end.column != g.column) && (g = m.start);
            else if (b == 1 && v >= 0)
              h = this.$clickSelection.start, (m.start.row != g.row || m.start.column != g.column) && (g = m.end);
            else if (v == -1 && b == 1)
              g = m.end, h = m.start;
            else {
              var x = c(this.$clickSelection, g);
              g = x.cursor, h = x.anchor;
            }
            p.selection.setSelectionAnchor(h.row, h.column);
          }
          p.selection.selectToPosition(g), p.renderer.scrollCursorIntoView();
        }, d.prototype.selectByLinesEnd = function() {
          this.$clickSelection = null, this.editor.unsetStyle("ace_selecting");
        }, d.prototype.focusWait = function() {
          var f = u(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y), h = Date.now();
          (f > s || h - this.mousedownEvent.time > this.$focusTimeout) && this.startSelect(this.mousedownEvent.getDocumentPosition());
        }, d.prototype.onDoubleClick = function(f) {
          var h = f.getDocumentPosition(), p = this.editor, g = p.session, m = g.getBracketRange(h);
          m ? (m.isEmpty() && (m.start.column--, m.end.column++), this.setState("select")) : (m = p.selection.getWordRange(h.row, h.column), this.setState("selectByWords")), this.$clickSelection = m, this.select();
        }, d.prototype.onTripleClick = function(f) {
          var h = f.getDocumentPosition(), p = this.editor;
          this.setState("selectByLines");
          var g = p.getSelectionRange();
          g.isMultiLine() && g.contains(h.row, h.column) ? (this.$clickSelection = p.selection.getLineRange(g.start.row), this.$clickSelection.end = p.selection.getLineRange(g.end.row).end) : this.$clickSelection = p.selection.getLineRange(h.row), this.select();
        }, d.prototype.onQuadClick = function(f) {
          var h = this.editor;
          h.selectAll(), this.$clickSelection = h.getSelectionRange(), this.setState("selectAll");
        }, d.prototype.onMouseWheel = function(f) {
          if (!f.getAccelKey()) {
            f.getShiftKey() && f.wheelY && !f.wheelX && (f.wheelX = f.wheelY, f.wheelY = 0);
            var h = this.editor;
            this.$lastScroll || (this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 });
            var p = this.$lastScroll, g = f.domEvent.timeStamp, m = g - p.t, v = m ? f.wheelX / m : p.vx, b = m ? f.wheelY / m : p.vy;
            m < a && (v = (v + p.vx) / 2, b = (b + p.vy) / 2);
            var x = Math.abs(v / b), w = !1;
            if (x >= 1 && h.renderer.isScrollableBy(f.wheelX * f.speed, 0) && (w = !0), x <= 1 && h.renderer.isScrollableBy(0, f.wheelY * f.speed) && (w = !0), w)
              p.allowed = g;
            else if (g - p.allowed < a) {
              var C = Math.abs(v) <= 1.5 * Math.abs(p.vx) && Math.abs(b) <= 1.5 * Math.abs(p.vy);
              C ? (w = !0, p.allowed = g) : p.allowed = 0;
            }
            if (p.t = g, p.vx = v, p.vy = b, w)
              return h.renderer.scrollBy(f.wheelX * f.speed, f.wheelY * f.speed), f.stop();
          }
        }, d;
      }()
    );
    l.prototype.selectEnd = l.prototype.selectByLinesEnd, l.prototype.selectAllEnd = l.prototype.selectByLinesEnd, l.prototype.selectByWordsEnd = l.prototype.selectByLinesEnd, r.DefaultHandlers = l;
    function u(d, f, h, p) {
      return Math.sqrt(Math.pow(h - d, 2) + Math.pow(p - f, 2));
    }
    function c(d, f) {
      if (d.start.row == d.end.row)
        var h = 2 * f.column - d.start.column - d.end.column;
      else if (d.start.row == d.end.row - 1 && !d.start.column && !d.end.column)
        var h = f.column - 4;
      else
        var h = 2 * f.row - d.start.row - d.end.row;
      return h < 0 ? { cursor: d.start, anchor: d.end } : { cursor: d.end, anchor: d.start };
    }
  }), ace.define("ace/lib/scroll", ["require", "exports", "module"], function(n, r, i) {
    r.preventParentScroll = function(s) {
      s.stopPropagation();
      var a = s.currentTarget, l = a.scrollHeight > a.clientHeight;
      l || s.preventDefault();
    };
  }), ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/range", "ace/lib/scroll"], function(n, r, i) {
    var o = this && this.__extends || /* @__PURE__ */ function() {
      var g = function(m, v) {
        return g = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(b, x) {
          b.__proto__ = x;
        } || function(b, x) {
          for (var w in x)
            Object.prototype.hasOwnProperty.call(x, w) && (b[w] = x[w]);
        }, g(m, v);
      };
      return function(m, v) {
        if (typeof v != "function" && v !== null)
          throw new TypeError("Class extends value " + String(v) + " is not a constructor or null");
        g(m, v);
        function b() {
          this.constructor = m;
        }
        m.prototype = v === null ? Object.create(v) : (b.prototype = v.prototype, new b());
      };
    }(), s = this && this.__values || function(g) {
      var m = typeof Symbol == "function" && Symbol.iterator, v = m && g[m], b = 0;
      if (v)
        return v.call(g);
      if (g && typeof g.length == "number")
        return {
          next: function() {
            return g && b >= g.length && (g = void 0), { value: g && g[b++], done: !g };
          }
        };
      throw new TypeError(m ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }, a = n("./lib/dom");
    n("./lib/event");
    var l = n("./range").Range, u = n("./lib/scroll").preventParentScroll, c = "ace_tooltip", d = (
      /** @class */
      function() {
        function g(m) {
          this.isOpen = !1, this.$element = null, this.$parentNode = m;
        }
        return g.prototype.$init = function() {
          return this.$element = a.createElement("div"), this.$element.className = c, this.$element.style.display = "none", this.$parentNode.appendChild(this.$element), this.$element;
        }, g.prototype.getElement = function() {
          return this.$element || this.$init();
        }, g.prototype.setText = function(m) {
          this.getElement().textContent = m;
        }, g.prototype.setHtml = function(m) {
          this.getElement().innerHTML = m;
        }, g.prototype.setPosition = function(m, v) {
          this.getElement().style.left = m + "px", this.getElement().style.top = v + "px";
        }, g.prototype.setClassName = function(m) {
          a.addCssClass(this.getElement(), m);
        }, g.prototype.setTheme = function(m) {
          this.$element.className = c + " " + (m.isDark ? "ace_dark " : "") + (m.cssClass || "");
        }, g.prototype.show = function(m, v, b) {
          m != null && this.setText(m), v != null && b != null && this.setPosition(v, b), this.isOpen || (this.getElement().style.display = "block", this.isOpen = !0);
        }, g.prototype.hide = function(m) {
          this.isOpen && (this.getElement().style.display = "none", this.getElement().className = c, this.isOpen = !1);
        }, g.prototype.getHeight = function() {
          return this.getElement().offsetHeight;
        }, g.prototype.getWidth = function() {
          return this.getElement().offsetWidth;
        }, g.prototype.destroy = function() {
          this.isOpen = !1, this.$element && this.$element.parentNode && this.$element.parentNode.removeChild(this.$element);
        }, g;
      }()
    ), f = (
      /** @class */
      function() {
        function g() {
          this.popups = [];
        }
        return g.prototype.addPopup = function(m) {
          this.popups.push(m), this.updatePopups();
        }, g.prototype.removePopup = function(m) {
          var v = this.popups.indexOf(m);
          v !== -1 && (this.popups.splice(v, 1), this.updatePopups());
        }, g.prototype.updatePopups = function() {
          var m, v, b, x;
          this.popups.sort(function(T, D) {
            return D.priority - T.priority;
          });
          var w = [];
          try {
            for (var C = s(this.popups), y = C.next(); !y.done; y = C.next()) {
              var S = y.value, A = !0;
              try {
                for (var $ = (b = void 0, s(w)), M = $.next(); !M.done; M = $.next()) {
                  var _ = M.value;
                  if (this.doPopupsOverlap(_, S)) {
                    A = !1;
                    break;
                  }
                }
              } catch (T) {
                b = { error: T };
              } finally {
                try {
                  M && !M.done && (x = $.return) && x.call($);
                } finally {
                  if (b)
                    throw b.error;
                }
              }
              A ? w.push(S) : S.hide();
            }
          } catch (T) {
            m = { error: T };
          } finally {
            try {
              y && !y.done && (v = C.return) && v.call(C);
            } finally {
              if (m)
                throw m.error;
            }
          }
        }, g.prototype.doPopupsOverlap = function(m, v) {
          var b = m.getElement().getBoundingClientRect(), x = v.getElement().getBoundingClientRect();
          return b.left < x.right && b.right > x.left && b.top < x.bottom && b.bottom > x.top;
        }, g;
      }()
    ), h = new f();
    r.popupManager = h, r.Tooltip = d;
    var p = (
      /** @class */
      function(g) {
        o(m, g);
        function m(v) {
          v === void 0 && (v = document.body);
          var b = g.call(this, v) || this;
          b.timeout = void 0, b.lastT = 0, b.idleTime = 350, b.lastEvent = void 0, b.onMouseOut = b.onMouseOut.bind(b), b.onMouseMove = b.onMouseMove.bind(b), b.waitForHover = b.waitForHover.bind(b), b.hide = b.hide.bind(b);
          var x = b.getElement();
          return x.style.whiteSpace = "pre-wrap", x.style.pointerEvents = "auto", x.addEventListener("mouseout", b.onMouseOut), x.tabIndex = -1, x.addEventListener("blur", (function() {
            x.contains(document.activeElement) || this.hide();
          }).bind(b)), x.addEventListener("wheel", u), b;
        }
        return m.prototype.addToEditor = function(v) {
          v.on("mousemove", this.onMouseMove), v.on("mousedown", this.hide), v.renderer.getMouseEventTarget().addEventListener("mouseout", this.onMouseOut, !0);
        }, m.prototype.removeFromEditor = function(v) {
          v.off("mousemove", this.onMouseMove), v.off("mousedown", this.hide), v.renderer.getMouseEventTarget().removeEventListener("mouseout", this.onMouseOut, !0), this.timeout && (clearTimeout(this.timeout), this.timeout = null);
        }, m.prototype.onMouseMove = function(v, b) {
          this.lastEvent = v, this.lastT = Date.now();
          var x = b.$mouseHandler.isMousePressed;
          if (this.isOpen) {
            var w = this.lastEvent && this.lastEvent.getDocumentPosition();
            (!this.range || !this.range.contains(w.row, w.column) || x || this.isOutsideOfText(this.lastEvent)) && this.hide();
          }
          this.timeout || x || (this.lastEvent = v, this.timeout = setTimeout(this.waitForHover, this.idleTime));
        }, m.prototype.waitForHover = function() {
          this.timeout && clearTimeout(this.timeout);
          var v = Date.now() - this.lastT;
          if (this.idleTime - v > 10) {
            this.timeout = setTimeout(this.waitForHover, this.idleTime - v);
            return;
          }
          this.timeout = null, this.lastEvent && !this.isOutsideOfText(this.lastEvent) && this.$gatherData(this.lastEvent, this.lastEvent.editor);
        }, m.prototype.isOutsideOfText = function(v) {
          var b = v.editor, x = v.getDocumentPosition(), w = b.session.getLine(x.row);
          if (x.column == w.length) {
            var C = b.renderer.pixelToScreenCoordinates(v.clientX, v.clientY), y = b.session.documentToScreenPosition(x.row, x.column);
            if (y.column != C.column || y.row != C.row)
              return !0;
          }
          return !1;
        }, m.prototype.setDataProvider = function(v) {
          this.$gatherData = v;
        }, m.prototype.showForRange = function(v, b, x, w) {
          var C = 10;
          if (!(w && w != this.lastEvent) && !(this.isOpen && document.activeElement == this.getElement())) {
            var y = v.renderer;
            this.isOpen || (h.addPopup(this), this.$registerCloseEvents(), this.setTheme(y.theme)), this.isOpen = !0, this.addMarker(b, v.session), this.range = l.fromPoints(b.start, b.end);
            var S = y.textToScreenCoordinates(b.start.row, b.start.column), A = y.scroller.getBoundingClientRect();
            S.pageX < A.left && (S.pageX = A.left);
            var $ = this.getElement();
            $.innerHTML = "", $.appendChild(x), $.style.maxHeight = "", $.style.display = "block";
            var M = $.clientHeight, _ = $.clientWidth, T = window.innerHeight - S.pageY - y.lineHeight, D = !0;
            S.pageY - M < 0 && S.pageY < T && (D = !1), $.style.maxHeight = (D ? S.pageY : T) - C + "px", $.style.top = D ? "" : S.pageY + y.lineHeight + "px", $.style.bottom = D ? window.innerHeight - S.pageY + "px" : "", $.style.left = Math.min(S.pageX, window.innerWidth - _ - C) + "px";
          }
        }, m.prototype.addMarker = function(v, b) {
          this.marker && this.$markerSession.removeMarker(this.marker), this.$markerSession = b, this.marker = b && b.addMarker(v, "ace_highlight-marker", "text");
        }, m.prototype.hide = function(v) {
          !v && document.activeElement == this.getElement() || v && v.target && (v.type != "keydown" || v.ctrlKey || v.metaKey) && this.$element.contains(v.target) || (this.lastEvent = null, this.timeout && clearTimeout(this.timeout), this.timeout = null, this.addMarker(null), this.isOpen && (this.$removeCloseEvents(), this.getElement().style.display = "none", this.isOpen = !1, h.removePopup(this)));
        }, m.prototype.$registerCloseEvents = function() {
          window.addEventListener("keydown", this.hide, !0), window.addEventListener("wheel", this.hide, !0), window.addEventListener("mousedown", this.hide, !0);
        }, m.prototype.$removeCloseEvents = function() {
          window.removeEventListener("keydown", this.hide, !0), window.removeEventListener("wheel", this.hide, !0), window.removeEventListener("mousedown", this.hide, !0);
        }, m.prototype.onMouseOut = function(v) {
          this.timeout && (clearTimeout(this.timeout), this.timeout = null), this.lastEvent = null, this.isOpen && (!v.relatedTarget || this.getElement().contains(v.relatedTarget) || v && v.currentTarget.contains(v.relatedTarget) || v.relatedTarget.classList.contains("ace_content") || this.hide());
        }, m;
      }(d)
    );
    r.HoverTooltip = p;
  }), ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/tooltip", "ace/config"], function(n, r, i) {
    var o = this && this.__extends || /* @__PURE__ */ function() {
      var h = function(p, g) {
        return h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(m, v) {
          m.__proto__ = v;
        } || function(m, v) {
          for (var b in v)
            Object.prototype.hasOwnProperty.call(v, b) && (m[b] = v[b]);
        }, h(p, g);
      };
      return function(p, g) {
        if (typeof g != "function" && g !== null)
          throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
        h(p, g);
        function m() {
          this.constructor = p;
        }
        p.prototype = g === null ? Object.create(g) : (m.prototype = g.prototype, new m());
      };
    }(), s = this && this.__values || function(h) {
      var p = typeof Symbol == "function" && Symbol.iterator, g = p && h[p], m = 0;
      if (g)
        return g.call(h);
      if (h && typeof h.length == "number")
        return {
          next: function() {
            return h && m >= h.length && (h = void 0), { value: h && h[m++], done: !h };
          }
        };
      throw new TypeError(p ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }, a = n("../lib/dom"), l = n("../lib/event"), u = n("../tooltip").Tooltip, c = n("../config").nls;
    function d(h) {
      var p = h.editor, g = p.renderer.$gutterLayer, m = new f(p);
      h.editor.setDefaultHandler("guttermousedown", function(y) {
        if (!(!p.isFocused() || y.getButton() != 0)) {
          var S = g.getRegion(y);
          if (S != "foldWidgets") {
            var A = y.getDocumentPosition().row, $ = p.session.selection;
            if (y.getShiftKey())
              $.selectTo(A, 0);
            else {
              if (y.domEvent.detail == 2)
                return p.selectAll(), y.preventDefault();
              h.$clickSelection = p.selection.getLineRange(A);
            }
            return h.setState("selectByLines"), h.captureMouse(y), y.preventDefault();
          }
        }
      });
      var v, b;
      function x() {
        var y = b.getDocumentPosition().row, S = p.session.getLength();
        if (y == S) {
          var A = p.renderer.pixelToScreenCoordinates(0, b.y).row, $ = b.$pos;
          if (A > p.session.documentToScreenRow($.row, $.column))
            return w();
        }
        if (m.showTooltip(y), !!m.isOpen)
          if (p.on("mousewheel", w), h.$tooltipFollowsMouse)
            C(b);
          else {
            var M = b.getGutterRow(), _ = g.$lines.get(M);
            if (_) {
              var T = _.element.querySelector(".ace_gutter_annotation"), D = T.getBoundingClientRect(), E = m.getElement().style;
              E.left = D.right + "px", E.top = D.bottom + "px";
            } else
              C(b);
          }
      }
      function w() {
        v && (v = clearTimeout(v)), m.isOpen && (m.hideTooltip(), p.off("mousewheel", w));
      }
      function C(y) {
        m.setPosition(y.x, y.y);
      }
      h.editor.setDefaultHandler("guttermousemove", function(y) {
        var S = y.domEvent.target || y.domEvent.srcElement;
        if (a.hasCssClass(S, "ace_fold-widget"))
          return w();
        m.isOpen && h.$tooltipFollowsMouse && C(y), b = y, !v && (v = setTimeout(function() {
          v = null, b && !h.isMousePressed ? x() : w();
        }, 50));
      }), l.addListener(p.renderer.$gutter, "mouseout", function(y) {
        b = null, !(!m.isOpen || v) && (v = setTimeout(function() {
          v = null, w();
        }, 50));
      }, p), p.on("changeSession", w), p.on("input", w);
    }
    r.GutterHandler = d;
    var f = (
      /** @class */
      function(h) {
        o(p, h);
        function p(g) {
          var m = h.call(this, g.container) || this;
          return m.editor = g, m;
        }
        return p.prototype.setPosition = function(g, m) {
          var v = window.innerWidth || document.documentElement.clientWidth, b = window.innerHeight || document.documentElement.clientHeight, x = this.getWidth(), w = this.getHeight();
          g += 15, m += 15, g + x > v && (g -= g + x - v), m + w > b && (m -= 20 + w), u.prototype.setPosition.call(this, g, m);
        }, Object.defineProperty(p, "annotationLabels", {
          get: function() {
            return {
              error: {
                singular: c("gutter-tooltip.aria-label.error.singular", "error"),
                plural: c("gutter-tooltip.aria-label.error.plural", "errors")
              },
              warning: {
                singular: c("gutter-tooltip.aria-label.warning.singular", "warning"),
                plural: c("gutter-tooltip.aria-label.warning.plural", "warnings")
              },
              info: {
                singular: c("gutter-tooltip.aria-label.info.singular", "information message"),
                plural: c("gutter-tooltip.aria-label.info.plural", "information messages")
              }
            };
          },
          enumerable: !1,
          configurable: !0
        }), p.prototype.showTooltip = function(g) {
          var m = this.editor.renderer.$gutterLayer, v = m.$annotations[g], b;
          v ? b = { text: Array.from(v.text), type: Array.from(v.type) } : b = { text: [], type: [] };
          var x = m.session.getFoldLine(g);
          if (x && m.$showFoldedAnnotations) {
            for (var w = { error: [], warning: [], info: [] }, C, y = g + 1; y <= x.end.row; y++)
              if (m.$annotations[y])
                for (var S = 0; S < m.$annotations[y].text.length; S++) {
                  var A = m.$annotations[y].type[S];
                  if (w[A].push(m.$annotations[y].text[S]), A === "error") {
                    C = "error_fold";
                    continue;
                  }
                  if (A === "warning") {
                    C = "warning_fold";
                    continue;
                  }
                }
            if (C === "error_fold" || C === "warning_fold") {
              var $ = "".concat(p.annotationsToSummaryString(w), " in folded code.");
              b.text.push($), b.type.push(C);
            }
          }
          if (b.text.length === 0)
            return this.hide();
          for (var M = { error: [], warning: [], info: [] }, _ = m.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon", y = 0; y < b.text.length; y++) {
            var T = "<span class='ace_".concat(b.type[y], " ").concat(_, "' aria-label='").concat(p.annotationLabels[b.type[y].replace("_fold", "")].singular, "' role=img> </span> ").concat(b.text[y]);
            M[b.type[y].replace("_fold", "")].push(T);
          }
          var D = [].concat(M.error, M.warning, M.info).join("<br>");
          this.setHtml(D), this.$element.setAttribute("aria-live", "polite"), this.isOpen || (this.setTheme(this.editor.renderer.theme), this.setClassName("ace_gutter-tooltip")), this.show(), this.editor._signal("showGutterTooltip", this);
        }, p.prototype.hideTooltip = function() {
          this.$element.removeAttribute("aria-live"), this.hide(), this.editor._signal("hideGutterTooltip", this);
        }, p.annotationsToSummaryString = function(g) {
          var m, v, b = [], x = ["error", "warning", "info"];
          try {
            for (var w = s(x), C = w.next(); !C.done; C = w.next()) {
              var y = C.value;
              if (g[y].length) {
                var S = g[y].length === 1 ? p.annotationLabels[y].singular : p.annotationLabels[y].plural;
                b.push("".concat(g[y].length, " ").concat(S));
              }
            }
          } catch (A) {
            m = { error: A };
          } finally {
            try {
              C && !C.done && (v = w.return) && v.call(w);
            } finally {
              if (m)
                throw m.error;
            }
          }
          return b.join(", ");
        }, p;
      }(u)
    );
    r.GutterTooltip = f;
  }), ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(n, r, i) {
    var o = n("../lib/event"), s = n("../lib/useragent"), a = (
      /** @class */
      function() {
        function l(u, c) {
          this.speed, this.wheelX, this.wheelY, this.domEvent = u, this.editor = c, this.x = this.clientX = u.clientX, this.y = this.clientY = u.clientY, this.$pos = null, this.$inSelection = null, this.propagationStopped = !1, this.defaultPrevented = !1;
        }
        return l.prototype.stopPropagation = function() {
          o.stopPropagation(this.domEvent), this.propagationStopped = !0;
        }, l.prototype.preventDefault = function() {
          o.preventDefault(this.domEvent), this.defaultPrevented = !0;
        }, l.prototype.stop = function() {
          this.stopPropagation(), this.preventDefault();
        }, l.prototype.getDocumentPosition = function() {
          return this.$pos ? this.$pos : (this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY), this.$pos);
        }, l.prototype.getGutterRow = function() {
          var u = this.getDocumentPosition().row, c = this.editor.session.documentToScreenRow(u, 0), d = this.editor.session.documentToScreenRow(this.editor.renderer.$gutterLayer.$lines.get(0).row, 0);
          return c - d;
        }, l.prototype.inSelection = function() {
          if (this.$inSelection !== null)
            return this.$inSelection;
          var u = this.editor, c = u.getSelectionRange();
          if (c.isEmpty())
            this.$inSelection = !1;
          else {
            var d = this.getDocumentPosition();
            this.$inSelection = c.contains(d.row, d.column);
          }
          return this.$inSelection;
        }, l.prototype.getButton = function() {
          return o.getButton(this.domEvent);
        }, l.prototype.getShiftKey = function() {
          return this.domEvent.shiftKey;
        }, l.prototype.getAccelKey = function() {
          return s.isMac ? this.domEvent.metaKey : this.domEvent.ctrlKey;
        }, l;
      }()
    );
    r.MouseEvent = a;
  }), ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function(n, r, i) {
    var o = n("../lib/dom"), s = n("../lib/event"), a = n("../lib/useragent"), l = 200, u = 200, c = 5;
    function d(h) {
      var p = h.editor, g = o.createElement("div");
      g.style.cssText = "top:-100px;position:absolute;z-index:2147483647;opacity:0.5", g.textContent = "";
      var m = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
      m.forEach(function(j) {
        h[j] = this[j];
      }, this), p.on("mousedown", this.onMouseDown.bind(h));
      var v = p.container, b, x, w, C, y, S, A = 0, $, M, _, T, D;
      this.onDragStart = function(j) {
        if (this.cancelDrag || !v.draggable) {
          var z = this;
          return setTimeout(function() {
            z.startSelect(), z.captureMouse(j);
          }, 0), j.preventDefault();
        }
        y = p.getSelectionRange();
        var H = j.dataTransfer;
        H.effectAllowed = p.getReadOnly() ? "copy" : "copyMove", p.container.appendChild(g), H.setDragImage && H.setDragImage(g, 0, 0), setTimeout(function() {
          p.container.removeChild(g);
        }), H.clearData(), H.setData("Text", p.session.getTextRange()), M = !0, this.setState("drag");
      }, this.onDragEnd = function(j) {
        if (v.draggable = !1, M = !1, this.setState(null), !p.getReadOnly()) {
          var z = j.dataTransfer.dropEffect;
          !$ && z == "move" && p.session.remove(p.getSelectionRange()), p.$resetCursorStyle();
        }
        this.editor.unsetStyle("ace_dragging"), this.editor.renderer.setCursorStyle("");
      }, this.onDragEnter = function(j) {
        if (!(p.getReadOnly() || !F(j.dataTransfer)))
          return x = j.clientX, w = j.clientY, b || k(), A++, j.dataTransfer.dropEffect = $ = B(j), s.preventDefault(j);
      }, this.onDragOver = function(j) {
        if (!(p.getReadOnly() || !F(j.dataTransfer)))
          return x = j.clientX, w = j.clientY, b || (k(), A++), L !== null && (L = null), j.dataTransfer.dropEffect = $ = B(j), s.preventDefault(j);
      }, this.onDragLeave = function(j) {
        if (A--, A <= 0 && b)
          return P(), $ = null, s.preventDefault(j);
      }, this.onDrop = function(j) {
        if (S) {
          var z = j.dataTransfer;
          if (M)
            switch ($) {
              case "move":
                y.contains(S.row, S.column) ? y = {
                  start: S,
                  end: S
                } : y = p.moveText(y, S);
                break;
              case "copy":
                y = p.moveText(y, S, !0);
                break;
            }
          else {
            var H = z.getData("Text");
            y = {
              start: S,
              end: p.session.insert(S, H)
            }, p.focus(), $ = null;
          }
          return P(), s.preventDefault(j);
        }
      }, s.addListener(v, "dragstart", this.onDragStart.bind(h), p), s.addListener(v, "dragend", this.onDragEnd.bind(h), p), s.addListener(v, "dragenter", this.onDragEnter.bind(h), p), s.addListener(v, "dragover", this.onDragOver.bind(h), p), s.addListener(v, "dragleave", this.onDragLeave.bind(h), p), s.addListener(v, "drop", this.onDrop.bind(h), p);
      function E(j, z) {
        var H = Date.now(), W = !z || j.row != z.row, G = !z || j.column != z.column;
        if (!T || W || G)
          p.moveCursorToPosition(j), T = H, D = { x, y: w };
        else {
          var K = f(D.x, D.y, x, w);
          K > c ? T = null : H - T >= u && (p.renderer.scrollCursorIntoView(), T = null);
        }
      }
      function R(j, z) {
        var H = Date.now(), W = p.renderer.layerConfig.lineHeight, G = p.renderer.layerConfig.characterWidth, K = p.renderer.scroller.getBoundingClientRect(), Y = {
          x: {
            left: x - K.left,
            right: K.right - x
          },
          y: {
            top: w - K.top,
            bottom: K.bottom - w
          }
        }, X = Math.min(Y.x.left, Y.x.right), Z = Math.min(Y.y.top, Y.y.bottom), Q = { row: j.row, column: j.column };
        X / G <= 2 && (Q.column += Y.x.left < Y.x.right ? -3 : 2), Z / W <= 1 && (Q.row += Y.y.top < Y.y.bottom ? -1 : 1);
        var ne = j.row != Q.row, q = j.column != Q.column, te = !z || j.row != z.row;
        ne || q && !te ? _ ? H - _ >= l && p.renderer.scrollCursorIntoView(Q) : _ = H : _ = null;
      }
      function I() {
        var j = S;
        S = p.renderer.screenToTextCoordinates(x, w), E(S, j), R(S, j);
      }
      function k() {
        y = p.selection.toOrientedRange(), b = p.session.addMarker(y, "ace_selection", p.getSelectionStyle()), p.clearSelection(), p.isFocused() && p.renderer.$cursorLayer.setBlinking(!1), clearInterval(C), I(), C = setInterval(I, 20), A = 0, s.addListener(document, "mousemove", N);
      }
      function P() {
        clearInterval(C), p.session.removeMarker(b), b = null, p.selection.fromOrientedRange(y), p.isFocused() && !M && p.$resetCursorStyle(), y = null, S = null, A = 0, _ = null, T = null, s.removeListener(document, "mousemove", N);
      }
      var L = null;
      function N() {
        L == null && (L = setTimeout(function() {
          L != null && b && P();
        }, 20));
      }
      function F(j) {
        var z = j.types;
        return !z || Array.prototype.some.call(z, function(H) {
          return H == "text/plain" || H == "Text";
        });
      }
      function B(j) {
        var z = ["copy", "copymove", "all", "uninitialized"], H = ["move", "copymove", "linkmove", "all", "uninitialized"], W = a.isMac ? j.altKey : j.ctrlKey, G = "uninitialized";
        try {
          G = j.dataTransfer.effectAllowed.toLowerCase();
        } catch {
        }
        var K = "none";
        return W && z.indexOf(G) >= 0 ? K = "copy" : H.indexOf(G) >= 0 ? K = "move" : z.indexOf(G) >= 0 && (K = "copy"), K;
      }
    }
    (function() {
      this.dragWait = function() {
        var h = Date.now() - this.mousedownEvent.time;
        h > this.editor.getDragDelay() && this.startDrag();
      }, this.dragWaitEnd = function() {
        var h = this.editor.container;
        h.draggable = !1, this.startSelect(this.mousedownEvent.getDocumentPosition()), this.selectEnd();
      }, this.dragReadyEnd = function(h) {
        this.editor.$resetCursorStyle(), this.editor.unsetStyle("ace_dragging"), this.editor.renderer.setCursorStyle(""), this.dragWaitEnd();
      }, this.startDrag = function() {
        this.cancelDrag = !1;
        var h = this.editor, p = h.container;
        p.draggable = !0, h.renderer.$cursorLayer.setBlinking(!1), h.setStyle("ace_dragging");
        var g = a.isWin ? "default" : "move";
        h.renderer.setCursorStyle(g), this.setState("dragReady");
      }, this.onMouseDrag = function(h) {
        var p = this.editor.container;
        if (a.isIE && this.state == "dragReady") {
          var g = f(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
          g > 3 && p.dragDrop();
        }
        if (this.state === "dragWait") {
          var g = f(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
          g > 0 && (p.draggable = !1, this.startSelect(this.mousedownEvent.getDocumentPosition()));
        }
      }, this.onMouseDown = function(h) {
        if (this.$dragEnabled) {
          this.mousedownEvent = h;
          var p = this.editor, g = h.inSelection(), m = h.getButton(), v = h.domEvent.detail || 1;
          if (v === 1 && m === 0 && g) {
            if (h.editor.inMultiSelectMode && (h.getAccelKey() || h.getShiftKey()))
              return;
            this.mousedownEvent.time = Date.now();
            var b = h.domEvent.target || h.domEvent.srcElement;
            if ("unselectable" in b && (b.unselectable = "on"), p.getDragDelay()) {
              if (a.isWebKit) {
                this.cancelDrag = !0;
                var x = p.container;
                x.draggable = !0;
              }
              this.setState("dragWait");
            } else
              this.startDrag();
            this.captureMouse(h, this.onMouseDrag.bind(this)), h.defaultPrevented = !0;
          }
        }
      };
    }).call(d.prototype);
    function f(h, p, g, m) {
      return Math.sqrt(Math.pow(g - h, 2) + Math.pow(m - p, 2));
    }
    r.DragdropHandler = d;
  }), ace.define("ace/mouse/touch_handler", ["require", "exports", "module", "ace/mouse/mouse_event", "ace/lib/event", "ace/lib/dom"], function(n, r, i) {
    var o = n("./mouse_event").MouseEvent, s = n("../lib/event"), a = n("../lib/dom");
    r.addTouchListeners = function(l, u) {
      var c = "scroll", d, f, h, p, g, m, v = 0, b, x = 0, w = 0, C = 0, y, S;
      function A() {
        var E = window.navigator && window.navigator.clipboard, R = !1, I = function() {
          var P = u.getCopyText(), L = u.session.getUndoManager().hasUndo();
          S.replaceChild(a.buildDom(R ? [
            "span",
            !P && ["span", { class: "ace_mobile-button", action: "selectall" }, "Select All"],
            P && ["span", { class: "ace_mobile-button", action: "copy" }, "Copy"],
            P && ["span", { class: "ace_mobile-button", action: "cut" }, "Cut"],
            E && ["span", { class: "ace_mobile-button", action: "paste" }, "Paste"],
            L && ["span", { class: "ace_mobile-button", action: "undo" }, "Undo"],
            ["span", { class: "ace_mobile-button", action: "find" }, "Find"],
            ["span", { class: "ace_mobile-button", action: "openCommandPalette" }, "Palette"]
          ] : ["span"]), S.firstChild);
        }, k = function(P) {
          var L = P.target.getAttribute("action");
          if (L == "more" || !R)
            return R = !R, I();
          L == "paste" ? E.readText().then(function(N) {
            u.execCommand(L, N);
          }) : L && ((L == "cut" || L == "copy") && (E ? E.writeText(u.getCopyText()) : document.execCommand("copy")), u.execCommand(L)), S.firstChild.style.display = "none", R = !1, L != "openCommandPalette" && u.focus();
        };
        S = a.buildDom([
          "div",
          {
            class: "ace_mobile-menu",
            ontouchstart: function(P) {
              c = "menu", P.stopPropagation(), P.preventDefault(), u.textInput.focus();
            },
            ontouchend: function(P) {
              P.stopPropagation(), P.preventDefault(), k(P);
            },
            onclick: k
          },
          ["span"],
          ["span", { class: "ace_mobile-button", action: "more" }, "..."]
        ], u.container);
      }
      function $() {
        S || A();
        var E = u.selection.cursor, R = u.renderer.textToScreenCoordinates(E.row, E.column), I = u.renderer.textToScreenCoordinates(0, 0).pageX, k = u.renderer.scrollLeft, P = u.container.getBoundingClientRect();
        S.style.top = R.pageY - P.top - 3 + "px", R.pageX - P.left < P.width - 70 ? (S.style.left = "", S.style.right = "10px") : (S.style.right = "", S.style.left = I + k - P.left + "px"), S.style.display = "", S.firstChild.style.display = "none", u.on("input", M);
      }
      function M(E) {
        S && (S.style.display = "none"), u.off("input", M);
      }
      function _() {
        g = null, clearTimeout(g);
        var E = u.selection.getRange(), R = E.contains(b.row, b.column);
        (E.isEmpty() || !R) && (u.selection.moveToPosition(b), u.selection.selectWord()), c = "wait", $();
      }
      function T() {
        g = null, clearTimeout(g), u.selection.moveToPosition(b);
        var E = x >= 2 ? u.selection.getLineRange(b.row) : u.session.getBracketRange(b);
        E && !E.isEmpty() ? u.selection.setRange(E) : u.selection.selectWord(), c = "wait";
      }
      s.addListener(l, "contextmenu", function(E) {
        if (y) {
          var R = u.textInput.getElement();
          R.focus();
        }
      }, u), s.addListener(l, "touchstart", function(E) {
        var R = E.touches;
        if (g || R.length > 1) {
          clearTimeout(g), g = null, h = -1, c = "zoom";
          return;
        }
        y = u.$mouseHandler.isMousePressed = !0;
        var I = u.renderer.layerConfig.lineHeight, k = u.renderer.layerConfig.lineHeight, P = E.timeStamp;
        p = P;
        var L = R[0], N = L.clientX, F = L.clientY;
        Math.abs(d - N) + Math.abs(f - F) > I && (h = -1), d = E.clientX = N, f = E.clientY = F, w = C = 0;
        var B = new o(E, u);
        if (b = B.getDocumentPosition(), P - h < 500 && R.length == 1 && !v)
          x++, E.preventDefault(), E.button = 0, T();
        else {
          x = 0;
          var j = u.selection.cursor, z = u.selection.isEmpty() ? j : u.selection.anchor, H = u.renderer.$cursorLayer.getPixelPosition(j, !0), W = u.renderer.$cursorLayer.getPixelPosition(z, !0), G = u.renderer.scroller.getBoundingClientRect(), K = u.renderer.layerConfig.offset, Y = u.renderer.scrollLeft, X = function(ne, q) {
            return ne = ne / k, q = q / I - 0.75, ne * ne + q * q;
          };
          if (E.clientX < G.left) {
            c = "zoom";
            return;
          }
          var Z = X(E.clientX - G.left - H.left + Y, E.clientY - G.top - H.top + K), Q = X(E.clientX - G.left - W.left + Y, E.clientY - G.top - W.top + K);
          Z < 3.5 && Q < 3.5 && (c = Z > Q ? "cursor" : "anchor"), Q < 3.5 ? c = "anchor" : Z < 3.5 ? c = "cursor" : c = "scroll", g = setTimeout(_, 450);
        }
        h = P;
      }, u), s.addListener(l, "touchend", function(E) {
        y = u.$mouseHandler.isMousePressed = !1, m && clearInterval(m), c == "zoom" ? (c = "", v = 0) : g ? (u.selection.moveToPosition(b), v = 0, $()) : c == "scroll" ? (D(), M()) : $(), clearTimeout(g), g = null;
      }, u), s.addListener(l, "touchmove", function(E) {
        g && (clearTimeout(g), g = null);
        var R = E.touches;
        if (!(R.length > 1 || c == "zoom")) {
          var I = R[0], k = d - I.clientX, P = f - I.clientY;
          if (c == "wait")
            if (k * k + P * P > 4)
              c = "cursor";
            else
              return E.preventDefault();
          d = I.clientX, f = I.clientY, E.clientX = I.clientX, E.clientY = I.clientY;
          var L = E.timeStamp, N = L - p;
          if (p = L, c == "scroll") {
            var F = new o(E, u);
            F.speed = 1, F.wheelX = k, F.wheelY = P, 10 * Math.abs(k) < Math.abs(P) && (k = 0), 10 * Math.abs(P) < Math.abs(k) && (P = 0), N != 0 && (w = k / N, C = P / N), u._emit("mousewheel", F), F.propagationStopped || (w = C = 0);
          } else {
            var B = new o(E, u), j = B.getDocumentPosition();
            c == "cursor" ? u.selection.moveCursorToPosition(j) : c == "anchor" && u.selection.setSelectionAnchor(j.row, j.column), u.renderer.scrollCursorIntoView(j), E.preventDefault();
          }
        }
      }, u);
      function D() {
        v += 60, m = setInterval(function() {
          v-- <= 0 && (clearInterval(m), m = null), Math.abs(w) < 0.01 && (w = 0), Math.abs(C) < 0.01 && (C = 0), v < 20 && (w = 0.9 * w), v < 20 && (C = 0.9 * C);
          var E = u.session.getScrollTop();
          u.renderer.scrollBy(10 * w, 10 * C), E == u.session.getScrollTop() && (v = 0);
        }, 10);
      }
    };
  }), ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/mouse/touch_handler", "ace/config"], function(n, r, i) {
    var o = n("../lib/event"), s = n("../lib/useragent"), a = n("./default_handlers").DefaultHandlers, l = n("./default_gutter_handler").GutterHandler, u = n("./mouse_event").MouseEvent, c = n("./dragdrop_handler").DragdropHandler, d = n("./touch_handler").addTouchListeners, f = n("../config"), h = (
      /** @class */
      function() {
        function p(g) {
          this.$dragDelay, this.$dragEnabled, this.$mouseMoved, this.mouseEvent, this.$focusTimeout;
          var m = this;
          this.editor = g, new a(this), new l(this), new c(this);
          var v = function(w) {
            var C = !document.hasFocus || !document.hasFocus() || !g.isFocused() && document.activeElement == (g.textInput && g.textInput.getElement());
            C && window.focus(), g.focus(), setTimeout(function() {
              g.isFocused() || g.focus();
            });
          }, b = g.renderer.getMouseEventTarget();
          o.addListener(b, "click", this.onMouseEvent.bind(this, "click"), g), o.addListener(b, "mousemove", this.onMouseMove.bind(this, "mousemove"), g), o.addMultiMouseDownListener([
            b,
            g.renderer.scrollBarV && g.renderer.scrollBarV.inner,
            g.renderer.scrollBarH && g.renderer.scrollBarH.inner,
            g.textInput && g.textInput.getElement()
          ].filter(Boolean), [400, 300, 250], this, "onMouseEvent", g), o.addMouseWheelListener(g.container, this.onMouseWheel.bind(this, "mousewheel"), g), d(g.container, g);
          var x = g.renderer.$gutter;
          o.addListener(x, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), g), o.addListener(x, "click", this.onMouseEvent.bind(this, "gutterclick"), g), o.addListener(x, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), g), o.addListener(x, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), g), o.addListener(b, "mousedown", v, g), o.addListener(x, "mousedown", v, g), s.isIE && g.renderer.scrollBarV && (o.addListener(g.renderer.scrollBarV.element, "mousedown", v, g), o.addListener(g.renderer.scrollBarH.element, "mousedown", v, g)), g.on(
            "mousemove",
            function(w) {
              if (!(m.state || m.$dragDelay || !m.$dragEnabled)) {
                var C = g.renderer.screenToTextCoordinates(w.x, w.y), y = g.session.selection.getRange(), S = g.renderer;
                !y.isEmpty() && y.insideStart(C.row, C.column) ? S.setCursorStyle("default") : S.setCursorStyle("");
              }
            },
            //@ts-expect-error TODO: seems mistyping - should be boolean
            g
          );
        }
        return p.prototype.onMouseEvent = function(g, m) {
          this.editor.session && this.editor._emit(g, new u(m, this.editor));
        }, p.prototype.onMouseMove = function(g, m) {
          var v = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
          !v || !v.length || this.editor._emit(g, new u(m, this.editor));
        }, p.prototype.onMouseWheel = function(g, m) {
          var v = new u(m, this.editor);
          v.speed = this.$scrollSpeed * 2, v.wheelX = m.wheelX, v.wheelY = m.wheelY, this.editor._emit(g, v);
        }, p.prototype.setState = function(g) {
          this.state = g;
        }, p.prototype.captureMouse = function(g, m) {
          this.x = g.x, this.y = g.y, this.isMousePressed = !0;
          var v = this.editor, b = this.editor.renderer;
          b.$isMousePressed = !0;
          var x = this, w = function($) {
            if ($) {
              if (s.isWebKit && !$.which && x.releaseMouse)
                return x.releaseMouse();
              x.x = $.clientX, x.y = $.clientY, m && m($), x.mouseEvent = new u($, x.editor), x.$mouseMoved = !0;
            }
          }, C = function($) {
            v.off("beforeEndOperation", S), clearInterval(A), v.session && y(), x[x.state + "End"] && x[x.state + "End"]($), x.state = "", x.isMousePressed = b.$isMousePressed = !1, b.$keepTextAreaAtCursor && b.$moveTextAreaToCursor(), x.$onCaptureMouseMove = x.releaseMouse = null, $ && x.onMouseEvent("mouseup", $), v.endOperation();
          }, y = function() {
            x[x.state] && x[x.state](), x.$mouseMoved = !1;
          };
          if (s.isOldIE && g.domEvent.type == "dblclick")
            return setTimeout(function() {
              C(g);
            });
          var S = function($) {
            x.releaseMouse && v.curOp.command.name && v.curOp.selectionChanged && (x[x.state + "End"] && x[x.state + "End"](), x.state = "", x.releaseMouse());
          };
          v.on("beforeEndOperation", S), v.startOperation({ command: { name: "mouse" } }), x.$onCaptureMouseMove = w, x.releaseMouse = o.capture(this.editor.container, w, C);
          var A = setInterval(y, 20);
        }, p.prototype.cancelContextMenu = function() {
          var g = (function(m) {
            m && m.domEvent && m.domEvent.type != "contextmenu" || (this.editor.off("nativecontextmenu", g), m && m.domEvent && o.stopEvent(m.domEvent));
          }).bind(this);
          setTimeout(g, 10), this.editor.on("nativecontextmenu", g);
        }, p.prototype.destroy = function() {
          this.releaseMouse && this.releaseMouse();
        }, p;
      }()
    );
    h.prototype.releaseMouse = null, f.defineOptions(h.prototype, "mouseHandler", {
      scrollSpeed: { initialValue: 2 },
      dragDelay: { initialValue: s.isMac ? 150 : 0 },
      dragEnabled: { initialValue: !0 },
      focusTimeout: { initialValue: 0 },
      tooltipFollowsMouse: { initialValue: !0 }
    }), r.MouseHandler = h;
  }), ace.define("ace/mouse/fold_handler", ["require", "exports", "module", "ace/lib/dom"], function(n, r, i) {
    var o = n("../lib/dom"), s = (
      /** @class */
      /* @__PURE__ */ function() {
        function a(l) {
          l.on("click", function(u) {
            var c = u.getDocumentPosition(), d = l.session, f = d.getFoldAt(c.row, c.column, 1);
            f && (u.getAccelKey() ? d.removeFold(f) : d.expandFold(f), u.stop());
            var h = u.domEvent && u.domEvent.target;
            h && o.hasCssClass(h, "ace_inline_button") && o.hasCssClass(h, "ace_toggle_wrap") && (d.setOption("wrap", !d.getUseWrapMode()), l.renderer.scrollCursorIntoView());
          }), l.on("gutterclick", function(u) {
            var c = l.renderer.$gutterLayer.getRegion(u);
            if (c == "foldWidgets") {
              var d = u.getDocumentPosition().row, f = l.session;
              f.foldWidgets && f.foldWidgets[d] && l.session.onFoldWidgetClick(d, u), l.isFocused() || l.focus(), u.stop();
            }
          }), l.on("gutterdblclick", function(u) {
            var c = l.renderer.$gutterLayer.getRegion(u);
            if (c == "foldWidgets") {
              var d = u.getDocumentPosition().row, f = l.session, h = f.getParentFoldRangeData(d, !0), p = h.range || h.firstRange;
              if (p) {
                d = p.start.row;
                var g = f.getFoldAt(d, f.getLine(d).length, 1);
                g ? f.removeFold(g) : (f.addFold("...", p), l.renderer.scrollCursorIntoView({ row: p.start.row, column: 0 }));
              }
              u.stop();
            }
          });
        }
        return a;
      }()
    );
    r.FoldHandler = s;
  }), ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function(n, r, i) {
    var o = n("../lib/keys"), s = n("../lib/event"), a = (
      /** @class */
      function() {
        function l(u) {
          this.$editor = u, this.$data = { editor: u }, this.$handlers = [], this.setDefaultHandler(u.commands);
        }
        return l.prototype.setDefaultHandler = function(u) {
          this.removeKeyboardHandler(this.$defaultHandler), this.$defaultHandler = u, this.addKeyboardHandler(u, 0);
        }, l.prototype.setKeyboardHandler = function(u) {
          var c = this.$handlers;
          if (c[c.length - 1] != u) {
            for (; c[c.length - 1] && c[c.length - 1] != this.$defaultHandler; )
              this.removeKeyboardHandler(c[c.length - 1]);
            this.addKeyboardHandler(u, 1);
          }
        }, l.prototype.addKeyboardHandler = function(u, c) {
          if (u) {
            typeof u == "function" && !u.handleKeyboard && (u.handleKeyboard = u);
            var d = this.$handlers.indexOf(u);
            d != -1 && this.$handlers.splice(d, 1), c == null ? this.$handlers.push(u) : this.$handlers.splice(c, 0, u), d == -1 && u.attach && u.attach(this.$editor);
          }
        }, l.prototype.removeKeyboardHandler = function(u) {
          var c = this.$handlers.indexOf(u);
          return c == -1 ? !1 : (this.$handlers.splice(c, 1), u.detach && u.detach(this.$editor), !0);
        }, l.prototype.getKeyboardHandler = function() {
          return this.$handlers[this.$handlers.length - 1];
        }, l.prototype.getStatusText = function() {
          var u = this.$data, c = u.editor;
          return this.$handlers.map(function(d) {
            return d.getStatusText && d.getStatusText(c, u) || "";
          }).filter(Boolean).join(" ");
        }, l.prototype.$callKeyboardHandlers = function(u, c, d, f) {
          for (var h, p = !1, g = this.$editor.commands, m = this.$handlers.length; m-- && (h = this.$handlers[m].handleKeyboard(
            this.$data,
            u,
            c,
            d,
            f
          ), !(!(!h || !h.command) && (h.command == "null" ? p = !0 : p = g.exec(h.command, this.$editor, h.args, f), p && f && u != -1 && h.passEvent != !0 && h.command.passEvent != !0 && s.stopEvent(f), p))); )
            ;
          return !p && u == -1 && (h = { command: "insertstring" }, p = g.exec("insertstring", this.$editor, c)), p && this.$editor._signal && this.$editor._signal("keyboardActivity", h), p;
        }, l.prototype.onCommandKey = function(u, c, d) {
          var f = o.keyCodeToString(d);
          return this.$callKeyboardHandlers(c, f, d, u);
        }, l.prototype.onTextInput = function(u) {
          return this.$callKeyboardHandlers(-1, u);
        }, l;
      }()
    );
    r.KeyBinding = a;
  }), ace.define("ace/lib/bidiutil", ["require", "exports", "module"], function(n, r, i) {
    var o = 0, s = 0, a = !1, l = !1, u = !1, c = [
      [0, 3, 0, 1, 0, 0, 0],
      [0, 3, 0, 1, 2, 2, 0],
      [0, 3, 0, 17, 2, 0, 1],
      [0, 3, 5, 5, 4, 1, 0],
      [0, 3, 21, 21, 4, 0, 1],
      [0, 3, 5, 5, 4, 2, 0]
    ], d = [
      [2, 0, 1, 1, 0, 1, 0],
      [2, 0, 1, 1, 0, 2, 0],
      [2, 0, 2, 1, 3, 2, 0],
      [2, 0, 2, 33, 3, 1, 1]
    ], f = 0, h = 1, p = 0, g = 1, m = 2, v = 3, b = 4, x = 5, w = 6, C = 7, y = 8, S = 9, A = 10, $ = 11, M = 12, _ = 13, T = 14, D = 15, E = 16, R = 17, I = 18, k = [
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      w,
      x,
      w,
      y,
      x,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      x,
      x,
      x,
      w,
      y,
      b,
      b,
      $,
      $,
      $,
      b,
      b,
      b,
      b,
      b,
      A,
      S,
      A,
      S,
      S,
      m,
      m,
      m,
      m,
      m,
      m,
      m,
      m,
      m,
      m,
      S,
      b,
      b,
      b,
      b,
      b,
      b,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      b,
      b,
      b,
      b,
      b,
      b,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      p,
      b,
      b,
      b,
      b,
      I,
      I,
      I,
      I,
      I,
      I,
      x,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      I,
      S,
      b,
      $,
      $,
      $,
      $,
      b,
      b,
      b,
      b,
      p,
      b,
      b,
      I,
      b,
      b,
      $,
      $,
      m,
      m,
      b,
      p,
      b,
      b,
      b,
      m,
      p,
      b,
      b,
      b,
      b,
      b
    ], P = [
      y,
      y,
      y,
      y,
      y,
      y,
      y,
      y,
      y,
      y,
      y,
      I,
      I,
      I,
      p,
      g,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      y,
      x,
      _,
      T,
      D,
      E,
      R,
      S,
      $,
      $,
      $,
      $,
      $,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      S,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      b,
      y
    ];
    function L(j, z, H, W) {
      var G = o ? d : c, K = null, Y = null, X = null, Z = 0, Q = null, ne = null, q = -1, te = null, fe = null, Se = [];
      if (!W)
        for (te = 0, W = []; te < H; te++)
          W[te] = B(j[te]);
      for (s = o, a = !1, l = !1, u = !1, fe = 0; fe < H; fe++) {
        if (K = Z, Se[fe] = Y = F(j, W, Se, fe), Z = G[K][Y], Q = Z & 240, Z &= 15, z[fe] = X = G[Z][5], Q > 0)
          if (Q == 16) {
            for (te = q; te < fe; te++)
              z[te] = 1;
            q = -1;
          } else
            q = -1;
        if (ne = G[Z][6], ne)
          q == -1 && (q = fe);
        else if (q > -1) {
          for (te = q; te < fe; te++)
            z[te] = X;
          q = -1;
        }
        W[fe] == x && (z[fe] = 0), s |= X;
      }
      if (u) {
        for (te = 0; te < H; te++)
          if (W[te] == w) {
            z[te] = o;
            for (var de = te - 1; de >= 0 && W[de] == y; de--)
              z[de] = o;
          }
      }
    }
    function N(j, z, H) {
      if (!(s < j)) {
        if (j == 1 && o == h && !l) {
          H.reverse();
          return;
        }
        for (var W = H.length, G = 0, K, Y, X, Z; G < W; ) {
          if (z[G] >= j) {
            for (K = G + 1; K < W && z[K] >= j; )
              K++;
            for (Y = G, X = K - 1; Y < X; Y++, X--)
              Z = H[Y], H[Y] = H[X], H[X] = Z;
            G = K;
          }
          G++;
        }
      }
    }
    function F(j, z, H, W) {
      var G = z[W], K, Y, X, Z;
      switch (G) {
        case p:
        case g:
          a = !1;
        case b:
        case v:
          return G;
        case m:
          return a ? v : m;
        case C:
          return a = !0, g;
        case y:
          return b;
        case S:
          return W < 1 || W + 1 >= z.length || (K = H[W - 1]) != m && K != v || (Y = z[W + 1]) != m && Y != v ? b : (a && (Y = v), Y == K ? Y : b);
        case A:
          return K = W > 0 ? H[W - 1] : x, K == m && W + 1 < z.length && z[W + 1] == m ? m : b;
        case $:
          if (W > 0 && H[W - 1] == m)
            return m;
          if (a)
            return b;
          for (Z = W + 1, X = z.length; Z < X && z[Z] == $; )
            Z++;
          return Z < X && z[Z] == m ? m : b;
        case M:
          for (X = z.length, Z = W + 1; Z < X && z[Z] == M; )
            Z++;
          if (Z < X) {
            var Q = j[W], ne = Q >= 1425 && Q <= 2303 || Q == 64286;
            if (K = z[Z], ne && (K == g || K == C))
              return g;
          }
          return W < 1 || (K = z[W - 1]) == x ? b : H[W - 1];
        case x:
          return a = !1, l = !0, o;
        case w:
          return u = !0, b;
        case _:
        case T:
        case E:
        case R:
        case D:
          a = !1;
        case I:
          return b;
      }
    }
    function B(j) {
      var z = j.charCodeAt(0), H = z >> 8;
      return H == 0 ? z > 191 ? p : k[z] : H == 5 ? /[\u0591-\u05f4]/.test(j) ? g : p : H == 6 ? /[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(j) ? M : /[\u0660-\u0669\u066b-\u066c]/.test(j) ? v : z == 1642 ? $ : /[\u06f0-\u06f9]/.test(j) ? m : C : H == 32 && z <= 8287 ? P[z & 255] : H == 254 && z >= 65136 ? C : b;
    }
    r.L = p, r.R = g, r.EN = m, r.ON_R = 3, r.AN = 4, r.R_H = 5, r.B = 6, r.RLE = 7, r.DOT = "", r.doBidiReorder = function(j, z, H) {
      if (j.length < 2)
        return {};
      var W = j.split(""), G = new Array(W.length), K = new Array(W.length), Y = [];
      o = H ? h : f, L(W, Y, W.length, z);
      for (var X = 0; X < G.length; G[X] = X, X++)
        ;
      N(2, Y, G), N(1, Y, G);
      for (var X = 0; X < G.length - 1; X++)
        z[X] === v ? Y[X] = r.AN : Y[X] === g && (z[X] > C && z[X] < _ || z[X] === b || z[X] === I) ? Y[X] = r.ON_R : X > 0 && W[X - 1] === "" && /\u0622|\u0623|\u0625|\u0627/.test(W[X]) && (Y[X - 1] = Y[X] = r.R_H, X++);
      W[W.length - 1] === r.DOT && (Y[W.length - 1] = r.B), W[0] === "" && (Y[0] = r.RLE);
      for (var X = 0; X < G.length; X++)
        K[X] = Y[G[X]];
      return { logicalFromVisual: G, bidiLevels: K };
    }, r.hasBidiCharacters = function(j, z) {
      for (var H = !1, W = 0; W < j.length; W++)
        z[W] = B(j.charAt(W)), !H && (z[W] == g || z[W] == C || z[W] == v) && (H = !0);
      return H;
    }, r.getVisualFromLogicalIdx = function(j, z) {
      for (var H = 0; H < z.logicalFromVisual.length; H++)
        if (z.logicalFromVisual[H] == j)
          return H;
      return 0;
    };
  }), ace.define("ace/bidihandler", ["require", "exports", "module", "ace/lib/bidiutil", "ace/lib/lang"], function(n, r, i) {
    var o = n("./lib/bidiutil"), s = n("./lib/lang"), a = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/, l = (
      /** @class */
      function() {
        function u(c) {
          this.session = c, this.bidiMap = {}, this.currentRow = null, this.bidiUtil = o, this.charWidths = [], this.EOL = "", this.showInvisibles = !0, this.isRtlDir = !1, this.$isRtl = !1, this.line = "", this.wrapIndent = 0, this.EOF = "", this.RLE = "", this.contentWidth = 0, this.fontMetrics = null, this.rtlLineOffset = 0, this.wrapOffset = 0, this.isMoveLeftOperation = !1, this.seenBidi = a.test(c.getValue());
        }
        return u.prototype.isBidiRow = function(c, d, f) {
          return this.seenBidi ? (c !== this.currentRow && (this.currentRow = c, this.updateRowLine(d, f), this.updateBidiMap()), this.bidiMap.bidiLevels) : !1;
        }, u.prototype.onChange = function(c) {
          this.seenBidi ? this.currentRow = null : c.action == "insert" && a.test(c.lines.join(`
`)) && (this.seenBidi = !0, this.currentRow = null);
        }, u.prototype.getDocumentRow = function() {
          var c = 0, d = this.session.$screenRowCache;
          if (d.length) {
            var f = this.session.$getRowCacheIndex(d, this.currentRow);
            f >= 0 && (c = this.session.$docRowCache[f]);
          }
          return c;
        }, u.prototype.getSplitIndex = function() {
          var c = 0, d = this.session.$screenRowCache;
          if (d.length)
            for (var f, h = this.session.$getRowCacheIndex(d, this.currentRow); this.currentRow - c > 0 && (f = this.session.$getRowCacheIndex(d, this.currentRow - c - 1), f === h); )
              h = f, c++;
          else
            c = this.currentRow;
          return c;
        }, u.prototype.updateRowLine = function(c, d) {
          c === void 0 && (c = this.getDocumentRow());
          var f = c === this.session.getLength() - 1, h = f ? this.EOF : this.EOL;
          if (this.wrapIndent = 0, this.line = this.session.getLine(c), this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE, this.session.$useWrapMode) {
            var p = this.session.$wrapData[c];
            p && (d === void 0 && (d = this.getSplitIndex()), d > 0 && p.length ? (this.wrapIndent = p.indent, this.wrapOffset = this.wrapIndent * this.charWidths[o.L], this.line = d < p.length ? this.line.substring(p[d - 1], p[d]) : this.line.substring(p[p.length - 1])) : this.line = this.line.substring(0, p[d]), d == p.length && (this.line += this.showInvisibles ? h : o.DOT));
          } else
            this.line += this.showInvisibles ? h : o.DOT;
          var g = this.session, m = 0, v;
          this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(b, x) {
            return b === "	" || g.isFullWidth(b.charCodeAt(0)) ? (v = b === "	" ? g.getScreenTabSize(x + m) : 2, m += v - 1, s.stringRepeat(o.DOT, v)) : b;
          }), this.isRtlDir && (this.fontMetrics.$main.textContent = this.line.charAt(this.line.length - 1) == o.DOT ? this.line.substr(0, this.line.length - 1) : this.line, this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width);
        }, u.prototype.updateBidiMap = function() {
          var c = [];
          o.hasBidiCharacters(this.line, c) || this.isRtlDir ? this.bidiMap = o.doBidiReorder(this.line, c, this.isRtlDir) : this.bidiMap = {};
        }, u.prototype.markAsDirty = function() {
          this.currentRow = null;
        }, u.prototype.updateCharacterWidths = function(c) {
          if (this.characterWidth !== c.$characterSize.width) {
            this.fontMetrics = c;
            var d = this.characterWidth = c.$characterSize.width, f = c.$measureCharWidth("");
            this.charWidths[o.L] = this.charWidths[o.EN] = this.charWidths[o.ON_R] = d, this.charWidths[o.R] = this.charWidths[o.AN] = f, this.charWidths[o.R_H] = f * 0.45, this.charWidths[o.B] = this.charWidths[o.RLE] = 0, this.currentRow = null;
          }
        }, u.prototype.setShowInvisibles = function(c) {
          this.showInvisibles = c, this.currentRow = null;
        }, u.prototype.setEolChar = function(c) {
          this.EOL = c;
        }, u.prototype.setContentWidth = function(c) {
          this.contentWidth = c;
        }, u.prototype.isRtlLine = function(c) {
          return this.$isRtl ? !0 : c != null ? this.session.getLine(c).charAt(0) == this.RLE : this.isRtlDir;
        }, u.prototype.setRtlDirection = function(c, d) {
          for (var f = c.getCursorPosition(), h = c.selection.getSelectionAnchor().row; h <= f.row; h++)
            !d && c.session.getLine(h).charAt(0) === c.session.$bidiHandler.RLE ? c.session.doc.removeInLine(h, 0, 1) : d && c.session.getLine(h).charAt(0) !== c.session.$bidiHandler.RLE && c.session.doc.insert({ column: 0, row: h }, c.session.$bidiHandler.RLE);
        }, u.prototype.getPosLeft = function(c) {
          c -= this.wrapIndent;
          var d = this.line.charAt(0) === this.RLE ? 1 : 0, f = c > d ? this.session.getOverwrite() ? c : c - 1 : d, h = o.getVisualFromLogicalIdx(f, this.bidiMap), p = this.bidiMap.bidiLevels, g = 0;
          !this.session.getOverwrite() && c <= d && p[h] % 2 !== 0 && h++;
          for (var m = 0; m < h; m++)
            g += this.charWidths[p[m]];
          return !this.session.getOverwrite() && c > d && p[h] % 2 === 0 && (g += this.charWidths[p[h]]), this.wrapIndent && (g += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset), this.isRtlDir && (g += this.rtlLineOffset), g;
        }, u.prototype.getSelections = function(c, d) {
          var f = this.bidiMap, h = f.bidiLevels, p, g = [], m = 0, v = Math.min(c, d) - this.wrapIndent, b = Math.max(c, d) - this.wrapIndent, x = !1, w = !1, C = 0;
          this.wrapIndent && (m += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset);
          for (var y, S = 0; S < h.length; S++)
            y = f.logicalFromVisual[S], p = h[S], x = y >= v && y < b, x && !w ? C = m : !x && w && g.push({ left: C, width: m - C }), m += this.charWidths[p], w = x;
          if (x && S === h.length && g.push({ left: C, width: m - C }), this.isRtlDir)
            for (var A = 0; A < g.length; A++)
              g[A].left += this.rtlLineOffset;
          return g;
        }, u.prototype.offsetToCol = function(f) {
          this.isRtlDir && (f -= this.rtlLineOffset);
          var d = 0, f = Math.max(f, 0), h = 0, p = 0, g = this.bidiMap.bidiLevels, m = this.charWidths[g[p]];
          for (this.wrapIndent && (f -= this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset); f > h + m / 2; ) {
            if (h += m, p === g.length - 1) {
              m = 0;
              break;
            }
            m = this.charWidths[g[++p]];
          }
          return p > 0 && g[p - 1] % 2 !== 0 && g[p] % 2 === 0 ? (f < h && p--, d = this.bidiMap.logicalFromVisual[p]) : p > 0 && g[p - 1] % 2 === 0 && g[p] % 2 !== 0 ? d = 1 + (f > h ? this.bidiMap.logicalFromVisual[p] : this.bidiMap.logicalFromVisual[p - 1]) : this.isRtlDir && p === g.length - 1 && m === 0 && g[p - 1] % 2 === 0 || !this.isRtlDir && p === 0 && g[p] % 2 !== 0 ? d = 1 + this.bidiMap.logicalFromVisual[p] : (p > 0 && g[p - 1] % 2 !== 0 && m !== 0 && p--, d = this.bidiMap.logicalFromVisual[p]), d === 0 && this.isRtlDir && d++, d + this.wrapIndent;
        }, u;
      }()
    );
    r.BidiHandler = l;
  }), ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function(n, r, i) {
    var o = n("./lib/oop"), s = n("./lib/lang"), a = n("./lib/event_emitter").EventEmitter, l = n("./range").Range, u = (
      /** @class */
      function() {
        function c(d) {
          this.session = d, this.doc = d.getDocument(), this.clearSelection(), this.cursor = this.lead = this.doc.createAnchor(0, 0), this.anchor = this.doc.createAnchor(0, 0), this.$silent = !1;
          var f = this;
          this.cursor.on("change", function(h) {
            f.$cursorChanged = !0, f.$silent || f._emit("changeCursor"), !f.$isEmpty && !f.$silent && f._emit("changeSelection"), !f.$keepDesiredColumnOnChange && h.old.column != h.value.column && (f.$desiredColumn = null);
          }), this.anchor.on("change", function() {
            f.$anchorChanged = !0, !f.$isEmpty && !f.$silent && f._emit("changeSelection");
          });
        }
        return c.prototype.isEmpty = function() {
          return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
        }, c.prototype.isMultiLine = function() {
          return !this.$isEmpty && this.anchor.row != this.cursor.row;
        }, c.prototype.getCursor = function() {
          return this.lead.getPosition();
        }, c.prototype.setAnchor = function(d, f) {
          this.$isEmpty = !1, this.anchor.setPosition(d, f);
        }, c.prototype.getAnchor = function() {
          return this.$isEmpty ? this.getSelectionLead() : this.anchor.getPosition();
        }, c.prototype.getSelectionLead = function() {
          return this.lead.getPosition();
        }, c.prototype.isBackwards = function() {
          var d = this.anchor, f = this.lead;
          return d.row > f.row || d.row == f.row && d.column > f.column;
        }, c.prototype.getRange = function() {
          var d = this.anchor, f = this.lead;
          return this.$isEmpty ? l.fromPoints(f, f) : this.isBackwards() ? l.fromPoints(f, d) : l.fromPoints(d, f);
        }, c.prototype.clearSelection = function() {
          this.$isEmpty || (this.$isEmpty = !0, this._emit("changeSelection"));
        }, c.prototype.selectAll = function() {
          this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
        }, c.prototype.setRange = function(d, f) {
          var h = f ? d.end : d.start, p = f ? d.start : d.end;
          this.$setSelection(h.row, h.column, p.row, p.column);
        }, c.prototype.$setSelection = function(d, f, h, p) {
          if (!this.$silent) {
            var g = this.$isEmpty, m = this.inMultiSelectMode;
            this.$silent = !0, this.$cursorChanged = this.$anchorChanged = !1, this.anchor.setPosition(d, f), this.cursor.setPosition(h, p), this.$isEmpty = !l.comparePoints(this.anchor, this.cursor), this.$silent = !1, this.$cursorChanged && this._emit("changeCursor"), (this.$cursorChanged || this.$anchorChanged || g != this.$isEmpty || m) && this._emit("changeSelection");
          }
        }, c.prototype.$moveSelection = function(d) {
          var f = this.lead;
          this.$isEmpty && this.setSelectionAnchor(f.row, f.column), d.call(this);
        }, c.prototype.selectTo = function(d, f) {
          this.$moveSelection(function() {
            this.moveCursorTo(d, f);
          });
        }, c.prototype.selectToPosition = function(d) {
          this.$moveSelection(function() {
            this.moveCursorToPosition(d);
          });
        }, c.prototype.moveTo = function(d, f) {
          this.clearSelection(), this.moveCursorTo(d, f);
        }, c.prototype.moveToPosition = function(d) {
          this.clearSelection(), this.moveCursorToPosition(d);
        }, c.prototype.selectUp = function() {
          this.$moveSelection(this.moveCursorUp);
        }, c.prototype.selectDown = function() {
          this.$moveSelection(this.moveCursorDown);
        }, c.prototype.selectRight = function() {
          this.$moveSelection(this.moveCursorRight);
        }, c.prototype.selectLeft = function() {
          this.$moveSelection(this.moveCursorLeft);
        }, c.prototype.selectLineStart = function() {
          this.$moveSelection(this.moveCursorLineStart);
        }, c.prototype.selectLineEnd = function() {
          this.$moveSelection(this.moveCursorLineEnd);
        }, c.prototype.selectFileEnd = function() {
          this.$moveSelection(this.moveCursorFileEnd);
        }, c.prototype.selectFileStart = function() {
          this.$moveSelection(this.moveCursorFileStart);
        }, c.prototype.selectWordRight = function() {
          this.$moveSelection(this.moveCursorWordRight);
        }, c.prototype.selectWordLeft = function() {
          this.$moveSelection(this.moveCursorWordLeft);
        }, c.prototype.getWordRange = function(d, f) {
          if (typeof f > "u") {
            var h = d || this.lead;
            d = h.row, f = h.column;
          }
          return this.session.getWordRange(d, f);
        }, c.prototype.selectWord = function() {
          this.setSelectionRange(this.getWordRange());
        }, c.prototype.selectAWord = function() {
          var d = this.getCursor(), f = this.session.getAWordRange(d.row, d.column);
          this.setSelectionRange(f);
        }, c.prototype.getLineRange = function(d, f) {
          var h = typeof d == "number" ? d : this.lead.row, p, g = this.session.getFoldLine(h);
          return g ? (h = g.start.row, p = g.end.row) : p = h, f === !0 ? new l(h, 0, p, this.session.getLine(p).length) : new l(h, 0, p + 1, 0);
        }, c.prototype.selectLine = function() {
          this.setSelectionRange(this.getLineRange());
        }, c.prototype.moveCursorUp = function() {
          this.moveCursorBy(-1, 0);
        }, c.prototype.moveCursorDown = function() {
          this.moveCursorBy(1, 0);
        }, c.prototype.wouldMoveIntoSoftTab = function(d, f, h) {
          var p = d.column, g = d.column + f;
          return h < 0 && (p = d.column - f, g = d.column), this.session.isTabStop(d) && this.doc.getLine(d.row).slice(p, g).split(" ").length - 1 == f;
        }, c.prototype.moveCursorLeft = function() {
          var d = this.lead.getPosition(), f;
          if (f = this.session.getFoldAt(d.row, d.column, -1))
            this.moveCursorTo(f.start.row, f.start.column);
          else if (d.column === 0)
            d.row > 0 && this.moveCursorTo(d.row - 1, this.doc.getLine(d.row - 1).length);
          else {
            var h = this.session.getTabSize();
            this.wouldMoveIntoSoftTab(d, h, -1) && !this.session.getNavigateWithinSoftTabs() ? this.moveCursorBy(0, -h) : this.moveCursorBy(0, -1);
          }
        }, c.prototype.moveCursorRight = function() {
          var d = this.lead.getPosition(), f;
          if (f = this.session.getFoldAt(d.row, d.column, 1))
            this.moveCursorTo(f.end.row, f.end.column);
          else if (this.lead.column == this.doc.getLine(this.lead.row).length)
            this.lead.row < this.doc.getLength() - 1 && this.moveCursorTo(this.lead.row + 1, 0);
          else {
            var h = this.session.getTabSize(), d = this.lead;
            this.wouldMoveIntoSoftTab(d, h, 1) && !this.session.getNavigateWithinSoftTabs() ? this.moveCursorBy(0, h) : this.moveCursorBy(0, 1);
          }
        }, c.prototype.moveCursorLineStart = function() {
          var d = this.lead.row, f = this.lead.column, h = this.session.documentToScreenRow(d, f), p = this.session.screenToDocumentPosition(h, 0), g = this.session.getDisplayLine(d, null, p.row, p.column), m = g.match(/^\s*/);
          m[0].length != f && !this.session.$useEmacsStyleLineStart && (p.column += m[0].length), this.moveCursorToPosition(p);
        }, c.prototype.moveCursorLineEnd = function() {
          var d = this.lead, f = this.session.getDocumentLastRowColumnPosition(d.row, d.column);
          if (this.lead.column == f.column) {
            var h = this.session.getLine(f.row);
            if (f.column == h.length) {
              var p = h.search(/\s+$/);
              p > 0 && (f.column = p);
            }
          }
          this.moveCursorTo(f.row, f.column);
        }, c.prototype.moveCursorFileEnd = function() {
          var d = this.doc.getLength() - 1, f = this.doc.getLine(d).length;
          this.moveCursorTo(d, f);
        }, c.prototype.moveCursorFileStart = function() {
          this.moveCursorTo(0, 0);
        }, c.prototype.moveCursorLongWordRight = function() {
          var d = this.lead.row, f = this.lead.column, h = this.doc.getLine(d), p = h.substring(f);
          this.session.nonTokenRe.lastIndex = 0, this.session.tokenRe.lastIndex = 0;
          var g = this.session.getFoldAt(d, f, 1);
          if (g) {
            this.moveCursorTo(g.end.row, g.end.column);
            return;
          }
          if (this.session.nonTokenRe.exec(p) && (f += this.session.nonTokenRe.lastIndex, this.session.nonTokenRe.lastIndex = 0, p = h.substring(f)), f >= h.length) {
            this.moveCursorTo(d, h.length), this.moveCursorRight(), d < this.doc.getLength() - 1 && this.moveCursorWordRight();
            return;
          }
          this.session.tokenRe.exec(p) && (f += this.session.tokenRe.lastIndex, this.session.tokenRe.lastIndex = 0), this.moveCursorTo(d, f);
        }, c.prototype.moveCursorLongWordLeft = function() {
          var d = this.lead.row, f = this.lead.column, h;
          if (h = this.session.getFoldAt(d, f, -1)) {
            this.moveCursorTo(h.start.row, h.start.column);
            return;
          }
          var p = this.session.getFoldStringAt(d, f, -1);
          p == null && (p = this.doc.getLine(d).substring(0, f));
          var g = s.stringReverse(p);
          if (this.session.nonTokenRe.lastIndex = 0, this.session.tokenRe.lastIndex = 0, this.session.nonTokenRe.exec(g) && (f -= this.session.nonTokenRe.lastIndex, g = g.slice(this.session.nonTokenRe.lastIndex), this.session.nonTokenRe.lastIndex = 0), f <= 0) {
            this.moveCursorTo(d, 0), this.moveCursorLeft(), d > 0 && this.moveCursorWordLeft();
            return;
          }
          this.session.tokenRe.exec(g) && (f -= this.session.tokenRe.lastIndex, this.session.tokenRe.lastIndex = 0), this.moveCursorTo(d, f);
        }, c.prototype.$shortWordEndIndex = function(d) {
          var f = 0, h, p = /\s/, g = this.session.tokenRe;
          if (g.lastIndex = 0, this.session.tokenRe.exec(d))
            f = this.session.tokenRe.lastIndex;
          else {
            for (; (h = d[f]) && p.test(h); )
              f++;
            if (f < 1) {
              for (g.lastIndex = 0; (h = d[f]) && !g.test(h); )
                if (g.lastIndex = 0, f++, p.test(h))
                  if (f > 2) {
                    f--;
                    break;
                  } else {
                    for (; (h = d[f]) && p.test(h); )
                      f++;
                    if (f > 2)
                      break;
                  }
            }
          }
          return g.lastIndex = 0, f;
        }, c.prototype.moveCursorShortWordRight = function() {
          var d = this.lead.row, f = this.lead.column, h = this.doc.getLine(d), p = h.substring(f), g = this.session.getFoldAt(d, f, 1);
          if (g)
            return this.moveCursorTo(g.end.row, g.end.column);
          if (f == h.length) {
            var m = this.doc.getLength();
            do
              d++, p = this.doc.getLine(d);
            while (d < m && /^\s*$/.test(p));
            /^\s+/.test(p) || (p = ""), f = 0;
          }
          var v = this.$shortWordEndIndex(p);
          this.moveCursorTo(d, f + v);
        }, c.prototype.moveCursorShortWordLeft = function() {
          var d = this.lead.row, f = this.lead.column, h;
          if (h = this.session.getFoldAt(d, f, -1))
            return this.moveCursorTo(h.start.row, h.start.column);
          var p = this.session.getLine(d).substring(0, f);
          if (f === 0) {
            do
              d--, p = this.doc.getLine(d);
            while (d > 0 && /^\s*$/.test(p));
            f = p.length, /\s+$/.test(p) || (p = "");
          }
          var g = s.stringReverse(p), m = this.$shortWordEndIndex(g);
          return this.moveCursorTo(d, f - m);
        }, c.prototype.moveCursorWordRight = function() {
          this.session.$selectLongWords ? this.moveCursorLongWordRight() : this.moveCursorShortWordRight();
        }, c.prototype.moveCursorWordLeft = function() {
          this.session.$selectLongWords ? this.moveCursorLongWordLeft() : this.moveCursorShortWordLeft();
        }, c.prototype.moveCursorBy = function(d, f) {
          var h = this.session.documentToScreenPosition(this.lead.row, this.lead.column), p;
          if (f === 0 && (d !== 0 && (this.session.$bidiHandler.isBidiRow(h.row, this.lead.row) ? (p = this.session.$bidiHandler.getPosLeft(h.column), h.column = Math.round(p / this.session.$bidiHandler.charWidths[0])) : p = h.column * this.session.$bidiHandler.charWidths[0]), this.$desiredColumn ? h.column = this.$desiredColumn : this.$desiredColumn = h.column), d != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
            var g = this.session.lineWidgets[this.lead.row];
            d < 0 ? d -= g.rowsAbove || 0 : d > 0 && (d += g.rowCount - (g.rowsAbove || 0));
          }
          var m = this.session.screenToDocumentPosition(h.row + d, h.column, p);
          d !== 0 && f === 0 && m.row === this.lead.row && (m.column, this.lead.column), this.moveCursorTo(m.row, m.column + f, f === 0);
        }, c.prototype.moveCursorToPosition = function(d) {
          this.moveCursorTo(d.row, d.column);
        }, c.prototype.moveCursorTo = function(d, f, h) {
          var p = this.session.getFoldAt(d, f, 1);
          p && (d = p.start.row, f = p.start.column), this.$keepDesiredColumnOnChange = !0;
          var g = this.session.getLine(d);
          /[\uDC00-\uDFFF]/.test(g.charAt(f)) && g.charAt(f - 1) && (this.lead.row == d && this.lead.column == f + 1 ? f = f - 1 : f = f + 1), this.lead.setPosition(d, f), this.$keepDesiredColumnOnChange = !1, h || (this.$desiredColumn = null);
        }, c.prototype.moveCursorToScreen = function(d, f, h) {
          var p = this.session.screenToDocumentPosition(d, f);
          this.moveCursorTo(p.row, p.column, h);
        }, c.prototype.detach = function() {
          this.lead.detach(), this.anchor.detach();
        }, c.prototype.fromOrientedRange = function(d) {
          this.setSelectionRange(d, d.cursor == d.start), this.$desiredColumn = d.desiredColumn || this.$desiredColumn;
        }, c.prototype.toOrientedRange = function(d) {
          var f = this.getRange();
          return d ? (d.start.column = f.start.column, d.start.row = f.start.row, d.end.column = f.end.column, d.end.row = f.end.row) : d = f, d.cursor = this.isBackwards() ? d.start : d.end, d.desiredColumn = this.$desiredColumn, d;
        }, c.prototype.getRangeOfMovements = function(d) {
          var f = this.getCursor();
          try {
            d(this);
            var h = this.getCursor();
            return l.fromPoints(f, h);
          } catch {
            return l.fromPoints(f, f);
          } finally {
            this.moveCursorToPosition(f);
          }
        }, c.prototype.toJSON = function() {
          if (this.rangeCount)
            var d = this.ranges.map(function(f) {
              var h = f.clone();
              return h.isBackwards = f.cursor == f.start, h;
            });
          else {
            var d = this.getRange();
            d.isBackwards = this.isBackwards();
          }
          return d;
        }, c.prototype.fromJSON = function(d) {
          if (d.start == null)
            if (this.rangeList && d.length > 1) {
              this.toSingleRange(d[0]);
              for (var f = d.length; f--; ) {
                var h = l.fromPoints(d[f].start, d[f].end);
                d[f].isBackwards && (h.cursor = h.start), this.addRange(h, !0);
              }
              return;
            } else
              d = d[0];
          this.rangeList && this.toSingleRange(d), this.setSelectionRange(d, d.isBackwards);
        }, c.prototype.isEqual = function(d) {
          if ((d.length || this.rangeCount) && d.length != this.rangeCount)
            return !1;
          if (!d.length || !this.ranges)
            return this.getRange().isEqual(d);
          for (var f = this.ranges.length; f--; )
            if (!this.ranges[f].isEqual(d[f]))
              return !1;
          return !0;
        }, c;
      }()
    );
    u.prototype.setSelectionAnchor = u.prototype.setAnchor, u.prototype.getSelectionAnchor = u.prototype.getAnchor, u.prototype.setSelectionRange = u.prototype.setRange, o.implement(u.prototype, a), r.Selection = u;
  }), ace.define("ace/tokenizer", ["require", "exports", "module", "ace/lib/report_error"], function(n, r, i) {
    var o = n("./lib/report_error").reportError, s = 2e3, a = (
      /** @class */
      function() {
        function l(u) {
          this.splitRegex, this.states = u, this.regExps = {}, this.matchMappings = {};
          for (var c in this.states) {
            for (var d = this.states[c], f = [], h = 0, p = this.matchMappings[c] = { defaultToken: "text" }, g = "g", m = [], v = 0; v < d.length; v++) {
              var b = d[v];
              if (b.defaultToken && (p.defaultToken = b.defaultToken), b.caseInsensitive && g.indexOf("i") === -1 && (g += "i"), b.unicode && g.indexOf("u") === -1 && (g += "u"), b.regex != null) {
                b.regex instanceof RegExp && (b.regex = b.regex.toString().slice(1, -1));
                var x = b.regex, w = new RegExp("(?:(" + x + ")|(.))").exec("a").length - 2;
                Array.isArray(b.token) ? b.token.length == 1 || w == 1 ? b.token = b.token[0] : w - 1 != b.token.length ? (this.reportError("number of classes and regexp groups doesn't match", {
                  rule: b,
                  groupCount: w - 1
                }), b.token = b.token[0]) : (b.tokenArray = b.token, b.token = null, b.onMatch = this.$arrayTokens) : typeof b.token == "function" && !b.onMatch && (w > 1 ? b.onMatch = this.$applyToken : b.onMatch = b.token), w > 1 && (/\\\d/.test(b.regex) ? x = b.regex.replace(/\\([0-9]+)/g, function(C, y) {
                  return "\\" + (parseInt(y, 10) + h + 1);
                }) : (w = 1, x = this.removeCapturingGroups(b.regex)), !b.splitRegex && typeof b.token != "string" && m.push(b)), p[h] = v, h += w, f.push(x), b.onMatch || (b.onMatch = null);
              }
            }
            f.length || (p[0] = 0, f.push("$")), m.forEach(function(C) {
              C.splitRegex = this.createSplitterRegexp(C.regex, g);
            }, this), this.regExps[c] = new RegExp("(" + f.join(")|(") + ")|($)", g);
          }
        }
        return l.prototype.$setMaxTokenCount = function(u) {
          s = u | 0;
        }, l.prototype.$applyToken = function(u) {
          var c = this.splitRegex.exec(u).slice(1), d = this.token.apply(this, c);
          if (typeof d == "string")
            return [{ type: d, value: u }];
          for (var f = [], h = 0, p = d.length; h < p; h++)
            c[h] && (f[f.length] = {
              type: d[h],
              value: c[h]
            });
          return f;
        }, l.prototype.$arrayTokens = function(u) {
          if (!u)
            return [];
          var c = this.splitRegex.exec(u);
          if (!c)
            return "text";
          for (var d = [], f = this.tokenArray, h = 0, p = f.length; h < p; h++)
            c[h + 1] && (d[d.length] = {
              type: f[h],
              value: c[h + 1]
            });
          return d;
        }, l.prototype.removeCapturingGroups = function(u) {
          var c = u.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!<]|(\()/g, function(d, f) {
            return f ? "(?:" : d;
          });
          return c;
        }, l.prototype.createSplitterRegexp = function(u, c) {
          if (u.indexOf("(?=") != -1) {
            var d = 0, f = !1, h = {};
            u.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(p, g, m, v, b, x) {
              return f ? f = b != "]" : b ? f = !0 : v ? (d == h.stack && (h.end = x + 1, h.stack = -1), d--) : m && (d++, m.length != 1 && (h.stack = d, h.start = x)), p;
            }), h.end != null && /^\)*$/.test(u.substr(h.end)) && (u = u.substring(0, h.start) + u.substr(h.end));
          }
          return u.charAt(0) != "^" && (u = "^" + u), u.charAt(u.length - 1) != "$" && (u += "$"), new RegExp(u, (c || "").replace("g", ""));
        }, l.prototype.getLineTokens = function(u, c) {
          if (c && typeof c != "string") {
            var d = c.slice(0);
            c = d[0], c === "#tmp" && (d.shift(), c = d.shift());
          } else
            var d = [];
          var f = (
            /**@type{string}*/
            c || "start"
          ), h = this.states[f];
          h || (f = "start", h = this.states[f]);
          var p = this.matchMappings[f], g = this.regExps[f];
          g.lastIndex = 0;
          for (var m, v = [], b = 0, x = 0, w = { type: null, value: "" }; m = g.exec(u); ) {
            var C = p.defaultToken, y = null, S = m[0], A = g.lastIndex;
            if (A - S.length > b) {
              var $ = u.substring(b, A - S.length);
              w.type == C ? w.value += $ : (w.type && v.push(w), w = { type: C, value: $ });
            }
            for (var M = 0; M < m.length - 2; M++)
              if (m[M + 1] !== void 0) {
                y = h[p[M]], y.onMatch ? C = y.onMatch(S, f, d, u) : C = y.token, y.next && (typeof y.next == "string" ? f = y.next : f = y.next(f, d), h = this.states[f], h || (this.reportError("state doesn't exist", f), f = "start", h = this.states[f]), p = this.matchMappings[f], b = A, g = this.regExps[f], g.lastIndex = A), y.consumeLineEnd && (b = A);
                break;
              }
            if (S) {
              if (typeof C == "string")
                (!y || y.merge !== !1) && w.type === C ? w.value += S : (w.type && v.push(w), w = { type: C, value: S });
              else if (C) {
                w.type && v.push(w), w = { type: null, value: "" };
                for (var M = 0; M < C.length; M++)
                  v.push(C[M]);
              }
            }
            if (b == u.length)
              break;
            if (b = A, x++ > s) {
              for (x > 2 * u.length && this.reportError("infinite loop with in ace tokenizer", {
                startState: c,
                line: u
              }); b < u.length; )
                w.type && v.push(w), w = {
                  value: u.substring(b, b += 500),
                  type: "overflow"
                };
              f = "start", d = [];
              break;
            }
          }
          return w.type && v.push(w), d.length > 1 && d[0] !== f && d.unshift("#tmp", f), {
            tokens: v,
            state: d.length ? d : f
          };
        }, l;
      }()
    );
    a.prototype.reportError = o, r.Tokenizer = a;
  }), ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/deep_copy"], function(n, r, i) {
    var o = n("../lib/deep_copy").deepCopy, s;
    s = function() {
      this.$rules = {
        start: [{
          token: "empty_line",
          regex: "^$"
        }, {
          defaultToken: "text"
        }]
      };
    }, (function() {
      this.addRules = function(u, c) {
        if (!c) {
          for (var d in u)
            this.$rules[d] = u[d];
          return;
        }
        for (var d in u) {
          for (var f = u[d], h = 0; h < f.length; h++) {
            var p = f[h];
            (p.next || p.onMatch) && (typeof p.next == "string" && p.next.indexOf(c) !== 0 && (p.next = c + p.next), p.nextState && p.nextState.indexOf(c) !== 0 && (p.nextState = c + p.nextState));
          }
          this.$rules[c + d] = f;
        }
      }, this.getRules = function() {
        return this.$rules;
      }, this.embedRules = function(u, c, d, f, h) {
        var p = typeof u == "function" ? new u().getRules() : u;
        if (f)
          for (var g = 0; g < f.length; g++)
            f[g] = c + f[g];
        else {
          f = [];
          for (var m in p)
            f.push(c + m);
        }
        if (this.addRules(p, c), d)
          for (var v = Array.prototype[h ? "push" : "unshift"], g = 0; g < f.length; g++)
            v.apply(this.$rules[f[g]], o(d));
        this.$embeds || (this.$embeds = []), this.$embeds.push(c);
      }, this.getEmbeds = function() {
        return this.$embeds;
      };
      var a = function(u, c) {
        return (u != "start" || c.length) && c.unshift(this.nextState, u), this.nextState;
      }, l = function(u, c) {
        return c.shift(), c.shift() || "start";
      };
      this.normalizeRules = function() {
        var u = 0, c = this.$rules;
        function d(f) {
          var h = c[f];
          h.processed = !0;
          for (var p = 0; p < h.length; p++) {
            var g = h[p], m = null;
            Array.isArray(g) && (m = g, g = {}), !g.regex && g.start && (g.regex = g.start, g.next || (g.next = []), g.next.push({
              defaultToken: g.token
            }, {
              token: g.token + ".end",
              regex: g.end || g.start,
              next: "pop"
            }), g.token = g.token + ".start", g.push = !0);
            var v = g.next || g.push;
            if (v && Array.isArray(v)) {
              var b = g.stateName;
              b || (b = g.token, typeof b != "string" && (b = b[0] || ""), c[b] && (b += u++)), c[b] = v, g.next = b, d(b);
            } else
              v == "pop" && (g.next = l);
            if (g.push && (g.nextState = g.next || g.push, g.next = a, delete g.push), g.rules)
              for (var x in g.rules)
                c[x] ? c[x].push && c[x].push.apply(c[x], g.rules[x]) : c[x] = g.rules[x];
            var w = typeof g == "string" ? g : g.include;
            if (w && (w === "$self" && (w = "start"), Array.isArray(w) ? m = w.map(function(y) {
              return c[y];
            }) : m = c[w]), m) {
              var C = [p, 1].concat(m);
              g.noEscape && (C = C.filter(function(y) {
                return !y.next;
              })), h.splice.apply(h, C), p--;
            }
            g.keywordMap && (g.token = this.createKeywordMapper(g.keywordMap, g.defaultToken || "text", g.caseInsensitive), delete g.defaultToken);
          }
        }
        Object.keys(c).forEach(d, this);
      }, this.createKeywordMapper = function(u, c, d, f) {
        var h = /* @__PURE__ */ Object.create(null);
        return this.$keywordList = [], Object.keys(u).forEach(function(p) {
          for (var g = u[p], m = g.split(f || "|"), v = m.length; v--; ) {
            var b = m[v];
            this.$keywordList.push(b), d && (b = b.toLowerCase()), h[b] = p;
          }
        }, this), u = null, d ? function(p) {
          return h[p.toLowerCase()] || c;
        } : function(p) {
          return h[p] || c;
        };
      }, this.getKeywords = function() {
        return this.$keywords;
      };
    }).call(s.prototype), r.TextHighlightRules = s;
  }), ace.define("ace/mode/behaviour", ["require", "exports", "module"], function(n, r, i) {
    var o;
    o = function() {
      this.$behaviours = {};
    }, (function() {
      this.add = function(s, a, l) {
        switch (void 0) {
          case this.$behaviours:
            this.$behaviours = {};
          case this.$behaviours[s]:
            this.$behaviours[s] = {};
        }
        this.$behaviours[s][a] = l;
      }, this.addBehaviours = function(s) {
        for (var a in s)
          for (var l in s[a])
            this.add(a, l, s[a][l]);
      }, this.remove = function(s) {
        this.$behaviours && this.$behaviours[s] && delete this.$behaviours[s];
      }, this.inherit = function(s, a) {
        if (typeof s == "function")
          var l = new s().getBehaviours(a);
        else
          var l = s.getBehaviours(a);
        this.addBehaviours(l);
      }, this.getBehaviours = function(s) {
        if (s) {
          for (var a = {}, l = 0; l < s.length; l++)
            this.$behaviours[s[l]] && (a[s[l]] = this.$behaviours[s[l]]);
          return a;
        } else
          return this.$behaviours;
      };
    }).call(o.prototype), r.Behaviour = o;
  }), ace.define("ace/token_iterator", ["require", "exports", "module", "ace/range"], function(n, r, i) {
    var o = n("./range").Range, s = (
      /** @class */
      function() {
        function a(l, u, c) {
          this.$session = l, this.$row = u, this.$rowTokens = l.getTokens(u);
          var d = l.getTokenAt(u, c);
          this.$tokenIndex = d ? d.index : -1;
        }
        return a.prototype.stepBackward = function() {
          for (this.$tokenIndex -= 1; this.$tokenIndex < 0; ) {
            if (this.$row -= 1, this.$row < 0)
              return this.$row = 0, null;
            this.$rowTokens = this.$session.getTokens(this.$row), this.$tokenIndex = this.$rowTokens.length - 1;
          }
          return this.$rowTokens[this.$tokenIndex];
        }, a.prototype.stepForward = function() {
          this.$tokenIndex += 1;
          for (var l; this.$tokenIndex >= this.$rowTokens.length; ) {
            if (this.$row += 1, l || (l = this.$session.getLength()), this.$row >= l)
              return this.$row = l - 1, null;
            this.$rowTokens = this.$session.getTokens(this.$row), this.$tokenIndex = 0;
          }
          return this.$rowTokens[this.$tokenIndex];
        }, a.prototype.getCurrentToken = function() {
          return this.$rowTokens[this.$tokenIndex];
        }, a.prototype.getCurrentTokenRow = function() {
          return this.$row;
        }, a.prototype.getCurrentTokenColumn = function() {
          var l = this.$rowTokens, u = this.$tokenIndex, c = l[u].start;
          if (c !== void 0)
            return c;
          for (c = 0; u > 0; )
            u -= 1, c += l[u].value.length;
          return c;
        }, a.prototype.getCurrentTokenPosition = function() {
          return { row: this.$row, column: this.getCurrentTokenColumn() };
        }, a.prototype.getCurrentTokenRange = function() {
          var l = this.$rowTokens[this.$tokenIndex], u = this.getCurrentTokenColumn();
          return new o(this.$row, u, this.$row, u + l.value.length);
        }, a;
      }()
    );
    r.TokenIterator = s;
  }), ace.define("ace/mode/behaviour/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function(n, r, i) {
    var o = n("../../lib/oop"), s = n("../behaviour").Behaviour, a = n("../../token_iterator").TokenIterator, l = n("../../lib/lang"), u = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator"], c = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator", "comment"], d, f = {}, h = { '"': '"', "'": "'" }, p = function(v) {
      var b = -1;
      if (v.multiSelect && (b = v.selection.index, f.rangeCount != v.multiSelect.rangeCount && (f = { rangeCount: v.multiSelect.rangeCount })), f[b])
        return d = f[b];
      d = f[b] = {
        autoInsertedBrackets: 0,
        autoInsertedRow: -1,
        autoInsertedLineEnd: "",
        maybeInsertedBrackets: 0,
        maybeInsertedRow: -1,
        maybeInsertedLineStart: "",
        maybeInsertedLineEnd: ""
      };
    }, g = function(v, b, x, w) {
      var C = v.end.row - v.start.row;
      return {
        text: x + b + w,
        selection: [
          0,
          v.start.column + 1,
          C,
          v.end.column + (C ? 0 : 1)
        ]
      };
    }, m;
    m = function(v) {
      v = v || {}, this.add("braces", "insertion", function(b, x, w, C, y) {
        var S = w.getCursorPosition(), A = C.doc.getLine(S.row);
        if (y == "{") {
          p(w);
          var $ = w.getSelectionRange(), M = C.doc.getTextRange($), _ = C.getTokenAt(S.row, S.column);
          if (M !== "" && M !== "{" && w.getWrapBehavioursEnabled())
            return g($, M, "{", "}");
          if (_ && /(?:string)\.quasi|\.xml/.test(_.type)) {
            var T = [
              /tag\-(?:open|name)/,
              /attribute\-name/
            ];
            return T.some(function(L) {
              return L.test(_.type);
            }) || /(string)\.quasi/.test(_.type) && _.value[S.column - _.start - 1] !== "$" ? void 0 : (m.recordAutoInsert(w, C, "}"), {
              text: "{}",
              selection: [1, 1]
            });
          } else if (m.isSaneInsertion(w, C))
            return /[\]\}\)]/.test(A[S.column]) || w.inMultiSelectMode || v.braces ? (m.recordAutoInsert(w, C, "}"), {
              text: "{}",
              selection: [1, 1]
            }) : (m.recordMaybeInsert(w, C, "{"), {
              text: "{",
              selection: [1, 1]
            });
        } else if (y == "}") {
          p(w);
          var D = A.substring(S.column, S.column + 1);
          if (D == "}") {
            var E = C.$findOpeningBracket("}", { column: S.column + 1, row: S.row });
            if (E !== null && m.isAutoInsertedClosing(S, A, y))
              return m.popAutoInsertedClosing(), {
                text: "",
                selection: [1, 1]
              };
          }
        } else if (y == `
` || y == `\r
`) {
          p(w);
          var R = "";
          m.isMaybeInsertedClosing(S, A) && (R = l.stringRepeat("}", d.maybeInsertedBrackets), m.clearMaybeInsertedClosing());
          var D = A.substring(S.column, S.column + 1);
          if (D === "}") {
            var I = C.findMatchingBracket({ row: S.row, column: S.column + 1 }, "}");
            if (!I)
              return null;
            var k = this.$getIndent(C.getLine(I.row));
          } else if (R)
            var k = this.$getIndent(A);
          else {
            m.clearMaybeInsertedClosing();
            return;
          }
          var P = k + C.getTabString();
          return {
            text: `
` + P + `
` + k + R,
            selection: [1, P.length, 1, P.length]
          };
        } else
          m.clearMaybeInsertedClosing();
      }), this.add("braces", "deletion", function(b, x, w, C, y) {
        var S = C.doc.getTextRange(y);
        if (!y.isMultiLine() && S == "{") {
          p(w);
          var A = C.doc.getLine(y.start.row), $ = A.substring(y.end.column, y.end.column + 1);
          if ($ == "}")
            return y.end.column++, y;
          d.maybeInsertedBrackets--;
        }
      }), this.add("parens", "insertion", function(b, x, w, C, y) {
        if (y == "(") {
          p(w);
          var S = w.getSelectionRange(), A = C.doc.getTextRange(S);
          if (A !== "" && w.getWrapBehavioursEnabled())
            return g(S, A, "(", ")");
          if (m.isSaneInsertion(w, C))
            return m.recordAutoInsert(w, C, ")"), {
              text: "()",
              selection: [1, 1]
            };
        } else if (y == ")") {
          p(w);
          var $ = w.getCursorPosition(), M = C.doc.getLine($.row), _ = M.substring($.column, $.column + 1);
          if (_ == ")") {
            var T = C.$findOpeningBracket(")", { column: $.column + 1, row: $.row });
            if (T !== null && m.isAutoInsertedClosing($, M, y))
              return m.popAutoInsertedClosing(), {
                text: "",
                selection: [1, 1]
              };
          }
        }
      }), this.add("parens", "deletion", function(b, x, w, C, y) {
        var S = C.doc.getTextRange(y);
        if (!y.isMultiLine() && S == "(") {
          p(w);
          var A = C.doc.getLine(y.start.row), $ = A.substring(y.start.column + 1, y.start.column + 2);
          if ($ == ")")
            return y.end.column++, y;
        }
      }), this.add("brackets", "insertion", function(b, x, w, C, y) {
        if (y == "[") {
          p(w);
          var S = w.getSelectionRange(), A = C.doc.getTextRange(S);
          if (A !== "" && w.getWrapBehavioursEnabled())
            return g(S, A, "[", "]");
          if (m.isSaneInsertion(w, C))
            return m.recordAutoInsert(w, C, "]"), {
              text: "[]",
              selection: [1, 1]
            };
        } else if (y == "]") {
          p(w);
          var $ = w.getCursorPosition(), M = C.doc.getLine($.row), _ = M.substring($.column, $.column + 1);
          if (_ == "]") {
            var T = C.$findOpeningBracket("]", { column: $.column + 1, row: $.row });
            if (T !== null && m.isAutoInsertedClosing($, M, y))
              return m.popAutoInsertedClosing(), {
                text: "",
                selection: [1, 1]
              };
          }
        }
      }), this.add("brackets", "deletion", function(b, x, w, C, y) {
        var S = C.doc.getTextRange(y);
        if (!y.isMultiLine() && S == "[") {
          p(w);
          var A = C.doc.getLine(y.start.row), $ = A.substring(y.start.column + 1, y.start.column + 2);
          if ($ == "]")
            return y.end.column++, y;
        }
      }), this.add("string_dquotes", "insertion", function(b, x, w, C, y) {
        var S = C.$mode.$quotes || h;
        if (y.length == 1 && S[y]) {
          if (this.lineCommentStart && this.lineCommentStart.indexOf(y) != -1)
            return;
          p(w);
          var A = y, $ = w.getSelectionRange(), M = C.doc.getTextRange($);
          if (M !== "" && (M.length != 1 || !S[M]) && w.getWrapBehavioursEnabled())
            return g($, M, A, A);
          if (!M) {
            var _ = w.getCursorPosition(), T = C.doc.getLine(_.row), D = T.substring(_.column - 1, _.column), E = T.substring(_.column, _.column + 1), R = C.getTokenAt(_.row, _.column), I = C.getTokenAt(_.row, _.column + 1);
            if (D == "\\" && R && /escape/.test(R.type))
              return null;
            var k = R && /string|escape/.test(R.type), P = !I || /string|escape/.test(I.type), L;
            if (E == A)
              L = k !== P, L && /string\.end/.test(I.type) && (L = !1);
            else {
              if (k && !P || k && P)
                return null;
              var N = C.$mode.tokenRe;
              N.lastIndex = 0;
              var F = N.test(D);
              N.lastIndex = 0;
              var B = N.test(E), j = C.$mode.$pairQuotesAfter, z = j && j[A] && j[A].test(D);
              if (!z && F || B || E && !/[\s;,.})\]\\]/.test(E))
                return null;
              var H = T[_.column - 2];
              if (D == A && (H == A || N.test(H)))
                return null;
              L = !0;
            }
            return {
              text: L ? A + A : "",
              selection: [1, 1]
            };
          }
        }
      }), this.add("string_dquotes", "deletion", function(b, x, w, C, y) {
        var S = C.$mode.$quotes || h, A = C.doc.getTextRange(y);
        if (!y.isMultiLine() && S.hasOwnProperty(A)) {
          p(w);
          var $ = C.doc.getLine(y.start.row), M = $.substring(y.start.column + 1, y.start.column + 2);
          if (M == A)
            return y.end.column++, y;
        }
      }), v.closeDocComment !== !1 && this.add("doc comment end", "insertion", function(b, x, w, C, y) {
        if (b === "doc-start" && (y === `
` || y === `\r
`) && w.selection.isEmpty()) {
          var S = w.getCursorPosition(), A = C.doc.getLine(S.row), $ = C.doc.getLine(S.row + 1), M = this.$getIndent(A);
          if (/\s*\*/.test($))
            return /^\s*\*/.test(A) ? {
              text: y + M + "* ",
              selection: [1, 3 + M.length, 1, 3 + M.length]
            } : {
              text: y + M + " * ",
              selection: [1, 3 + M.length, 1, 3 + M.length]
            };
          if (/\/\*\*/.test(A.substring(0, S.column)))
            return {
              text: y + M + " * " + y + " " + M + "*/",
              selection: [1, 4 + M.length, 1, 4 + M.length]
            };
        }
      });
    }, m.isSaneInsertion = function(v, b) {
      var x = v.getCursorPosition(), w = new a(b, x.row, x.column);
      if (!this.$matchTokenType(w.getCurrentToken() || "text", u)) {
        if (/[)}\]]/.test(v.session.getLine(x.row)[x.column]))
          return !0;
        var C = new a(b, x.row, x.column + 1);
        if (!this.$matchTokenType(C.getCurrentToken() || "text", u))
          return !1;
      }
      return w.stepForward(), w.getCurrentTokenRow() !== x.row || this.$matchTokenType(w.getCurrentToken() || "text", c);
    }, m.$matchTokenType = function(v, b) {
      return b.indexOf(v.type || v) > -1;
    }, m.recordAutoInsert = function(v, b, x) {
      var w = v.getCursorPosition(), C = b.doc.getLine(w.row);
      this.isAutoInsertedClosing(w, C, d.autoInsertedLineEnd[0]) || (d.autoInsertedBrackets = 0), d.autoInsertedRow = w.row, d.autoInsertedLineEnd = x + C.substr(w.column), d.autoInsertedBrackets++;
    }, m.recordMaybeInsert = function(v, b, x) {
      var w = v.getCursorPosition(), C = b.doc.getLine(w.row);
      this.isMaybeInsertedClosing(w, C) || (d.maybeInsertedBrackets = 0), d.maybeInsertedRow = w.row, d.maybeInsertedLineStart = C.substr(0, w.column) + x, d.maybeInsertedLineEnd = C.substr(w.column), d.maybeInsertedBrackets++;
    }, m.isAutoInsertedClosing = function(v, b, x) {
      return d.autoInsertedBrackets > 0 && v.row === d.autoInsertedRow && x === d.autoInsertedLineEnd[0] && b.substr(v.column) === d.autoInsertedLineEnd;
    }, m.isMaybeInsertedClosing = function(v, b) {
      return d.maybeInsertedBrackets > 0 && v.row === d.maybeInsertedRow && b.substr(v.column) === d.maybeInsertedLineEnd && b.substr(0, v.column) == d.maybeInsertedLineStart;
    }, m.popAutoInsertedClosing = function() {
      d.autoInsertedLineEnd = d.autoInsertedLineEnd.substr(1), d.autoInsertedBrackets--;
    }, m.clearMaybeInsertedClosing = function() {
      d && (d.maybeInsertedBrackets = 0, d.maybeInsertedRow = -1);
    }, o.inherits(m, s), r.CstyleBehaviour = m;
  }), ace.define("ace/unicode", ["require", "exports", "module"], function(n, r, i) {
    for (var o = [48, 9, 8, 25, 5, 0, 2, 25, 48, 0, 11, 0, 5, 0, 6, 22, 2, 30, 2, 457, 5, 11, 15, 4, 8, 0, 2, 0, 18, 116, 2, 1, 3, 3, 9, 0, 2, 2, 2, 0, 2, 19, 2, 82, 2, 138, 2, 4, 3, 155, 12, 37, 3, 0, 8, 38, 10, 44, 2, 0, 2, 1, 2, 1, 2, 0, 9, 26, 6, 2, 30, 10, 7, 61, 2, 9, 5, 101, 2, 7, 3, 9, 2, 18, 3, 0, 17, 58, 3, 100, 15, 53, 5, 0, 6, 45, 211, 57, 3, 18, 2, 5, 3, 11, 3, 9, 2, 1, 7, 6, 2, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 0, 4, 3, 3, 8, 3, 1, 3, 3, 9, 0, 5, 1, 2, 4, 3, 11, 16, 2, 2, 5, 5, 1, 3, 21, 2, 6, 2, 1, 2, 1, 2, 1, 3, 0, 2, 4, 5, 1, 3, 2, 4, 0, 8, 3, 2, 0, 8, 15, 12, 2, 2, 8, 2, 2, 2, 21, 2, 6, 2, 1, 2, 4, 3, 9, 2, 2, 2, 2, 3, 0, 16, 3, 3, 9, 18, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 3, 8, 3, 1, 3, 2, 9, 1, 5, 1, 2, 4, 3, 9, 2, 0, 17, 1, 2, 5, 4, 2, 2, 3, 4, 1, 2, 0, 2, 1, 4, 1, 4, 2, 4, 11, 5, 4, 4, 2, 2, 3, 3, 0, 7, 0, 15, 9, 18, 2, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 4, 7, 2, 2, 2, 3, 8, 1, 2, 1, 7, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 3, 8, 2, 2, 2, 3, 8, 1, 8, 0, 2, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 15, 4, 7, 2, 2, 2, 3, 10, 0, 9, 3, 3, 9, 11, 5, 3, 1, 2, 17, 4, 23, 2, 8, 2, 0, 3, 6, 4, 0, 5, 5, 2, 0, 2, 7, 19, 1, 14, 57, 6, 14, 2, 9, 40, 1, 2, 0, 3, 1, 2, 0, 3, 0, 7, 3, 2, 6, 2, 2, 2, 0, 2, 0, 3, 1, 2, 12, 2, 2, 3, 4, 2, 0, 2, 5, 3, 9, 3, 1, 35, 0, 24, 1, 7, 9, 12, 0, 2, 0, 2, 0, 5, 9, 2, 35, 5, 19, 2, 5, 5, 7, 2, 35, 10, 0, 58, 73, 7, 77, 3, 37, 11, 42, 2, 0, 4, 328, 2, 3, 3, 6, 2, 0, 2, 3, 3, 40, 2, 3, 3, 32, 2, 3, 3, 6, 2, 0, 2, 3, 3, 14, 2, 56, 2, 3, 3, 66, 5, 0, 33, 15, 17, 84, 13, 619, 3, 16, 2, 25, 6, 74, 22, 12, 2, 6, 12, 20, 12, 19, 13, 12, 2, 2, 2, 1, 13, 51, 3, 29, 4, 0, 5, 1, 3, 9, 34, 2, 3, 9, 7, 87, 9, 42, 6, 69, 11, 28, 4, 11, 5, 11, 11, 39, 3, 4, 12, 43, 5, 25, 7, 10, 38, 27, 5, 62, 2, 28, 3, 10, 7, 9, 14, 0, 89, 75, 5, 9, 18, 8, 13, 42, 4, 11, 71, 55, 9, 9, 4, 48, 83, 2, 2, 30, 14, 230, 23, 280, 3, 5, 3, 37, 3, 5, 3, 7, 2, 0, 2, 0, 2, 0, 2, 30, 3, 52, 2, 6, 2, 0, 4, 2, 2, 6, 4, 3, 3, 5, 5, 12, 6, 2, 2, 6, 67, 1, 20, 0, 29, 0, 14, 0, 17, 4, 60, 12, 5, 0, 4, 11, 18, 0, 5, 0, 3, 9, 2, 0, 4, 4, 7, 0, 2, 0, 2, 0, 2, 3, 2, 10, 3, 3, 6, 4, 5, 0, 53, 1, 2684, 46, 2, 46, 2, 132, 7, 6, 15, 37, 11, 53, 10, 0, 17, 22, 10, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 31, 48, 0, 470, 1, 36, 5, 2, 4, 6, 1, 5, 85, 3, 1, 3, 2, 2, 89, 2, 3, 6, 40, 4, 93, 18, 23, 57, 15, 513, 6581, 75, 20939, 53, 1164, 68, 45, 3, 268, 4, 27, 21, 31, 3, 13, 13, 1, 2, 24, 9, 69, 11, 1, 38, 8, 3, 102, 3, 1, 111, 44, 25, 51, 13, 68, 12, 9, 7, 23, 4, 0, 5, 45, 3, 35, 13, 28, 4, 64, 15, 10, 39, 54, 10, 13, 3, 9, 7, 22, 4, 1, 5, 66, 25, 2, 227, 42, 2, 1, 3, 9, 7, 11171, 13, 22, 5, 48, 8453, 301, 3, 61, 3, 105, 39, 6, 13, 4, 6, 11, 2, 12, 2, 4, 2, 0, 2, 1, 2, 1, 2, 107, 34, 362, 19, 63, 3, 53, 41, 11, 5, 15, 17, 6, 13, 1, 25, 2, 33, 4, 2, 134, 20, 9, 8, 25, 5, 0, 2, 25, 12, 88, 4, 5, 3, 5, 3, 5, 3, 2], s = 0, a = [], l = 0; l < o.length; l += 2)
      a.push(s += o[l]), o[l + 1] && a.push(45, s += o[l + 1]);
    r.wordChars = String.fromCharCode.apply(null, a);
  }), ace.define("ace/mode/text", ["require", "exports", "module", "ace/config", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour/cstyle", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function(n, r, i) {
    var o = n("../config"), s = n("../tokenizer").Tokenizer, a = n("./text_highlight_rules").TextHighlightRules, l = n("./behaviour/cstyle").CstyleBehaviour, u = n("../unicode"), c = n("../lib/lang"), d = n("../token_iterator").TokenIterator, f = n("../range").Range, h;
    h = function() {
      this.HighlightRules = a;
    }, (function() {
      this.$defaultBehaviour = new l(), this.tokenRe = new RegExp("^[" + u.wordChars + "\\$_]+", "g"), this.nonTokenRe = new RegExp("^(?:[^" + u.wordChars + "\\$_]|\\s])+", "g"), this.getTokenizer = function() {
        return this.$tokenizer || (this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig), this.$tokenizer = new s(this.$highlightRules.getRules())), this.$tokenizer;
      }, this.lineCommentStart = "", this.blockComment = "", this.toggleCommentLines = function(p, g, m, v) {
        var b = g.doc, x = !0, w = !0, C = 1 / 0, y = g.getTabSize(), S = !1;
        if (this.lineCommentStart) {
          if (Array.isArray(this.lineCommentStart))
            var M = this.lineCommentStart.map(c.escapeRegExp).join("|"), A = this.lineCommentStart[0];
          else
            var M = c.escapeRegExp(this.lineCommentStart), A = this.lineCommentStart;
          M = new RegExp("^(\\s*)(?:" + M + ") ?"), S = g.getUseSoftTabs();
          var D = function(B, j) {
            var z = B.match(M);
            if (z) {
              var H = z[1].length, W = z[0].length;
              !I(B, H, W) && z[0][W - 1] == " " && W--, b.removeInLine(j, H, W);
            }
          }, R = A + " ", T = function(B, j) {
            (!x || /\S/.test(B)) && (I(B, C, C) ? b.insertInLine({ row: j, column: C }, R) : b.insertInLine({ row: j, column: C }, A));
          }, E = function(B, j) {
            return M.test(B);
          }, I = function(B, j, z) {
            for (var H = 0; j-- && B.charAt(j) == " "; )
              H++;
            if (H % y != 0)
              return !1;
            for (var H = 0; B.charAt(z++) == " "; )
              H++;
            return y > 2 ? H % y != y - 1 : H % y == 0;
          };
        } else {
          if (!this.blockComment)
            return !1;
          var A = this.blockComment.start, $ = this.blockComment.end, M = new RegExp("^(\\s*)(?:" + c.escapeRegExp(A) + ")"), _ = new RegExp("(?:" + c.escapeRegExp($) + ")\\s*$"), T = function(L, N) {
            E(L, N) || (!x || /\S/.test(L)) && (b.insertInLine({ row: N, column: L.length }, $), b.insertInLine({ row: N, column: C }, A));
          }, D = function(L, N) {
            var F;
            (F = L.match(_)) && b.removeInLine(N, L.length - F[0].length, L.length), (F = L.match(M)) && b.removeInLine(N, F[1].length, F[0].length);
          }, E = function(L, N) {
            if (M.test(L))
              return !0;
            for (var F = g.getTokens(N), B = 0; B < F.length; B++)
              if (F[B].type === "comment")
                return !0;
          };
        }
        function k(L) {
          for (var N = m; N <= v; N++)
            L(b.getLine(N), N);
        }
        var P = 1 / 0;
        k(function(L, N) {
          var F = L.search(/\S/);
          F !== -1 ? (F < C && (C = F), w && !E(L, N) && (w = !1)) : P > L.length && (P = L.length);
        }), C == 1 / 0 && (C = P, x = !1, w = !1), S && C % y != 0 && (C = Math.floor(C / y) * y), k(w ? D : T);
      }, this.toggleBlockComment = function(p, g, m, v) {
        var b = this.blockComment;
        if (b) {
          !b.start && b[0] && (b = b[0]);
          var x = new d(g, v.row, v.column), w = x.getCurrentToken();
          g.selection;
          var C = g.selection.toOrientedRange(), y, S;
          if (w && /comment/.test(w.type)) {
            for (var A, $; w && /comment/.test(w.type); ) {
              var M = w.value.indexOf(b.start);
              if (M != -1) {
                var _ = x.getCurrentTokenRow(), T = x.getCurrentTokenColumn() + M;
                A = new f(_, T, _, T + b.start.length);
                break;
              }
              w = x.stepBackward();
            }
            for (var x = new d(g, v.row, v.column), w = x.getCurrentToken(); w && /comment/.test(w.type); ) {
              var M = w.value.indexOf(b.end);
              if (M != -1) {
                var _ = x.getCurrentTokenRow(), T = x.getCurrentTokenColumn() + M;
                $ = new f(_, T, _, T + b.end.length);
                break;
              }
              w = x.stepForward();
            }
            $ && g.remove($), A && (g.remove(A), y = A.start.row, S = -b.start.length);
          } else
            S = b.start.length, y = m.start.row, g.insert(m.end, b.end), g.insert(m.start, b.start);
          C.start.row == y && (C.start.column += S), C.end.row == y && (C.end.column += S), g.selection.fromOrientedRange(C);
        }
      }, this.getNextLineIndent = function(p, g, m) {
        return this.$getIndent(g);
      }, this.checkOutdent = function(p, g, m) {
        return !1;
      }, this.autoOutdent = function(p, g, m) {
      }, this.$getIndent = function(p) {
        return p.match(/^\s*/)[0];
      }, this.createWorker = function(p) {
        return null;
      }, this.createModeDelegates = function(p) {
        this.$embeds = [], this.$modes = {};
        for (var g in p)
          if (p[g]) {
            var m = p[g], v = m.prototype.$id, b = o.$modes[v];
            b || (o.$modes[v] = b = new m()), o.$modes[g] || (o.$modes[g] = b), this.$embeds.push(g), this.$modes[g] = b;
          }
        for (var x = [
          "toggleBlockComment",
          "toggleCommentLines",
          "getNextLineIndent",
          "checkOutdent",
          "autoOutdent",
          "transformAction",
          "getCompletions"
        ], w = function(y) {
          (function(S) {
            var A = x[y], $ = S[A];
            S[x[y]] = function() {
              return this.$delegator(A, arguments, $);
            };
          })(C);
        }, C = this, g = 0; g < x.length; g++)
          w(g);
      }, this.$delegator = function(p, g, m) {
        var v = g[0] || "start";
        if (typeof v != "string") {
          if (Array.isArray(v[2])) {
            var b = v[2][v[2].length - 1], x = this.$modes[b];
            if (x)
              return x[p].apply(x, [v[1]].concat([].slice.call(g, 1)));
          }
          v = v[0] || "start";
        }
        for (var w = 0; w < this.$embeds.length; w++)
          if (this.$modes[this.$embeds[w]]) {
            var C = v.split(this.$embeds[w]);
            if (!C[0] && C[1]) {
              g[0] = C[1];
              var x = this.$modes[this.$embeds[w]];
              return x[p].apply(x, g);
            }
          }
        var y = m.apply(this, g);
        return m ? y : void 0;
      }, this.transformAction = function(p, g, m, v, b) {
        if (this.$behaviour) {
          var x = this.$behaviour.getBehaviours();
          for (var w in x)
            if (x[w][g]) {
              var C = x[w][g].apply(this, arguments);
              if (C)
                return C;
            }
        }
      }, this.getKeywords = function(p) {
        if (!this.completionKeywords) {
          var g = this.$tokenizer.rules, m = [];
          for (var v in g)
            for (var b = g[v], x = 0, w = b.length; x < w; x++)
              if (typeof b[x].token == "string")
                /keyword|support|storage/.test(b[x].token) && m.push(b[x].regex);
              else if (typeof b[x].token == "object") {
                for (var C = 0, y = b[x].token.length; C < y; C++)
                  if (/keyword|support|storage/.test(b[x].token[C])) {
                    var v = b[x].regex.match(/\(.+?\)/g)[C];
                    m.push(v.substr(1, v.length - 2));
                  }
              }
          this.completionKeywords = m;
        }
        return p ? m.concat(this.$keywordList || []) : this.$keywordList;
      }, this.$createKeywordList = function() {
        return this.$highlightRules || this.getTokenizer(), this.$keywordList = this.$highlightRules.$keywordList || [];
      }, this.getCompletions = function(p, g, m, v) {
        var b = this.$keywordList || this.$createKeywordList();
        return b.map(function(x) {
          return {
            name: x,
            value: x,
            score: 0,
            meta: "keyword"
          };
        });
      }, this.$id = "ace/mode/text";
    }).call(h.prototype), r.Mode = h;
  }), ace.define("ace/apply_delta", ["require", "exports", "module"], function(n, r, i) {
    r.applyDelta = function(o, s, a) {
      var l = s.start.row, u = s.start.column, c = o[l] || "";
      switch (s.action) {
        case "insert":
          var d = s.lines;
          if (d.length === 1)
            o[l] = c.substring(0, u) + s.lines[0] + c.substring(u);
          else {
            var f = [l, 1].concat(s.lines);
            o.splice.apply(o, f), o[l] = c.substring(0, u) + o[l], o[l + s.lines.length - 1] += c.substring(u);
          }
          break;
        case "remove":
          var h = s.end.column, p = s.end.row;
          l === p ? o[l] = c.substring(0, u) + c.substring(h) : o.splice(l, p - l + 1, c.substring(0, u) + o[p].substring(h));
          break;
      }
    };
  }), ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(n, r, i) {
    var o = n("./lib/oop"), s = n("./lib/event_emitter").EventEmitter, a = (
      /** @class */
      function() {
        function c(d, f, h) {
          this.$onChange = this.onChange.bind(this), this.attach(d), typeof f != "number" ? this.setPosition(f.row, f.column) : this.setPosition(f, h);
        }
        return c.prototype.getPosition = function() {
          return this.$clipPositionToDocument(this.row, this.column);
        }, c.prototype.getDocument = function() {
          return this.document;
        }, c.prototype.onChange = function(d) {
          if (!(d.start.row == d.end.row && d.start.row != this.row) && !(d.start.row > this.row)) {
            var f = u(d, { row: this.row, column: this.column }, this.$insertRight);
            this.setPosition(f.row, f.column, !0);
          }
        }, c.prototype.setPosition = function(d, f, h) {
          var p;
          if (h ? p = {
            row: d,
            column: f
          } : p = this.$clipPositionToDocument(d, f), !(this.row == p.row && this.column == p.column)) {
            var g = {
              row: this.row,
              column: this.column
            };
            this.row = p.row, this.column = p.column, this._signal("change", {
              old: g,
              value: p
            });
          }
        }, c.prototype.detach = function() {
          this.document.off("change", this.$onChange);
        }, c.prototype.attach = function(d) {
          this.document = d || this.document, this.document.on("change", this.$onChange);
        }, c.prototype.$clipPositionToDocument = function(d, f) {
          var h = {};
          return d >= this.document.getLength() ? (h.row = Math.max(0, this.document.getLength() - 1), h.column = this.document.getLine(h.row).length) : d < 0 ? (h.row = 0, h.column = 0) : (h.row = d, h.column = Math.min(this.document.getLine(h.row).length, Math.max(0, f))), f < 0 && (h.column = 0), h;
        }, c;
      }()
    );
    a.prototype.$insertRight = !1, o.implement(a.prototype, s);
    function l(c, d, f) {
      var h = f ? c.column <= d.column : c.column < d.column;
      return c.row < d.row || c.row == d.row && h;
    }
    function u(c, d, f) {
      var h = c.action == "insert", p = (h ? 1 : -1) * (c.end.row - c.start.row), g = (h ? 1 : -1) * (c.end.column - c.start.column), m = c.start, v = h ? m : c.end;
      return l(d, m, f) ? {
        row: d.row,
        column: d.column
      } : l(v, d, !f) ? {
        row: d.row + p,
        column: d.column + (d.row == v.row ? g : 0)
      } : {
        row: m.row,
        column: m.column
      };
    }
    r.Anchor = a;
  }), ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function(n, r, i) {
    var o = n("./lib/oop"), s = n("./apply_delta").applyDelta, a = n("./lib/event_emitter").EventEmitter, l = n("./range").Range, u = n("./anchor").Anchor, c = (
      /** @class */
      function() {
        function d(f) {
          this.$lines = [""], f.length === 0 ? this.$lines = [""] : Array.isArray(f) ? this.insertMergedLines({ row: 0, column: 0 }, f) : this.insert({ row: 0, column: 0 }, f);
        }
        return d.prototype.setValue = function(f) {
          var h = this.getLength() - 1;
          this.remove(new l(0, 0, h, this.getLine(h).length)), this.insert({ row: 0, column: 0 }, f || "");
        }, d.prototype.getValue = function() {
          return this.getAllLines().join(this.getNewLineCharacter());
        }, d.prototype.createAnchor = function(f, h) {
          return new u(this, f, h);
        }, d.prototype.$detectNewLine = function(f) {
          var h = f.match(/^.*?(\r\n|\r|\n)/m);
          this.$autoNewLine = h ? h[1] : `
`, this._signal("changeNewLineMode");
        }, d.prototype.getNewLineCharacter = function() {
          switch (this.$newLineMode) {
            case "windows":
              return `\r
`;
            case "unix":
              return `
`;
            default:
              return this.$autoNewLine || `
`;
          }
        }, d.prototype.setNewLineMode = function(f) {
          this.$newLineMode !== f && (this.$newLineMode = f, this._signal("changeNewLineMode"));
        }, d.prototype.getNewLineMode = function() {
          return this.$newLineMode;
        }, d.prototype.isNewLine = function(f) {
          return f == `\r
` || f == "\r" || f == `
`;
        }, d.prototype.getLine = function(f) {
          return this.$lines[f] || "";
        }, d.prototype.getLines = function(f, h) {
          return this.$lines.slice(f, h + 1);
        }, d.prototype.getAllLines = function() {
          return this.getLines(0, this.getLength());
        }, d.prototype.getLength = function() {
          return this.$lines.length;
        }, d.prototype.getTextRange = function(f) {
          return this.getLinesForRange(f).join(this.getNewLineCharacter());
        }, d.prototype.getLinesForRange = function(f) {
          var h;
          if (f.start.row === f.end.row)
            h = [this.getLine(f.start.row).substring(f.start.column, f.end.column)];
          else {
            h = this.getLines(f.start.row, f.end.row), h[0] = (h[0] || "").substring(f.start.column);
            var p = h.length - 1;
            f.end.row - f.start.row == p && (h[p] = h[p].substring(0, f.end.column));
          }
          return h;
        }, d.prototype.insertLines = function(f, h) {
          return console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead."), this.insertFullLines(f, h);
        }, d.prototype.removeLines = function(f, h) {
          return console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead."), this.removeFullLines(f, h);
        }, d.prototype.insertNewLine = function(f) {
          return console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead."), this.insertMergedLines(f, ["", ""]);
        }, d.prototype.insert = function(f, h) {
          return this.getLength() <= 1 && this.$detectNewLine(h), this.insertMergedLines(f, this.$split(h));
        }, d.prototype.insertInLine = function(f, h) {
          var p = this.clippedPos(f.row, f.column), g = this.pos(f.row, f.column + h.length);
          return this.applyDelta({
            start: p,
            end: g,
            action: "insert",
            lines: [h]
          }, !0), this.clonePos(g);
        }, d.prototype.clippedPos = function(f, h) {
          var p = this.getLength();
          f === void 0 ? f = p : f < 0 ? f = 0 : f >= p && (f = p - 1, h = void 0);
          var g = this.getLine(f);
          return h == null && (h = g.length), h = Math.min(Math.max(h, 0), g.length), { row: f, column: h };
        }, d.prototype.clonePos = function(f) {
          return { row: f.row, column: f.column };
        }, d.prototype.pos = function(f, h) {
          return { row: f, column: h };
        }, d.prototype.$clipPosition = function(f) {
          var h = this.getLength();
          return f.row >= h ? (f.row = Math.max(0, h - 1), f.column = this.getLine(h - 1).length) : (f.row = Math.max(0, f.row), f.column = Math.min(Math.max(f.column, 0), this.getLine(f.row).length)), f;
        }, d.prototype.insertFullLines = function(f, h) {
          f = Math.min(Math.max(f, 0), this.getLength());
          var p = 0;
          f < this.getLength() ? (h = h.concat([""]), p = 0) : (h = [""].concat(h), f--, p = this.$lines[f].length), this.insertMergedLines({ row: f, column: p }, h);
        }, d.prototype.insertMergedLines = function(f, h) {
          var p = this.clippedPos(f.row, f.column), g = {
            row: p.row + h.length - 1,
            column: (h.length == 1 ? p.column : 0) + h[h.length - 1].length
          };
          return this.applyDelta({
            start: p,
            end: g,
            action: "insert",
            lines: h
          }), this.clonePos(g);
        }, d.prototype.remove = function(f) {
          var h = this.clippedPos(f.start.row, f.start.column), p = this.clippedPos(f.end.row, f.end.column);
          return this.applyDelta({
            start: h,
            end: p,
            action: "remove",
            lines: this.getLinesForRange({ start: h, end: p })
          }), this.clonePos(h);
        }, d.prototype.removeInLine = function(f, h, p) {
          var g = this.clippedPos(f, h), m = this.clippedPos(f, p);
          return this.applyDelta({
            start: g,
            end: m,
            action: "remove",
            lines: this.getLinesForRange({ start: g, end: m })
          }, !0), this.clonePos(g);
        }, d.prototype.removeFullLines = function(f, h) {
          f = Math.min(Math.max(0, f), this.getLength() - 1), h = Math.min(Math.max(0, h), this.getLength() - 1);
          var p = h == this.getLength() - 1 && f > 0, g = h < this.getLength() - 1, m = p ? f - 1 : f, v = p ? this.getLine(m).length : 0, b = g ? h + 1 : h, x = g ? 0 : this.getLine(b).length, w = new l(m, v, b, x), C = this.$lines.slice(f, h + 1);
          return this.applyDelta({
            start: w.start,
            end: w.end,
            action: "remove",
            lines: this.getLinesForRange(w)
          }), C;
        }, d.prototype.removeNewLine = function(f) {
          f < this.getLength() - 1 && f >= 0 && this.applyDelta({
            start: this.pos(f, this.getLine(f).length),
            end: this.pos(f + 1, 0),
            action: "remove",
            lines: ["", ""]
          });
        }, d.prototype.replace = function(f, h) {
          if (f instanceof l || (f = l.fromPoints(f.start, f.end)), h.length === 0 && f.isEmpty())
            return f.start;
          if (h == this.getTextRange(f))
            return f.end;
          this.remove(f);
          var p;
          return h ? p = this.insert(f.start, h) : p = f.start, p;
        }, d.prototype.applyDeltas = function(f) {
          for (var h = 0; h < f.length; h++)
            this.applyDelta(f[h]);
        }, d.prototype.revertDeltas = function(f) {
          for (var h = f.length - 1; h >= 0; h--)
            this.revertDelta(f[h]);
        }, d.prototype.applyDelta = function(f, h) {
          var p = f.action == "insert";
          (p ? f.lines.length <= 1 && !f.lines[0] : !l.comparePoints(f.start, f.end)) || (p && f.lines.length > 2e4 ? this.$splitAndapplyLargeDelta(f, 2e4) : (s(this.$lines, f, h), this._signal("change", f)));
        }, d.prototype.$safeApplyDelta = function(f) {
          var h = this.$lines.length;
          (f.action == "remove" && f.start.row < h && f.end.row < h || f.action == "insert" && f.start.row <= h) && this.applyDelta(f);
        }, d.prototype.$splitAndapplyLargeDelta = function(f, h) {
          for (var p = f.lines, g = p.length - h + 1, m = f.start.row, v = f.start.column, b = 0, x = 0; b < g; b = x) {
            x += h - 1;
            var w = p.slice(b, x);
            w.push(""), this.applyDelta({
              start: this.pos(m + b, v),
              end: this.pos(m + x, v = 0),
              action: f.action,
              lines: w
            }, !0);
          }
          f.lines = p.slice(b), f.start.row = m + b, f.start.column = v, this.applyDelta(f, !0);
        }, d.prototype.revertDelta = function(f) {
          this.$safeApplyDelta({
            start: this.clonePos(f.start),
            end: this.clonePos(f.end),
            action: f.action == "insert" ? "remove" : "insert",
            lines: f.lines.slice()
          });
        }, d.prototype.indexToPosition = function(f, h) {
          for (var p = this.$lines || this.getAllLines(), g = this.getNewLineCharacter().length, m = h || 0, v = p.length; m < v; m++)
            if (f -= p[m].length + g, f < 0)
              return { row: m, column: f + p[m].length + g };
          return { row: v - 1, column: f + p[v - 1].length + g };
        }, d.prototype.positionToIndex = function(f, h) {
          for (var p = this.$lines || this.getAllLines(), g = this.getNewLineCharacter().length, m = 0, v = Math.min(f.row, p.length), b = h || 0; b < v; ++b)
            m += p[b].length + g;
          return m + f.column;
        }, d.prototype.$split = function(f) {
          return f.split(/\r\n|\r|\n/);
        }, d;
      }()
    );
    c.prototype.$autoNewLine = "", c.prototype.$newLineMode = "auto", o.implement(c.prototype, a), r.Document = c;
  }), ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(n, r, i) {
    var o = n("./lib/oop"), s = n("./lib/event_emitter").EventEmitter, a = (
      /** @class */
      function() {
        function l(u, c) {
          this.running = !1, this.lines = [], this.states = [], this.currentLine = 0, this.tokenizer = u;
          var d = this;
          this.$worker = function() {
            if (d.running) {
              for (var f = /* @__PURE__ */ new Date(), h = d.currentLine, p = -1, g = d.doc, m = h; d.lines[h]; )
                h++;
              var v = g.getLength(), b = 0;
              for (d.running = !1; h < v; ) {
                d.$tokenizeRow(h), p = h;
                do
                  h++;
                while (d.lines[h]);
                if (b++, b % 5 === 0 && /* @__PURE__ */ new Date() - f > 20) {
                  d.running = setTimeout(d.$worker, 20);
                  break;
                }
              }
              d.currentLine = h, p == -1 && (p = h), m <= p && d.fireUpdateEvent(m, p);
            }
          };
        }
        return l.prototype.setTokenizer = function(u) {
          this.tokenizer = u, this.lines = [], this.states = [], this.start(0);
        }, l.prototype.setDocument = function(u) {
          this.doc = u, this.lines = [], this.states = [], this.stop();
        }, l.prototype.fireUpdateEvent = function(u, c) {
          var d = {
            first: u,
            last: c
          };
          this._signal("update", { data: d });
        }, l.prototype.start = function(u) {
          this.currentLine = Math.min(u || 0, this.currentLine, this.doc.getLength()), this.lines.splice(this.currentLine, this.lines.length), this.states.splice(this.currentLine, this.states.length), this.stop(), this.running = setTimeout(this.$worker, 700);
        }, l.prototype.scheduleStart = function() {
          this.running || (this.running = setTimeout(this.$worker, 700));
        }, l.prototype.$updateOnChange = function(u) {
          var c = u.start.row, d = u.end.row - c;
          if (d === 0)
            this.lines[c] = null;
          else if (u.action == "remove")
            this.lines.splice(c, d + 1, null), this.states.splice(c, d + 1, null);
          else {
            var f = Array(d + 1);
            f.unshift(c, 1), this.lines.splice.apply(this.lines, f), this.states.splice.apply(this.states, f);
          }
          this.currentLine = Math.min(c, this.currentLine, this.doc.getLength()), this.stop();
        }, l.prototype.stop = function() {
          this.running && clearTimeout(this.running), this.running = !1;
        }, l.prototype.getTokens = function(u) {
          return this.lines[u] || this.$tokenizeRow(u);
        }, l.prototype.getState = function(u) {
          return this.currentLine == u && this.$tokenizeRow(u), this.states[u] || "start";
        }, l.prototype.$tokenizeRow = function(u) {
          var c = this.doc.getLine(u), d = this.states[u - 1], f = this.tokenizer.getLineTokens(c, d, u);
          return this.states[u] + "" != f.state + "" ? (this.states[u] = f.state, this.lines[u + 1] = null, this.currentLine > u + 1 && (this.currentLine = u + 1)) : this.currentLine == u && (this.currentLine = u + 1), this.lines[u] = f.tokens;
        }, l.prototype.cleanup = function() {
          this.running = !1, this.lines = [], this.states = [], this.currentLine = 0, this.removeAllListeners();
        }, l;
      }()
    );
    o.implement(a.prototype, s), r.BackgroundTokenizer = a;
  }), ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/range"], function(n, r, i) {
    var o = n("./lib/lang"), s = n("./range").Range, a = (
      /** @class */
      function() {
        function l(u, c, d) {
          d === void 0 && (d = "text"), this.setRegexp(u), this.clazz = c, this.type = d;
        }
        return l.prototype.setRegexp = function(u) {
          this.regExp + "" != u + "" && (this.regExp = u, this.cache = []);
        }, l.prototype.update = function(u, c, d, f) {
          if (this.regExp)
            for (var h = f.firstRow, p = f.lastRow, g = {}, m = h; m <= p; m++) {
              var v = this.cache[m];
              v == null && (v = o.getMatchOffsets(d.getLine(m), this.regExp), v.length > this.MAX_RANGES && (v = v.slice(0, this.MAX_RANGES)), v = v.map(function(C) {
                return new s(m, C.offset, m, C.offset + C.length);
              }), this.cache[m] = v.length ? v : "");
              for (var b = v.length; b--; ) {
                var x = v[b].toScreenRange(d), w = x.toString();
                g[w] || (g[w] = !0, c.drawSingleLineMarker(u, x, this.clazz, f));
              }
            }
        }, l;
      }()
    );
    a.prototype.MAX_RANGES = 500, r.SearchHighlight = a;
  }), ace.define("ace/undomanager", ["require", "exports", "module", "ace/range"], function(n, r, i) {
    var o = (
      /** @class */
      function() {
        function C() {
          this.$keepRedoStack, this.$maxRev = 0, this.$fromUndo = !1, this.$undoDepth = 1 / 0, this.reset();
        }
        return C.prototype.addSession = function(y) {
          this.$session = y;
        }, C.prototype.add = function(y, S, A) {
          if (!this.$fromUndo && y != this.$lastDelta) {
            if (this.$keepRedoStack || (this.$redoStack.length = 0), S === !1 || !this.lastDeltas) {
              this.lastDeltas = [];
              var $ = this.$undoStack.length;
              $ > this.$undoDepth - 1 && this.$undoStack.splice(0, $ - this.$undoDepth + 1), this.$undoStack.push(this.lastDeltas), y.id = this.$rev = ++this.$maxRev;
            }
            (y.action == "remove" || y.action == "insert") && (this.$lastDelta = y), this.lastDeltas.push(y);
          }
        }, C.prototype.addSelection = function(y, S) {
          this.selections.push({
            value: y,
            rev: S || this.$rev
          });
        }, C.prototype.startNewGroup = function() {
          return this.lastDeltas = null, this.$rev;
        }, C.prototype.markIgnored = function(y, S) {
          S == null && (S = this.$rev + 1);
          for (var A = this.$undoStack, $ = A.length; $--; ) {
            var M = A[$][0];
            if (M.id <= y)
              break;
            M.id < S && (M.ignore = !0);
          }
          this.lastDeltas = null;
        }, C.prototype.getSelection = function(y, S) {
          for (var A = this.selections, $ = A.length; $--; ) {
            var M = A[$];
            if (M.rev < y)
              return S && (M = A[$ + 1]), M;
          }
        }, C.prototype.getRevision = function() {
          return this.$rev;
        }, C.prototype.getDeltas = function(y, S) {
          S == null && (S = this.$rev + 1);
          for (var A = this.$undoStack, $ = null, M = 0, _ = A.length; _--; ) {
            var T = A[_][0];
            if (T.id < S && !$ && ($ = _ + 1), T.id <= y) {
              M = _ + 1;
              break;
            }
          }
          return A.slice(M, $);
        }, C.prototype.getChangedRanges = function(y, S) {
          S == null && (S = this.$rev + 1);
        }, C.prototype.getChangedLines = function(y, S) {
          S == null && (S = this.$rev + 1);
        }, C.prototype.undo = function(y, S) {
          this.lastDeltas = null;
          var A = this.$undoStack;
          if (s(A, A.length)) {
            y || (y = this.$session), this.$redoStackBaseRev !== this.$rev && this.$redoStack.length && (this.$redoStack = []), this.$fromUndo = !0;
            var $ = A.pop(), M = null;
            return $ && (M = y.undoChanges($, S), this.$redoStack.push($), this.$syncRev()), this.$fromUndo = !1, M;
          }
        }, C.prototype.redo = function(y, S) {
          if (this.lastDeltas = null, y || (y = this.$session), this.$fromUndo = !0, this.$redoStackBaseRev != this.$rev) {
            var A = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
            w(this.$redoStack, A), this.$redoStackBaseRev = this.$rev, this.$redoStack.forEach(function(_) {
              _[0].id = ++this.$maxRev;
            }, this);
          }
          var $ = this.$redoStack.pop(), M = null;
          return $ && (M = y.redoChanges($, S), this.$undoStack.push($), this.$syncRev()), this.$fromUndo = !1, M;
        }, C.prototype.$syncRev = function() {
          var y = this.$undoStack, S = y[y.length - 1], A = S && S[0].id || 0;
          this.$redoStackBaseRev = A, this.$rev = A;
        }, C.prototype.reset = function() {
          this.lastDeltas = null, this.$lastDelta = null, this.$undoStack = [], this.$redoStack = [], this.$rev = 0, this.mark = 0, this.$redoStackBaseRev = this.$rev, this.selections = [];
        }, C.prototype.canUndo = function() {
          return this.$undoStack.length > 0;
        }, C.prototype.canRedo = function() {
          return this.$redoStack.length > 0;
        }, C.prototype.bookmark = function(y) {
          y == null && (y = this.$rev), this.mark = y;
        }, C.prototype.isAtBookmark = function() {
          return this.$rev === this.mark;
        }, C.prototype.toJSON = function() {
          return {
            $redoStack: this.$redoStack,
            $undoStack: this.$undoStack
          };
        }, C.prototype.fromJSON = function(y) {
          this.reset(), this.$undoStack = y.$undoStack, this.$redoStack = y.$redoStack;
        }, C.prototype.$prettyPrint = function(y) {
          return y ? d(y) : d(this.$undoStack) + `
---
` + d(this.$redoStack);
        }, C;
      }()
    );
    o.prototype.hasUndo = o.prototype.canUndo, o.prototype.hasRedo = o.prototype.canRedo, o.prototype.isClean = o.prototype.isAtBookmark, o.prototype.markClean = o.prototype.bookmark;
    function s(C, y) {
      for (var S = y; S--; ) {
        var A = C[S];
        if (A && !A[0].ignore) {
          for (; S < y - 1; ) {
            var $ = p(C[S], C[S + 1]);
            C[S] = $[0], C[S + 1] = $[1], S++;
          }
          return !0;
        }
      }
    }
    var a = n("./range").Range, l = a.comparePoints;
    a.comparePoints;
    function u(C) {
      return { row: C.row, column: C.column };
    }
    function c(C) {
      return {
        start: u(C.start),
        end: u(C.end),
        action: C.action,
        lines: C.lines.slice()
      };
    }
    function d(C) {
      if (C = C || this, Array.isArray(C))
        return C.map(d).join(`
`);
      var y = "";
      return C.action ? (y = C.action == "insert" ? "+" : "-", y += "[" + C.lines + "]") : C.value && (Array.isArray(C.value) ? y = C.value.map(f).join(`
`) : y = f(C.value)), C.start && (y += f(C)), (C.id || C.rev) && (y += "	(" + (C.id || C.rev) + ")"), y;
    }
    function f(C) {
      return C.start.row + ":" + C.start.column + "=>" + C.end.row + ":" + C.end.column;
    }
    function h(C, y) {
      var S = C.action == "insert", A = y.action == "insert";
      if (S && A)
        if (l(y.start, C.end) >= 0)
          m(y, C, -1);
        else if (l(y.start, C.start) <= 0)
          m(C, y, 1);
        else
          return null;
      else if (S && !A)
        if (l(y.start, C.end) >= 0)
          m(y, C, -1);
        else if (l(y.end, C.start) <= 0)
          m(C, y, -1);
        else
          return null;
      else if (!S && A)
        if (l(y.start, C.start) >= 0)
          m(y, C, 1);
        else if (l(y.start, C.start) <= 0)
          m(C, y, 1);
        else
          return null;
      else if (!S && !A)
        if (l(y.start, C.start) >= 0)
          m(y, C, 1);
        else if (l(y.end, C.start) <= 0)
          m(C, y, -1);
        else
          return null;
      return [y, C];
    }
    function p(C, y) {
      for (var S = C.length; S--; )
        for (var A = 0; A < y.length; A++)
          if (!h(C[S], y[A])) {
            for (; S < C.length; ) {
              for (; A--; )
                h(y[A], C[S]);
              A = y.length, S++;
            }
            return [C, y];
          }
      return C.selectionBefore = y.selectionBefore = C.selectionAfter = y.selectionAfter = null, [y, C];
    }
    function g(C, y) {
      var S = C.action == "insert", A = y.action == "insert";
      if (S && A)
        l(C.start, y.start) < 0 ? m(y, C, 1) : m(C, y, 1);
      else if (S && !A)
        l(C.start, y.end) >= 0 ? m(C, y, -1) : (l(C.start, y.start) <= 0 || m(C, a.fromPoints(y.start, C.start), -1), m(y, C, 1));
      else if (!S && A)
        l(y.start, C.end) >= 0 ? m(y, C, -1) : (l(y.start, C.start) <= 0 || m(y, a.fromPoints(C.start, y.start), -1), m(C, y, 1));
      else if (!S && !A)
        if (l(y.start, C.end) >= 0)
          m(y, C, -1);
        else if (l(y.end, C.start) <= 0)
          m(C, y, -1);
        else {
          var $, M;
          return l(C.start, y.start) < 0 && ($ = C, C = b(C, y.start)), l(C.end, y.end) > 0 && (M = b(C, y.end)), v(y.end, C.start, C.end, -1), M && !$ && (C.lines = M.lines, C.start = M.start, C.end = M.end, M = C), [y, $, M].filter(Boolean);
        }
      return [y, C];
    }
    function m(C, y, S) {
      v(C.start, y.start, y.end, S), v(C.end, y.start, y.end, S);
    }
    function v(C, y, S, A) {
      C.row == (A == 1 ? y : S).row && (C.column += A * (S.column - y.column)), C.row += A * (S.row - y.row);
    }
    function b(C, y) {
      var S = C.lines, A = C.end;
      C.end = u(y);
      var $ = C.end.row - C.start.row, M = S.splice($, S.length), _ = $ ? y.column : y.column - C.start.column;
      S.push(M[0].substring(0, _)), M[0] = M[0].substr(_);
      var T = {
        start: u(y),
        end: A,
        lines: M,
        action: C.action
      };
      return T;
    }
    function x(C, y) {
      y = c(y);
      for (var S = C.length; S--; ) {
        for (var A = C[S], $ = 0; $ < A.length; $++) {
          var M = A[$], _ = g(M, y);
          y = _[0], _.length != 2 && (_[2] ? (A.splice($ + 1, 1, _[1], _[2]), $++) : _[1] || (A.splice($, 1), $--));
        }
        A.length || C.splice(S, 1);
      }
      return C;
    }
    function w(C, y) {
      for (var S = 0; S < y.length; S++)
        for (var A = y[S], $ = 0; $ < A.length; $++)
          x(C, A[$]);
    }
    r.UndoManager = o;
  }), ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function(n, r, i) {
    var o = n("../range").Range, s = (
      /** @class */
      function() {
        function a(l, u) {
          this.foldData = l, Array.isArray(u) ? this.folds = u : u = this.folds = [u];
          var c = u[u.length - 1];
          this.range = new o(u[0].start.row, u[0].start.column, c.end.row, c.end.column), this.start = this.range.start, this.end = this.range.end, this.folds.forEach(function(d) {
            d.setFoldLine(this);
          }, this);
        }
        return a.prototype.shiftRow = function(l) {
          this.start.row += l, this.end.row += l, this.folds.forEach(function(u) {
            u.start.row += l, u.end.row += l;
          });
        }, a.prototype.addFold = function(l) {
          if (l.sameRow) {
            if (l.start.row < this.startRow || l.endRow > this.endRow)
              throw new Error("Can't add a fold to this FoldLine as it has no connection");
            this.folds.push(l), this.folds.sort(function(u, c) {
              return -u.range.compareEnd(c.start.row, c.start.column);
            }), this.range.compareEnd(l.start.row, l.start.column) > 0 ? (this.end.row = l.end.row, this.end.column = l.end.column) : this.range.compareStart(l.end.row, l.end.column) < 0 && (this.start.row = l.start.row, this.start.column = l.start.column);
          } else if (l.start.row == this.end.row)
            this.folds.push(l), this.end.row = l.end.row, this.end.column = l.end.column;
          else if (l.end.row == this.start.row)
            this.folds.unshift(l), this.start.row = l.start.row, this.start.column = l.start.column;
          else
            throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
          l.foldLine = this;
        }, a.prototype.containsRow = function(l) {
          return l >= this.start.row && l <= this.end.row;
        }, a.prototype.walk = function(l, u, c) {
          var d = 0, f = this.folds, h, p, g, m = !0;
          u == null && (u = this.end.row, c = this.end.column);
          for (var v = 0; v < f.length; v++) {
            if (h = f[v], p = h.range.compareStart(u, c), p == -1) {
              l(null, u, c, d, m);
              return;
            }
            if (g = l(null, h.start.row, h.start.column, d, m), g = !g && l(h.placeholder, h.start.row, h.start.column, d), g || p === 0)
              return;
            m = !h.sameRow, d = h.end.column;
          }
          l(null, u, c, d, m);
        }, a.prototype.getNextFoldTo = function(l, u) {
          for (var c, d, f = 0; f < this.folds.length; f++) {
            if (c = this.folds[f], d = c.range.compareEnd(l, u), d == -1)
              return {
                fold: c,
                kind: "after"
              };
            if (d === 0)
              return {
                fold: c,
                kind: "inside"
              };
          }
          return null;
        }, a.prototype.addRemoveChars = function(l, u, c) {
          var d = this.getNextFoldTo(l, u), f, h;
          if (d) {
            if (f = d.fold, d.kind == "inside" && f.start.column != u && f.start.row != l)
              window.console && window.console.log(l, u, f);
            else if (f.start.row == l) {
              h = this.folds;
              var p = h.indexOf(f);
              for (p === 0 && (this.start.column += c), p; p < h.length; p++) {
                if (f = h[p], f.start.column += c, !f.sameRow)
                  return;
                f.end.column += c;
              }
              this.end.column += c;
            }
          }
        }, a.prototype.split = function(l, u) {
          var c = this.getNextFoldTo(l, u);
          if (!c || c.kind == "inside")
            return null;
          var d = c.fold, f = this.folds, h = this.foldData, p = f.indexOf(d), g = f[p - 1];
          this.end.row = g.end.row, this.end.column = g.end.column, f = f.splice(p, f.length - p);
          var m = new a(h, f);
          return h.splice(h.indexOf(this) + 1, 0, m), m;
        }, a.prototype.merge = function(l) {
          for (var u = l.folds, c = 0; c < u.length; c++)
            this.addFold(u[c]);
          var d = this.foldData;
          d.splice(d.indexOf(l), 1);
        }, a.prototype.toString = function() {
          var l = [this.range.toString() + ": ["];
          return this.folds.forEach(function(u) {
            l.push("  " + u.toString());
          }), l.push("]"), l.join(`
`);
        }, a.prototype.idxToPosition = function(l) {
          for (var u = 0, c = 0; c < this.folds.length; c++) {
            var d = this.folds[c];
            if (l -= d.start.column - u, l < 0)
              return {
                row: d.start.row,
                column: d.start.column + l
              };
            if (l -= d.placeholder.length, l < 0)
              return d.start;
            u = d.end.column;
          }
          return {
            row: this.end.row,
            column: this.end.column + l
          };
        }, a;
      }()
    );
    r.FoldLine = s;
  }), ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function(n, r, i) {
    var o = n("./range").Range, s = o.comparePoints, a = (
      /** @class */
      function() {
        function l() {
          this.ranges = [], this.$bias = 1;
        }
        return l.prototype.pointIndex = function(u, c, d) {
          for (var f = this.ranges, h = d || 0; h < f.length; h++) {
            var p = f[h], g = s(u, p.end);
            if (!(g > 0)) {
              var m = s(u, p.start);
              return g === 0 ? c && m !== 0 ? -h - 2 : h : m > 0 || m === 0 && !c ? h : -h - 1;
            }
          }
          return -h - 1;
        }, l.prototype.add = function(u) {
          var c = !u.isEmpty(), d = this.pointIndex(u.start, c);
          d < 0 && (d = -d - 1);
          var f = this.pointIndex(u.end, c, d);
          return f < 0 ? f = -f - 1 : f++, this.ranges.splice(d, f - d, u);
        }, l.prototype.addList = function(u) {
          for (var c = [], d = u.length; d--; )
            c.push.apply(c, this.add(u[d]));
          return c;
        }, l.prototype.substractPoint = function(u) {
          var c = this.pointIndex(u);
          if (c >= 0)
            return this.ranges.splice(c, 1);
        }, l.prototype.merge = function() {
          var u = [], c = this.ranges;
          c = c.sort(function(g, m) {
            return s(g.start, m.start);
          });
          for (var d = c[0], f, h = 1; h < c.length; h++) {
            f = d, d = c[h];
            var p = s(f.end, d.start);
            p < 0 || p == 0 && !f.isEmpty() && !d.isEmpty() || (s(f.end, d.end) < 0 && (f.end.row = d.end.row, f.end.column = d.end.column), c.splice(h, 1), u.push(d), d = f, h--);
          }
          return this.ranges = c, u;
        }, l.prototype.contains = function(u, c) {
          return this.pointIndex({ row: u, column: c }) >= 0;
        }, l.prototype.containsPoint = function(u) {
          return this.pointIndex(u) >= 0;
        }, l.prototype.rangeAtPoint = function(u) {
          var c = this.pointIndex(u);
          if (c >= 0)
            return this.ranges[c];
        }, l.prototype.clipRows = function(u, c) {
          var d = this.ranges;
          if (d[0].start.row > c || d[d.length - 1].start.row < u)
            return [];
          var f = this.pointIndex({ row: u, column: 0 });
          f < 0 && (f = -f - 1);
          var h = this.pointIndex({ row: c, column: 0 }, f);
          h < 0 && (h = -h - 1);
          for (var p = [], g = f; g < h; g++)
            p.push(d[g]);
          return p;
        }, l.prototype.removeAll = function() {
          return this.ranges.splice(0, this.ranges.length);
        }, l.prototype.attach = function(u) {
          this.session && this.detach(), this.session = u, this.onChange = this.$onChange.bind(this), this.session.on("change", this.onChange);
        }, l.prototype.detach = function() {
          this.session && (this.session.removeListener("change", this.onChange), this.session = null);
        }, l.prototype.$onChange = function(u) {
          for (var c = u.start, d = u.end, f = c.row, h = d.row, p = this.ranges, g = 0, m = p.length; g < m; g++) {
            var v = p[g];
            if (v.end.row >= f)
              break;
          }
          if (u.action == "insert")
            for (var b = h - f, x = -c.column + d.column; g < m; g++) {
              var v = p[g];
              if (v.start.row > f)
                break;
              if (v.start.row == f && v.start.column >= c.column && (v.start.column == c.column && this.$bias <= 0 || (v.start.column += x, v.start.row += b)), v.end.row == f && v.end.column >= c.column) {
                if (v.end.column == c.column && this.$bias < 0)
                  continue;
                v.end.column == c.column && x > 0 && g < m - 1 && v.end.column > v.start.column && v.end.column == p[g + 1].start.column && (v.end.column -= x), v.end.column += x, v.end.row += b;
              }
            }
          else
            for (var b = f - h, x = c.column - d.column; g < m; g++) {
              var v = p[g];
              if (v.start.row > h)
                break;
              v.end.row < h && (f < v.end.row || f == v.end.row && c.column < v.end.column) ? (v.end.row = f, v.end.column = c.column) : v.end.row == h ? v.end.column <= d.column ? (b || v.end.column > c.column) && (v.end.column = c.column, v.end.row = c.row) : (v.end.column += x, v.end.row += b) : v.end.row > h && (v.end.row += b), v.start.row < h && (f < v.start.row || f == v.start.row && c.column < v.start.column) ? (v.start.row = f, v.start.column = c.column) : v.start.row == h ? v.start.column <= d.column ? (b || v.start.column > c.column) && (v.start.column = c.column, v.start.row = c.row) : (v.start.column += x, v.start.row += b) : v.start.row > h && (v.start.row += b);
            }
          if (b != 0 && g < m)
            for (; g < m; g++) {
              var v = p[g];
              v.start.row += b, v.end.row += b;
            }
        }, l;
      }()
    );
    a.prototype.comparePoints = s, r.RangeList = a;
  }), ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range_list"], function(n, r, i) {
    var o = this && this.__extends || /* @__PURE__ */ function() {
      var f = function(h, p) {
        return f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(g, m) {
          g.__proto__ = m;
        } || function(g, m) {
          for (var v in m)
            Object.prototype.hasOwnProperty.call(m, v) && (g[v] = m[v]);
        }, f(h, p);
      };
      return function(h, p) {
        if (typeof p != "function" && p !== null)
          throw new TypeError("Class extends value " + String(p) + " is not a constructor or null");
        f(h, p);
        function g() {
          this.constructor = h;
        }
        h.prototype = p === null ? Object.create(p) : (g.prototype = p.prototype, new g());
      };
    }(), s = n("../range_list").RangeList, a = (
      /** @class */
      function(f) {
        o(h, f);
        function h(p, g) {
          var m = f.call(this) || this;
          return m.foldLine = null, m.placeholder = g, m.range = p, m.start = p.start, m.end = p.end, m.sameRow = p.start.row == p.end.row, m.subFolds = m.ranges = [], m;
        }
        return h.prototype.toString = function() {
          return '"' + this.placeholder + '" ' + this.range.toString();
        }, h.prototype.setFoldLine = function(p) {
          this.foldLine = p, this.subFolds.forEach(function(g) {
            g.setFoldLine(p);
          });
        }, h.prototype.clone = function() {
          var p = this.range.clone(), g = new h(p, this.placeholder);
          return this.subFolds.forEach(function(m) {
            g.subFolds.push(m.clone());
          }), g.collapseChildren = this.collapseChildren, g;
        }, h.prototype.addSubFold = function(p) {
          if (!this.range.isEqual(p)) {
            u(p, this.start);
            for (var x = p.start.row, w = p.start.column, g = 0, m = -1; g < this.subFolds.length && (m = this.subFolds[g].range.compare(x, w), m == 1); g++)
              ;
            var v = this.subFolds[g], b = 0;
            if (m == 0) {
              if (v.range.containsRange(p))
                return v.addSubFold(p);
              b = 1;
            }
            for (var x = p.range.end.row, w = p.range.end.column, C = g, m = -1; C < this.subFolds.length && (m = this.subFolds[C].range.compare(x, w), m == 1); C++)
              ;
            m == 0 && C++;
            for (var y = this.subFolds.splice(g, C - g, p), S = m == 0 ? y.length - 1 : y.length, A = b; A < S; A++)
              p.addSubFold(y[A]);
            return p.setFoldLine(this.foldLine), p;
          }
        }, h.prototype.restoreRange = function(p) {
          return d(p, this.start);
        }, h;
      }(s)
    );
    function l(f, h) {
      f.row -= h.row, f.row == 0 && (f.column -= h.column);
    }
    function u(f, h) {
      l(f.start, h), l(f.end, h);
    }
    function c(f, h) {
      f.row == 0 && (f.column += h.column), f.row += h.row;
    }
    function d(f, h) {
      c(f.start, h), c(f.end, h);
    }
    r.Fold = a;
  }), ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator", "ace/mouse/mouse_event"], function(n, r, i) {
    var o = n("../range").Range, s = n("./fold_line").FoldLine, a = n("./fold").Fold, l = n("../token_iterator").TokenIterator, u = n("../mouse/mouse_event").MouseEvent;
    function c() {
      this.getFoldAt = function(d, f, h) {
        var p = this.getFoldLine(d);
        if (!p)
          return null;
        for (var g = p.folds, m = 0; m < g.length; m++) {
          var v = g[m].range;
          if (v.contains(d, f)) {
            if (h == 1 && v.isEnd(d, f) && !v.isEmpty())
              continue;
            if (h == -1 && v.isStart(d, f) && !v.isEmpty())
              continue;
            return g[m];
          }
        }
      }, this.getFoldsInRange = function(d) {
        var f = d.start, h = d.end, p = this.$foldData, g = [];
        f.column += 1, h.column -= 1;
        for (var m = 0; m < p.length; m++) {
          var v = p[m].range.compareRange(d);
          if (v != 2) {
            if (v == -2)
              break;
            for (var b = p[m].folds, x = 0; x < b.length; x++) {
              var w = b[x];
              if (v = w.range.compareRange(d), v == -2)
                break;
              if (v == 2)
                continue;
              if (v == 42)
                break;
              g.push(w);
            }
          }
        }
        return f.column -= 1, h.column += 1, g;
      }, this.getFoldsInRangeList = function(d) {
        if (Array.isArray(d)) {
          var f = [];
          d.forEach(function(h) {
            f = f.concat(this.getFoldsInRange(h));
          }, this);
        } else
          var f = this.getFoldsInRange(d);
        return f;
      }, this.getAllFolds = function() {
        for (var d = [], f = this.$foldData, h = 0; h < f.length; h++)
          for (var p = 0; p < f[h].folds.length; p++)
            d.push(f[h].folds[p]);
        return d;
      }, this.getFoldStringAt = function(d, f, h, p) {
        if (p = p || this.getFoldLine(d), !p)
          return null;
        for (var g = {
          end: { column: 0 }
        }, m, v, b = 0; b < p.folds.length; b++) {
          v = p.folds[b];
          var x = v.range.compareEnd(d, f);
          if (x == -1) {
            m = this.getLine(v.start.row).substring(g.end.column, v.start.column);
            break;
          } else if (x === 0)
            return null;
          g = v;
        }
        return m || (m = this.getLine(v.start.row).substring(g.end.column)), h == -1 ? m.substring(0, f - g.end.column) : h == 1 ? m.substring(f - g.end.column) : m;
      }, this.getFoldLine = function(d, f) {
        var h = this.$foldData, p = 0;
        for (f && (p = h.indexOf(f)), p == -1 && (p = 0), p; p < h.length; p++) {
          var g = h[p];
          if (g.start.row <= d && g.end.row >= d)
            return g;
          if (g.end.row > d)
            return null;
        }
        return null;
      }, this.getNextFoldLine = function(d, f) {
        var h = this.$foldData, p = 0;
        for (f && (p = h.indexOf(f)), p == -1 && (p = 0), p; p < h.length; p++) {
          var g = h[p];
          if (g.end.row >= d)
            return g;
        }
        return null;
      }, this.getFoldedRowCount = function(d, f) {
        for (var h = this.$foldData, p = f - d + 1, g = 0; g < h.length; g++) {
          var m = h[g], v = m.end.row, b = m.start.row;
          if (v >= f) {
            b < f && (b >= d ? p -= f - b : p = 0);
            break;
          } else
            v >= d && (b >= d ? p -= v - b : p -= v - d + 1);
        }
        return p;
      }, this.$addFoldLine = function(d) {
        return this.$foldData.push(d), this.$foldData.sort(function(f, h) {
          return f.start.row - h.start.row;
        }), d;
      }, this.addFold = function(d, f) {
        var h = this.$foldData, p = !1, g;
        d instanceof a ? g = d : (g = new a(f, d), g.collapseChildren = f.collapseChildren), this.$clipRangeToDocument(g.range);
        var m = g.start.row, v = g.start.column, b = g.end.row, x = g.end.column, w = this.getFoldAt(m, v, 1), C = this.getFoldAt(b, x, -1);
        if (w && C == w)
          return w.addSubFold(g);
        w && !w.range.isStart(m, v) && this.removeFold(w), C && !C.range.isEnd(b, x) && this.removeFold(C);
        var y = this.getFoldsInRange(g.range);
        y.length > 0 && (this.removeFolds(y), g.collapseChildren || y.forEach(function(M) {
          g.addSubFold(M);
        }));
        for (var S = 0; S < h.length; S++) {
          var A = h[S];
          if (b == A.start.row) {
            A.addFold(g), p = !0;
            break;
          } else if (m == A.end.row) {
            if (A.addFold(g), p = !0, !g.sameRow) {
              var $ = h[S + 1];
              if ($ && $.start.row == b) {
                A.merge($);
                break;
              }
            }
            break;
          } else if (b <= A.start.row)
            break;
        }
        return p || (A = this.$addFoldLine(new s(this.$foldData, g))), this.$useWrapMode ? this.$updateWrapData(A.start.row, A.start.row) : this.$updateRowLengthCache(A.start.row, A.start.row), this.$modified = !0, this._signal("changeFold", { data: g, action: "add" }), g;
      }, this.addFolds = function(d) {
        d.forEach(function(f) {
          this.addFold(f);
        }, this);
      }, this.removeFold = function(d) {
        var f = d.foldLine, h = f.start.row, p = f.end.row, g = this.$foldData, m = f.folds;
        if (m.length == 1)
          g.splice(g.indexOf(f), 1);
        else if (f.range.isEnd(d.end.row, d.end.column))
          m.pop(), f.end.row = m[m.length - 1].end.row, f.end.column = m[m.length - 1].end.column;
        else if (f.range.isStart(d.start.row, d.start.column))
          m.shift(), f.start.row = m[0].start.row, f.start.column = m[0].start.column;
        else if (d.sameRow)
          m.splice(m.indexOf(d), 1);
        else {
          var v = f.split(d.start.row, d.start.column);
          m = v.folds, m.shift(), v.start.row = m[0].start.row, v.start.column = m[0].start.column;
        }
        this.$updating || (this.$useWrapMode ? this.$updateWrapData(h, p) : this.$updateRowLengthCache(h, p)), this.$modified = !0, this._signal("changeFold", { data: d, action: "remove" });
      }, this.removeFolds = function(d) {
        for (var f = [], h = 0; h < d.length; h++)
          f.push(d[h]);
        f.forEach(function(p) {
          this.removeFold(p);
        }, this), this.$modified = !0;
      }, this.expandFold = function(d) {
        this.removeFold(d), d.subFolds.forEach(function(f) {
          d.restoreRange(f), this.addFold(f);
        }, this), d.collapseChildren > 0 && this.foldAll(d.start.row + 1, d.end.row, d.collapseChildren - 1), d.subFolds = [];
      }, this.expandFolds = function(d) {
        d.forEach(function(f) {
          this.expandFold(f);
        }, this);
      }, this.unfold = function(d, f) {
        var h, p;
        if (d == null)
          h = new o(0, 0, this.getLength(), 0), f == null && (f = !0);
        else if (typeof d == "number")
          h = new o(d, 0, d, this.getLine(d).length);
        else if ("row" in d)
          h = o.fromPoints(d, d);
        else {
          if (Array.isArray(d))
            return p = [], d.forEach(function(m) {
              p = p.concat(this.unfold(m));
            }, this), p;
          h = d;
        }
        p = this.getFoldsInRangeList(h);
        for (var g = p; p.length == 1 && o.comparePoints(p[0].start, h.start) < 0 && o.comparePoints(p[0].end, h.end) > 0; )
          this.expandFolds(p), p = this.getFoldsInRangeList(h);
        if (f != !1 ? this.removeFolds(p) : this.expandFolds(p), g.length)
          return g;
      }, this.isRowFolded = function(d, f) {
        return !!this.getFoldLine(d, f);
      }, this.getRowFoldEnd = function(d, f) {
        var h = this.getFoldLine(d, f);
        return h ? h.end.row : d;
      }, this.getRowFoldStart = function(d, f) {
        var h = this.getFoldLine(d, f);
        return h ? h.start.row : d;
      }, this.getFoldDisplayLine = function(d, f, h, p, g) {
        p == null && (p = d.start.row), g == null && (g = 0), f == null && (f = d.end.row), h == null && (h = this.getLine(f).length);
        var m = this.doc, v = "";
        return d.walk(function(b, x, w, C) {
          if (!(x < p)) {
            if (x == p) {
              if (w < g)
                return;
              C = Math.max(g, C);
            }
            b != null ? v += b : v += m.getLine(x).substring(C, w);
          }
        }, f, h), v;
      }, this.getDisplayLine = function(d, f, h, p) {
        var g = this.getFoldLine(d);
        if (g)
          return this.getFoldDisplayLine(g, d, f, h, p);
        var m;
        return m = this.doc.getLine(d), m.substring(p || 0, f || m.length);
      }, this.$cloneFoldData = function() {
        var d = [];
        return d = this.$foldData.map(function(f) {
          var h = f.folds.map(function(p) {
            return p.clone();
          });
          return new s(d, h);
        }), d;
      }, this.toggleFold = function(d) {
        var f = this.selection, h = f.getRange(), p, g;
        if (h.isEmpty()) {
          var m = h.start;
          if (p = this.getFoldAt(m.row, m.column), p) {
            this.expandFold(p);
            return;
          } else
            (g = this.findMatchingBracket(m)) ? h.comparePoint(g) == 1 ? h.end = g : (h.start = g, h.start.column++, h.end.column--) : (g = this.findMatchingBracket({ row: m.row, column: m.column + 1 })) ? (h.comparePoint(g) == 1 ? h.end = g : h.start = g, h.start.column++) : h = this.getCommentFoldRange(m.row, m.column) || h;
        } else {
          var v = this.getFoldsInRange(h);
          if (d && v.length) {
            this.expandFolds(v);
            return;
          } else
            v.length == 1 && (p = v[0]);
        }
        if (p || (p = this.getFoldAt(h.start.row, h.start.column)), p && p.range.toString() == h.toString()) {
          this.expandFold(p);
          return;
        }
        var b = "...";
        if (!h.isMultiLine()) {
          if (b = this.getTextRange(h), b.length < 4)
            return;
          b = b.trim().substring(0, 2) + "..";
        }
        this.addFold(b, h);
      }, this.getCommentFoldRange = function(d, f, h) {
        var p = new l(this, d, f), g = p.getCurrentToken(), m = g && g.type;
        if (g && /^comment|string/.test(m)) {
          m = m.match(/comment|string/)[0], m == "comment" && (m += "|doc-start|\\.doc");
          var v = new RegExp(m), b = new o();
          if (h != 1) {
            do
              g = p.stepBackward();
            while (g && v.test(g.type) && !/^comment.end/.test(g.type));
            g = p.stepForward();
          }
          if (b.start.row = p.getCurrentTokenRow(), b.start.column = p.getCurrentTokenColumn() + (/^comment.start/.test(g.type) ? g.value.length : 2), p = new l(this, d, f), h != -1) {
            var x = -1;
            do
              if (g = p.stepForward(), x == -1) {
                var w = this.getState(p.$row);
                v.test(w) || (x = p.$row);
              } else if (p.$row > x)
                break;
            while (g && v.test(g.type) && !/^comment.start/.test(g.type));
            g = p.stepBackward();
          } else
            g = p.getCurrentToken();
          return b.end.row = p.getCurrentTokenRow(), b.end.column = p.getCurrentTokenColumn(), /^comment.end/.test(g.type) || (b.end.column += g.value.length - 2), b;
        }
      }, this.foldAll = function(d, f, h, p) {
        h == null && (h = 1e5);
        var g = this.foldWidgets;
        if (g) {
          f = f || this.getLength(), d = d || 0;
          for (var m = d; m < f; m++)
            if (g[m] == null && (g[m] = this.getFoldWidget(m)), g[m] == "start" && !(p && !p(m))) {
              var v = this.getFoldWidgetRange(m);
              v && v.isMultiLine() && v.end.row <= f && v.start.row >= d && (m = v.end.row, v.collapseChildren = h, this.addFold("...", v));
            }
        }
      }, this.foldToLevel = function(d) {
        for (this.foldAll(); d-- > 0; )
          this.unfold(null, !1);
      }, this.foldAllComments = function() {
        var d = this;
        this.foldAll(null, null, null, function(f) {
          for (var h = d.getTokens(f), p = 0; p < h.length; p++) {
            var g = h[p];
            if (!(g.type == "text" && /^\s+$/.test(g.value)))
              return !!/comment/.test(g.type);
          }
        });
      }, this.$foldStyles = {
        manual: 1,
        markbegin: 1,
        markbeginend: 1
      }, this.$foldStyle = "markbegin", this.setFoldStyle = function(d) {
        if (!this.$foldStyles[d])
          throw new Error("invalid fold style: " + d + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
        if (this.$foldStyle != d) {
          this.$foldStyle = d, d == "manual" && this.unfold();
          var f = this.$foldMode;
          this.$setFolding(null), this.$setFolding(f);
        }
      }, this.$setFolding = function(d) {
        if (this.$foldMode != d) {
          if (this.$foldMode = d, this.off("change", this.$updateFoldWidgets), this.off("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets), this._signal("changeAnnotation"), !d || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
          }
          this.foldWidgets = [], this.getFoldWidget = d.getFoldWidget.bind(d, this, this.$foldStyle), this.getFoldWidgetRange = d.getFoldWidgetRange.bind(d, this, this.$foldStyle), this.$updateFoldWidgets = this.updateFoldWidgets.bind(this), this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this), this.on("change", this.$updateFoldWidgets), this.on("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
        }
      }, this.getParentFoldRangeData = function(d, f) {
        var h = this.foldWidgets;
        if (!h || f && h[d])
          return {};
        for (var p = d - 1, g; p >= 0; ) {
          var m = h[p];
          if (m == null && (m = h[p] = this.getFoldWidget(p)), m == "start") {
            var v = this.getFoldWidgetRange(p);
            if (g || (g = v), v && v.end.row >= d)
              break;
          }
          p--;
        }
        return {
          range: p !== -1 && v,
          firstRange: g
        };
      }, this.onFoldWidgetClick = function(d, f) {
        f instanceof u && (f = f.domEvent);
        var h = {
          children: f.shiftKey,
          all: f.ctrlKey || f.metaKey,
          siblings: f.altKey
        }, p = this.$toggleFoldWidget(d, h);
        if (!p) {
          var g = f.target || f.srcElement;
          g && /ace_fold-widget/.test(g.className) && (g.className += " ace_invalid");
        }
      }, this.$toggleFoldWidget = function(d, f) {
        if (this.getFoldWidget) {
          var h = this.getFoldWidget(d), p = this.getLine(d), g = h === "end" ? -1 : 1, m = this.getFoldAt(d, g === -1 ? 0 : p.length, g);
          if (m)
            return f.children || f.all ? this.removeFold(m) : this.expandFold(m), m;
          var v = this.getFoldWidgetRange(d, !0);
          if (v && !v.isMultiLine() && (m = this.getFoldAt(v.start.row, v.start.column, 1), m && v.isEqual(m.range)))
            return this.removeFold(m), m;
          if (f.siblings) {
            var b = this.getParentFoldRangeData(d);
            if (b.range)
              var x = b.range.start.row + 1, w = b.range.end.row;
            this.foldAll(x, w, f.all ? 1e4 : 0);
          } else
            f.children ? (w = v ? v.end.row : this.getLength(), this.foldAll(d + 1, w, f.all ? 1e4 : 0)) : v && (f.all && (v.collapseChildren = 1e4), this.addFold("...", v));
          return v;
        }
      }, this.toggleFoldWidget = function(d) {
        var f = this.selection.getCursor().row;
        f = this.getRowFoldStart(f);
        var h = this.$toggleFoldWidget(f, {});
        if (!h) {
          var p = this.getParentFoldRangeData(f, !0);
          if (h = p.range || p.firstRange, h) {
            f = h.start.row;
            var g = this.getFoldAt(f, this.getLine(f).length, 1);
            g ? this.removeFold(g) : this.addFold("...", h);
          }
        }
      }, this.updateFoldWidgets = function(d) {
        var f = d.start.row, h = d.end.row - f;
        if (h === 0)
          this.foldWidgets[f] = null;
        else if (d.action == "remove")
          this.foldWidgets.splice(f, h + 1, null);
        else {
          var p = Array(h + 1);
          p.unshift(f, 1), this.foldWidgets.splice.apply(this.foldWidgets, p);
        }
      }, this.tokenizerUpdateFoldWidgets = function(d) {
        var f = d.data;
        f.first != f.last && this.foldWidgets.length > f.first && this.foldWidgets.splice(f.first, this.foldWidgets.length);
      };
    }
    r.Folding = c;
  }), ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function(n, r, i) {
    var o = n("../token_iterator").TokenIterator, s = n("../range").Range;
    function a() {
      this.findMatchingBracket = function(l, u) {
        if (l.column == 0)
          return null;
        var c = u || this.getLine(l.row).charAt(l.column - 1);
        if (c == "")
          return null;
        var d = c.match(/([\(\[\{])|([\)\]\}])/);
        return d ? d[1] ? this.$findClosingBracket(d[1], l) : this.$findOpeningBracket(d[2], l) : null;
      }, this.getBracketRange = function(l) {
        var u = this.getLine(l.row), c = !0, d, f = u.charAt(l.column - 1), h = f && f.match(/([\(\[\{])|([\)\]\}])/);
        if (h || (f = u.charAt(l.column), l = { row: l.row, column: l.column + 1 }, h = f && f.match(/([\(\[\{])|([\)\]\}])/), c = !1), !h)
          return null;
        if (h[1]) {
          var p = this.$findClosingBracket(h[1], l);
          if (!p)
            return null;
          d = s.fromPoints(l, p), c || (d.end.column++, d.start.column--), d.cursor = d.end;
        } else {
          var p = this.$findOpeningBracket(h[2], l);
          if (!p)
            return null;
          d = s.fromPoints(p, l), c || (d.start.column++, d.end.column--), d.cursor = d.start;
        }
        return d;
      }, this.getMatchingBracketRanges = function(l, u) {
        var c = this.getLine(l.row), d = /([\(\[\{])|([\)\]\}])/, f = !u && c.charAt(l.column - 1), h = f && f.match(d);
        if (h || (f = (u === void 0 || u) && c.charAt(l.column), l = {
          row: l.row,
          column: l.column + 1
        }, h = f && f.match(d)), !h)
          return null;
        var p = new s(l.row, l.column - 1, l.row, l.column), g = h[1] ? this.$findClosingBracket(h[1], l) : this.$findOpeningBracket(h[2], l);
        if (!g)
          return [p];
        var m = new s(g.row, g.column, g.row, g.column + 1);
        return [p, m];
      }, this.$brackets = {
        ")": "(",
        "(": ")",
        "]": "[",
        "[": "]",
        "{": "}",
        "}": "{",
        "<": ">",
        ">": "<"
      }, this.$findOpeningBracket = function(l, u, c) {
        var d = this.$brackets[l], f = 1, h = new o(this, u.row, u.column), p = h.getCurrentToken();
        if (p || (p = h.stepForward()), !!p) {
          c || (c = new RegExp("(\\.?" + p.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)").replace(/-close\b/, "-(close|open)") + ")+"));
          for (var g = u.column - h.getCurrentTokenColumn() - 2, m = p.value; ; ) {
            for (; g >= 0; ) {
              var v = m.charAt(g);
              if (v == d) {
                if (f -= 1, f == 0)
                  return {
                    row: h.getCurrentTokenRow(),
                    column: g + h.getCurrentTokenColumn()
                  };
              } else
                v == l && (f += 1);
              g -= 1;
            }
            do
              p = h.stepBackward();
            while (p && !c.test(p.type));
            if (p == null)
              break;
            m = p.value, g = m.length - 1;
          }
          return null;
        }
      }, this.$findClosingBracket = function(l, u, c) {
        var d = this.$brackets[l], f = 1, h = new o(this, u.row, u.column), p = h.getCurrentToken();
        if (p || (p = h.stepForward()), !!p) {
          c || (c = new RegExp("(\\.?" + p.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)").replace(/-open\b/, "-(close|open)") + ")+"));
          for (var g = u.column - h.getCurrentTokenColumn(); ; ) {
            for (var m = p.value, v = m.length; g < v; ) {
              var b = m.charAt(g);
              if (b == d) {
                if (f -= 1, f == 0)
                  return {
                    row: h.getCurrentTokenRow(),
                    column: g + h.getCurrentTokenColumn()
                  };
              } else
                b == l && (f += 1);
              g += 1;
            }
            do
              p = h.stepForward();
            while (p && !c.test(p.type));
            if (p == null)
              break;
            g = 0;
          }
          return null;
        }
      }, this.getMatchingTags = function(l) {
        var u = new o(this, l.row, l.column), c = this.$findTagName(u);
        if (c) {
          var d = u.stepBackward();
          return d.value === "<" ? this.$findClosingTag(u, c) : this.$findOpeningTag(u, c);
        }
      }, this.$findTagName = function(l) {
        var u = l.getCurrentToken(), c = !1, d = !1;
        if (u && u.type.indexOf("tag-name") === -1)
          do
            d ? u = l.stepBackward() : u = l.stepForward(), u && (u.value === "/>" ? d = !0 : u.type.indexOf("tag-name") !== -1 && (c = !0));
          while (u && !c);
        return u;
      }, this.$findClosingTag = function(l, u) {
        var c, d = u.value, f = u.value, h = 0, p = new s(l.getCurrentTokenRow(), l.getCurrentTokenColumn(), l.getCurrentTokenRow(), l.getCurrentTokenColumn() + 1);
        u = l.stepForward();
        var g = new s(l.getCurrentTokenRow(), l.getCurrentTokenColumn(), l.getCurrentTokenRow(), l.getCurrentTokenColumn() + u.value.length), m = !1;
        do {
          if (c = u, c.type.indexOf("tag-close") !== -1 && !m) {
            var v = new s(l.getCurrentTokenRow(), l.getCurrentTokenColumn(), l.getCurrentTokenRow(), l.getCurrentTokenColumn() + 1);
            m = !0;
          }
          if (u = l.stepForward(), u) {
            if (u.value === ">" && !m) {
              var v = new s(l.getCurrentTokenRow(), l.getCurrentTokenColumn(), l.getCurrentTokenRow(), l.getCurrentTokenColumn() + 1);
              m = !0;
            }
            if (u.type.indexOf("tag-name") !== -1) {
              if (d = u.value, f === d) {
                if (c.value === "<")
                  h++;
                else if (c.value === "</" && (h--, h < 0)) {
                  l.stepBackward();
                  var b = new s(l.getCurrentTokenRow(), l.getCurrentTokenColumn(), l.getCurrentTokenRow(), l.getCurrentTokenColumn() + 2);
                  u = l.stepForward();
                  var x = new s(l.getCurrentTokenRow(), l.getCurrentTokenColumn(), l.getCurrentTokenRow(), l.getCurrentTokenColumn() + u.value.length);
                  if (u.type.indexOf("tag-close") === -1 && (u = l.stepForward()), u && u.value === ">")
                    var w = new s(l.getCurrentTokenRow(), l.getCurrentTokenColumn(), l.getCurrentTokenRow(), l.getCurrentTokenColumn() + 1);
                  else
                    return;
                }
              }
            } else if (f === d && u.value === "/>" && (h--, h < 0))
              var b = new s(l.getCurrentTokenRow(), l.getCurrentTokenColumn(), l.getCurrentTokenRow(), l.getCurrentTokenColumn() + 2), x = b, w = x, v = new s(g.end.row, g.end.column, g.end.row, g.end.column + 1);
          }
        } while (u && h >= 0);
        if (p && v && b && w && g && x)
          return {
            openTag: new s(p.start.row, p.start.column, v.end.row, v.end.column),
            closeTag: new s(b.start.row, b.start.column, w.end.row, w.end.column),
            openTagName: g,
            closeTagName: x
          };
      }, this.$findOpeningTag = function(l, u) {
        var c = l.getCurrentToken(), d = u.value, f = 0, h = l.getCurrentTokenRow(), p = l.getCurrentTokenColumn(), g = p + 2, m = new s(h, p, h, g);
        l.stepForward();
        var v = new s(l.getCurrentTokenRow(), l.getCurrentTokenColumn(), l.getCurrentTokenRow(), l.getCurrentTokenColumn() + u.value.length);
        if (u.type.indexOf("tag-close") === -1 && (u = l.stepForward()), !(!u || u.value !== ">")) {
          var b = new s(l.getCurrentTokenRow(), l.getCurrentTokenColumn(), l.getCurrentTokenRow(), l.getCurrentTokenColumn() + 1);
          l.stepBackward(), l.stepBackward();
          do
            if (u = c, h = l.getCurrentTokenRow(), p = l.getCurrentTokenColumn(), g = p + u.value.length, c = l.stepBackward(), u) {
              if (u.type.indexOf("tag-name") !== -1) {
                if (d === u.value)
                  if (c.value === "<") {
                    if (f++, f > 0) {
                      var x = new s(h, p, h, g), w = new s(l.getCurrentTokenRow(), l.getCurrentTokenColumn(), l.getCurrentTokenRow(), l.getCurrentTokenColumn() + 1);
                      do
                        u = l.stepForward();
                      while (u && u.value !== ">");
                      var C = new s(l.getCurrentTokenRow(), l.getCurrentTokenColumn(), l.getCurrentTokenRow(), l.getCurrentTokenColumn() + 1);
                    }
                  } else
                    c.value === "</" && f--;
              } else if (u.value === "/>") {
                for (var y = 0, S = c; S; ) {
                  if (S.type.indexOf("tag-name") !== -1 && S.value === d) {
                    f--;
                    break;
                  } else if (S.value === "<")
                    break;
                  S = l.stepBackward(), y++;
                }
                for (var A = 0; A < y; A++)
                  l.stepForward();
              }
            }
          while (c && f <= 0);
          if (w && C && m && b && x && v)
            return {
              openTag: new s(w.start.row, w.start.column, C.end.row, C.end.column),
              closeTag: new s(m.start.row, m.start.column, b.end.row, b.end.column),
              openTagName: x,
              closeTagName: v
            };
        }
      };
    }
    r.BracketMatch = a;
  }), ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/bidihandler", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/undomanager", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function(n, r, i) {
    var o = n("./lib/oop"), s = n("./lib/lang"), a = n("./bidihandler").BidiHandler, l = n("./config"), u = n("./lib/event_emitter").EventEmitter, c = n("./selection").Selection, d = n("./mode/text").Mode, f = n("./range").Range, h = n("./document").Document, p = n("./background_tokenizer").BackgroundTokenizer, g = n("./search_highlight").SearchHighlight, m = n("./undomanager").UndoManager, v = (
      /** @class */
      function() {
        function _(T, D) {
          this.doc, this.$breakpoints = [], this.$decorations = [], this.$frontMarkers = {}, this.$backMarkers = {}, this.$markerId = 1, this.$undoSelect = !0, this.$foldData = [], this.id = "session" + ++_.$uid, this.$foldData.toString = function() {
            return this.join(`
`);
          }, this.bgTokenizer = new p(new d().getTokenizer(), this);
          var E = this;
          this.bgTokenizer.on("update", function(R) {
            E._signal("tokenizerUpdate", R);
          }), this.on("changeFold", this.onChangeFold.bind(this)), this.$onChange = this.onChange.bind(this), (typeof T != "object" || !T.getLine) && (T = new h(
            /**@type{string}*/
            T
          )), this.setDocument(T), this.selection = new c(this), this.$bidiHandler = new a(this), l.resetOptions(this), this.setMode(D), l._signal("session", this), this.destroyed = !1;
        }
        return _.prototype.setDocument = function(T) {
          this.doc && this.doc.off("change", this.$onChange), this.doc = T, T.on("change", this.$onChange, !0), this.bgTokenizer.setDocument(this.getDocument()), this.resetCaches();
        }, _.prototype.getDocument = function() {
          return this.doc;
        }, _.prototype.$resetRowCache = function(T) {
          if (!T) {
            this.$docRowCache = [], this.$screenRowCache = [];
            return;
          }
          var D = this.$docRowCache.length, E = this.$getRowCacheIndex(this.$docRowCache, T) + 1;
          D > E && (this.$docRowCache.splice(E, D), this.$screenRowCache.splice(E, D));
        }, _.prototype.$getRowCacheIndex = function(T, D) {
          for (var E = 0, R = T.length - 1; E <= R; ) {
            var I = E + R >> 1, k = T[I];
            if (D > k)
              E = I + 1;
            else if (D < k)
              R = I - 1;
            else
              return I;
          }
          return E - 1;
        }, _.prototype.resetCaches = function() {
          this.$modified = !0, this.$wrapData = [], this.$rowLengthCache = [], this.$resetRowCache(0), this.destroyed || this.bgTokenizer.start(0);
        }, _.prototype.onChangeFold = function(T) {
          var D = T.data;
          this.$resetRowCache(D.start.row);
        }, _.prototype.onChange = function(T) {
          this.$modified = !0, this.$bidiHandler.onChange(T), this.$resetRowCache(T.start.row);
          var D = this.$updateInternalDataOnChange(T);
          !this.$fromUndo && this.$undoManager && (D && D.length && (this.$undoManager.add({
            action: "removeFolds",
            folds: D
          }, this.mergeUndoDeltas), this.mergeUndoDeltas = !0), this.$undoManager.add(T, this.mergeUndoDeltas), this.mergeUndoDeltas = !0, this.$informUndoManager.schedule()), this.bgTokenizer.$updateOnChange(T), this._signal("change", T);
        }, _.prototype.setValue = function(T) {
          this.doc.setValue(T), this.selection.moveTo(0, 0), this.$resetRowCache(0), this.setUndoManager(this.$undoManager), this.getUndoManager().reset();
        }, _.fromJSON = function(T) {
          typeof T == "string" && (T = JSON.parse(T));
          var D = new m();
          D.$undoStack = T.history.undo, D.$redoStack = T.history.redo, D.mark = T.history.mark, D.$rev = T.history.rev;
          var E = new _(T.value);
          return T.folds.forEach(function(R) {
            E.addFold("...", f.fromPoints(R.start, R.end));
          }), E.setAnnotations(T.annotations), E.setBreakpoints(T.breakpoints), E.setMode(T.mode), E.setScrollLeft(T.scrollLeft), E.setScrollTop(T.scrollTop), E.setUndoManager(D), E.selection.fromJSON(T.selection), E;
        }, _.prototype.toJSON = function() {
          return {
            annotations: this.$annotations,
            breakpoints: this.$breakpoints,
            folds: this.getAllFolds().map(function(T) {
              return T.range;
            }),
            history: this.getUndoManager(),
            mode: this.$mode.$id,
            scrollLeft: this.$scrollLeft,
            scrollTop: this.$scrollTop,
            selection: this.selection.toJSON(),
            value: this.doc.getValue()
          };
        }, _.prototype.toString = function() {
          return this.doc.getValue();
        }, _.prototype.getSelection = function() {
          return this.selection;
        }, _.prototype.getState = function(T) {
          return this.bgTokenizer.getState(T);
        }, _.prototype.getTokens = function(T) {
          return this.bgTokenizer.getTokens(T);
        }, _.prototype.getTokenAt = function(T, D) {
          var E = this.bgTokenizer.getTokens(T), R, I = 0;
          if (D == null) {
            var k = E.length - 1;
            I = this.getLine(T).length;
          } else
            for (var k = 0; k < E.length && (I += E[k].value.length, !(I >= D)); k++)
              ;
          return R = E[k], R ? (R.index = k, R.start = I - R.value.length, R) : null;
        }, _.prototype.setUndoManager = function(T) {
          if (this.$undoManager = T, this.$informUndoManager && this.$informUndoManager.cancel(), T) {
            var D = this;
            T.addSession(this), this.$syncInformUndoManager = function() {
              D.$informUndoManager.cancel(), D.mergeUndoDeltas = !1;
            }, this.$informUndoManager = s.delayedCall(this.$syncInformUndoManager);
          } else
            this.$syncInformUndoManager = function() {
            };
        }, _.prototype.markUndoGroup = function() {
          this.$syncInformUndoManager && this.$syncInformUndoManager();
        }, _.prototype.getUndoManager = function() {
          return this.$undoManager || this.$defaultUndoManager;
        }, _.prototype.getTabString = function() {
          return this.getUseSoftTabs() ? s.stringRepeat(" ", this.getTabSize()) : "	";
        }, _.prototype.setUseSoftTabs = function(T) {
          this.setOption("useSoftTabs", T);
        }, _.prototype.getUseSoftTabs = function() {
          return this.$useSoftTabs && !this.$mode.$indentWithTabs;
        }, _.prototype.setTabSize = function(T) {
          this.setOption("tabSize", T);
        }, _.prototype.getTabSize = function() {
          return this.$tabSize;
        }, _.prototype.isTabStop = function(T) {
          return this.$useSoftTabs && T.column % this.$tabSize === 0;
        }, _.prototype.setNavigateWithinSoftTabs = function(T) {
          this.setOption("navigateWithinSoftTabs", T);
        }, _.prototype.getNavigateWithinSoftTabs = function() {
          return this.$navigateWithinSoftTabs;
        }, _.prototype.setOverwrite = function(T) {
          this.setOption("overwrite", T);
        }, _.prototype.getOverwrite = function() {
          return this.$overwrite;
        }, _.prototype.toggleOverwrite = function() {
          this.setOverwrite(!this.$overwrite);
        }, _.prototype.addGutterDecoration = function(T, D) {
          this.$decorations[T] || (this.$decorations[T] = ""), this.$decorations[T] += " " + D, this._signal("changeBreakpoint", {});
        }, _.prototype.removeGutterDecoration = function(T, D) {
          this.$decorations[T] = (this.$decorations[T] || "").replace(" " + D, ""), this._signal("changeBreakpoint", {});
        }, _.prototype.getBreakpoints = function() {
          return this.$breakpoints;
        }, _.prototype.setBreakpoints = function(T) {
          this.$breakpoints = [];
          for (var D = 0; D < T.length; D++)
            this.$breakpoints[T[D]] = "ace_breakpoint";
          this._signal("changeBreakpoint", {});
        }, _.prototype.clearBreakpoints = function() {
          this.$breakpoints = [], this._signal("changeBreakpoint", {});
        }, _.prototype.setBreakpoint = function(T, D) {
          D === void 0 && (D = "ace_breakpoint"), D ? this.$breakpoints[T] = D : delete this.$breakpoints[T], this._signal("changeBreakpoint", {});
        }, _.prototype.clearBreakpoint = function(T) {
          delete this.$breakpoints[T], this._signal("changeBreakpoint", {});
        }, _.prototype.addMarker = function(T, D, E, R) {
          var I = this.$markerId++, k = {
            range: T,
            type: E || "line",
            renderer: typeof E == "function" ? E : null,
            clazz: D,
            inFront: !!R,
            id: I
          };
          return R ? (this.$frontMarkers[I] = k, this._signal("changeFrontMarker")) : (this.$backMarkers[I] = k, this._signal("changeBackMarker")), I;
        }, _.prototype.addDynamicMarker = function(T, D) {
          if (T.update) {
            var E = this.$markerId++;
            return T.id = E, T.inFront = !!D, D ? (this.$frontMarkers[E] = T, this._signal("changeFrontMarker")) : (this.$backMarkers[E] = T, this._signal("changeBackMarker")), T;
          }
        }, _.prototype.removeMarker = function(T) {
          var D = this.$frontMarkers[T] || this.$backMarkers[T];
          if (D) {
            var E = D.inFront ? this.$frontMarkers : this.$backMarkers;
            delete E[T], this._signal(D.inFront ? "changeFrontMarker" : "changeBackMarker");
          }
        }, _.prototype.getMarkers = function(T) {
          return T ? this.$frontMarkers : this.$backMarkers;
        }, _.prototype.highlight = function(T) {
          if (!this.$searchHighlight) {
            var D = new g(null, "ace_selected-word", "text");
            this.$searchHighlight = this.addDynamicMarker(D);
          }
          this.$searchHighlight.setRegexp(T);
        }, _.prototype.highlightLines = function(T, D, E, R) {
          typeof D != "number" && (E = D, D = T), E || (E = "ace_step");
          var I = new f(T, 0, D, 1 / 0);
          return I.id = this.addMarker(I, E, "fullLine", R), I;
        }, _.prototype.setAnnotations = function(T) {
          this.$annotations = T, this._signal("changeAnnotation", {});
        }, _.prototype.getAnnotations = function() {
          return this.$annotations || [];
        }, _.prototype.clearAnnotations = function() {
          this.setAnnotations([]);
        }, _.prototype.$detectNewLine = function(T) {
          var D = T.match(/^.*?(\r?\n)/m);
          D ? this.$autoNewLine = D[1] : this.$autoNewLine = `
`;
        }, _.prototype.getWordRange = function(T, D) {
          var E = this.getLine(T), R = !1;
          if (D > 0 && (R = !!E.charAt(D - 1).match(this.tokenRe)), R || (R = !!E.charAt(D).match(this.tokenRe)), R)
            var I = this.tokenRe;
          else if (/^\s+$/.test(E.slice(D - 1, D + 1)))
            var I = /\s/;
          else
            var I = this.nonTokenRe;
          var k = D;
          if (k > 0) {
            do
              k--;
            while (k >= 0 && E.charAt(k).match(I));
            k++;
          }
          for (var P = D; P < E.length && E.charAt(P).match(I); )
            P++;
          return new f(T, k, T, P);
        }, _.prototype.getAWordRange = function(T, D) {
          for (var E = this.getWordRange(T, D), R = this.getLine(E.end.row); R.charAt(E.end.column).match(/[ \t]/); )
            E.end.column += 1;
          return E;
        }, _.prototype.setNewLineMode = function(T) {
          this.doc.setNewLineMode(T);
        }, _.prototype.getNewLineMode = function() {
          return this.doc.getNewLineMode();
        }, _.prototype.setUseWorker = function(T) {
          this.setOption("useWorker", T);
        }, _.prototype.getUseWorker = function() {
          return this.$useWorker;
        }, _.prototype.onReloadTokenizer = function(T) {
          var D = T.data;
          this.bgTokenizer.start(D.first), this._signal("tokenizerUpdate", T);
        }, _.prototype.setMode = function(T, D) {
          if (T && typeof T == "object") {
            if (T.getTokenizer)
              return this.$onChangeMode(T);
            var E = T, R = E.path;
          } else
            R = /**@type{string}*/
            T || "ace/mode/text";
          if (this.$modes["ace/mode/text"] || (this.$modes["ace/mode/text"] = new d()), this.$modes[R] && !E) {
            this.$onChangeMode(this.$modes[R]), D && D();
            return;
          }
          this.$modeId = R, l.loadModule(["mode", R], (function(I) {
            if (this.$modeId !== R)
              return D && D();
            this.$modes[R] && !E ? this.$onChangeMode(this.$modes[R]) : I && I.Mode && (I = new I.Mode(E), E || (this.$modes[R] = I, I.$id = R), this.$onChangeMode(I)), D && D();
          }).bind(this)), this.$mode || this.$onChangeMode(this.$modes["ace/mode/text"], !0);
        }, _.prototype.$onChangeMode = function(T, D) {
          if (D || (this.$modeId = T.$id), this.$mode !== T) {
            var E = this.$mode;
            this.$mode = T, this.$stopWorker(), this.$useWorker && this.$startWorker();
            var R = T.getTokenizer();
            if (R.on !== void 0) {
              var I = this.onReloadTokenizer.bind(this);
              R.on("update", I);
            }
            this.bgTokenizer.setTokenizer(R), this.bgTokenizer.setDocument(this.getDocument()), this.tokenRe = T.tokenRe, this.nonTokenRe = T.nonTokenRe, D || (T.attachToSession && T.attachToSession(this), this.$options.wrapMethod.set.call(this, this.$wrapMethod), this.$setFolding(T.foldingRules), this.bgTokenizer.start(0), this._emit("changeMode", { oldMode: E, mode: T }));
          }
        }, _.prototype.$stopWorker = function() {
          this.$worker && (this.$worker.terminate(), this.$worker = null);
        }, _.prototype.$startWorker = function() {
          try {
            this.$worker = this.$mode.createWorker(this);
          } catch (T) {
            l.warn("Could not load worker", T), this.$worker = null;
          }
        }, _.prototype.getMode = function() {
          return this.$mode;
        }, _.prototype.setScrollTop = function(T) {
          this.$scrollTop === T || isNaN(T) || (this.$scrollTop = T, this._signal("changeScrollTop", T));
        }, _.prototype.getScrollTop = function() {
          return this.$scrollTop;
        }, _.prototype.setScrollLeft = function(T) {
          this.$scrollLeft === T || isNaN(T) || (this.$scrollLeft = T, this._signal("changeScrollLeft", T));
        }, _.prototype.getScrollLeft = function() {
          return this.$scrollLeft;
        }, _.prototype.getScreenWidth = function() {
          return this.$computeWidth(), this.lineWidgets ? Math.max(this.getLineWidgetMaxWidth(), this.screenWidth) : this.screenWidth;
        }, _.prototype.getLineWidgetMaxWidth = function() {
          if (this.lineWidgetsWidth != null)
            return this.lineWidgetsWidth;
          var T = 0;
          return this.lineWidgets.forEach(function(D) {
            D && D.screenWidth > T && (T = D.screenWidth);
          }), this.lineWidgetWidth = T;
        }, _.prototype.$computeWidth = function(T) {
          if (this.$modified || T) {
            if (this.$modified = !1, this.$useWrapMode)
              return this.screenWidth = this.$wrapLimit;
            for (var D = this.doc.getAllLines(), E = this.$rowLengthCache, R = 0, I = 0, k = this.$foldData[I], P = k ? k.start.row : 1 / 0, L = D.length, N = 0; N < L; N++) {
              if (N > P) {
                if (N = k.end.row + 1, N >= L)
                  break;
                k = this.$foldData[I++], P = k ? k.start.row : 1 / 0;
              }
              E[N] == null && (E[N] = this.$getStringScreenWidth(D[N])[0]), E[N] > R && (R = E[N]);
            }
            this.screenWidth = R;
          }
        }, _.prototype.getLine = function(T) {
          return this.doc.getLine(T);
        }, _.prototype.getLines = function(T, D) {
          return this.doc.getLines(T, D);
        }, _.prototype.getLength = function() {
          return this.doc.getLength();
        }, _.prototype.getTextRange = function(T) {
          return this.doc.getTextRange(T || this.selection.getRange());
        }, _.prototype.insert = function(T, D) {
          return this.doc.insert(T, D);
        }, _.prototype.remove = function(T) {
          return this.doc.remove(T);
        }, _.prototype.removeFullLines = function(T, D) {
          return this.doc.removeFullLines(T, D);
        }, _.prototype.undoChanges = function(T, D) {
          if (T.length) {
            this.$fromUndo = !0;
            for (var E = T.length - 1; E != -1; E--) {
              var R = T[E];
              R.action == "insert" || R.action == "remove" ? this.doc.revertDelta(R) : R.folds && this.addFolds(R.folds);
            }
            !D && this.$undoSelect && (T.selectionBefore ? this.selection.fromJSON(T.selectionBefore) : this.selection.setRange(this.$getUndoSelection(T, !0))), this.$fromUndo = !1;
          }
        }, _.prototype.redoChanges = function(T, D) {
          if (T.length) {
            this.$fromUndo = !0;
            for (var E = 0; E < T.length; E++) {
              var R = T[E];
              (R.action == "insert" || R.action == "remove") && this.doc.$safeApplyDelta(R);
            }
            !D && this.$undoSelect && (T.selectionAfter ? this.selection.fromJSON(T.selectionAfter) : this.selection.setRange(this.$getUndoSelection(T, !1))), this.$fromUndo = !1;
          }
        }, _.prototype.setUndoSelect = function(T) {
          this.$undoSelect = T;
        }, _.prototype.$getUndoSelection = function(T, D) {
          function E(L) {
            return D ? L.action !== "insert" : L.action === "insert";
          }
          for (var R, I, k = 0; k < T.length; k++) {
            var P = T[k];
            if (P.start) {
              if (!R) {
                E(P) ? R = f.fromPoints(P.start, P.end) : R = f.fromPoints(P.start, P.start);
                continue;
              }
              E(P) ? (I = P.start, R.compare(I.row, I.column) == -1 && R.setStart(I), I = P.end, R.compare(I.row, I.column) == 1 && R.setEnd(I)) : (I = P.start, R.compare(I.row, I.column) == -1 && (R = f.fromPoints(P.start, P.start)));
            }
          }
          return R;
        }, _.prototype.replace = function(T, D) {
          return this.doc.replace(T, D);
        }, _.prototype.moveText = function(T, D, E) {
          var R = this.getTextRange(T), I = this.getFoldsInRange(T), k = f.fromPoints(D, D);
          if (!E) {
            this.remove(T);
            var P = T.start.row - T.end.row, L = P ? -T.end.column : T.start.column - T.end.column;
            L && (k.start.row == T.end.row && k.start.column > T.end.column && (k.start.column += L), k.end.row == T.end.row && k.end.column > T.end.column && (k.end.column += L)), P && k.start.row >= T.end.row && (k.start.row += P, k.end.row += P);
          }
          if (k.end = this.insert(k.start, R), I.length) {
            var N = T.start, F = k.start, P = F.row - N.row, L = F.column - N.column;
            this.addFolds(I.map(function(z) {
              return z = z.clone(), z.start.row == N.row && (z.start.column += L), z.end.row == N.row && (z.end.column += L), z.start.row += P, z.end.row += P, z;
            }));
          }
          return k;
        }, _.prototype.indentRows = function(T, D, E) {
          E = E.replace(/\t/g, this.getTabString());
          for (var R = T; R <= D; R++)
            this.doc.insertInLine({ row: R, column: 0 }, E);
        }, _.prototype.outdentRows = function(T) {
          for (var D = T.collapseRows(), E = new f(0, 0, 0, 0), R = this.getTabSize(), I = D.start.row; I <= D.end.row; ++I) {
            var k = this.getLine(I);
            E.start.row = I, E.end.row = I;
            for (var P = 0; P < R && k.charAt(P) == " "; ++P)
              ;
            P < R && k.charAt(P) == "	" ? (E.start.column = P, E.end.column = P + 1) : (E.start.column = 0, E.end.column = P), this.remove(E);
          }
        }, _.prototype.$moveLines = function(T, D, E) {
          if (T = this.getRowFoldStart(T), D = this.getRowFoldEnd(D), E < 0) {
            var R = this.getRowFoldStart(T + E);
            if (R < 0)
              return 0;
            var I = R - T;
          } else if (E > 0) {
            var R = this.getRowFoldEnd(D + E);
            if (R > this.doc.getLength() - 1)
              return 0;
            var I = R - D;
          } else {
            T = this.$clipRowToDocument(T), D = this.$clipRowToDocument(D);
            var I = D - T + 1;
          }
          var k = new f(T, 0, D, Number.MAX_VALUE), P = this.getFoldsInRange(k).map(function(N) {
            return N = N.clone(), N.start.row += I, N.end.row += I, N;
          }), L = E == 0 ? this.doc.getLines(T, D) : this.doc.removeFullLines(T, D);
          return this.doc.insertFullLines(T + I, L), P.length && this.addFolds(P), I;
        }, _.prototype.moveLinesUp = function(T, D) {
          return this.$moveLines(T, D, -1);
        }, _.prototype.moveLinesDown = function(T, D) {
          return this.$moveLines(T, D, 1);
        }, _.prototype.duplicateLines = function(T, D) {
          return this.$moveLines(T, D, 0);
        }, _.prototype.$clipRowToDocument = function(T) {
          return Math.max(0, Math.min(T, this.doc.getLength() - 1));
        }, _.prototype.$clipColumnToRow = function(T, D) {
          return D < 0 ? 0 : Math.min(this.doc.getLine(T).length, D);
        }, _.prototype.$clipPositionToDocument = function(T, D) {
          if (D = Math.max(0, D), T < 0)
            T = 0, D = 0;
          else {
            var E = this.doc.getLength();
            T >= E ? (T = E - 1, D = this.doc.getLine(E - 1).length) : D = Math.min(this.doc.getLine(T).length, D);
          }
          return {
            row: T,
            column: D
          };
        }, _.prototype.$clipRangeToDocument = function(T) {
          T.start.row < 0 ? (T.start.row = 0, T.start.column = 0) : T.start.column = this.$clipColumnToRow(T.start.row, T.start.column);
          var D = this.doc.getLength() - 1;
          return T.end.row > D ? (T.end.row = D, T.end.column = this.doc.getLine(D).length) : T.end.column = this.$clipColumnToRow(T.end.row, T.end.column), T;
        }, _.prototype.setUseWrapMode = function(T) {
          if (T != this.$useWrapMode) {
            if (this.$useWrapMode = T, this.$modified = !0, this.$resetRowCache(0), T) {
              var D = this.getLength();
              this.$wrapData = Array(D), this.$updateWrapData(0, D - 1);
            }
            this._signal("changeWrapMode");
          }
        }, _.prototype.getUseWrapMode = function() {
          return this.$useWrapMode;
        }, _.prototype.setWrapLimitRange = function(T, D) {
          (this.$wrapLimitRange.min !== T || this.$wrapLimitRange.max !== D) && (this.$wrapLimitRange = { min: T, max: D }, this.$modified = !0, this.$bidiHandler.markAsDirty(), this.$useWrapMode && this._signal("changeWrapMode"));
        }, _.prototype.adjustWrapLimit = function(T, D) {
          var E = this.$wrapLimitRange;
          E.max < 0 && (E = { min: D, max: D });
          var R = this.$constrainWrapLimit(T, E.min, E.max);
          return R != this.$wrapLimit && R > 1 ? (this.$wrapLimit = R, this.$modified = !0, this.$useWrapMode && (this.$updateWrapData(0, this.getLength() - 1), this.$resetRowCache(0), this._signal("changeWrapLimit")), !0) : !1;
        }, _.prototype.$constrainWrapLimit = function(T, D, E) {
          return D && (T = Math.max(D, T)), E && (T = Math.min(E, T)), T;
        }, _.prototype.getWrapLimit = function() {
          return this.$wrapLimit;
        }, _.prototype.setWrapLimit = function(T) {
          this.setWrapLimitRange(T, T);
        }, _.prototype.getWrapLimitRange = function() {
          return {
            min: this.$wrapLimitRange.min,
            max: this.$wrapLimitRange.max
          };
        }, _.prototype.$updateInternalDataOnChange = function(T) {
          var D = this.$useWrapMode, E = T.action, R = T.start, I = T.end, k = R.row, P = I.row, L = P - k, N = null;
          if (this.$updating = !0, L != 0)
            if (E === "remove") {
              this[D ? "$wrapData" : "$rowLengthCache"].splice(k, L);
              var F = this.$foldData;
              N = this.getFoldsInRange(T), this.removeFolds(N);
              var B = this.getFoldLine(I.row), j = 0;
              if (B) {
                B.addRemoveChars(I.row, I.column, R.column - I.column), B.shiftRow(-L);
                var z = this.getFoldLine(k);
                z && z !== B && (z.merge(B), B = z), j = F.indexOf(B) + 1;
              }
              for (j; j < F.length; j++) {
                var B = F[j];
                B.start.row >= I.row && B.shiftRow(-L);
              }
              P = k;
            } else {
              var H = Array(L);
              H.unshift(k, 0);
              var W = D ? this.$wrapData : this.$rowLengthCache;
              W.splice.apply(W, H);
              var F = this.$foldData, B = this.getFoldLine(k), j = 0;
              if (B) {
                var G = B.range.compareInside(R.row, R.column);
                G == 0 ? (B = B.split(R.row, R.column), B && (B.shiftRow(L), B.addRemoveChars(P, 0, I.column - R.column))) : G == -1 && (B.addRemoveChars(k, 0, I.column - R.column), B.shiftRow(L)), j = F.indexOf(B) + 1;
              }
              for (j; j < F.length; j++) {
                var B = F[j];
                B.start.row >= k && B.shiftRow(L);
              }
            }
          else {
            L = Math.abs(T.start.column - T.end.column), E === "remove" && (N = this.getFoldsInRange(T), this.removeFolds(N), L = -L);
            var B = this.getFoldLine(k);
            B && B.addRemoveChars(k, R.column, L);
          }
          return D && this.$wrapData.length != this.doc.getLength() && console.error("doc.getLength() and $wrapData.length have to be the same!"), this.$updating = !1, D ? this.$updateWrapData(k, P) : this.$updateRowLengthCache(k, P), N;
        }, _.prototype.$updateRowLengthCache = function(T, D) {
          this.$rowLengthCache[T] = null, this.$rowLengthCache[D] = null;
        }, _.prototype.$updateWrapData = function(T, D) {
          var E = this.doc.getAllLines(), R = this.getTabSize(), I = this.$wrapData, k = this.$wrapLimit, P, L, N = T;
          for (D = Math.min(D, E.length - 1); N <= D; )
            L = this.getFoldLine(N, L), L ? (P = [], L.walk((function(F, B, j, z) {
              var H;
              if (F != null) {
                H = this.$getDisplayTokens(F, P.length), H[0] = w;
                for (var W = 1; W < H.length; W++)
                  H[W] = C;
              } else
                H = this.$getDisplayTokens(E[B].substring(z, j), P.length);
              P = P.concat(H);
            }).bind(this), L.end.row, E[L.end.row].length + 1), I[L.start.row] = this.$computeWrapSplits(P, k, R), N = L.end.row + 1) : (P = this.$getDisplayTokens(E[N]), I[N] = this.$computeWrapSplits(P, k, R), N++);
        }, _.prototype.$computeWrapSplits = function(T, D, E) {
          if (T.length == 0)
            return [];
          var R = [], I = T.length, k = 0, P = 0, L = this.$wrapAsCode, N = this.$indentedSoftWrap, F = D <= Math.max(2 * E, 8) || N === !1 ? 0 : Math.floor(D / 2);
          function B() {
            var G = 0;
            if (F === 0)
              return G;
            if (N)
              for (var K = 0; K < T.length; K++) {
                var Y = T[K];
                if (Y == S)
                  G += 1;
                else if (Y == A)
                  G += E;
                else {
                  if (Y == $)
                    continue;
                  break;
                }
              }
            return L && N !== !1 && (G += E), Math.min(G, F);
          }
          function j(G) {
            for (var K = G - k, Y = k; Y < G; Y++) {
              var X = T[Y];
              (X === 12 || X === 2) && (K -= 1);
            }
            R.length || (z = B(), R.indent = z), P += K, R.push(P), k = G;
          }
          for (var z = 0; I - k > D - z; ) {
            var H = k + D - z;
            if (T[H - 1] >= S && T[H] >= S) {
              j(H);
              continue;
            }
            if (T[H] == w || T[H] == C) {
              for (H; H != k - 1 && T[H] != w; H--)
                ;
              if (H > k) {
                j(H);
                continue;
              }
              for (H = k + D, H; H < T.length && T[H] == C; H++)
                ;
              if (H == T.length)
                break;
              j(H);
              continue;
            }
            for (var W = Math.max(H - (D - (D >> 2)), k - 1); H > W && T[H] < w; )
              H--;
            if (L) {
              for (; H > W && T[H] < w; )
                H--;
              for (; H > W && T[H] == y; )
                H--;
            } else
              for (; H > W && T[H] < S; )
                H--;
            if (H > W) {
              j(++H);
              continue;
            }
            H = k + D, T[H] == x && H--, j(H - z);
          }
          return R;
        }, _.prototype.$getDisplayTokens = function(T, D) {
          var E = [], R;
          D = D || 0;
          for (var I = 0; I < T.length; I++) {
            var k = T.charCodeAt(I);
            if (k == 9) {
              R = this.getScreenTabSize(E.length + D), E.push(A);
              for (var P = 1; P < R; P++)
                E.push($);
            } else
              k == 32 ? E.push(S) : k > 39 && k < 48 || k > 57 && k < 64 ? E.push(y) : k >= 4352 && M(k) ? E.push(b, x) : E.push(b);
          }
          return E;
        }, _.prototype.$getStringScreenWidth = function(T, D, E) {
          if (D == 0)
            return [0, 0];
          D == null && (D = 1 / 0), E = E || 0;
          var R, I;
          for (I = 0; I < T.length && (R = T.charCodeAt(I), R == 9 ? E += this.getScreenTabSize(E) : R >= 4352 && M(R) ? E += 2 : E += 1, !(E > D)); I++)
            ;
          return [E, I];
        }, _.prototype.getRowLength = function(T) {
          var D = 1;
          return this.lineWidgets && (D += this.lineWidgets[T] && this.lineWidgets[T].rowCount || 0), !this.$useWrapMode || !this.$wrapData[T] ? D : this.$wrapData[T].length + D;
        }, _.prototype.getRowLineCount = function(T) {
          return !this.$useWrapMode || !this.$wrapData[T] ? 1 : this.$wrapData[T].length + 1;
        }, _.prototype.getRowWrapIndent = function(T) {
          if (this.$useWrapMode) {
            var D = this.screenToDocumentPosition(T, Number.MAX_VALUE), E = this.$wrapData[D.row];
            return E.length && E[0] < D.column ? E.indent : 0;
          } else
            return 0;
        }, _.prototype.getScreenLastRowColumn = function(T) {
          var D = this.screenToDocumentPosition(T, Number.MAX_VALUE);
          return this.documentToScreenColumn(D.row, D.column);
        }, _.prototype.getDocumentLastRowColumn = function(T, D) {
          var E = this.documentToScreenRow(T, D);
          return this.getScreenLastRowColumn(E);
        }, _.prototype.getDocumentLastRowColumnPosition = function(T, D) {
          var E = this.documentToScreenRow(T, D);
          return this.screenToDocumentPosition(E, Number.MAX_VALUE / 10);
        }, _.prototype.getRowSplitData = function(T) {
          if (this.$useWrapMode)
            return this.$wrapData[T];
        }, _.prototype.getScreenTabSize = function(T) {
          return this.$tabSize - (T % this.$tabSize | 0);
        }, _.prototype.screenToDocumentRow = function(T, D) {
          return this.screenToDocumentPosition(T, D).row;
        }, _.prototype.screenToDocumentColumn = function(T, D) {
          return this.screenToDocumentPosition(T, D).column;
        }, _.prototype.screenToDocumentPosition = function(T, D, E) {
          if (T < 0)
            return { row: 0, column: 0 };
          var R, I = 0, k = 0, P, L = 0, N = 0, F = this.$screenRowCache, B = this.$getRowCacheIndex(F, T), j = F.length;
          if (j && B >= 0)
            var L = F[B], I = this.$docRowCache[B], z = T > F[j - 1];
          else
            var z = !j;
          for (var H = this.getLength() - 1, W = this.getNextFoldLine(I), G = W ? W.start.row : 1 / 0; L <= T && (N = this.getRowLength(I), !(L + N > T || I >= H)); )
            L += N, I++, I > G && (I = W.end.row + 1, W = this.getNextFoldLine(I, W), G = W ? W.start.row : 1 / 0), z && (this.$docRowCache.push(I), this.$screenRowCache.push(L));
          if (W && W.start.row <= I)
            R = this.getFoldDisplayLine(W), I = W.start.row;
          else {
            if (L + N <= T || I > H)
              return {
                row: H,
                column: this.getLine(H).length
              };
            R = this.getLine(I), W = null;
          }
          var K = 0, Y = Math.floor(T - L);
          if (this.$useWrapMode) {
            var X = this.$wrapData[I];
            X && (P = X[Y], Y > 0 && X.length && (K = X.indent, k = X[Y - 1] || X[X.length - 1], R = R.substring(k)));
          }
          return E !== void 0 && this.$bidiHandler.isBidiRow(L + Y, I, Y) && (D = this.$bidiHandler.offsetToCol(E)), k += this.$getStringScreenWidth(R, D - K)[1], this.$useWrapMode && k >= P && (k = P - 1), W ? W.idxToPosition(k) : { row: I, column: k };
        }, _.prototype.documentToScreenPosition = function(T, D) {
          if (typeof D > "u")
            var E = this.$clipPositionToDocument(
              /**@type{Point}*/
              T.row,
              /**@type{Point}*/
              T.column
            );
          else
            E = this.$clipPositionToDocument(
              /**@type{number}*/
              T,
              D
            );
          T = E.row, D = E.column;
          var R = 0, I = null, k = null;
          k = this.getFoldAt(T, D, 1), k && (T = k.start.row, D = k.start.column);
          var P, L = 0, N = this.$docRowCache, F = this.$getRowCacheIndex(N, T), B = N.length;
          if (B && F >= 0)
            var L = N[F], R = this.$screenRowCache[F], j = T > N[B - 1];
          else
            var j = !B;
          for (var z = this.getNextFoldLine(L), H = z ? z.start.row : 1 / 0; L < T; ) {
            if (L >= H) {
              if (P = z.end.row + 1, P > T)
                break;
              z = this.getNextFoldLine(P, z), H = z ? z.start.row : 1 / 0;
            } else
              P = L + 1;
            R += this.getRowLength(L), L = P, j && (this.$docRowCache.push(L), this.$screenRowCache.push(R));
          }
          var W = "";
          z && L >= H ? (W = this.getFoldDisplayLine(z, T, D), I = z.start.row) : (W = this.getLine(T).substring(0, D), I = T);
          var G = 0;
          if (this.$useWrapMode) {
            var K = this.$wrapData[I];
            if (K) {
              for (var Y = 0; W.length >= K[Y]; )
                R++, Y++;
              W = W.substring(K[Y - 1] || 0, W.length), G = Y > 0 ? K.indent : 0;
            }
          }
          return this.lineWidgets && this.lineWidgets[L] && this.lineWidgets[L].rowsAbove && (R += this.lineWidgets[L].rowsAbove), {
            row: R,
            column: G + this.$getStringScreenWidth(W)[0]
          };
        }, _.prototype.documentToScreenColumn = function(T, D) {
          return this.documentToScreenPosition(T, D).column;
        }, _.prototype.documentToScreenRow = function(T, D) {
          return this.documentToScreenPosition(T, D).row;
        }, _.prototype.getScreenLength = function() {
          var T = 0, D = null;
          if (this.$useWrapMode)
            for (var I = this.$wrapData.length, k = 0, R = 0, D = this.$foldData[R++], P = D ? D.start.row : 1 / 0; k < I; ) {
              var L = this.$wrapData[k];
              T += L ? L.length + 1 : 1, k++, k > P && (k = D.end.row + 1, D = this.$foldData[R++], P = D ? D.start.row : 1 / 0);
            }
          else {
            T = this.getLength();
            for (var E = this.$foldData, R = 0; R < E.length; R++)
              D = E[R], T -= D.end.row - D.start.row;
          }
          return this.lineWidgets && (T += this.$getWidgetScreenLength()), T;
        }, _.prototype.$setFontMetrics = function(T) {
          this.$enableVarChar && (this.$getStringScreenWidth = function(D, E, R) {
            if (E === 0)
              return [0, 0];
            E || (E = 1 / 0), R = R || 0;
            var I, k;
            for (k = 0; k < D.length && (I = D.charAt(k), I === "	" ? R += this.getScreenTabSize(R) : R += T.getCharacterWidth(I), !(R > E)); k++)
              ;
            return [R, k];
          });
        }, _.prototype.getPrecedingCharacter = function() {
          var T = this.selection.getCursor();
          if (T.column === 0)
            return T.row === 0 ? "" : this.doc.getNewLineCharacter();
          var D = this.getLine(T.row);
          return D[T.column - 1];
        }, _.prototype.destroy = function() {
          this.destroyed || (this.bgTokenizer.setDocument(null), this.bgTokenizer.cleanup(), this.destroyed = !0), this.$stopWorker(), this.removeAllListeners(), this.doc && this.doc.off("change", this.$onChange), this.selection.detach();
        }, _;
      }()
    );
    v.$uid = 0, v.prototype.$modes = l.$modes, v.prototype.getValue = v.prototype.toString, v.prototype.$defaultUndoManager = {
      undo: function() {
      },
      redo: function() {
      },
      hasUndo: function() {
      },
      hasRedo: function() {
      },
      reset: function() {
      },
      add: function() {
      },
      addSelection: function() {
      },
      startNewGroup: function() {
      },
      addSession: function() {
      }
    }, v.prototype.$overwrite = !1, v.prototype.$mode = null, v.prototype.$modeId = null, v.prototype.$scrollTop = 0, v.prototype.$scrollLeft = 0, v.prototype.$wrapLimit = 80, v.prototype.$useWrapMode = !1, v.prototype.$wrapLimitRange = {
      min: null,
      max: null
    }, v.prototype.lineWidgets = null, v.prototype.isFullWidth = M, o.implement(v.prototype, u);
    var b = 1, x = 2, w = 3, C = 4, y = 9, S = 10, A = 11, $ = 12;
    function M(_) {
      return _ < 4352 ? !1 : _ >= 4352 && _ <= 4447 || _ >= 4515 && _ <= 4519 || _ >= 4602 && _ <= 4607 || _ >= 9001 && _ <= 9002 || _ >= 11904 && _ <= 11929 || _ >= 11931 && _ <= 12019 || _ >= 12032 && _ <= 12245 || _ >= 12272 && _ <= 12283 || _ >= 12288 && _ <= 12350 || _ >= 12353 && _ <= 12438 || _ >= 12441 && _ <= 12543 || _ >= 12549 && _ <= 12589 || _ >= 12593 && _ <= 12686 || _ >= 12688 && _ <= 12730 || _ >= 12736 && _ <= 12771 || _ >= 12784 && _ <= 12830 || _ >= 12832 && _ <= 12871 || _ >= 12880 && _ <= 13054 || _ >= 13056 && _ <= 19903 || _ >= 19968 && _ <= 42124 || _ >= 42128 && _ <= 42182 || _ >= 43360 && _ <= 43388 || _ >= 44032 && _ <= 55203 || _ >= 55216 && _ <= 55238 || _ >= 55243 && _ <= 55291 || _ >= 63744 && _ <= 64255 || _ >= 65040 && _ <= 65049 || _ >= 65072 && _ <= 65106 || _ >= 65108 && _ <= 65126 || _ >= 65128 && _ <= 65131 || _ >= 65281 && _ <= 65376 || _ >= 65504 && _ <= 65510;
    }
    n("./edit_session/folding").Folding.call(v.prototype), n("./edit_session/bracket_match").BracketMatch.call(v.prototype), l.defineOptions(v.prototype, "session", {
      wrap: {
        set: function(_) {
          if (!_ || _ == "off" ? _ = !1 : _ == "free" ? _ = !0 : _ == "printMargin" ? _ = -1 : typeof _ == "string" && (_ = parseInt(_, 10) || !1), this.$wrap != _)
            if (this.$wrap = _, !_)
              this.setUseWrapMode(!1);
            else {
              var T = typeof _ == "number" ? _ : null;
              this.setWrapLimitRange(T, T), this.setUseWrapMode(!0);
            }
        },
        get: function() {
          return this.getUseWrapMode() ? this.$wrap == -1 ? "printMargin" : this.getWrapLimitRange().min ? this.$wrap : "free" : "off";
        },
        handlesSet: !0
      },
      wrapMethod: {
        set: function(_) {
          _ = _ == "auto" ? this.$mode.type != "text" : _ != "text", _ != this.$wrapAsCode && (this.$wrapAsCode = _, this.$useWrapMode && (this.$useWrapMode = !1, this.setUseWrapMode(!0)));
        },
        initialValue: "auto"
      },
      indentedSoftWrap: {
        set: function() {
          this.$useWrapMode && (this.$useWrapMode = !1, this.setUseWrapMode(!0));
        },
        initialValue: !0
      },
      firstLineNumber: {
        set: function() {
          this._signal("changeBreakpoint");
        },
        initialValue: 1
      },
      useWorker: {
        set: function(_) {
          this.$useWorker = _, this.$stopWorker(), _ && this.$startWorker();
        },
        initialValue: !0
      },
      useSoftTabs: { initialValue: !0 },
      tabSize: {
        set: function(_) {
          _ = parseInt(_), _ > 0 && this.$tabSize !== _ && (this.$modified = !0, this.$rowLengthCache = [], this.$tabSize = _, this._signal("changeTabSize"));
        },
        initialValue: 4,
        handlesSet: !0
      },
      navigateWithinSoftTabs: { initialValue: !1 },
      foldStyle: {
        set: function(_) {
          this.setFoldStyle(_);
        },
        handlesSet: !0
      },
      overwrite: {
        set: function(_) {
          this._signal("changeOverwrite");
        },
        initialValue: !1
      },
      newLineMode: {
        set: function(_) {
          this.doc.setNewLineMode(_);
        },
        get: function() {
          return this.doc.getNewLineMode();
        },
        handlesSet: !0
      },
      mode: {
        set: function(_) {
          this.setMode(_);
        },
        get: function() {
          return this.$modeId;
        },
        handlesSet: !0
      }
    }), r.EditSession = v;
  }), ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(n, r, i) {
    var o = n("./lib/lang"), s = n("./lib/oop"), a = n("./range").Range, l = (
      /** @class */
      function() {
        function c() {
          this.$options = {};
        }
        return c.prototype.set = function(d) {
          return s.mixin(this.$options, d), this;
        }, c.prototype.getOptions = function() {
          return o.copyObject(this.$options);
        }, c.prototype.setOptions = function(d) {
          this.$options = d;
        }, c.prototype.find = function(d) {
          var f = this.$options, h = this.$matchIterator(d, f);
          if (!h)
            return !1;
          var p = null;
          return h.forEach(function(g, m, v, b) {
            return p = new a(g, m, v, b), m == b && f.start && /**@type{Range}*/
            f.start.start && f.skipCurrent != !1 && p.isEqual(
              /**@type{Range}*/
              f.start
            ) ? (p = null, !1) : !0;
          }), p;
        }, c.prototype.findAll = function(d) {
          var f = this.$options;
          if (!f.needle)
            return [];
          this.$assembleRegExp(f);
          var h = f.range, p = h ? d.getLines(h.start.row, h.end.row) : d.doc.getAllLines(), g = [], m = f.re;
          if (f.$isMultiLine) {
            var v = m.length, b = p.length - v, x;
            e:
              for (var w = m.offset || 0; w <= b; w++) {
                for (var C = 0; C < v; C++)
                  if (p[w + C].search(m[C]) == -1)
                    continue e;
                var y = p[w], S = p[w + v - 1], A = y.length - y.match(m[0])[0].length, $ = S.match(m[v - 1])[0].length;
                x && x.end.row === w && x.end.column > A || (g.push(x = new a(w, A, w + v - 1, $)), v > 2 && (w = w + v - 2));
              }
          } else
            for (var M = 0; M < p.length; M++)
              for (var _ = o.getMatchOffsets(p[M], m), C = 0; C < _.length; C++) {
                var T = _[C];
                g.push(new a(M, T.offset, M, T.offset + T.length));
              }
          if (h) {
            for (var D = h.start.column, E = h.end.column, M = 0, C = g.length - 1; M < C && g[M].start.column < D && g[M].start.row == 0; )
              M++;
            for (var R = h.end.row - h.start.row; M < C && g[C].end.column > E && g[C].end.row == R; )
              C--;
            for (g = g.slice(M, C + 1), M = 0, C = g.length; M < C; M++)
              g[M].start.row += h.start.row, g[M].end.row += h.start.row;
          }
          return g;
        }, c.prototype.replace = function(d, f) {
          var h = this.$options, p = this.$assembleRegExp(h);
          if (h.$isMultiLine)
            return f;
          if (p) {
            var g = p.exec(d);
            if (!g || g[0].length != d.length)
              return null;
            if (h.regExp || (f = f.replace(/\$/g, "$$$$")), f = d.replace(p, f), h.preserveCase) {
              f = f.split("");
              for (var m = Math.min(d.length, d.length); m--; ) {
                var v = d[m];
                v && v.toLowerCase() != v ? f[m] = f[m].toUpperCase() : f[m] = f[m].toLowerCase();
              }
              f = f.join("");
            }
            return f;
          }
        }, c.prototype.$assembleRegExp = function(d, f) {
          if (d.needle instanceof RegExp)
            return d.re = d.needle;
          var h = d.needle;
          if (!d.needle)
            return d.re = !1;
          d.regExp || (h = o.escapeRegExp(h));
          var p = d.caseSensitive ? "gm" : "gmi";
          try {
            new RegExp(h, "u"), d.$supportsUnicodeFlag = !0, p += "u";
          } catch {
            d.$supportsUnicodeFlag = !1;
          }
          if (d.wholeWord && (h = u(h, d)), d.$isMultiLine = !f && /[\n\r]/.test(h), d.$isMultiLine)
            return d.re = this.$assembleMultilineRegExp(h, p);
          try {
            var g = new RegExp(h, p);
          } catch {
            g = !1;
          }
          return d.re = g;
        }, c.prototype.$assembleMultilineRegExp = function(d, f) {
          for (var h = d.replace(/\r\n|\r|\n/g, `$
^`).split(`
`), p = [], g = 0; g < h.length; g++)
            try {
              p.push(new RegExp(h[g], f));
            } catch {
              return !1;
            }
          return p;
        }, c.prototype.$matchIterator = function(d, f) {
          var h = this.$assembleRegExp(f);
          if (!h)
            return !1;
          var p = f.backwards == !0, g = f.skipCurrent != !1, m = h.unicode, v = f.range, b = f.start;
          b || (b = v ? v[p ? "end" : "start"] : d.selection.getRange()), b.start && (b = b[g != p ? "end" : "start"]);
          var x = v ? v.start.row : 0, w = v ? v.end.row : d.getLength() - 1;
          if (p)
            var C = function(A) {
              var $ = b.row;
              if (!S($, b.column, A)) {
                for ($--; $ >= x; $--)
                  if (S($, Number.MAX_VALUE, A))
                    return;
                if (f.wrap != !1) {
                  for ($ = w, x = b.row; $ >= x; $--)
                    if (S($, Number.MAX_VALUE, A))
                      return;
                }
              }
            };
          else
            var C = function($) {
              var M = b.row;
              if (!S(M, b.column, $)) {
                for (M = M + 1; M <= w; M++)
                  if (S(M, 0, $))
                    return;
                if (f.wrap != !1) {
                  for (M = x, w = b.row; M <= w; M++)
                    if (S(M, 0, $))
                      return;
                }
              }
            };
          if (f.$isMultiLine)
            var y = h.length, S = function(A, $, M) {
              var _ = p ? A - y + 1 : A;
              if (!(_ < 0 || _ + y > d.getLength())) {
                var T = d.getLine(_), D = T.search(h[0]);
                if (!(!p && D < $ || D === -1)) {
                  for (var E = 1; E < y; E++)
                    if (T = d.getLine(_ + E), T.search(h[E]) == -1)
                      return;
                  var R = T.match(h[y - 1])[0].length;
                  if (!(p && R > $) && M(_, D, _ + y - 1, R))
                    return !0;
                }
              }
            };
          else if (p)
            var S = function($, M, _) {
              var T = d.getLine($), D = [], E, R = 0;
              for (h.lastIndex = 0; E = h.exec(T); ) {
                var I = E[0].length;
                if (R = E.index, !I) {
                  if (R >= T.length)
                    break;
                  h.lastIndex = R += o.skipEmptyMatch(T, R, m);
                }
                if (E.index + I > M)
                  break;
                D.push(E.index, I);
              }
              for (var k = D.length - 1; k >= 0; k -= 2) {
                var P = D[k - 1], I = D[k];
                if (_($, P, $, P + I))
                  return !0;
              }
            };
          else
            var S = function($, M, _) {
              var T = d.getLine($), D, E;
              for (h.lastIndex = M; E = h.exec(T); ) {
                var R = E[0].length;
                if (D = E.index, _($, D, $, D + R))
                  return !0;
                if (!R && (h.lastIndex = D += o.skipEmptyMatch(T, D, m), D >= T.length))
                  return !1;
              }
            };
          return { forEach: C };
        }, c;
      }()
    );
    function u(c, d) {
      var f = o.supportsLookbehind();
      function h(v, b) {
        b === void 0 && (b = !0);
        var x = f && d.$supportsUnicodeFlag ? new RegExp("[\\p{L}\\p{N}_]", "u") : new RegExp("\\w");
        return x.test(v) || d.regExp ? f && d.$supportsUnicodeFlag ? b ? "(?<=^|[^\\p{L}\\p{N}_])" : "(?=[^\\p{L}\\p{N}_]|$)" : "\\b" : "";
      }
      var p = Array.from(c), g = p[0], m = p[p.length - 1];
      return h(g) + c + h(m, !1);
    }
    r.Search = l;
  }), ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(n, r, i) {
    var o = this && this.__extends || /* @__PURE__ */ function() {
      var f = function(h, p) {
        return f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(g, m) {
          g.__proto__ = m;
        } || function(g, m) {
          for (var v in m)
            Object.prototype.hasOwnProperty.call(m, v) && (g[v] = m[v]);
        }, f(h, p);
      };
      return function(h, p) {
        if (typeof p != "function" && p !== null)
          throw new TypeError("Class extends value " + String(p) + " is not a constructor or null");
        f(h, p);
        function g() {
          this.constructor = h;
        }
        h.prototype = p === null ? Object.create(p) : (g.prototype = p.prototype, new g());
      };
    }(), s = n("../lib/keys"), a = n("../lib/useragent"), l = s.KEY_MODS, u = (
      /** @class */
      function() {
        function f(h, p) {
          this.$init(h, p, !1);
        }
        return f.prototype.$init = function(h, p, g) {
          this.platform = p || (a.isMac ? "mac" : "win"), this.commands = {}, this.commandKeyBinding = {}, this.addCommands(h), this.$singleCommand = g;
        }, f.prototype.addCommand = function(h) {
          this.commands[h.name] && this.removeCommand(h), this.commands[h.name] = h, h.bindKey && this._buildKeyHash(h);
        }, f.prototype.removeCommand = function(h, p) {
          var g = h && (typeof h == "string" ? h : h.name);
          h = this.commands[g], p || delete this.commands[g];
          var m = this.commandKeyBinding;
          for (var v in m) {
            var b = m[v];
            if (b == h)
              delete m[v];
            else if (Array.isArray(b)) {
              var x = b.indexOf(h);
              x != -1 && (b.splice(x, 1), b.length == 1 && (m[v] = b[0]));
            }
          }
        }, f.prototype.bindKey = function(h, p, g) {
          if (typeof h == "object" && h && (g == null && (g = h.position), h = h[this.platform]), !!h) {
            if (typeof p == "function")
              return this.addCommand({ exec: p, bindKey: h, name: p.name || /**@type{string}*/
              h });
            h.split("|").forEach(function(m) {
              var v = "";
              if (m.indexOf(" ") != -1) {
                var b = m.split(/\s+/);
                m = b.pop(), b.forEach(function(C) {
                  var y = this.parseKeys(C), S = l[y.hashId] + y.key;
                  v += (v ? " " : "") + S, this._addCommandToBinding(v, "chainKeys");
                }, this), v += " ";
              }
              var x = this.parseKeys(m), w = l[x.hashId] + x.key;
              this._addCommandToBinding(v + w, p, g);
            }, this);
          }
        }, f.prototype._addCommandToBinding = function(h, p, g) {
          var m = this.commandKeyBinding, v;
          if (!p)
            delete m[h];
          else if (!m[h] || this.$singleCommand)
            m[h] = p;
          else {
            Array.isArray(m[h]) ? (v = m[h].indexOf(p)) != -1 && m[h].splice(v, 1) : m[h] = [m[h]], typeof g != "number" && (g = c(p));
            var b = m[h];
            for (v = 0; v < b.length; v++) {
              var x = b[v], w = c(x);
              if (w > g)
                break;
            }
            b.splice(v, 0, p);
          }
        }, f.prototype.addCommands = function(h) {
          h && Object.keys(h).forEach(function(p) {
            var g = h[p];
            if (g) {
              if (typeof g == "string")
                return this.bindKey(g, p);
              typeof g == "function" && (g = { exec: g }), typeof g == "object" && (g.name || (g.name = p), this.addCommand(g));
            }
          }, this);
        }, f.prototype.removeCommands = function(h) {
          Object.keys(h).forEach(function(p) {
            this.removeCommand(h[p]);
          }, this);
        }, f.prototype.bindKeys = function(h) {
          Object.keys(h).forEach(function(p) {
            this.bindKey(p, h[p]);
          }, this);
        }, f.prototype._buildKeyHash = function(h) {
          this.bindKey(h.bindKey, h);
        }, f.prototype.parseKeys = function(h) {
          var p = h.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(w) {
            return w;
          }), g = p.pop(), m = s[g];
          if (s.FUNCTION_KEYS[m])
            g = s.FUNCTION_KEYS[m].toLowerCase();
          else if (p.length) {
            if (p.length == 1 && p[0] == "shift")
              return { key: g.toUpperCase(), hashId: -1 };
          } else
            return { key: g, hashId: -1 };
          for (var v = 0, b = p.length; b--; ) {
            var x = s.KEY_MODS[p[b]];
            if (x == null)
              return typeof console < "u" && console.error("invalid modifier " + p[b] + " in " + h), !1;
            v |= x;
          }
          return { key: g, hashId: v };
        }, f.prototype.findKeyCommand = function(h, p) {
          var g = l[h] + p;
          return this.commandKeyBinding[g];
        }, f.prototype.handleKeyboard = function(h, p, g, m) {
          if (!(m < 0)) {
            var v = l[p] + g, b = this.commandKeyBinding[v];
            return h.$keyChain && (h.$keyChain += " " + v, b = this.commandKeyBinding[h.$keyChain] || b), b && (b == "chainKeys" || b[b.length - 1] == "chainKeys") ? (h.$keyChain = h.$keyChain || v, { command: "null" }) : (h.$keyChain && ((!p || p == 4) && g.length == 1 ? h.$keyChain = h.$keyChain.slice(0, -v.length - 1) : (p == -1 || m > 0) && (h.$keyChain = "")), { command: b });
          }
        }, f.prototype.getStatusText = function(h, p) {
          return p.$keyChain || "";
        }, f;
      }()
    );
    function c(f) {
      return typeof f == "object" && f.bindKey && f.bindKey.position || (f.isDefault ? -100 : 0);
    }
    var d = (
      /** @class */
      function(f) {
        o(h, f);
        function h(p, g) {
          var m = f.call(this, p, g) || this;
          return m.$singleCommand = !0, m;
        }
        return h;
      }(u)
    );
    d.call = function(f, h, p) {
      u.prototype.$init.call(f, h, p, !0);
    }, u.call = function(f, h, p) {
      u.prototype.$init.call(f, h, p, !1);
    }, r.HashHandler = d, r.MultiHashHandler = u;
  }), ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function(n, r, i) {
    var o = this && this.__extends || /* @__PURE__ */ function() {
      var c = function(d, f) {
        return c = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(h, p) {
          h.__proto__ = p;
        } || function(h, p) {
          for (var g in p)
            Object.prototype.hasOwnProperty.call(p, g) && (h[g] = p[g]);
        }, c(d, f);
      };
      return function(d, f) {
        if (typeof f != "function" && f !== null)
          throw new TypeError("Class extends value " + String(f) + " is not a constructor or null");
        c(d, f);
        function h() {
          this.constructor = d;
        }
        d.prototype = f === null ? Object.create(f) : (h.prototype = f.prototype, new h());
      };
    }(), s = n("../lib/oop"), a = n("../keyboard/hash_handler").MultiHashHandler, l = n("../lib/event_emitter").EventEmitter, u = (
      /** @class */
      function(c) {
        o(d, c);
        function d(f, h) {
          var p = c.call(this, h, f) || this;
          return p.byName = p.commands, p.setDefaultHandler("exec", function(g) {
            return g.args ? g.command.exec(g.editor, g.args, g.event, !1) : g.command.exec(g.editor, {}, g.event, !0);
          }), p;
        }
        return d.prototype.exec = function(f, h, p) {
          if (Array.isArray(f)) {
            for (var g = f.length; g--; )
              if (this.exec(f[g], h, p))
                return !0;
            return !1;
          }
          if (typeof f == "string" && (f = this.commands[f]), !f || h && h.$readOnly && !f.readOnly || this.$checkCommandState != !1 && f.isAvailable && !f.isAvailable(h))
            return !1;
          var m = { editor: h, command: f, args: p };
          return m.returnValue = this._emit("exec", m), this._signal("afterExec", m), m.returnValue !== !1;
        }, d.prototype.toggleRecording = function(f) {
          if (!this.$inReplay)
            return f && f._emit("changeStatus"), this.recording ? (this.macro.pop(), this.off("exec", this.$addCommandToMacro), this.macro.length || (this.macro = this.oldMacro), this.recording = !1) : (this.$addCommandToMacro || (this.$addCommandToMacro = (function(h) {
              this.macro.push([h.command, h.args]);
            }).bind(this)), this.oldMacro = this.macro, this.macro = [], this.on("exec", this.$addCommandToMacro), this.recording = !0);
        }, d.prototype.replay = function(f) {
          if (!(this.$inReplay || !this.macro)) {
            if (this.recording)
              return this.toggleRecording(f);
            try {
              this.$inReplay = !0, this.macro.forEach(function(h) {
                typeof h == "string" ? this.exec(h, f) : this.exec(h[0], f, h[1]);
              }, this);
            } finally {
              this.$inReplay = !1;
            }
          }
        }, d.prototype.trimMacro = function(f) {
          return f.map(function(h) {
            return typeof h[0] != "string" && (h[0] = h[0].name), h[1] || (h = h[0]), h;
          });
        }, d;
      }(a)
    );
    s.implement(u.prototype, l), r.CommandManager = u;
  }), ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function(n, r, i) {
    var o = n("../lib/lang"), s = n("../config"), a = n("../range").Range;
    function l(c, d) {
      return { win: c, mac: d };
    }
    r.commands = [
      {
        name: "showSettingsMenu",
        description: "Show settings menu",
        bindKey: l("Ctrl-,", "Command-,"),
        exec: function(c) {
          s.loadModule("ace/ext/settings_menu", function(d) {
            d.init(c), c.showSettingsMenu();
          });
        },
        readOnly: !0
      },
      {
        name: "goToNextError",
        description: "Go to next error",
        bindKey: l("Alt-E", "F4"),
        exec: function(c) {
          s.loadModule("ace/ext/error_marker", function(d) {
            d.showErrorMarker(c, 1);
          });
        },
        scrollIntoView: "animate",
        readOnly: !0
      },
      {
        name: "goToPreviousError",
        description: "Go to previous error",
        bindKey: l("Alt-Shift-E", "Shift-F4"),
        exec: function(c) {
          s.loadModule("ace/ext/error_marker", function(d) {
            d.showErrorMarker(c, -1);
          });
        },
        scrollIntoView: "animate",
        readOnly: !0
      },
      {
        name: "selectall",
        description: "Select all",
        bindKey: l("Ctrl-A", "Command-A"),
        exec: function(c) {
          c.selectAll();
        },
        readOnly: !0
      },
      {
        name: "centerselection",
        description: "Center selection",
        bindKey: l(null, "Ctrl-L"),
        exec: function(c) {
          c.centerSelection();
        },
        readOnly: !0
      },
      {
        name: "gotoline",
        description: "Go to line...",
        bindKey: l("Ctrl-L", "Command-L"),
        exec: function(c, d) {
          typeof d == "number" && !isNaN(d) && c.gotoLine(d), c.prompt({ $type: "gotoLine" });
        },
        readOnly: !0
      },
      {
        name: "fold",
        bindKey: l("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
        exec: function(c) {
          c.session.toggleFold(!1);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: !0
      },
      {
        name: "unfold",
        bindKey: l("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
        exec: function(c) {
          c.session.toggleFold(!0);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: !0
      },
      {
        name: "toggleFoldWidget",
        description: "Toggle fold widget",
        bindKey: l("F2", "F2"),
        exec: function(c) {
          c.session.toggleFoldWidget();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: !0
      },
      {
        name: "toggleParentFoldWidget",
        description: "Toggle parent fold widget",
        bindKey: l("Alt-F2", "Alt-F2"),
        exec: function(c) {
          c.session.toggleFoldWidget(!0);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: !0
      },
      {
        name: "foldall",
        description: "Fold all",
        bindKey: l(null, "Ctrl-Command-Option-0"),
        exec: function(c) {
          c.session.foldAll();
        },
        scrollIntoView: "center",
        readOnly: !0
      },
      {
        name: "foldAllComments",
        description: "Fold all comments",
        bindKey: l(null, "Ctrl-Command-Option-0"),
        exec: function(c) {
          c.session.foldAllComments();
        },
        scrollIntoView: "center",
        readOnly: !0
      },
      {
        name: "foldOther",
        description: "Fold other",
        bindKey: l("Alt-0", "Command-Option-0"),
        exec: function(c) {
          c.session.foldAll(), c.session.unfold(c.selection.getAllRanges());
        },
        scrollIntoView: "center",
        readOnly: !0
      },
      {
        name: "unfoldall",
        description: "Unfold all",
        bindKey: l("Alt-Shift-0", "Command-Option-Shift-0"),
        exec: function(c) {
          c.session.unfold();
        },
        scrollIntoView: "center",
        readOnly: !0
      },
      {
        name: "findnext",
        description: "Find next",
        bindKey: l("Ctrl-K", "Command-G"),
        exec: function(c) {
          c.findNext();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: !0
      },
      {
        name: "findprevious",
        description: "Find previous",
        bindKey: l("Ctrl-Shift-K", "Command-Shift-G"),
        exec: function(c) {
          c.findPrevious();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "center",
        readOnly: !0
      },
      {
        name: "selectOrFindNext",
        description: "Select or find next",
        bindKey: l("Alt-K", "Ctrl-G"),
        exec: function(c) {
          c.selection.isEmpty() ? c.selection.selectWord() : c.findNext();
        },
        readOnly: !0
      },
      {
        name: "selectOrFindPrevious",
        description: "Select or find previous",
        bindKey: l("Alt-Shift-K", "Ctrl-Shift-G"),
        exec: function(c) {
          c.selection.isEmpty() ? c.selection.selectWord() : c.findPrevious();
        },
        readOnly: !0
      },
      {
        name: "find",
        description: "Find",
        bindKey: l("Ctrl-F", "Command-F"),
        exec: function(c) {
          s.loadModule("ace/ext/searchbox", function(d) {
            d.Search(c);
          });
        },
        readOnly: !0
      },
      {
        name: "overwrite",
        description: "Overwrite",
        bindKey: "Insert",
        exec: function(c) {
          c.toggleOverwrite();
        },
        readOnly: !0
      },
      {
        name: "selecttostart",
        description: "Select to start",
        bindKey: l("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
        exec: function(c) {
          c.getSelection().selectFileStart();
        },
        multiSelectAction: "forEach",
        readOnly: !0,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      },
      {
        name: "gotostart",
        description: "Go to start",
        bindKey: l("Ctrl-Home", "Command-Home|Command-Up"),
        exec: function(c) {
          c.navigateFileStart();
        },
        multiSelectAction: "forEach",
        readOnly: !0,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      },
      {
        name: "selectup",
        description: "Select up",
        bindKey: l("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
        exec: function(c) {
          c.getSelection().selectUp();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "golineup",
        description: "Go line up",
        bindKey: l("Up", "Up|Ctrl-P"),
        exec: function(c, d) {
          c.navigateUp(d.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "selecttoend",
        description: "Select to end",
        bindKey: l("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
        exec: function(c) {
          c.getSelection().selectFileEnd();
        },
        multiSelectAction: "forEach",
        readOnly: !0,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      },
      {
        name: "gotoend",
        description: "Go to end",
        bindKey: l("Ctrl-End", "Command-End|Command-Down"),
        exec: function(c) {
          c.navigateFileEnd();
        },
        multiSelectAction: "forEach",
        readOnly: !0,
        scrollIntoView: "animate",
        aceCommandGroup: "fileJump"
      },
      {
        name: "selectdown",
        description: "Select down",
        bindKey: l("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
        exec: function(c) {
          c.getSelection().selectDown();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "golinedown",
        description: "Go line down",
        bindKey: l("Down", "Down|Ctrl-N"),
        exec: function(c, d) {
          c.navigateDown(d.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "selectwordleft",
        description: "Select word left",
        bindKey: l("Ctrl-Shift-Left", "Option-Shift-Left"),
        exec: function(c) {
          c.getSelection().selectWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "gotowordleft",
        description: "Go to word left",
        bindKey: l("Ctrl-Left", "Option-Left"),
        exec: function(c) {
          c.navigateWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "selecttolinestart",
        description: "Select to line start",
        bindKey: l("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
        exec: function(c) {
          c.getSelection().selectLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "gotolinestart",
        description: "Go to line start",
        bindKey: l("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
        exec: function(c) {
          c.navigateLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "selectleft",
        description: "Select left",
        bindKey: l("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
        exec: function(c) {
          c.getSelection().selectLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "gotoleft",
        description: "Go to left",
        bindKey: l("Left", "Left|Ctrl-B"),
        exec: function(c, d) {
          c.navigateLeft(d.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "selectwordright",
        description: "Select word right",
        bindKey: l("Ctrl-Shift-Right", "Option-Shift-Right"),
        exec: function(c) {
          c.getSelection().selectWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "gotowordright",
        description: "Go to word right",
        bindKey: l("Ctrl-Right", "Option-Right"),
        exec: function(c) {
          c.navigateWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "selecttolineend",
        description: "Select to line end",
        bindKey: l("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
        exec: function(c) {
          c.getSelection().selectLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "gotolineend",
        description: "Go to line end",
        bindKey: l("Alt-Right|End", "Command-Right|End|Ctrl-E"),
        exec: function(c) {
          c.navigateLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "selectright",
        description: "Select right",
        bindKey: l("Shift-Right", "Shift-Right"),
        exec: function(c) {
          c.getSelection().selectRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "gotoright",
        description: "Go to right",
        bindKey: l("Right", "Right|Ctrl-F"),
        exec: function(c, d) {
          c.navigateRight(d.times);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "selectpagedown",
        description: "Select page down",
        bindKey: "Shift-PageDown",
        exec: function(c) {
          c.selectPageDown();
        },
        readOnly: !0
      },
      {
        name: "pagedown",
        description: "Page down",
        bindKey: l(null, "Option-PageDown"),
        exec: function(c) {
          c.scrollPageDown();
        },
        readOnly: !0
      },
      {
        name: "gotopagedown",
        description: "Go to page down",
        bindKey: l("PageDown", "PageDown|Ctrl-V"),
        exec: function(c) {
          c.gotoPageDown();
        },
        readOnly: !0
      },
      {
        name: "selectpageup",
        description: "Select page up",
        bindKey: "Shift-PageUp",
        exec: function(c) {
          c.selectPageUp();
        },
        readOnly: !0
      },
      {
        name: "pageup",
        description: "Page up",
        bindKey: l(null, "Option-PageUp"),
        exec: function(c) {
          c.scrollPageUp();
        },
        readOnly: !0
      },
      {
        name: "gotopageup",
        description: "Go to page up",
        bindKey: "PageUp",
        exec: function(c) {
          c.gotoPageUp();
        },
        readOnly: !0
      },
      {
        name: "scrollup",
        description: "Scroll up",
        bindKey: l("Ctrl-Up", null),
        exec: function(c) {
          c.renderer.scrollBy(0, -2 * c.renderer.layerConfig.lineHeight);
        },
        readOnly: !0
      },
      {
        name: "scrolldown",
        description: "Scroll down",
        bindKey: l("Ctrl-Down", null),
        exec: function(c) {
          c.renderer.scrollBy(0, 2 * c.renderer.layerConfig.lineHeight);
        },
        readOnly: !0
      },
      {
        name: "selectlinestart",
        description: "Select line start",
        bindKey: "Shift-Home",
        exec: function(c) {
          c.getSelection().selectLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "selectlineend",
        description: "Select line end",
        bindKey: "Shift-End",
        exec: function(c) {
          c.getSelection().selectLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "togglerecording",
        description: "Toggle recording",
        bindKey: l("Ctrl-Alt-E", "Command-Option-E"),
        exec: function(c) {
          c.commands.toggleRecording(c);
        },
        readOnly: !0
      },
      {
        name: "replaymacro",
        description: "Replay macro",
        bindKey: l("Ctrl-Shift-E", "Command-Shift-E"),
        exec: function(c) {
          c.commands.replay(c);
        },
        readOnly: !0
      },
      {
        name: "jumptomatching",
        description: "Jump to matching",
        bindKey: l("Ctrl-\\|Ctrl-P", "Command-\\"),
        exec: function(c) {
          c.jumpToMatching();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: !0
      },
      {
        name: "selecttomatching",
        description: "Select to matching",
        bindKey: l("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
        exec: function(c) {
          c.jumpToMatching(!0);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: !0
      },
      {
        name: "expandToMatching",
        description: "Expand to matching",
        bindKey: l("Ctrl-Shift-M", "Ctrl-Shift-M"),
        exec: function(c) {
          c.jumpToMatching(!0, !0);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "animate",
        readOnly: !0
      },
      {
        name: "passKeysToBrowser",
        description: "Pass keys to browser",
        bindKey: l(null, null),
        exec: function() {
        },
        passEvent: !0,
        readOnly: !0
      },
      {
        name: "copy",
        description: "Copy",
        exec: function(c) {
        },
        readOnly: !0
      },
      {
        name: "cut",
        description: "Cut",
        exec: function(c) {
          var d = c.$copyWithEmptySelection && c.selection.isEmpty(), f = d ? c.selection.getLineRange() : c.selection.getRange();
          c._emit("cut", f), f.isEmpty() || c.session.remove(f), c.clearSelection();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      },
      {
        name: "paste",
        description: "Paste",
        exec: function(c, d) {
          c.$handlePaste(d);
        },
        scrollIntoView: "cursor"
      },
      {
        name: "removeline",
        description: "Remove line",
        bindKey: l("Ctrl-D", "Command-D"),
        exec: function(c) {
          c.removeLines();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEachLine"
      },
      {
        name: "duplicateSelection",
        description: "Duplicate selection",
        bindKey: l("Ctrl-Shift-D", "Command-Shift-D"),
        exec: function(c) {
          c.duplicateSelection();
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      },
      {
        name: "sortlines",
        description: "Sort lines",
        bindKey: l("Ctrl-Alt-S", "Command-Alt-S"),
        exec: function(c) {
          c.sortLines();
        },
        scrollIntoView: "selection",
        multiSelectAction: "forEachLine"
      },
      {
        name: "togglecomment",
        description: "Toggle comment",
        bindKey: l("Ctrl-/", "Command-/"),
        exec: function(c) {
          c.toggleCommentLines();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      },
      {
        name: "toggleBlockComment",
        description: "Toggle block comment",
        bindKey: l("Ctrl-Shift-/", "Command-Shift-/"),
        exec: function(c) {
          c.toggleBlockComment();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      },
      {
        name: "modifyNumberUp",
        description: "Modify number up",
        bindKey: l("Ctrl-Shift-Up", "Alt-Shift-Up"),
        exec: function(c) {
          c.modifyNumber(1);
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      },
      {
        name: "modifyNumberDown",
        description: "Modify number down",
        bindKey: l("Ctrl-Shift-Down", "Alt-Shift-Down"),
        exec: function(c) {
          c.modifyNumber(-1);
        },
        scrollIntoView: "cursor",
        multiSelectAction: "forEach"
      },
      {
        name: "replace",
        description: "Replace",
        bindKey: l("Ctrl-H", "Command-Option-F"),
        exec: function(c) {
          s.loadModule("ace/ext/searchbox", function(d) {
            d.Search(c, !0);
          });
        }
      },
      {
        name: "undo",
        description: "Undo",
        bindKey: l("Ctrl-Z", "Command-Z"),
        exec: function(c) {
          c.undo();
        }
      },
      {
        name: "redo",
        description: "Redo",
        bindKey: l("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
        exec: function(c) {
          c.redo();
        }
      },
      {
        name: "copylinesup",
        description: "Copy lines up",
        bindKey: l("Alt-Shift-Up", "Command-Option-Up"),
        exec: function(c) {
          c.copyLinesUp();
        },
        scrollIntoView: "cursor"
      },
      {
        name: "movelinesup",
        description: "Move lines up",
        bindKey: l("Alt-Up", "Option-Up"),
        exec: function(c) {
          c.moveLinesUp();
        },
        scrollIntoView: "cursor"
      },
      {
        name: "copylinesdown",
        description: "Copy lines down",
        bindKey: l("Alt-Shift-Down", "Command-Option-Down"),
        exec: function(c) {
          c.copyLinesDown();
        },
        scrollIntoView: "cursor"
      },
      {
        name: "movelinesdown",
        description: "Move lines down",
        bindKey: l("Alt-Down", "Option-Down"),
        exec: function(c) {
          c.moveLinesDown();
        },
        scrollIntoView: "cursor"
      },
      {
        name: "del",
        description: "Delete",
        bindKey: l("Delete", "Delete|Ctrl-D|Shift-Delete"),
        exec: function(c) {
          c.remove("right");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "backspace",
        description: "Backspace",
        bindKey: l("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
        exec: function(c) {
          c.remove("left");
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "cut_or_delete",
        description: "Cut or delete",
        bindKey: l("Shift-Delete", null),
        exec: function(c) {
          if (c.selection.isEmpty())
            c.remove("left");
          else
            return !1;
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removetolinestart",
        description: "Remove to line start",
        bindKey: l("Alt-Backspace", "Command-Backspace"),
        exec: function(c) {
          c.removeToLineStart();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removetolineend",
        description: "Remove to line end",
        bindKey: l("Alt-Delete", "Ctrl-K|Command-Delete"),
        exec: function(c) {
          c.removeToLineEnd();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removetolinestarthard",
        description: "Remove to line start hard",
        bindKey: l("Ctrl-Shift-Backspace", null),
        exec: function(c) {
          var d = c.selection.getRange();
          d.start.column = 0, c.session.remove(d);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removetolineendhard",
        description: "Remove to line end hard",
        bindKey: l("Ctrl-Shift-Delete", null),
        exec: function(c) {
          var d = c.selection.getRange();
          d.end.column = Number.MAX_VALUE, c.session.remove(d);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removewordleft",
        description: "Remove word left",
        bindKey: l("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
        exec: function(c) {
          c.removeWordLeft();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "removewordright",
        description: "Remove word right",
        bindKey: l("Ctrl-Delete", "Alt-Delete"),
        exec: function(c) {
          c.removeWordRight();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "outdent",
        description: "Outdent",
        bindKey: l("Shift-Tab", "Shift-Tab"),
        exec: function(c) {
          c.blockOutdent();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      },
      {
        name: "indent",
        description: "Indent",
        bindKey: l("Tab", "Tab"),
        exec: function(c) {
          c.indent();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "selectionPart"
      },
      {
        name: "blockoutdent",
        description: "Block outdent",
        bindKey: l("Ctrl-[", "Ctrl-["),
        exec: function(c) {
          c.blockOutdent();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      },
      {
        name: "blockindent",
        description: "Block indent",
        bindKey: l("Ctrl-]", "Ctrl-]"),
        exec: function(c) {
          c.blockIndent();
        },
        multiSelectAction: "forEachLine",
        scrollIntoView: "selectionPart"
      },
      {
        name: "insertstring",
        description: "Insert string",
        exec: function(c, d) {
          c.insert(d);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "inserttext",
        description: "Insert text",
        exec: function(c, d) {
          c.insert(o.stringRepeat(d.text || "", d.times || 1));
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "splitline",
        description: "Split line",
        bindKey: l(null, "Ctrl-O"),
        exec: function(c) {
          c.splitLine();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "transposeletters",
        description: "Transpose letters",
        bindKey: l("Alt-Shift-X", "Ctrl-T"),
        exec: function(c) {
          c.transposeLetters();
        },
        multiSelectAction: function(c) {
          c.transposeSelections(1);
        },
        scrollIntoView: "cursor"
      },
      {
        name: "touppercase",
        description: "To uppercase",
        bindKey: l("Ctrl-U", "Ctrl-U"),
        exec: function(c) {
          c.toUpperCase();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "tolowercase",
        description: "To lowercase",
        bindKey: l("Ctrl-Shift-U", "Ctrl-Shift-U"),
        exec: function(c) {
          c.toLowerCase();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "autoindent",
        description: "Auto Indent",
        bindKey: l(null, null),
        exec: function(c) {
          c.autoIndent();
        },
        scrollIntoView: "animate"
      },
      {
        name: "expandtoline",
        description: "Expand to line",
        bindKey: l("Ctrl-Shift-L", "Command-Shift-L"),
        exec: function(c) {
          var d = c.selection.getRange();
          d.start.column = d.end.column = 0, d.end.row++, c.selection.setRange(d, !1);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor",
        readOnly: !0
      },
      {
        name: "openlink",
        bindKey: l("Ctrl+F3", "F3"),
        exec: function(c) {
          c.openLink();
        }
      },
      {
        name: "joinlines",
        description: "Join lines",
        bindKey: l(null, null),
        exec: function(c) {
          for (var d = c.selection.isBackwards(), f = d ? c.selection.getSelectionLead() : c.selection.getSelectionAnchor(), h = d ? c.selection.getSelectionAnchor() : c.selection.getSelectionLead(), p = c.session.doc.getLine(f.row).length, g = c.session.doc.getTextRange(c.selection.getRange()), m = g.replace(/\n\s*/, " ").length, v = c.session.doc.getLine(f.row), b = f.row + 1; b <= h.row + 1; b++) {
            var x = o.stringTrimLeft(o.stringTrimRight(c.session.doc.getLine(b)));
            x.length !== 0 && (x = " " + x), v += x;
          }
          h.row + 1 < c.session.doc.getLength() - 1 && (v += c.session.doc.getNewLineCharacter()), c.clearSelection(), c.session.doc.replace(new a(f.row, 0, h.row + 2, 0), v), m > 0 ? (c.selection.moveCursorTo(f.row, f.column), c.selection.selectTo(f.row, f.column + m)) : (p = c.session.doc.getLine(f.row).length > p ? p + 1 : p, c.selection.moveCursorTo(f.row, p));
        },
        multiSelectAction: "forEach",
        readOnly: !0
      },
      {
        name: "invertSelection",
        description: "Invert selection",
        bindKey: l(null, null),
        exec: function(c) {
          var d = c.session.doc.getLength() - 1, f = c.session.doc.getLine(d).length, h = c.selection.rangeList.ranges, p = [];
          h.length < 1 && (h = [c.selection.getRange()]);
          for (var g = 0; g < h.length; g++)
            g == h.length - 1 && (h[g].end.row === d && h[g].end.column === f || p.push(new a(h[g].end.row, h[g].end.column, d, f))), g === 0 ? h[g].start.row === 0 && h[g].start.column === 0 || p.push(new a(0, 0, h[g].start.row, h[g].start.column)) : p.push(new a(h[g - 1].end.row, h[g - 1].end.column, h[g].start.row, h[g].start.column));
          c.exitMultiSelectMode(), c.clearSelection();
          for (var g = 0; g < p.length; g++)
            c.selection.addRange(p[g], !1);
        },
        readOnly: !0,
        scrollIntoView: "none"
      },
      {
        name: "addLineAfter",
        description: "Add new line after the current line",
        exec: function(c) {
          c.selection.clearSelection(), c.navigateLineEnd(), c.insert(`
`);
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "addLineBefore",
        description: "Add new line before the current line",
        exec: function(c) {
          c.selection.clearSelection();
          var d = c.getCursorPosition();
          c.selection.moveTo(d.row - 1, Number.MAX_VALUE), c.insert(`
`), d.row === 0 && c.navigateUp();
        },
        multiSelectAction: "forEach",
        scrollIntoView: "cursor"
      },
      {
        name: "openCommandPallete",
        exec: function(c) {
          console.warn("This is an obsolete command. Please use `openCommandPalette` instead."), c.prompt({ $type: "commands" });
        },
        readOnly: !0
      },
      {
        name: "openCommandPalette",
        description: "Open command palette",
        bindKey: l("F1", "F1"),
        exec: function(c) {
          c.prompt({ $type: "commands" });
        },
        readOnly: !0
      },
      {
        name: "modeSelect",
        description: "Change language mode...",
        bindKey: l(null, null),
        exec: function(c) {
          c.prompt({ $type: "modes" });
        },
        readOnly: !0
      }
    ];
    for (var u = 1; u < 9; u++)
      r.commands.push({
        name: "foldToLevel" + u,
        description: "Fold To Level " + u,
        level: u,
        exec: function(c) {
          c.session.foldToLevel(this.level);
        },
        scrollIntoView: "center",
        readOnly: !0
      });
  }), ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/dom"], function(n, r, i) {
    var o = n("./lib/dom"), s = (
      /** @class */
      function() {
        function a(l) {
          this.session = l, this.session.widgetManager = this, this.session.getRowLength = this.getRowLength, this.session.$getWidgetScreenLength = this.$getWidgetScreenLength, this.updateOnChange = this.updateOnChange.bind(this), this.renderWidgets = this.renderWidgets.bind(this), this.measureWidgets = this.measureWidgets.bind(this), this.session._changedWidgets = [], this.$onChangeEditor = this.$onChangeEditor.bind(this), this.session.on("change", this.updateOnChange), this.session.on("changeFold", this.updateOnFold), this.session.on("changeEditor", this.$onChangeEditor);
        }
        return a.prototype.getRowLength = function(l) {
          var u;
          return this.lineWidgets ? u = this.lineWidgets[l] && this.lineWidgets[l].rowCount || 0 : u = 0, !this.$useWrapMode || !this.$wrapData[l] ? 1 + u : this.$wrapData[l].length + 1 + u;
        }, a.prototype.$getWidgetScreenLength = function() {
          var l = 0;
          return this.lineWidgets.forEach(function(u) {
            u && u.rowCount && !u.hidden && (l += u.rowCount);
          }), l;
        }, a.prototype.$onChangeEditor = function(l) {
          this.attach(l.editor);
        }, a.prototype.attach = function(l) {
          l && l.widgetManager && l.widgetManager != this && l.widgetManager.detach(), this.editor != l && (this.detach(), this.editor = l, l && (l.widgetManager = this, l.renderer.on("beforeRender", this.measureWidgets), l.renderer.on("afterRender", this.renderWidgets)));
        }, a.prototype.detach = function(l) {
          var u = this.editor;
          if (u) {
            this.editor = null, u.widgetManager = null, u.renderer.off("beforeRender", this.measureWidgets), u.renderer.off("afterRender", this.renderWidgets);
            var c = this.session.lineWidgets;
            c && c.forEach(function(d) {
              d && d.el && d.el.parentNode && (d._inDocument = !1, d.el.parentNode.removeChild(d.el));
            });
          }
        }, a.prototype.updateOnFold = function(l, u) {
          var c = u.lineWidgets;
          if (!(!c || !l.action)) {
            for (var d = l.data, f = d.start.row, h = d.end.row, p = l.action == "add", g = f + 1; g < h; g++)
              c[g] && (c[g].hidden = p);
            c[h] && (p ? c[f] ? c[h].hidden = p : c[f] = c[h] : (c[f] == c[h] && (c[f] = void 0), c[h].hidden = p));
          }
        }, a.prototype.updateOnChange = function(l) {
          var u = this.session.lineWidgets;
          if (u) {
            var c = l.start.row, d = l.end.row - c;
            if (d !== 0)
              if (l.action == "remove") {
                var f = u.splice(c + 1, d);
                !u[c] && f[f.length - 1] && (u[c] = f.pop()), f.forEach(function(p) {
                  p && this.removeLineWidget(p);
                }, this), this.$updateRows();
              } else {
                var h = new Array(d);
                u[c] && u[c].column != null && l.start.column > u[c].column && c++, h.unshift(c, 0), u.splice.apply(u, h), this.$updateRows();
              }
          }
        }, a.prototype.$updateRows = function() {
          var l = this.session.lineWidgets;
          if (l) {
            var u = !0;
            l.forEach(function(c, d) {
              if (c)
                for (u = !1, c.row = d; c.$oldWidget; )
                  c.$oldWidget.row = d, c = c.$oldWidget;
            }), u && (this.session.lineWidgets = null);
          }
        }, a.prototype.$registerLineWidget = function(l) {
          this.session.lineWidgets || (this.session.lineWidgets = new Array(this.session.getLength()));
          var u = this.session.lineWidgets[l.row];
          return u && (l.$oldWidget = u, u.el && u.el.parentNode && (u.el.parentNode.removeChild(u.el), u._inDocument = !1)), this.session.lineWidgets[l.row] = l, l;
        }, a.prototype.addLineWidget = function(l) {
          if (this.$registerLineWidget(l), l.session = this.session, !this.editor)
            return l;
          var u = this.editor.renderer;
          l.html && !l.el && (l.el = o.createElement("div"), l.el.innerHTML = l.html), l.text && !l.el && (l.el = o.createElement("div"), l.el.textContent = l.text), l.el && (o.addCssClass(l.el, "ace_lineWidgetContainer"), l.className && o.addCssClass(l.el, l.className), l.el.style.position = "absolute", l.el.style.zIndex = "5", u.container.appendChild(l.el), l._inDocument = !0, l.coverGutter || (l.el.style.zIndex = "3"), l.pixelHeight == null && (l.pixelHeight = l.el.offsetHeight)), l.rowCount == null && (l.rowCount = l.pixelHeight / u.layerConfig.lineHeight);
          var c = this.session.getFoldAt(l.row, 0);
          if (l.$fold = c, c) {
            var d = this.session.lineWidgets;
            l.row == c.end.row && !d[c.start.row] ? d[c.start.row] = l : l.hidden = !0;
          }
          return this.session._emit("changeFold", { data: { start: { row: l.row } } }), this.$updateRows(), this.renderWidgets(null, u), this.onWidgetChanged(l), l;
        }, a.prototype.removeLineWidget = function(l) {
          if (l._inDocument = !1, l.session = null, l.el && l.el.parentNode && l.el.parentNode.removeChild(l.el), l.editor && l.editor.destroy)
            try {
              l.editor.destroy();
            } catch {
            }
          if (this.session.lineWidgets) {
            var u = this.session.lineWidgets[l.row];
            if (u == l)
              this.session.lineWidgets[l.row] = l.$oldWidget, l.$oldWidget && this.onWidgetChanged(l.$oldWidget);
            else
              for (; u; ) {
                if (u.$oldWidget == l) {
                  u.$oldWidget = l.$oldWidget;
                  break;
                }
                u = u.$oldWidget;
              }
          }
          this.session._emit("changeFold", { data: { start: { row: l.row } } }), this.$updateRows();
        }, a.prototype.getWidgetsAtRow = function(l) {
          for (var u = this.session.lineWidgets, c = u && u[l], d = []; c; )
            d.push(c), c = c.$oldWidget;
          return d;
        }, a.prototype.onWidgetChanged = function(l) {
          this.session._changedWidgets.push(l), this.editor && this.editor.renderer.updateFull();
        }, a.prototype.measureWidgets = function(l, u) {
          var c = this.session._changedWidgets, d = u.layerConfig;
          if (!(!c || !c.length)) {
            for (var f = 1 / 0, h = 0; h < c.length; h++) {
              var p = c[h];
              if (!(!p || !p.el) && p.session == this.session) {
                if (!p._inDocument) {
                  if (this.session.lineWidgets[p.row] != p)
                    continue;
                  p._inDocument = !0, u.container.appendChild(p.el);
                }
                p.h = p.el.offsetHeight, p.fixedWidth || (p.w = p.el.offsetWidth, p.screenWidth = Math.ceil(p.w / d.characterWidth));
                var g = p.h / d.lineHeight;
                p.coverLine && (g -= this.session.getRowLineCount(p.row), g < 0 && (g = 0)), p.rowCount != g && (p.rowCount = g, p.row < f && (f = p.row));
              }
            }
            f != 1 / 0 && (this.session._emit("changeFold", { data: { start: { row: f } } }), this.session.lineWidgetWidth = null), this.session._changedWidgets = [];
          }
        }, a.prototype.renderWidgets = function(l, u) {
          var c = u.layerConfig, d = this.session.lineWidgets;
          if (d) {
            for (var f = Math.min(this.firstRow, c.firstRow), h = Math.max(this.lastRow, c.lastRow, d.length); f > 0 && !d[f]; )
              f--;
            this.firstRow = c.firstRow, this.lastRow = c.lastRow, u.$cursorLayer.config = c;
            for (var p = f; p <= h; p++) {
              var g = d[p];
              if (!(!g || !g.el)) {
                if (g.hidden) {
                  g.el.style.top = -100 - (g.pixelHeight || 0) + "px";
                  continue;
                }
                g._inDocument || (g._inDocument = !0, u.container.appendChild(g.el));
                var m = u.$cursorLayer.getPixelPosition({ row: p, column: 0 }, !0).top;
                g.coverLine || (m += c.lineHeight * this.session.getRowLineCount(g.row)), g.el.style.top = m - c.offset + "px";
                var v = g.coverGutter ? 0 : u.gutterWidth;
                g.fixedWidth || (v -= u.scrollLeft), g.el.style.left = v + "px", g.fullWidth && g.screenWidth && (g.el.style.minWidth = c.width + 2 * c.padding + "px"), g.fixedWidth ? g.el.style.right = u.scrollBar.getWidth() + "px" : g.el.style.right = "";
              }
            }
          }
        }, a;
      }()
    );
    r.LineWidgets = s;
  }), ace.define("ace/keyboard/gutter_handler", ["require", "exports", "module", "ace/lib/keys", "ace/mouse/default_gutter_handler"], function(n, r, i) {
    var o = n("../lib/keys"), s = n("../mouse/default_gutter_handler").GutterTooltip, a = (
      /** @class */
      function() {
        function u(c) {
          this.editor = c, this.gutterLayer = c.renderer.$gutterLayer, this.element = c.renderer.$gutter, this.lines = c.renderer.$gutterLayer.$lines, this.activeRowIndex = null, this.activeLane = null, this.annotationTooltip = new s(this.editor);
        }
        return u.prototype.addListener = function() {
          this.element.addEventListener("keydown", this.$onGutterKeyDown.bind(this)), this.element.addEventListener("focusout", this.$blurGutter.bind(this)), this.editor.on("mousewheel", this.$blurGutter.bind(this));
        }, u.prototype.removeListener = function() {
          this.element.removeEventListener("keydown", this.$onGutterKeyDown.bind(this)), this.element.removeEventListener("focusout", this.$blurGutter.bind(this)), this.editor.off("mousewheel", this.$blurGutter.bind(this));
        }, u.prototype.$onGutterKeyDown = function(c) {
          if (this.annotationTooltip.isOpen) {
            c.preventDefault(), c.keyCode === o.escape && this.annotationTooltip.hideTooltip();
            return;
          }
          if (c.target === this.element) {
            if (c.keyCode != o.enter)
              return;
            c.preventDefault();
            var d = this.editor.getCursorPosition().row;
            this.editor.isRowVisible(d) || this.editor.scrollToLine(d, !0, !0), setTimeout(
              (function() {
                var f = this.$rowToRowIndex(this.gutterLayer.$cursorCell.row), h = this.$findNearestFoldWidget(f), p = this.$findNearestAnnotation(f);
                if (!(h === null && p === null)) {
                  if (h === null && p !== null) {
                    this.activeRowIndex = p, this.activeLane = "annotation", this.$focusAnnotation(this.activeRowIndex);
                    return;
                  }
                  if (h !== null && p === null) {
                    this.activeRowIndex = h, this.activeLane = "fold", this.$focusFoldWidget(this.activeRowIndex);
                    return;
                  }
                  if (Math.abs(p - f) < Math.abs(h - f)) {
                    this.activeRowIndex = p, this.activeLane = "annotation", this.$focusAnnotation(this.activeRowIndex);
                    return;
                  } else {
                    this.activeRowIndex = h, this.activeLane = "fold", this.$focusFoldWidget(this.activeRowIndex);
                    return;
                  }
                }
              }).bind(this),
              10
            );
            return;
          }
          this.$handleGutterKeyboardInteraction(c), setTimeout((function() {
            this.editor._signal("gutterkeydown", new l(c, this));
          }).bind(this), 10);
        }, u.prototype.$handleGutterKeyboardInteraction = function(c) {
          if (c.keyCode === o.tab) {
            c.preventDefault();
            return;
          }
          if (c.keyCode === o.escape) {
            c.preventDefault(), this.$blurGutter(), this.element.focus(), this.lane = null;
            return;
          }
          if (c.keyCode === o.up) {
            switch (c.preventDefault(), this.activeLane) {
              case "fold":
                this.$moveFoldWidgetUp();
                break;
              case "annotation":
                this.$moveAnnotationUp();
                break;
            }
            return;
          }
          if (c.keyCode === o.down) {
            switch (c.preventDefault(), this.activeLane) {
              case "fold":
                this.$moveFoldWidgetDown();
                break;
              case "annotation":
                this.$moveAnnotationDown();
                break;
            }
            return;
          }
          if (c.keyCode === o.left) {
            c.preventDefault(), this.$switchLane("annotation");
            return;
          }
          if (c.keyCode === o.right) {
            c.preventDefault(), this.$switchLane("fold");
            return;
          }
          if (c.keyCode === o.enter || c.keyCode === o.space) {
            switch (c.preventDefault(), this.activeLane) {
              case "fold":
                if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === "start") {
                  var d = this.$rowIndexToRow(this.activeRowIndex);
                  this.editor.session.onFoldWidgetClick(this.$rowIndexToRow(this.activeRowIndex), c), setTimeout(
                    (function() {
                      this.$rowIndexToRow(this.activeRowIndex) !== d && (this.$blurFoldWidget(this.activeRowIndex), this.activeRowIndex = this.$rowToRowIndex(d), this.$focusFoldWidget(this.activeRowIndex));
                    }).bind(this),
                    10
                  );
                  break;
                } else if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === "end")
                  break;
                return;
              case "annotation":
                var f = this.lines.cells[this.activeRowIndex].element.childNodes[2], h = f.getBoundingClientRect(), p = this.annotationTooltip.getElement().style;
                p.left = h.right + "px", p.top = h.bottom + "px", this.annotationTooltip.showTooltip(this.$rowIndexToRow(this.activeRowIndex));
                break;
            }
            return;
          }
        }, u.prototype.$blurGutter = function() {
          if (this.activeRowIndex !== null)
            switch (this.activeLane) {
              case "fold":
                this.$blurFoldWidget(this.activeRowIndex);
                break;
              case "annotation":
                this.$blurAnnotation(this.activeRowIndex);
                break;
            }
          this.annotationTooltip.isOpen && this.annotationTooltip.hideTooltip();
        }, u.prototype.$isFoldWidgetVisible = function(c) {
          var d = this.editor.isRowFullyVisible(this.$rowIndexToRow(c)), f = this.$getFoldWidget(c).style.display !== "none";
          return d && f;
        }, u.prototype.$isAnnotationVisible = function(c) {
          var d = this.editor.isRowFullyVisible(this.$rowIndexToRow(c)), f = this.$getAnnotation(c).style.display !== "none";
          return d && f;
        }, u.prototype.$getFoldWidget = function(c) {
          var d = this.lines.get(c), f = d.element;
          return f.childNodes[1];
        }, u.prototype.$getAnnotation = function(c) {
          var d = this.lines.get(c), f = d.element;
          return f.childNodes[2];
        }, u.prototype.$findNearestFoldWidget = function(c) {
          if (this.$isFoldWidgetVisible(c))
            return c;
          for (var d = 0; c - d > 0 || c + d < this.lines.getLength() - 1; ) {
            if (d++, c - d >= 0 && this.$isFoldWidgetVisible(c - d))
              return c - d;
            if (c + d <= this.lines.getLength() - 1 && this.$isFoldWidgetVisible(c + d))
              return c + d;
          }
          return null;
        }, u.prototype.$findNearestAnnotation = function(c) {
          if (this.$isAnnotationVisible(c))
            return c;
          for (var d = 0; c - d > 0 || c + d < this.lines.getLength() - 1; ) {
            if (d++, c - d >= 0 && this.$isAnnotationVisible(c - d))
              return c - d;
            if (c + d <= this.lines.getLength() - 1 && this.$isAnnotationVisible(c + d))
              return c + d;
          }
          return null;
        }, u.prototype.$focusFoldWidget = function(c) {
          if (c != null) {
            var d = this.$getFoldWidget(c);
            d.classList.add(this.editor.renderer.keyboardFocusClassName), d.focus();
          }
        }, u.prototype.$focusAnnotation = function(c) {
          if (c != null) {
            var d = this.$getAnnotation(c);
            d.classList.add(this.editor.renderer.keyboardFocusClassName), d.focus();
          }
        }, u.prototype.$blurFoldWidget = function(c) {
          var d = this.$getFoldWidget(c);
          d.classList.remove(this.editor.renderer.keyboardFocusClassName), d.blur();
        }, u.prototype.$blurAnnotation = function(c) {
          var d = this.$getAnnotation(c);
          d.classList.remove(this.editor.renderer.keyboardFocusClassName), d.blur();
        }, u.prototype.$moveFoldWidgetUp = function() {
          for (var c = this.activeRowIndex; c > 0; )
            if (c--, this.$isFoldWidgetVisible(c)) {
              this.$blurFoldWidget(this.activeRowIndex), this.activeRowIndex = c, this.$focusFoldWidget(this.activeRowIndex);
              return;
            }
        }, u.prototype.$moveFoldWidgetDown = function() {
          for (var c = this.activeRowIndex; c < this.lines.getLength() - 1; )
            if (c++, this.$isFoldWidgetVisible(c)) {
              this.$blurFoldWidget(this.activeRowIndex), this.activeRowIndex = c, this.$focusFoldWidget(this.activeRowIndex);
              return;
            }
        }, u.prototype.$moveAnnotationUp = function() {
          for (var c = this.activeRowIndex; c > 0; )
            if (c--, this.$isAnnotationVisible(c)) {
              this.$blurAnnotation(this.activeRowIndex), this.activeRowIndex = c, this.$focusAnnotation(this.activeRowIndex);
              return;
            }
        }, u.prototype.$moveAnnotationDown = function() {
          for (var c = this.activeRowIndex; c < this.lines.getLength() - 1; )
            if (c++, this.$isAnnotationVisible(c)) {
              this.$blurAnnotation(this.activeRowIndex), this.activeRowIndex = c, this.$focusAnnotation(this.activeRowIndex);
              return;
            }
        }, u.prototype.$switchLane = function(c) {
          switch (c) {
            case "annotation":
              if (this.activeLane === "annotation")
                break;
              var d = this.$findNearestAnnotation(this.activeRowIndex);
              if (d == null)
                break;
              this.activeLane = "annotation", this.$blurFoldWidget(this.activeRowIndex), this.activeRowIndex = d, this.$focusAnnotation(this.activeRowIndex);
              break;
            case "fold":
              if (this.activeLane === "fold")
                break;
              var f = this.$findNearestFoldWidget(this.activeRowIndex);
              if (f == null)
                break;
              this.activeLane = "fold", this.$blurAnnotation(this.activeRowIndex), this.activeRowIndex = f, this.$focusFoldWidget(this.activeRowIndex);
              break;
          }
        }, u.prototype.$rowIndexToRow = function(c) {
          var d = this.lines.get(c);
          return d ? d.row : null;
        }, u.prototype.$rowToRowIndex = function(c) {
          for (var d = 0; d < this.lines.getLength(); d++) {
            var f = this.lines.get(d);
            if (f.row == c)
              return d;
          }
          return null;
        }, u;
      }()
    );
    r.GutterKeyboardHandler = a;
    var l = (
      /** @class */
      function() {
        function u(c, d) {
          this.gutterKeyboardHandler = d, this.domEvent = c;
        }
        return u.prototype.getKey = function() {
          return o.keyCodeToString(this.domEvent.keyCode);
        }, u.prototype.getRow = function() {
          return this.gutterKeyboardHandler.$rowIndexToRow(this.gutterKeyboardHandler.activeRowIndex);
        }, u.prototype.isInAnnotationLane = function() {
          return this.gutterKeyboardHandler.activeLane === "annotation";
        }, u.prototype.isInFoldLane = function() {
          return this.gutterKeyboardHandler.activeLane === "fold";
        }, u;
      }()
    );
    r.GutterKeyboardEvent = l;
  }), ace.define("ace/editor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator", "ace/line_widgets", "ace/keyboard/gutter_handler", "ace/config", "ace/clipboard", "ace/lib/keys"], function(n, r, i) {
    var o = this && this.__values || function(D) {
      var E = typeof Symbol == "function" && Symbol.iterator, R = E && D[E], I = 0;
      if (R)
        return R.call(D);
      if (D && typeof D.length == "number")
        return {
          next: function() {
            return D && I >= D.length && (D = void 0), { value: D && D[I++], done: !D };
          }
        };
      throw new TypeError(E ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }, s = n("./lib/oop"), a = n("./lib/dom"), l = n("./lib/lang"), u = n("./lib/useragent"), c = n("./keyboard/textinput").TextInput, d = n("./mouse/mouse_handler").MouseHandler, f = n("./mouse/fold_handler").FoldHandler, h = n("./keyboard/keybinding").KeyBinding, p = n("./edit_session").EditSession, g = n("./search").Search, m = n("./range").Range, v = n("./lib/event_emitter").EventEmitter, b = n("./commands/command_manager").CommandManager, x = n("./commands/default_commands").commands, w = n("./config"), C = n("./token_iterator").TokenIterator, y = n("./line_widgets").LineWidgets, S = n("./keyboard/gutter_handler").GutterKeyboardHandler, A = n("./config").nls, $ = n("./clipboard"), M = n("./lib/keys"), _ = (
      /** @class */
      function() {
        function D(E, R, I) {
          this.session, this.$toDestroy = [];
          var k = E.getContainerElement();
          this.container = k, this.renderer = E, this.id = "editor" + ++D.$uid, this.commands = new b(u.isMac ? "mac" : "win", x), typeof document == "object" && (this.textInput = new c(E.getTextAreaContainer(), this), this.renderer.textarea = this.textInput.getElement(), this.$mouseHandler = new d(this), new f(this)), this.keyBinding = new h(this), this.$search = new g().set({
            wrap: !0
          }), this.$historyTracker = this.$historyTracker.bind(this), this.commands.on("exec", this.$historyTracker), this.$initOperationListeners(), this._$emitInputEvent = l.delayedCall((function() {
            this._signal("input", {}), this.session && !this.session.destroyed && this.session.bgTokenizer.scheduleStart();
          }).bind(this)), this.on("change", function(P, L) {
            L._$emitInputEvent.schedule(31);
          }), this.setSession(R || I && I.session || new p("")), w.resetOptions(this), I && this.setOptions(I), w._signal("editor", this);
        }
        return D.prototype.$initOperationListeners = function() {
          this.commands.on("exec", this.startOperation.bind(this), !0), this.commands.on("afterExec", this.endOperation.bind(this), !0), this.$opResetTimer = l.delayedCall(this.endOperation.bind(this, !0)), this.on("change", (function() {
            this.curOp || (this.startOperation(), this.curOp.selectionBefore = this.$lastSel), this.curOp.docChanged = !0;
          }).bind(this), !0), this.on("changeSelection", (function() {
            this.curOp || (this.startOperation(), this.curOp.selectionBefore = this.$lastSel), this.curOp.selectionChanged = !0;
          }).bind(this), !0);
        }, D.prototype.startOperation = function(E) {
          if (this.curOp) {
            if (!E || this.curOp.command)
              return;
            this.prevOp = this.curOp;
          }
          E || (this.previousCommand = null, E = {}), this.$opResetTimer.schedule(), this.curOp = this.session.curOp = {
            command: E.command || {},
            args: E.args,
            scrollTop: this.renderer.scrollTop
          }, this.curOp.selectionBefore = this.selection.toJSON();
        }, D.prototype.endOperation = function(E) {
          if (this.curOp && this.session) {
            if (E && E.returnValue === !1 || !this.session)
              return this.curOp = null;
            if (E == !0 && this.curOp.command && this.curOp.command.name == "mouse" || (this._signal("beforeEndOperation"), !this.curOp))
              return;
            var R = this.curOp.command, I = R && R.scrollIntoView;
            if (I) {
              switch (I) {
                case "center-animate":
                  I = "animate";
                case "center":
                  this.renderer.scrollCursorIntoView(null, 0.5);
                  break;
                case "animate":
                case "cursor":
                  this.renderer.scrollCursorIntoView();
                  break;
                case "selectionPart":
                  var k = this.selection.getRange(), P = this.renderer.layerConfig;
                  (k.start.row >= P.lastRow || k.end.row <= P.firstRow) && this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                  break;
              }
              I == "animate" && this.renderer.animateScrolling(this.curOp.scrollTop);
            }
            var L = this.selection.toJSON();
            this.curOp.selectionAfter = L, this.$lastSel = this.selection.toJSON(), this.session.getUndoManager().addSelection(L), this.prevOp = this.curOp, this.curOp = null;
          }
        }, D.prototype.$historyTracker = function(E) {
          if (this.$mergeUndoDeltas) {
            var R = this.prevOp, I = this.$mergeableCommands, k = R.command && E.command.name == R.command.name;
            if (E.command.name == "insertstring") {
              var P = E.args;
              this.mergeNextCommand === void 0 && (this.mergeNextCommand = !0), k = k && this.mergeNextCommand && (!/\s/.test(P) || /\s/.test(R.args)), this.mergeNextCommand = !0;
            } else
              k = k && I.indexOf(E.command.name) !== -1;
            this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2e3 && (k = !1), k ? this.session.mergeUndoDeltas = !0 : I.indexOf(E.command.name) !== -1 && (this.sequenceStartTime = Date.now());
          }
        }, D.prototype.setKeyboardHandler = function(E, R) {
          if (E && typeof E == "string" && E != "ace") {
            this.$keybindingId = E;
            var I = this;
            w.loadModule(["keybinding", E], function(k) {
              I.$keybindingId == E && I.keyBinding.setKeyboardHandler(k && k.handler), R && R();
            });
          } else
            this.$keybindingId = null, this.keyBinding.setKeyboardHandler(E), R && R();
        }, D.prototype.getKeyboardHandler = function() {
          return this.keyBinding.getKeyboardHandler();
        }, D.prototype.setSession = function(E) {
          if (this.session != E) {
            this.curOp && this.endOperation(), this.curOp = {};
            var R = this.session;
            if (R) {
              this.session.off("change", this.$onDocumentChange), this.session.off("changeMode", this.$onChangeMode), this.session.off("tokenizerUpdate", this.$onTokenizerUpdate), this.session.off("changeTabSize", this.$onChangeTabSize), this.session.off("changeWrapLimit", this.$onChangeWrapLimit), this.session.off("changeWrapMode", this.$onChangeWrapMode), this.session.off("changeFold", this.$onChangeFold), this.session.off("changeFrontMarker", this.$onChangeFrontMarker), this.session.off("changeBackMarker", this.$onChangeBackMarker), this.session.off("changeBreakpoint", this.$onChangeBreakpoint), this.session.off("changeAnnotation", this.$onChangeAnnotation), this.session.off("changeOverwrite", this.$onCursorChange), this.session.off("changeScrollTop", this.$onScrollTopChange), this.session.off("changeScrollLeft", this.$onScrollLeftChange);
              var I = this.session.getSelection();
              I.off("changeCursor", this.$onCursorChange), I.off("changeSelection", this.$onSelectionChange);
            }
            this.session = E, E ? (this.$onDocumentChange = this.onDocumentChange.bind(this), E.on("change", this.$onDocumentChange), this.renderer.setSession(E), this.$onChangeMode = this.onChangeMode.bind(this), E.on("changeMode", this.$onChangeMode), this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this), E.on("tokenizerUpdate", this.$onTokenizerUpdate), this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer), E.on("changeTabSize", this.$onChangeTabSize), this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this), E.on("changeWrapLimit", this.$onChangeWrapLimit), this.$onChangeWrapMode = this.onChangeWrapMode.bind(this), E.on("changeWrapMode", this.$onChangeWrapMode), this.$onChangeFold = this.onChangeFold.bind(this), E.on("changeFold", this.$onChangeFold), this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this), this.session.on("changeFrontMarker", this.$onChangeFrontMarker), this.$onChangeBackMarker = this.onChangeBackMarker.bind(this), this.session.on("changeBackMarker", this.$onChangeBackMarker), this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this), this.session.on("changeBreakpoint", this.$onChangeBreakpoint), this.$onChangeAnnotation = this.onChangeAnnotation.bind(this), this.session.on("changeAnnotation", this.$onChangeAnnotation), this.$onCursorChange = this.onCursorChange.bind(this), this.session.on("changeOverwrite", this.$onCursorChange), this.$onScrollTopChange = this.onScrollTopChange.bind(this), this.session.on("changeScrollTop", this.$onScrollTopChange), this.$onScrollLeftChange = this.onScrollLeftChange.bind(this), this.session.on("changeScrollLeft", this.$onScrollLeftChange), this.selection = E.getSelection(), this.selection.on("changeCursor", this.$onCursorChange), this.$onSelectionChange = this.onSelectionChange.bind(this), this.selection.on("changeSelection", this.$onSelectionChange), this.onChangeMode(), this.onCursorChange(), this.onScrollTopChange(), this.onScrollLeftChange(), this.onSelectionChange(), this.onChangeFrontMarker(), this.onChangeBackMarker(), this.onChangeBreakpoint(), this.onChangeAnnotation(), this.session.getUseWrapMode() && this.renderer.adjustWrapLimit(), this.renderer.updateFull()) : (this.selection = null, this.renderer.setSession(E)), this._signal("changeSession", {
              session: E,
              oldSession: R
            }), this.curOp = null, R && R._signal("changeEditor", { oldEditor: this }), E && E._signal("changeEditor", { editor: this }), E && !E.destroyed && E.bgTokenizer.scheduleStart();
          }
        }, D.prototype.getSession = function() {
          return this.session;
        }, D.prototype.setValue = function(E, R) {
          return this.session.doc.setValue(E), R ? R == 1 ? this.navigateFileEnd() : R == -1 && this.navigateFileStart() : this.selectAll(), E;
        }, D.prototype.getValue = function() {
          return this.session.getValue();
        }, D.prototype.getSelection = function() {
          return this.selection;
        }, D.prototype.resize = function(E) {
          this.renderer.onResize(E);
        }, D.prototype.setTheme = function(E, R) {
          this.renderer.setTheme(E, R);
        }, D.prototype.getTheme = function() {
          return this.renderer.getTheme();
        }, D.prototype.setStyle = function(E) {
          this.renderer.setStyle(E);
        }, D.prototype.unsetStyle = function(E) {
          this.renderer.unsetStyle(E);
        }, D.prototype.getFontSize = function() {
          return this.getOption("fontSize") || a.computedStyle(this.container).fontSize;
        }, D.prototype.setFontSize = function(E) {
          this.setOption("fontSize", E);
        }, D.prototype.$highlightBrackets = function() {
          if (!this.$highlightPending) {
            var E = this;
            this.$highlightPending = !0, setTimeout(function() {
              E.$highlightPending = !1;
              var R = E.session;
              if (!(!R || R.destroyed)) {
                R.$bracketHighlight && (R.$bracketHighlight.markerIds.forEach(function(z) {
                  R.removeMarker(z);
                }), R.$bracketHighlight = null);
                var I = E.getCursorPosition(), k = E.getKeyboardHandler(), P = k && k.$getDirectionForHighlight && k.$getDirectionForHighlight(E), L = R.getMatchingBracketRanges(I, P);
                if (!L) {
                  var N = new C(R, I.row, I.column), F = N.getCurrentToken();
                  if (F && /\b(?:tag-open|tag-name)/.test(F.type)) {
                    var B = R.getMatchingTags(I);
                    B && (L = [
                      B.openTagName.isEmpty() ? B.openTag : B.openTagName,
                      B.closeTagName.isEmpty() ? B.closeTag : B.closeTagName
                    ]);
                  }
                }
                if (!L && R.$mode.getMatching && (L = R.$mode.getMatching(E.session)), !L) {
                  E.getHighlightIndentGuides() && E.renderer.$textLayer.$highlightIndentGuide();
                  return;
                }
                var j = "ace_bracket";
                Array.isArray(L) ? L.length == 1 && (j = "ace_error_bracket") : L = [L], L.length == 2 && (m.comparePoints(L[0].end, L[1].start) == 0 ? L = [m.fromPoints(L[0].start, L[1].end)] : m.comparePoints(L[0].start, L[1].end) == 0 && (L = [m.fromPoints(L[1].start, L[0].end)])), R.$bracketHighlight = {
                  ranges: L,
                  markerIds: L.map(function(z) {
                    return R.addMarker(z, j, "text");
                  })
                }, E.getHighlightIndentGuides() && E.renderer.$textLayer.$highlightIndentGuide();
              }
            }, 50);
          }
        }, D.prototype.focus = function() {
          this.textInput.focus();
        }, D.prototype.isFocused = function() {
          return this.textInput.isFocused();
        }, D.prototype.blur = function() {
          this.textInput.blur();
        }, D.prototype.onFocus = function(E) {
          this.$isFocused || (this.$isFocused = !0, this.renderer.showCursor(), this.renderer.visualizeFocus(), this._emit("focus", E));
        }, D.prototype.onBlur = function(E) {
          this.$isFocused && (this.$isFocused = !1, this.renderer.hideCursor(), this.renderer.visualizeBlur(), this._emit("blur", E));
        }, D.prototype.$cursorChange = function() {
          this.renderer.updateCursor(), this.$highlightBrackets(), this.$updateHighlightActiveLine();
        }, D.prototype.onDocumentChange = function(E) {
          var R = this.session.$useWrapMode, I = E.start.row == E.end.row ? E.end.row : 1 / 0;
          this.renderer.updateLines(E.start.row, I, R), this._signal("change", E), this.$cursorChange();
        }, D.prototype.onTokenizerUpdate = function(E) {
          var R = E.data;
          this.renderer.updateLines(R.first, R.last);
        }, D.prototype.onScrollTopChange = function() {
          this.renderer.scrollToY(this.session.getScrollTop());
        }, D.prototype.onScrollLeftChange = function() {
          this.renderer.scrollToX(this.session.getScrollLeft());
        }, D.prototype.onCursorChange = function() {
          this.$cursorChange(), this._signal("changeSelection");
        }, D.prototype.$updateHighlightActiveLine = function() {
          var E = this.getSession(), R;
          if (this.$highlightActiveLine && ((this.$selectionStyle != "line" || !this.selection.isMultiLine()) && (R = this.getCursorPosition()), this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty() && (R = !1), this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1) && (R = !1)), E.$highlightLineMarker && !R)
            E.removeMarker(E.$highlightLineMarker.id), E.$highlightLineMarker = null;
          else if (!E.$highlightLineMarker && R) {
            var I = new m(R.row, R.column, R.row, 1 / 0);
            I.id = E.addMarker(I, "ace_active-line", "screenLine"), E.$highlightLineMarker = I;
          } else
            R && (E.$highlightLineMarker.start.row = R.row, E.$highlightLineMarker.end.row = R.row, E.$highlightLineMarker.start.column = R.column, E._signal("changeBackMarker"));
        }, D.prototype.onSelectionChange = function(E) {
          var R = this.session;
          if (R.$selectionMarker && R.removeMarker(R.$selectionMarker), R.$selectionMarker = null, this.selection.isEmpty())
            this.$updateHighlightActiveLine();
          else {
            var I = this.selection.getRange(), k = this.getSelectionStyle();
            R.$selectionMarker = R.addMarker(I, "ace_selection", k);
          }
          var P = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
          this.session.highlight(P), this._signal("changeSelection");
        }, D.prototype.$getSelectionHighLightRegexp = function() {
          var E = this.session, R = this.getSelectionRange();
          if (!(R.isEmpty() || R.isMultiLine())) {
            var I = R.start.column, k = R.end.column, P = E.getLine(R.start.row), L = P.substring(I, k);
            if (!(L.length > 5e3 || !/[\w\d]/.test(L))) {
              var N = this.$search.$assembleRegExp({
                wholeWord: !0,
                caseSensitive: !0,
                needle: L
              }), F = P.substring(I - 1, k + 1);
              if (N.test(F))
                return N;
            }
          }
        }, D.prototype.onChangeFrontMarker = function() {
          this.renderer.updateFrontMarkers();
        }, D.prototype.onChangeBackMarker = function() {
          this.renderer.updateBackMarkers();
        }, D.prototype.onChangeBreakpoint = function() {
          this.renderer.updateBreakpoints();
        }, D.prototype.onChangeAnnotation = function() {
          this.renderer.setAnnotations(this.session.getAnnotations());
        }, D.prototype.onChangeMode = function(E) {
          this.renderer.updateText(), this._emit("changeMode", E);
        }, D.prototype.onChangeWrapLimit = function() {
          this.renderer.updateFull();
        }, D.prototype.onChangeWrapMode = function() {
          this.renderer.onResize(!0);
        }, D.prototype.onChangeFold = function() {
          this.$updateHighlightActiveLine(), this.renderer.updateFull();
        }, D.prototype.getSelectedText = function() {
          return this.session.getTextRange(this.getSelectionRange());
        }, D.prototype.getCopyText = function() {
          var E = this.getSelectedText(), R = this.session.doc.getNewLineCharacter(), I = !1;
          if (!E && this.$copyWithEmptySelection) {
            I = !0;
            for (var k = this.selection.getAllRanges(), P = 0; P < k.length; P++) {
              var L = k[P];
              P && k[P - 1].start.row == L.start.row || (E += this.session.getLine(L.start.row) + R);
            }
          }
          var N = { text: E };
          return this._signal("copy", N), $.lineMode = I ? N.text : !1, N.text;
        }, D.prototype.onCopy = function() {
          this.commands.exec("copy", this);
        }, D.prototype.onCut = function() {
          this.commands.exec("cut", this);
        }, D.prototype.onPaste = function(E, R) {
          var I = { text: E, event: R };
          this.commands.exec("paste", this, I);
        }, D.prototype.$handlePaste = function(E) {
          typeof E == "string" && (E = { text: E }), this._signal("paste", E);
          var R = E.text, I = R === $.lineMode, k = this.session;
          if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            I ? k.insert({ row: this.selection.lead.row, column: 0 }, R) : this.insert(R);
          else if (I)
            this.selection.rangeList.ranges.forEach(function(j) {
              k.insert({ row: j.start.row, column: 0 }, R);
            });
          else {
            var P = R.split(/\r\n|\r|\n/), L = this.selection.rangeList.ranges, N = P.length == 2 && (!P[0] || !P[1]);
            if (P.length != L.length || N)
              return this.commands.exec("insertstring", this, R);
            for (var F = L.length; F--; ) {
              var B = L[F];
              B.isEmpty() || k.remove(B), k.insert(B.start, P[F]);
            }
          }
        }, D.prototype.execCommand = function(E, R) {
          return this.commands.exec(E, this, R);
        }, D.prototype.insert = function(E, R) {
          var I = this.session, k = I.getMode(), P = this.getCursorPosition();
          if (this.getBehavioursEnabled() && !R) {
            var L = k.transformAction(I.getState(P.row), "insertion", this, I, E);
            L && (E !== L.text && (this.inVirtualSelectionMode || (this.session.mergeUndoDeltas = !1, this.mergeNextCommand = !1)), E = L.text);
          }
          if (E == "	" && (E = this.session.getTabString()), this.selection.isEmpty()) {
            if (this.session.getOverwrite() && E.indexOf(`
`) == -1) {
              var N = m.fromPoints(P, P);
              N.end.column += E.length, this.session.remove(N);
            }
          } else {
            var N = this.getSelectionRange();
            P = this.session.remove(N), this.clearSelection();
          }
          if (E == `
` || E == `\r
`) {
            var z = I.getLine(P.row);
            if (P.column > z.search(/\S|$/)) {
              var F = z.substr(P.column).search(/\S|$/);
              I.doc.removeInLine(P.row, P.column, P.column + F);
            }
          }
          this.clearSelection();
          var B = P.column, j = I.getState(P.row), z = I.getLine(P.row), H = k.checkOutdent(j, z, E);
          if (I.insert(P, E), L && L.selection && (L.selection.length == 2 ? this.selection.setSelectionRange(new m(P.row, B + L.selection[0], P.row, B + L.selection[1])) : this.selection.setSelectionRange(new m(P.row + L.selection[0], L.selection[1], P.row + L.selection[2], L.selection[3]))), this.$enableAutoIndent) {
            if (I.getDocument().isNewLine(E)) {
              var W = k.getNextLineIndent(j, z.slice(0, P.column), I.getTabString());
              I.insert({ row: P.row + 1, column: 0 }, W);
            }
            H && k.autoOutdent(j, I, P.row);
          }
        }, D.prototype.autoIndent = function() {
          for (var E = this.session, R = E.getMode(), I = this.selection.isEmpty() ? [new m(0, 0, E.doc.getLength() - 1, 0)] : this.selection.getAllRanges(), k = "", P = "", L = "", N = E.getTabString(), F = 0; F < I.length; F++)
            for (var B = I[F].start.row, j = I[F].end.row, z = B; z <= j; z++) {
              z > 0 && (k = E.getState(z - 1), P = E.getLine(z - 1), L = R.getNextLineIndent(k, P, N));
              var H = E.getLine(z), W = R.$getIndent(H);
              if (L !== W) {
                if (W.length > 0) {
                  var G = new m(z, 0, z, W.length);
                  E.remove(G);
                }
                L.length > 0 && E.insert({ row: z, column: 0 }, L);
              }
              R.autoOutdent(k, E, z);
            }
        }, D.prototype.onTextInput = function(E, R) {
          if (!R)
            return this.keyBinding.onTextInput(E);
          this.startOperation({ command: { name: "insertstring" } });
          var I = this.applyComposition.bind(this, E, R);
          this.selection.rangeCount ? this.forEachSelection(I) : I(), this.endOperation();
        }, D.prototype.applyComposition = function(E, R) {
          if (R.extendLeft || R.extendRight) {
            var I = this.selection.getRange();
            I.start.column -= R.extendLeft, I.end.column += R.extendRight, I.start.column < 0 && (I.start.row--, I.start.column += this.session.getLine(I.start.row).length + 1), this.selection.setRange(I), !E && !I.isEmpty() && this.remove();
          }
          if ((E || !this.selection.isEmpty()) && this.insert(E, !0), R.restoreStart || R.restoreEnd) {
            var I = this.selection.getRange();
            I.start.column -= R.restoreStart, I.end.column -= R.restoreEnd, this.selection.setRange(I);
          }
        }, D.prototype.onCommandKey = function(E, R, I) {
          return this.keyBinding.onCommandKey(E, R, I);
        }, D.prototype.setOverwrite = function(E) {
          this.session.setOverwrite(E);
        }, D.prototype.getOverwrite = function() {
          return this.session.getOverwrite();
        }, D.prototype.toggleOverwrite = function() {
          this.session.toggleOverwrite();
        }, D.prototype.setScrollSpeed = function(E) {
          this.setOption("scrollSpeed", E);
        }, D.prototype.getScrollSpeed = function() {
          return this.getOption("scrollSpeed");
        }, D.prototype.setDragDelay = function(E) {
          this.setOption("dragDelay", E);
        }, D.prototype.getDragDelay = function() {
          return this.getOption("dragDelay");
        }, D.prototype.setSelectionStyle = function(E) {
          this.setOption("selectionStyle", E);
        }, D.prototype.getSelectionStyle = function() {
          return this.getOption("selectionStyle");
        }, D.prototype.setHighlightActiveLine = function(E) {
          this.setOption("highlightActiveLine", E);
        }, D.prototype.getHighlightActiveLine = function() {
          return this.getOption("highlightActiveLine");
        }, D.prototype.setHighlightGutterLine = function(E) {
          this.setOption("highlightGutterLine", E);
        }, D.prototype.getHighlightGutterLine = function() {
          return this.getOption("highlightGutterLine");
        }, D.prototype.setHighlightSelectedWord = function(E) {
          this.setOption("highlightSelectedWord", E);
        }, D.prototype.getHighlightSelectedWord = function() {
          return this.$highlightSelectedWord;
        }, D.prototype.setAnimatedScroll = function(E) {
          this.renderer.setAnimatedScroll(E);
        }, D.prototype.getAnimatedScroll = function() {
          return this.renderer.getAnimatedScroll();
        }, D.prototype.setShowInvisibles = function(E) {
          this.renderer.setShowInvisibles(E);
        }, D.prototype.getShowInvisibles = function() {
          return this.renderer.getShowInvisibles();
        }, D.prototype.setDisplayIndentGuides = function(E) {
          this.renderer.setDisplayIndentGuides(E);
        }, D.prototype.getDisplayIndentGuides = function() {
          return this.renderer.getDisplayIndentGuides();
        }, D.prototype.setHighlightIndentGuides = function(E) {
          this.renderer.setHighlightIndentGuides(E);
        }, D.prototype.getHighlightIndentGuides = function() {
          return this.renderer.getHighlightIndentGuides();
        }, D.prototype.setShowPrintMargin = function(E) {
          this.renderer.setShowPrintMargin(E);
        }, D.prototype.getShowPrintMargin = function() {
          return this.renderer.getShowPrintMargin();
        }, D.prototype.setPrintMarginColumn = function(E) {
          this.renderer.setPrintMarginColumn(E);
        }, D.prototype.getPrintMarginColumn = function() {
          return this.renderer.getPrintMarginColumn();
        }, D.prototype.setReadOnly = function(E) {
          this.setOption("readOnly", E);
        }, D.prototype.getReadOnly = function() {
          return this.getOption("readOnly");
        }, D.prototype.setBehavioursEnabled = function(E) {
          this.setOption("behavioursEnabled", E);
        }, D.prototype.getBehavioursEnabled = function() {
          return this.getOption("behavioursEnabled");
        }, D.prototype.setWrapBehavioursEnabled = function(E) {
          this.setOption("wrapBehavioursEnabled", E);
        }, D.prototype.getWrapBehavioursEnabled = function() {
          return this.getOption("wrapBehavioursEnabled");
        }, D.prototype.setShowFoldWidgets = function(E) {
          this.setOption("showFoldWidgets", E);
        }, D.prototype.getShowFoldWidgets = function() {
          return this.getOption("showFoldWidgets");
        }, D.prototype.setFadeFoldWidgets = function(E) {
          this.setOption("fadeFoldWidgets", E);
        }, D.prototype.getFadeFoldWidgets = function() {
          return this.getOption("fadeFoldWidgets");
        }, D.prototype.remove = function(E) {
          this.selection.isEmpty() && (E == "left" ? this.selection.selectLeft() : this.selection.selectRight());
          var R = this.getSelectionRange();
          if (this.getBehavioursEnabled()) {
            var I = this.session, k = I.getState(R.start.row), P = I.getMode().transformAction(k, "deletion", this, I, R);
            if (R.end.column === 0) {
              var L = I.getTextRange(R);
              if (L[L.length - 1] == `
`) {
                var N = I.getLine(R.end.row);
                /^\s+$/.test(N) && (R.end.column = N.length);
              }
            }
            P && (R = P);
          }
          this.session.remove(R), this.clearSelection();
        }, D.prototype.removeWordRight = function() {
          this.selection.isEmpty() && this.selection.selectWordRight(), this.session.remove(this.getSelectionRange()), this.clearSelection();
        }, D.prototype.removeWordLeft = function() {
          this.selection.isEmpty() && this.selection.selectWordLeft(), this.session.remove(this.getSelectionRange()), this.clearSelection();
        }, D.prototype.removeToLineStart = function() {
          this.selection.isEmpty() && this.selection.selectLineStart(), this.selection.isEmpty() && this.selection.selectLeft(), this.session.remove(this.getSelectionRange()), this.clearSelection();
        }, D.prototype.removeToLineEnd = function() {
          this.selection.isEmpty() && this.selection.selectLineEnd();
          var E = this.getSelectionRange();
          E.start.column == E.end.column && E.start.row == E.end.row && (E.end.column = 0, E.end.row++), this.session.remove(E), this.clearSelection();
        }, D.prototype.splitLine = function() {
          this.selection.isEmpty() || (this.session.remove(this.getSelectionRange()), this.clearSelection());
          var E = this.getCursorPosition();
          this.insert(`
`), this.moveCursorToPosition(E);
        }, D.prototype.setGhostText = function(E, R) {
          this.session.widgetManager || (this.session.widgetManager = new y(this.session), this.session.widgetManager.attach(this)), this.renderer.setGhostText(E, R);
        }, D.prototype.removeGhostText = function() {
          this.session.widgetManager && this.renderer.removeGhostText();
        }, D.prototype.transposeLetters = function() {
          if (this.selection.isEmpty()) {
            var E = this.getCursorPosition(), R = E.column;
            if (R !== 0) {
              var I = this.session.getLine(E.row), k, P;
              R < I.length ? (k = I.charAt(R) + I.charAt(R - 1), P = new m(E.row, R - 1, E.row, R + 1)) : (k = I.charAt(R - 1) + I.charAt(R - 2), P = new m(E.row, R - 2, E.row, R)), this.session.replace(P, k), this.session.selection.moveToPosition(P.end);
            }
          }
        }, D.prototype.toLowerCase = function() {
          var E = this.getSelectionRange();
          this.selection.isEmpty() && this.selection.selectWord();
          var R = this.getSelectionRange(), I = this.session.getTextRange(R);
          this.session.replace(R, I.toLowerCase()), this.selection.setSelectionRange(E);
        }, D.prototype.toUpperCase = function() {
          var E = this.getSelectionRange();
          this.selection.isEmpty() && this.selection.selectWord();
          var R = this.getSelectionRange(), I = this.session.getTextRange(R);
          this.session.replace(R, I.toUpperCase()), this.selection.setSelectionRange(E);
        }, D.prototype.indent = function() {
          var E = this.session, R = this.getSelectionRange();
          if (R.start.row < R.end.row) {
            var I = this.$getSelectedRows();
            E.indentRows(I.first, I.last, "	");
            return;
          } else if (R.start.column < R.end.column) {
            var k = E.getTextRange(R);
            if (!/^\s+$/.test(k)) {
              var I = this.$getSelectedRows();
              E.indentRows(I.first, I.last, "	");
              return;
            }
          }
          var P = E.getLine(R.start.row), L = R.start, N = E.getTabSize(), F = E.documentToScreenColumn(L.row, L.column);
          if (this.session.getUseSoftTabs())
            var B = N - F % N, j = l.stringRepeat(" ", B);
          else {
            for (var B = F % N; P[R.start.column - 1] == " " && B; )
              R.start.column--, B--;
            this.selection.setSelectionRange(R), j = "	";
          }
          return this.insert(j);
        }, D.prototype.blockIndent = function() {
          var E = this.$getSelectedRows();
          this.session.indentRows(E.first, E.last, "	");
        }, D.prototype.blockOutdent = function() {
          var E = this.session.getSelection();
          this.session.outdentRows(E.getRange());
        }, D.prototype.sortLines = function() {
          for (var E = this.$getSelectedRows(), R = this.session, I = [], k = E.first; k <= E.last; k++)
            I.push(R.getLine(k));
          I.sort(function(N, F) {
            return N.toLowerCase() < F.toLowerCase() ? -1 : N.toLowerCase() > F.toLowerCase() ? 1 : 0;
          });
          for (var P = new m(0, 0, 0, 0), k = E.first; k <= E.last; k++) {
            var L = R.getLine(k);
            P.start.row = k, P.end.row = k, P.end.column = L.length, R.replace(P, I[k - E.first]);
          }
        }, D.prototype.toggleCommentLines = function() {
          var E = this.session.getState(this.getCursorPosition().row), R = this.$getSelectedRows();
          this.session.getMode().toggleCommentLines(E, this.session, R.first, R.last);
        }, D.prototype.toggleBlockComment = function() {
          var E = this.getCursorPosition(), R = this.session.getState(E.row), I = this.getSelectionRange();
          this.session.getMode().toggleBlockComment(R, this.session, I, E);
        }, D.prototype.getNumberAt = function(E, R) {
          var I = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
          I.lastIndex = 0;
          for (var k = this.session.getLine(E); I.lastIndex < R; ) {
            var P = I.exec(k);
            if (P.index <= R && P.index + P[0].length >= R) {
              var L = {
                value: P[0],
                start: P.index,
                end: P.index + P[0].length
              };
              return L;
            }
          }
          return null;
        }, D.prototype.modifyNumber = function(E) {
          var R = this.selection.getCursor().row, I = this.selection.getCursor().column, k = new m(R, I - 1, R, I), P = this.session.getTextRange(k);
          if (!isNaN(parseFloat(P)) && isFinite(P)) {
            var L = this.getNumberAt(R, I);
            if (L) {
              var N = L.value.indexOf(".") >= 0 ? L.start + L.value.indexOf(".") + 1 : L.end, F = L.start + L.value.length - N, B = parseFloat(L.value);
              B *= Math.pow(10, F), N !== L.end && I < N ? E *= Math.pow(10, L.end - I - 1) : E *= Math.pow(10, L.end - I), B += E, B /= Math.pow(10, F);
              var j = B.toFixed(F), z = new m(R, L.start, R, L.end);
              this.session.replace(z, j), this.moveCursorTo(R, Math.max(L.start + 1, I + j.length - L.value.length));
            }
          } else
            this.toggleWord();
        }, D.prototype.toggleWord = function() {
          var E = this.selection.getCursor().row, R = this.selection.getCursor().column;
          this.selection.selectWord();
          var I = this.getSelectedText(), k = this.selection.getWordRange().start.column, P = I.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, "$1 ").split(/\s/), L = R - k - 1;
          L < 0 && (L = 0);
          var N = 0, F = 0, B = this;
          I.match(/[A-Za-z0-9_]+/) && P.forEach(function(Z, Q) {
            F = N + Z.length, L >= N && L <= F && (I = Z, B.selection.clearSelection(), B.moveCursorTo(E, N + k), B.selection.selectTo(E, F + k)), N = F;
          });
          for (var j = this.$toggleWordPairs, z, H = 0; H < j.length; H++)
            for (var W = j[H], G = 0; G <= 1; G++) {
              var K = +!G, Y = I.match(new RegExp("^\\s?_?(" + l.escapeRegExp(W[G]) + ")\\s?$", "i"));
              if (Y) {
                var X = I.match(new RegExp("([_]|^|\\s)(" + l.escapeRegExp(Y[1]) + ")($|\\s)", "g"));
                X && (z = I.replace(new RegExp(l.escapeRegExp(W[G]), "i"), function(Z) {
                  var Q = W[K];
                  return Z.toUpperCase() == Z ? Q = Q.toUpperCase() : Z.charAt(0).toUpperCase() == Z.charAt(0) && (Q = Q.substr(0, 0) + W[K].charAt(0).toUpperCase() + Q.substr(1)), Q;
                }), this.insert(z), z = "");
              }
            }
        }, D.prototype.findLinkAt = function(E, R) {
          var I, k, P = this.session.getLine(E), L = P.split(/((?:https?|ftp):\/\/[\S]+)/), N = R;
          N < 0 && (N = 0);
          var F = 0, B = 0, j;
          try {
            for (var z = o(L), H = z.next(); !H.done; H = z.next()) {
              var W = H.value;
              if (B = F + W.length, N >= F && N <= B && W.match(/((?:https?|ftp):\/\/[\S]+)/)) {
                j = W.replace(/[\s:.,'";}\]]+$/, "");
                break;
              }
              F = B;
            }
          } catch (G) {
            I = { error: G };
          } finally {
            try {
              H && !H.done && (k = z.return) && k.call(z);
            } finally {
              if (I)
                throw I.error;
            }
          }
          return j;
        }, D.prototype.openLink = function() {
          var E = this.selection.getCursor(), R = this.findLinkAt(E.row, E.column);
          return R && window.open(R, "_blank"), R != null;
        }, D.prototype.removeLines = function() {
          var E = this.$getSelectedRows();
          this.session.removeFullLines(E.first, E.last), this.clearSelection();
        }, D.prototype.duplicateSelection = function() {
          var E = this.selection, R = this.session, I = E.getRange(), k = E.isBackwards();
          if (I.isEmpty()) {
            var P = I.start.row;
            R.duplicateLines(P, P);
          } else {
            var L = k ? I.start : I.end, N = R.insert(L, R.getTextRange(I));
            I.start = L, I.end = N, E.setSelectionRange(I, k);
          }
        }, D.prototype.moveLinesDown = function() {
          this.$moveLines(1, !1);
        }, D.prototype.moveLinesUp = function() {
          this.$moveLines(-1, !1);
        }, D.prototype.moveText = function(E, R, I) {
          return this.session.moveText(E, R, I);
        }, D.prototype.copyLinesUp = function() {
          this.$moveLines(-1, !0);
        }, D.prototype.copyLinesDown = function() {
          this.$moveLines(1, !0);
        }, D.prototype.$moveLines = function(E, R) {
          var I, k, P = this.selection;
          if (!P.inMultiSelectMode || this.inVirtualSelectionMode) {
            var L = P.toOrientedRange();
            I = this.$getSelectedRows(L), k = this.session.$moveLines(I.first, I.last, R ? 0 : E), R && E == -1 && (k = 0), L.moveBy(k, 0), P.fromOrientedRange(L);
          } else {
            var N = P.rangeList.ranges;
            P.rangeList.detach(this.session), this.inVirtualSelectionMode = !0;
            for (var F = 0, B = 0, j = N.length, z = 0; z < j; z++) {
              var H = z;
              N[z].moveBy(F, 0), I = this.$getSelectedRows(N[z]);
              for (var W = I.first, G = I.last; ++z < j; ) {
                B && N[z].moveBy(B, 0);
                var K = this.$getSelectedRows(N[z]);
                if (R && K.first != G)
                  break;
                if (!R && K.first > G + 1)
                  break;
                G = K.last;
              }
              for (z--, F = this.session.$moveLines(W, G, R ? 0 : E), R && E == -1 && (H = z + 1); H <= z; )
                N[H].moveBy(F, 0), H++;
              R || (F = 0), B += F;
            }
            P.fromOrientedRange(P.ranges[0]), P.rangeList.attach(this.session), this.inVirtualSelectionMode = !1;
          }
        }, D.prototype.$getSelectedRows = function(E) {
          return E = (E || this.getSelectionRange()).collapseRows(), {
            first: this.session.getRowFoldStart(E.start.row),
            last: this.session.getRowFoldEnd(E.end.row)
          };
        }, D.prototype.onCompositionStart = function(E) {
          this.renderer.showComposition(E);
        }, D.prototype.onCompositionUpdate = function(E) {
          this.renderer.setCompositionText(E);
        }, D.prototype.onCompositionEnd = function() {
          this.renderer.hideComposition();
        }, D.prototype.getFirstVisibleRow = function() {
          return this.renderer.getFirstVisibleRow();
        }, D.prototype.getLastVisibleRow = function() {
          return this.renderer.getLastVisibleRow();
        }, D.prototype.isRowVisible = function(E) {
          return E >= this.getFirstVisibleRow() && E <= this.getLastVisibleRow();
        }, D.prototype.isRowFullyVisible = function(E) {
          return E >= this.renderer.getFirstFullyVisibleRow() && E <= this.renderer.getLastFullyVisibleRow();
        }, D.prototype.$getVisibleRowCount = function() {
          return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
        }, D.prototype.$moveByPage = function(E, R) {
          var I = this.renderer, k = this.renderer.layerConfig, P = E * Math.floor(k.height / k.lineHeight);
          R === !0 ? this.selection.$moveSelection(function() {
            this.moveCursorBy(P, 0);
          }) : R === !1 && (this.selection.moveCursorBy(P, 0), this.selection.clearSelection());
          var L = I.scrollTop;
          I.scrollBy(0, P * k.lineHeight), R != null && I.scrollCursorIntoView(null, 0.5), I.animateScrolling(L);
        }, D.prototype.selectPageDown = function() {
          this.$moveByPage(1, !0);
        }, D.prototype.selectPageUp = function() {
          this.$moveByPage(-1, !0);
        }, D.prototype.gotoPageDown = function() {
          this.$moveByPage(1, !1);
        }, D.prototype.gotoPageUp = function() {
          this.$moveByPage(-1, !1);
        }, D.prototype.scrollPageDown = function() {
          this.$moveByPage(1);
        }, D.prototype.scrollPageUp = function() {
          this.$moveByPage(-1);
        }, D.prototype.scrollToRow = function(E) {
          this.renderer.scrollToRow(E);
        }, D.prototype.scrollToLine = function(E, R, I, k) {
          this.renderer.scrollToLine(E, R, I, k);
        }, D.prototype.centerSelection = function() {
          var E = this.getSelectionRange(), R = {
            row: Math.floor(E.start.row + (E.end.row - E.start.row) / 2),
            column: Math.floor(E.start.column + (E.end.column - E.start.column) / 2)
          };
          this.renderer.alignCursor(R, 0.5);
        }, D.prototype.getCursorPosition = function() {
          return this.selection.getCursor();
        }, D.prototype.getCursorPositionScreen = function() {
          return this.session.documentToScreenPosition(this.getCursorPosition());
        }, D.prototype.getSelectionRange = function() {
          return this.selection.getRange();
        }, D.prototype.selectAll = function() {
          this.selection.selectAll();
        }, D.prototype.clearSelection = function() {
          this.selection.clearSelection();
        }, D.prototype.moveCursorTo = function(E, R) {
          this.selection.moveCursorTo(E, R);
        }, D.prototype.moveCursorToPosition = function(E) {
          this.selection.moveCursorToPosition(E);
        }, D.prototype.jumpToMatching = function(E, R) {
          var I = this.getCursorPosition(), k = new C(this.session, I.row, I.column), P = k.getCurrentToken(), L = 0;
          P && P.type.indexOf("tag-name") !== -1 && (P = k.stepBackward());
          var N = P || k.stepForward();
          if (N) {
            var F, B = !1, j = {}, z = I.column - N.start, H, W = {
              ")": "(",
              "(": "(",
              "]": "[",
              "[": "[",
              "{": "{",
              "}": "{"
            };
            do {
              if (N.value.match(/[{}()\[\]]/g)) {
                for (; z < N.value.length && !B; z++)
                  if (W[N.value[z]])
                    switch (H = W[N.value[z]] + "." + N.type.replace("rparen", "lparen"), isNaN(j[H]) && (j[H] = 0), N.value[z]) {
                      case "(":
                      case "[":
                      case "{":
                        j[H]++;
                        break;
                      case ")":
                      case "]":
                      case "}":
                        j[H]--, j[H] === -1 && (F = "bracket", B = !0);
                        break;
                    }
              } else
                N.type.indexOf("tag-name") !== -1 && (isNaN(j[N.value]) && (j[N.value] = 0), P.value === "<" && L > 1 ? j[N.value]++ : P.value === "</" && j[N.value]--, j[N.value] === -1 && (F = "tag", B = !0));
              B || (P = N, L++, N = k.stepForward(), z = 0);
            } while (N && !B);
            if (F) {
              var G, K;
              if (F === "bracket")
                G = this.session.getBracketRange(I), G || (G = new m(k.getCurrentTokenRow(), k.getCurrentTokenColumn() + z - 1, k.getCurrentTokenRow(), k.getCurrentTokenColumn() + z - 1), K = G.start, (R || K.row === I.row && Math.abs(K.column - I.column) < 2) && (G = this.session.getBracketRange(K)));
              else if (F === "tag") {
                if (!N || N.type.indexOf("tag-name") === -1)
                  return;
                if (G = new m(k.getCurrentTokenRow(), k.getCurrentTokenColumn() - 2, k.getCurrentTokenRow(), k.getCurrentTokenColumn() - 2), G.compare(I.row, I.column) === 0) {
                  var Y = this.session.getMatchingTags(I);
                  Y && (Y.openTag.contains(I.row, I.column) ? (G = Y.closeTag, K = G.start) : (G = Y.openTag, Y.closeTag.start.row === I.row && Y.closeTag.start.column === I.column ? K = G.end : K = G.start));
                }
                K = K || G.start;
              }
              K = G && G.cursor || K, K && (E ? G && R ? this.selection.setRange(G) : G && G.isEqual(this.getSelectionRange()) ? this.clearSelection() : this.selection.selectTo(K.row, K.column) : this.selection.moveTo(K.row, K.column));
            }
          }
        }, D.prototype.gotoLine = function(E, R, I) {
          this.selection.clearSelection(), this.session.unfold({ row: E - 1, column: R || 0 }), this.exitMultiSelectMode && this.exitMultiSelectMode(), this.moveCursorTo(E - 1, R || 0), this.isRowFullyVisible(E - 1) || this.scrollToLine(E - 1, !0, I);
        }, D.prototype.navigateTo = function(E, R) {
          this.selection.moveTo(E, R);
        }, D.prototype.navigateUp = function(E) {
          if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
            var R = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(R);
          }
          this.selection.clearSelection(), this.selection.moveCursorBy(-E || -1, 0);
        }, D.prototype.navigateDown = function(E) {
          if (this.selection.isMultiLine() && this.selection.isBackwards()) {
            var R = this.selection.anchor.getPosition();
            return this.moveCursorToPosition(R);
          }
          this.selection.clearSelection(), this.selection.moveCursorBy(E || 1, 0);
        }, D.prototype.navigateLeft = function(E) {
          if (this.selection.isEmpty())
            for (E = E || 1; E--; )
              this.selection.moveCursorLeft();
          else {
            var R = this.getSelectionRange().start;
            this.moveCursorToPosition(R);
          }
          this.clearSelection();
        }, D.prototype.navigateRight = function(E) {
          if (this.selection.isEmpty())
            for (E = E || 1; E--; )
              this.selection.moveCursorRight();
          else {
            var R = this.getSelectionRange().end;
            this.moveCursorToPosition(R);
          }
          this.clearSelection();
        }, D.prototype.navigateLineStart = function() {
          this.selection.moveCursorLineStart(), this.clearSelection();
        }, D.prototype.navigateLineEnd = function() {
          this.selection.moveCursorLineEnd(), this.clearSelection();
        }, D.prototype.navigateFileEnd = function() {
          this.selection.moveCursorFileEnd(), this.clearSelection();
        }, D.prototype.navigateFileStart = function() {
          this.selection.moveCursorFileStart(), this.clearSelection();
        }, D.prototype.navigateWordRight = function() {
          this.selection.moveCursorWordRight(), this.clearSelection();
        }, D.prototype.navigateWordLeft = function() {
          this.selection.moveCursorWordLeft(), this.clearSelection();
        }, D.prototype.replace = function(E, R) {
          R && this.$search.set(R);
          var I = this.$search.find(this.session), k = 0;
          return I && (this.$tryReplace(I, E) && (k = 1), this.selection.setSelectionRange(I), this.renderer.scrollSelectionIntoView(I.start, I.end)), k;
        }, D.prototype.replaceAll = function(E, R) {
          R && this.$search.set(R);
          var I = this.$search.findAll(this.session), k = 0;
          if (!I.length)
            return k;
          var P = this.getSelectionRange();
          this.selection.moveTo(0, 0);
          for (var L = I.length - 1; L >= 0; --L)
            this.$tryReplace(I[L], E) && k++;
          return this.selection.setSelectionRange(P), k;
        }, D.prototype.$tryReplace = function(E, R) {
          var I = this.session.getTextRange(E);
          return R = this.$search.replace(I, R), R !== null ? (E.end = this.session.replace(E, R), E) : null;
        }, D.prototype.getLastSearchOptions = function() {
          return this.$search.getOptions();
        }, D.prototype.find = function(E, R, I) {
          R || (R = {}), typeof E == "string" || E instanceof RegExp ? R.needle = E : typeof E == "object" && s.mixin(R, E);
          var k = this.selection.getRange();
          R.needle == null && (E = this.session.getTextRange(k) || this.$search.$options.needle, E || (k = this.session.getWordRange(k.start.row, k.start.column), E = this.session.getTextRange(k)), this.$search.set({ needle: E })), this.$search.set(R), R.start || this.$search.set({ start: k });
          var P = this.$search.find(this.session);
          if (R.preventScroll)
            return P;
          if (P)
            return this.revealRange(P, I), P;
          R.backwards ? k.start = k.end : k.end = k.start, this.selection.setRange(k);
        }, D.prototype.findNext = function(E, R) {
          this.find({ skipCurrent: !0, backwards: !1 }, E, R);
        }, D.prototype.findPrevious = function(E, R) {
          this.find(E, { skipCurrent: !0, backwards: !0 }, R);
        }, D.prototype.revealRange = function(E, R) {
          this.session.unfold(E), this.selection.setSelectionRange(E);
          var I = this.renderer.scrollTop;
          this.renderer.scrollSelectionIntoView(E.start, E.end, 0.5), R !== !1 && this.renderer.animateScrolling(I);
        }, D.prototype.undo = function() {
          this.session.getUndoManager().undo(this.session), this.renderer.scrollCursorIntoView(null, 0.5);
        }, D.prototype.redo = function() {
          this.session.getUndoManager().redo(this.session), this.renderer.scrollCursorIntoView(null, 0.5);
        }, D.prototype.destroy = function() {
          this.$toDestroy && (this.$toDestroy.forEach(function(E) {
            E.destroy();
          }), this.$toDestroy = null), this.$mouseHandler && this.$mouseHandler.destroy(), this.renderer.destroy(), this._signal("destroy", this), this.session && this.session.destroy(), this._$emitInputEvent && this._$emitInputEvent.cancel(), this.removeAllListeners();
        }, D.prototype.setAutoScrollEditorIntoView = function(E) {
          if (E) {
            var R, I = this, k = !1;
            this.$scrollAnchor || (this.$scrollAnchor = document.createElement("div"));
            var P = this.$scrollAnchor;
            P.style.cssText = "position:absolute", this.container.insertBefore(P, this.container.firstChild);
            var L = this.on("changeSelection", function() {
              k = !0;
            }), N = this.renderer.on("beforeRender", function() {
              k && (R = I.renderer.container.getBoundingClientRect());
            }), F = this.renderer.on("afterRender", function() {
              if (k && R && (I.isFocused() || I.searchBox && I.searchBox.isFocused())) {
                var B = I.renderer, j = B.$cursorLayer.$pixelPos, z = B.layerConfig, H = j.top - z.offset;
                j.top >= 0 && H + R.top < 0 ? k = !0 : j.top < z.height && j.top + R.top + z.lineHeight > window.innerHeight ? k = !1 : k = null, k != null && (P.style.top = H + "px", P.style.left = j.left + "px", P.style.height = z.lineHeight + "px", P.scrollIntoView(k)), k = R = null;
              }
            });
            this.setAutoScrollEditorIntoView = function(B) {
              B || (delete this.setAutoScrollEditorIntoView, this.off("changeSelection", L), this.renderer.off("afterRender", F), this.renderer.off("beforeRender", N));
            };
          }
        }, D.prototype.$resetCursorStyle = function() {
          var E = this.$cursorStyle || "ace", R = this.renderer.$cursorLayer;
          R && (R.setSmoothBlinking(/smooth/.test(E)), R.isBlinking = !this.$readOnly && E != "wide", a.setCssClass(R.element, "ace_slim-cursors", /slim/.test(E)));
        }, D.prototype.prompt = function(E, R, I) {
          var k = this;
          w.loadModule("ace/ext/prompt", function(P) {
            P.prompt(k, E, R, I);
          });
        }, D;
      }()
    );
    _.$uid = 0, _.prototype.curOp = null, _.prototype.prevOp = {}, _.prototype.$mergeableCommands = ["backspace", "del", "insertstring"], _.prototype.$toggleWordPairs = [
      ["first", "last"],
      ["true", "false"],
      ["yes", "no"],
      ["width", "height"],
      ["top", "bottom"],
      ["right", "left"],
      ["on", "off"],
      ["x", "y"],
      ["get", "set"],
      ["max", "min"],
      ["horizontal", "vertical"],
      ["show", "hide"],
      ["add", "remove"],
      ["up", "down"],
      ["before", "after"],
      ["even", "odd"],
      ["in", "out"],
      ["inside", "outside"],
      ["next", "previous"],
      ["increase", "decrease"],
      ["attach", "detach"],
      ["&&", "||"],
      ["==", "!="]
    ], s.implement(_.prototype, v), w.defineOptions(_.prototype, "editor", {
      selectionStyle: {
        set: function(D) {
          this.onSelectionChange(), this._signal("changeSelectionStyle", { data: D });
        },
        initialValue: "line"
      },
      highlightActiveLine: {
        set: function() {
          this.$updateHighlightActiveLine();
        },
        initialValue: !0
      },
      highlightSelectedWord: {
        set: function(D) {
          this.$onSelectionChange();
        },
        initialValue: !0
      },
      readOnly: {
        set: function(D) {
          this.textInput.setReadOnly(D), this.$resetCursorStyle();
        },
        initialValue: !1
      },
      copyWithEmptySelection: {
        set: function(D) {
          this.textInput.setCopyWithEmptySelection(D);
        },
        initialValue: !1
      },
      cursorStyle: {
        set: function(D) {
          this.$resetCursorStyle();
        },
        values: ["ace", "slim", "smooth", "wide"],
        initialValue: "ace"
      },
      mergeUndoDeltas: {
        values: [!1, !0, "always"],
        initialValue: !0
      },
      behavioursEnabled: { initialValue: !0 },
      wrapBehavioursEnabled: { initialValue: !0 },
      enableAutoIndent: { initialValue: !0 },
      autoScrollEditorIntoView: {
        set: function(D) {
          this.setAutoScrollEditorIntoView(D);
        }
      },
      keyboardHandler: {
        set: function(D) {
          this.setKeyboardHandler(D);
        },
        get: function() {
          return this.$keybindingId;
        },
        handlesSet: !0
      },
      value: {
        set: function(D) {
          this.session.setValue(D);
        },
        get: function() {
          return this.getValue();
        },
        handlesSet: !0,
        hidden: !0
      },
      session: {
        set: function(D) {
          this.setSession(D);
        },
        get: function() {
          return this.session;
        },
        handlesSet: !0,
        hidden: !0
      },
      showLineNumbers: {
        set: function(D) {
          this.renderer.$gutterLayer.setShowLineNumbers(D), this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER), D && this.$relativeLineNumbers ? T.attach(this) : T.detach(this);
        },
        initialValue: !0
      },
      relativeLineNumbers: {
        set: function(D) {
          this.$showLineNumbers && D ? T.attach(this) : T.detach(this);
        }
      },
      placeholder: {
        set: function(D) {
          this.$updatePlaceholder || (this.$updatePlaceholder = (function() {
            var E = this.session && (this.renderer.$composition || this.session.getLength() > 1 || this.session.getLine(0).length > 0);
            if (E && this.renderer.placeholderNode)
              this.renderer.off("afterRender", this.$updatePlaceholder), a.removeCssClass(this.container, "ace_hasPlaceholder"), this.renderer.placeholderNode.remove(), this.renderer.placeholderNode = null;
            else if (!E && !this.renderer.placeholderNode) {
              this.renderer.on("afterRender", this.$updatePlaceholder), a.addCssClass(this.container, "ace_hasPlaceholder");
              var R = a.createElement("div");
              R.className = "ace_placeholder", R.textContent = this.$placeholder || "", this.renderer.placeholderNode = R, this.renderer.content.appendChild(this.renderer.placeholderNode);
            } else
              !E && this.renderer.placeholderNode && (this.renderer.placeholderNode.textContent = this.$placeholder || "");
          }).bind(this), this.on("input", this.$updatePlaceholder)), this.$updatePlaceholder();
        }
      },
      enableKeyboardAccessibility: {
        set: function(D) {
          var E = {
            name: "blurTextInput",
            description: "Set focus to the editor content div to allow tabbing through the page",
            bindKey: "Esc",
            exec: function(k) {
              k.blur(), k.renderer.scroller.focus();
            },
            readOnly: !0
          }, R = function(k) {
            if (k.target == this.renderer.scroller && k.keyCode === M.enter) {
              k.preventDefault();
              var P = this.getCursorPosition().row;
              this.isRowVisible(P) || this.scrollToLine(P, !0, !0), this.focus();
            }
          }, I;
          D ? (this.renderer.enableKeyboardAccessibility = !0, this.renderer.keyboardFocusClassName = "ace_keyboard-focus", this.textInput.getElement().setAttribute("tabindex", -1), this.textInput.setNumberOfExtraLines(u.isWin ? 3 : 0), this.renderer.scroller.setAttribute("tabindex", 0), this.renderer.scroller.setAttribute("role", "group"), this.renderer.scroller.setAttribute("aria-roledescription", A("editor.scroller.aria-roledescription", "editor")), this.renderer.scroller.classList.add(this.renderer.keyboardFocusClassName), this.renderer.scroller.setAttribute("aria-label", A("editor.scroller.aria-label", "Editor content, press Enter to start editing, press Escape to exit")), this.renderer.scroller.addEventListener("keyup", R.bind(this)), this.commands.addCommand(E), this.renderer.$gutter.setAttribute("tabindex", 0), this.renderer.$gutter.setAttribute("aria-hidden", !1), this.renderer.$gutter.setAttribute("role", "group"), this.renderer.$gutter.setAttribute("aria-roledescription", A("editor.gutter.aria-roledescription", "editor")), this.renderer.$gutter.setAttribute("aria-label", A("editor.gutter.aria-label", "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit")), this.renderer.$gutter.classList.add(this.renderer.keyboardFocusClassName), this.renderer.content.setAttribute("aria-hidden", !0), I || (I = new S(this)), I.addListener()) : (this.renderer.enableKeyboardAccessibility = !1, this.textInput.getElement().setAttribute("tabindex", 0), this.textInput.setNumberOfExtraLines(0), this.renderer.scroller.setAttribute("tabindex", -1), this.renderer.scroller.removeAttribute("role"), this.renderer.scroller.removeAttribute("aria-roledescription"), this.renderer.scroller.classList.remove(this.renderer.keyboardFocusClassName), this.renderer.scroller.removeAttribute("aria-label"), this.renderer.scroller.removeEventListener("keyup", R.bind(this)), this.commands.removeCommand(E), this.renderer.content.removeAttribute("aria-hidden"), this.renderer.$gutter.setAttribute("tabindex", -1), this.renderer.$gutter.setAttribute("aria-hidden", !0), this.renderer.$gutter.removeAttribute("role"), this.renderer.$gutter.removeAttribute("aria-roledescription"), this.renderer.$gutter.removeAttribute("aria-label"), this.renderer.$gutter.classList.remove(this.renderer.keyboardFocusClassName), I && I.removeListener());
        },
        initialValue: !1
      },
      customScrollbar: "renderer",
      hScrollBarAlwaysVisible: "renderer",
      vScrollBarAlwaysVisible: "renderer",
      highlightGutterLine: "renderer",
      animatedScroll: "renderer",
      showInvisibles: "renderer",
      showPrintMargin: "renderer",
      printMarginColumn: "renderer",
      printMargin: "renderer",
      fadeFoldWidgets: "renderer",
      showFoldWidgets: "renderer",
      displayIndentGuides: "renderer",
      highlightIndentGuides: "renderer",
      showGutter: "renderer",
      fontSize: "renderer",
      fontFamily: "renderer",
      maxLines: "renderer",
      minLines: "renderer",
      scrollPastEnd: "renderer",
      fixedWidthGutter: "renderer",
      theme: "renderer",
      hasCssTransforms: "renderer",
      maxPixelHeight: "renderer",
      useTextareaForIME: "renderer",
      useResizeObserver: "renderer",
      useSvgGutterIcons: "renderer",
      showFoldedAnnotations: "renderer",
      scrollSpeed: "$mouseHandler",
      dragDelay: "$mouseHandler",
      dragEnabled: "$mouseHandler",
      focusTimeout: "$mouseHandler",
      tooltipFollowsMouse: "$mouseHandler",
      firstLineNumber: "session",
      overwrite: "session",
      newLineMode: "session",
      useWorker: "session",
      useSoftTabs: "session",
      navigateWithinSoftTabs: "session",
      tabSize: "session",
      wrap: "session",
      indentedSoftWrap: "session",
      foldStyle: "session",
      mode: "session"
    });
    var T = {
      getText: function(D, E) {
        return (Math.abs(D.selection.lead.row - E) || E + 1 + (E < 9 ? "" : "")) + "";
      },
      getWidth: function(D, E, R) {
        return Math.max(E.toString().length, (R.lastRow + 1).toString().length, 2) * R.characterWidth;
      },
      update: function(D, E) {
        E.renderer.$loop.schedule(E.renderer.CHANGE_GUTTER);
      },
      attach: function(D) {
        D.renderer.$gutterLayer.$renderer = this, D.on("changeSelection", this.update), this.update(null, D);
      },
      detach: function(D) {
        D.renderer.$gutterLayer.$renderer == this && (D.renderer.$gutterLayer.$renderer = null), D.off("changeSelection", this.update), this.update(null, D);
      }
    };
    r.Editor = _;
  }), ace.define("ace/layer/lines", ["require", "exports", "module", "ace/lib/dom"], function(n, r, i) {
    var o = n("../lib/dom"), s = (
      /** @class */
      function() {
        function a(l, u) {
          this.element = l, this.canvasHeight = u || 5e5, this.element.style.height = this.canvasHeight * 2 + "px", this.cells = [], this.cellCache = [], this.$offsetCoefficient = 0;
        }
        return a.prototype.moveContainer = function(l) {
          o.translate(this.element, 0, -(l.firstRowScreen * l.lineHeight % this.canvasHeight) - l.offset * this.$offsetCoefficient);
        }, a.prototype.pageChanged = function(l, u) {
          return Math.floor(l.firstRowScreen * l.lineHeight / this.canvasHeight) !== Math.floor(u.firstRowScreen * u.lineHeight / this.canvasHeight);
        }, a.prototype.computeLineTop = function(l, u, c) {
          var d = u.firstRowScreen * u.lineHeight, f = Math.floor(d / this.canvasHeight), h = c.documentToScreenRow(l, 0) * u.lineHeight;
          return h - f * this.canvasHeight;
        }, a.prototype.computeLineHeight = function(l, u, c) {
          return u.lineHeight * c.getRowLineCount(l);
        }, a.prototype.getLength = function() {
          return this.cells.length;
        }, a.prototype.get = function(l) {
          return this.cells[l];
        }, a.prototype.shift = function() {
          this.$cacheCell(this.cells.shift());
        }, a.prototype.pop = function() {
          this.$cacheCell(this.cells.pop());
        }, a.prototype.push = function(l) {
          if (Array.isArray(l)) {
            this.cells.push.apply(this.cells, l);
            for (var u = o.createFragment(this.element), c = 0; c < l.length; c++)
              u.appendChild(l[c].element);
            this.element.appendChild(u);
          } else
            this.cells.push(l), this.element.appendChild(l.element);
        }, a.prototype.unshift = function(l) {
          if (Array.isArray(l)) {
            this.cells.unshift.apply(this.cells, l);
            for (var u = o.createFragment(this.element), c = 0; c < l.length; c++)
              u.appendChild(l[c].element);
            this.element.firstChild ? this.element.insertBefore(u, this.element.firstChild) : this.element.appendChild(u);
          } else
            this.cells.unshift(l), this.element.insertAdjacentElement("afterbegin", l.element);
        }, a.prototype.last = function() {
          return this.cells.length ? this.cells[this.cells.length - 1] : null;
        }, a.prototype.$cacheCell = function(l) {
          l && (l.element.remove(), this.cellCache.push(l));
        }, a.prototype.createCell = function(l, u, c, d) {
          var f = this.cellCache.pop();
          if (!f) {
            var h = o.createElement("div");
            d && d(h), this.element.appendChild(h), f = {
              element: h,
              text: "",
              row: l
            };
          }
          return f.row = l, f;
        }, a;
      }()
    );
    r.Lines = s;
  }), ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/layer/lines", "ace/config"], function(n, r, i) {
    var o = n("../lib/dom"), s = n("../lib/oop"), a = n("../lib/lang"), l = n("../lib/event_emitter").EventEmitter, u = n("./lines").Lines, c = n("../config").nls, d = (
      /** @class */
      function() {
        function h(p) {
          this.element = o.createElement("div"), this.element.className = "ace_layer ace_gutter-layer", p.appendChild(this.element), this.setShowFoldWidgets(this.$showFoldWidgets), this.gutterWidth = 0, this.$annotations = [], this.$updateAnnotations = this.$updateAnnotations.bind(this), this.$lines = new u(this.element), this.$lines.$offsetCoefficient = 1;
        }
        return h.prototype.setSession = function(p) {
          this.session && this.session.off("change", this.$updateAnnotations), this.session = p, p && p.on("change", this.$updateAnnotations);
        }, h.prototype.addGutterDecoration = function(p, g) {
          window.console && console.warn && console.warn("deprecated use session.addGutterDecoration"), this.session.addGutterDecoration(p, g);
        }, h.prototype.removeGutterDecoration = function(p, g) {
          window.console && console.warn && console.warn("deprecated use session.removeGutterDecoration"), this.session.removeGutterDecoration(p, g);
        }, h.prototype.setAnnotations = function(p) {
          this.$annotations = [];
          for (var g = 0; g < p.length; g++) {
            var m = p[g], v = m.row, b = this.$annotations[v];
            b || (b = this.$annotations[v] = { text: [], type: [] });
            var x = m.text, w = m.type;
            x = x ? a.escapeHTML(x) : m.html || "", b.text.indexOf(x) === -1 && (b.text.push(x), b.type.push(w));
            var C = m.className;
            C ? b.className = C : w == "error" ? b.className = " ace_error" : w == "warning" && b.className != " ace_error" ? b.className = " ace_warning" : w == "info" && !b.className && (b.className = " ace_info");
          }
        }, h.prototype.$updateAnnotations = function(p) {
          if (this.$annotations.length) {
            var g = p.start.row, m = p.end.row - g;
            if (m !== 0)
              if (p.action == "remove")
                this.$annotations.splice(g, m + 1, null);
              else {
                var v = new Array(m + 1);
                v.unshift(g, 1), this.$annotations.splice.apply(this.$annotations, v);
              }
          }
        }, h.prototype.update = function(p) {
          this.config = p;
          var g = this.session, m = p.firstRow, v = Math.min(
            p.lastRow + p.gutterOffset,
            // needed to compensate for hor scollbar
            g.getLength() - 1
          );
          this.oldLastRow = v, this.config = p, this.$lines.moveContainer(p), this.$updateCursorRow();
          for (var b = g.getNextFoldLine(m), x = b ? b.start.row : 1 / 0, w = null, C = -1, y = m; ; ) {
            if (y > x && (y = b.end.row + 1, b = g.getNextFoldLine(y, b), x = b ? b.start.row : 1 / 0), y > v) {
              for (; this.$lines.getLength() > C + 1; )
                this.$lines.pop();
              break;
            }
            w = this.$lines.get(++C), w ? w.row = y : (w = this.$lines.createCell(y, p, this.session, f), this.$lines.push(w)), this.$renderCell(w, p, b, y), y++;
          }
          this._signal("afterRender"), this.$updateGutterWidth(p);
        }, h.prototype.$updateGutterWidth = function(p) {
          var g = this.session, m = g.gutterRenderer || this.$renderer, v = g.$firstLineNumber, b = this.$lines.last() ? this.$lines.last().text : "";
          (this.$fixedWidth || g.$useWrapMode) && (b = g.getLength() + v - 1);
          var x = m ? m.getWidth(g, b, p) : b.toString().length * p.characterWidth, w = this.$padding || this.$computePadding();
          x += w.left + w.right, x !== this.gutterWidth && !isNaN(x) && (this.gutterWidth = x, this.element.parentNode.style.width = this.element.style.width = Math.ceil(this.gutterWidth) + "px", this._signal("changeGutterWidth", x));
        }, h.prototype.$updateCursorRow = function() {
          if (this.$highlightGutterLine) {
            var p = this.session.selection.getCursor();
            this.$cursorRow !== p.row && (this.$cursorRow = p.row);
          }
        }, h.prototype.updateLineHighlight = function() {
          if (this.$highlightGutterLine) {
            var p = this.session.selection.cursor.row;
            if (this.$cursorRow = p, !(this.$cursorCell && this.$cursorCell.row == p)) {
              this.$cursorCell && (this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", ""));
              var g = this.$lines.cells;
              this.$cursorCell = null;
              for (var m = 0; m < g.length; m++) {
                var v = g[m];
                if (v.row >= this.$cursorRow) {
                  if (v.row > this.$cursorRow) {
                    var b = this.session.getFoldLine(this.$cursorRow);
                    if (m > 0 && b && b.start.row == g[m - 1].row)
                      v = g[m - 1];
                    else
                      break;
                  }
                  v.element.className = "ace_gutter-active-line " + v.element.className, this.$cursorCell = v;
                  break;
                }
              }
            }
          }
        }, h.prototype.scrollLines = function(p) {
          var g = this.config;
          if (this.config = p, this.$updateCursorRow(), this.$lines.pageChanged(g, p))
            return this.update(p);
          this.$lines.moveContainer(p);
          var m = Math.min(
            p.lastRow + p.gutterOffset,
            // needed to compensate for hor scollbar
            this.session.getLength() - 1
          ), v = this.oldLastRow;
          if (this.oldLastRow = m, !g || v < p.firstRow)
            return this.update(p);
          if (m < g.firstRow)
            return this.update(p);
          if (g.firstRow < p.firstRow)
            for (var b = this.session.getFoldedRowCount(g.firstRow, p.firstRow - 1); b > 0; b--)
              this.$lines.shift();
          if (v > m)
            for (var b = this.session.getFoldedRowCount(m + 1, v); b > 0; b--)
              this.$lines.pop();
          p.firstRow < g.firstRow && this.$lines.unshift(this.$renderLines(p, p.firstRow, g.firstRow - 1)), m > v && this.$lines.push(this.$renderLines(p, v + 1, m)), this.updateLineHighlight(), this._signal("afterRender"), this.$updateGutterWidth(p);
        }, h.prototype.$renderLines = function(p, g, m) {
          for (var v = [], b = g, x = this.session.getNextFoldLine(b), w = x ? x.start.row : 1 / 0; b > w && (b = x.end.row + 1, x = this.session.getNextFoldLine(b, x), w = x ? x.start.row : 1 / 0), !(b > m); ) {
            var C = this.$lines.createCell(b, p, this.session, f);
            this.$renderCell(C, p, x, b), v.push(C), b++;
          }
          return v;
        }, h.prototype.$renderCell = function(p, g, m, v) {
          var b = p.element, x = this.session, w = b.childNodes[0], C = b.childNodes[1], y = b.childNodes[2], S = y.firstChild, A = x.$firstLineNumber, $ = x.$breakpoints, M = x.$decorations, _ = x.gutterRenderer || this.$renderer, T = this.$showFoldWidgets && x.foldWidgets, D = m ? m.start.row : Number.MAX_VALUE, E = g.lineHeight + "px", R = this.$useSvgGutterIcons ? "ace_gutter-cell_svg-icons " : "ace_gutter-cell ", I = this.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon", k = (_ ? _.getText(x, v) : v + A).toString();
          if (this.$highlightGutterLine && (v == this.$cursorRow || m && v < this.$cursorRow && v >= D && this.$cursorRow <= m.end.row) && (R += "ace_gutter-active-line ", this.$cursorCell != p && (this.$cursorCell && (this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "")), this.$cursorCell = p)), $[v] && (R += $[v]), M[v] && (R += M[v]), this.$annotations[v] && v !== D && (R += this.$annotations[v].className), T) {
            var P = T[v];
            P == null && (P = T[v] = x.getFoldWidget(v));
          }
          if (P) {
            var L = "ace_fold-widget ace_" + P, N = P == "start" && v == D && v < m.end.row;
            if (N) {
              L += " ace_closed";
              for (var F = "", B = !1, j = v + 1; j <= m.end.row; j++)
                if (this.$annotations[j]) {
                  if (this.$annotations[j].className === " ace_error") {
                    B = !0, F = " ace_error_fold";
                    break;
                  }
                  if (this.$annotations[j].className === " ace_warning") {
                    B = !0, F = " ace_warning_fold";
                    continue;
                  }
                }
              R += F;
            } else
              L += " ace_open";
            C.className != L && (C.className = L), o.setStyle(C.style, "height", E), o.setStyle(C.style, "display", "inline-block"), C.setAttribute("role", "button"), C.setAttribute("tabindex", "-1");
            var z = x.getFoldWidgetRange(v);
            z ? C.setAttribute("aria-label", c("gutter.code-folding.range.aria-label", "Toggle code folding, rows $0 through $1", [z.start.row + 1, z.end.row + 1])) : m ? C.setAttribute("aria-label", c("gutter.code-folding.closed.aria-label", "Toggle code folding, rows $0 through $1", [m.start.row + 1, m.end.row + 1])) : C.setAttribute("aria-label", c("gutter.code-folding.open.aria-label", "Toggle code folding, row $0", [v + 1])), N ? (C.setAttribute("aria-expanded", "false"), C.setAttribute("title", c("gutter.code-folding.closed.title", "Unfold code"))) : (C.setAttribute("aria-expanded", "true"), C.setAttribute("title", c("gutter.code-folding.open.title", "Fold code")));
          } else
            C && (o.setStyle(C.style, "display", "none"), C.setAttribute("tabindex", "0"), C.removeAttribute("role"), C.removeAttribute("aria-label"));
          if (B && this.$showFoldedAnnotations) {
            y.className = "ace_gutter_annotation", S.className = I, S.className += F, o.setStyle(S.style, "height", E), o.setStyle(y.style, "display", "block"), o.setStyle(y.style, "height", E);
            var H;
            switch (F) {
              case " ace_error_fold":
                H = c("gutter.annotation.aria-label.error", "Read annotations row $0", [k]);
                break;
              case " ace_warning_fold":
                H = c("gutter.annotation.aria-label.warning", "Read annotations row $0", [k]);
                break;
            }
            y.setAttribute("aria-label", H), y.setAttribute("tabindex", "-1"), y.setAttribute("role", "button");
          } else if (this.$annotations[v]) {
            y.className = "ace_gutter_annotation", S.className = I, this.$useSvgGutterIcons ? S.className += this.$annotations[v].className : b.classList.add(this.$annotations[v].className.replace(" ", "")), o.setStyle(S.style, "height", E), o.setStyle(y.style, "display", "block"), o.setStyle(y.style, "height", E);
            var H;
            switch (this.$annotations[v].className) {
              case " ace_error":
                H = c("gutter.annotation.aria-label.error", "Read annotations row $0", [k]);
                break;
              case " ace_warning":
                H = c("gutter.annotation.aria-label.warning", "Read annotations row $0", [k]);
                break;
              case " ace_info":
                H = c("gutter.annotation.aria-label.info", "Read annotations row $0", [k]);
                break;
            }
            y.setAttribute("aria-label", H), y.setAttribute("tabindex", "-1"), y.setAttribute("role", "button");
          } else
            o.setStyle(y.style, "display", "none"), y.removeAttribute("aria-label"), y.removeAttribute("role"), y.setAttribute("tabindex", "0");
          return k !== w.data && (w.data = k), b.className != R && (b.className = R), o.setStyle(p.element.style, "height", this.$lines.computeLineHeight(v, g, x) + "px"), o.setStyle(p.element.style, "top", this.$lines.computeLineTop(v, g, x) + "px"), p.text = k, y.style.display === "none" && C.style.display === "none" ? p.element.setAttribute("aria-hidden", !0) : p.element.setAttribute("aria-hidden", !1), p;
        }, h.prototype.setHighlightGutterLine = function(p) {
          this.$highlightGutterLine = p;
        }, h.prototype.setShowLineNumbers = function(p) {
          this.$renderer = !p && {
            getWidth: function() {
              return 0;
            },
            getText: function() {
              return "";
            }
          };
        }, h.prototype.getShowLineNumbers = function() {
          return this.$showLineNumbers;
        }, h.prototype.setShowFoldWidgets = function(p) {
          p ? o.addCssClass(this.element, "ace_folding-enabled") : o.removeCssClass(this.element, "ace_folding-enabled"), this.$showFoldWidgets = p, this.$padding = null;
        }, h.prototype.getShowFoldWidgets = function() {
          return this.$showFoldWidgets;
        }, h.prototype.$computePadding = function() {
          if (!this.element.firstChild)
            return { left: 0, right: 0 };
          var p = o.computedStyle(
            /**@type{Element}*/
            this.element.firstChild
          );
          return this.$padding = {}, this.$padding.left = (parseInt(p.borderLeftWidth) || 0) + (parseInt(p.paddingLeft) || 0) + 1, this.$padding.right = (parseInt(p.borderRightWidth) || 0) + (parseInt(p.paddingRight) || 0), this.$padding;
        }, h.prototype.getRegion = function(p) {
          var g = this.$padding || this.$computePadding(), m = this.element.getBoundingClientRect();
          if (p.x < g.left + m.left)
            return "markers";
          if (this.$showFoldWidgets && p.x > m.right - g.right)
            return "foldWidgets";
        }, h;
      }()
    );
    d.prototype.$fixedWidth = !1, d.prototype.$highlightGutterLine = !0, d.prototype.$renderer = "", d.prototype.$showLineNumbers = !0, d.prototype.$showFoldWidgets = !0, s.implement(d.prototype, l);
    function f(h) {
      var p = document.createTextNode("");
      h.appendChild(p);
      var g = o.createElement("span");
      h.appendChild(g);
      var m = o.createElement("span");
      h.appendChild(m);
      var v = o.createElement("span");
      return m.appendChild(v), h;
    }
    r.Gutter = d;
  }), ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function(n, r, i) {
    var o = n("../range").Range, s = n("../lib/dom"), a = (
      /** @class */
      function() {
        function u(c) {
          this.element = s.createElement("div"), this.element.className = "ace_layer ace_marker-layer", c.appendChild(this.element);
        }
        return u.prototype.setPadding = function(c) {
          this.$padding = c;
        }, u.prototype.setSession = function(c) {
          this.session = c;
        }, u.prototype.setMarkers = function(c) {
          this.markers = c;
        }, u.prototype.elt = function(c, d) {
          var f = this.i != -1 && this.element.childNodes[this.i];
          f ? this.i++ : (f = document.createElement("div"), this.element.appendChild(f), this.i = -1), f.style.cssText = d, f.className = c;
        }, u.prototype.update = function(c) {
          if (c) {
            this.config = c, this.i = 0;
            var d;
            for (var f in this.markers) {
              var h = this.markers[f];
              if (!h.range) {
                h.update(d, this, this.session, c);
                continue;
              }
              var p = h.range.clipRows(c.firstRow, c.lastRow);
              if (!p.isEmpty())
                if (p = p.toScreenRange(this.session), h.renderer) {
                  var g = this.$getTop(p.start.row, c), m = this.$padding + p.start.column * c.characterWidth;
                  h.renderer(d, p, m, g, c);
                } else
                  h.type == "fullLine" ? this.drawFullLineMarker(d, p, h.clazz, c) : h.type == "screenLine" ? this.drawScreenLineMarker(d, p, h.clazz, c) : p.isMultiLine() ? h.type == "text" ? this.drawTextMarker(d, p, h.clazz, c) : this.drawMultiLineMarker(d, p, h.clazz, c) : this.drawSingleLineMarker(d, p, h.clazz + " ace_start ace_br15", c);
            }
            if (this.i != -1)
              for (; this.i < this.element.childElementCount; )
                this.element.removeChild(this.element.lastChild);
          }
        }, u.prototype.$getTop = function(c, d) {
          return (c - d.firstRowScreen) * d.lineHeight;
        }, u.prototype.drawTextMarker = function(c, d, f, h, p) {
          for (var g = this.session, m = d.start.row, v = d.end.row, b = m, x = 0, w = 0, C = g.getScreenLastRowColumn(b), y = new o(b, d.start.column, b, w); b <= v; b++)
            y.start.row = y.end.row = b, y.start.column = b == m ? d.start.column : g.getRowWrapIndent(b), y.end.column = C, x = w, w = C, C = b + 1 < v ? g.getScreenLastRowColumn(b + 1) : b == v ? 0 : d.end.column, this.drawSingleLineMarker(c, y, f + (b == m ? " ace_start" : "") + " ace_br" + l(b == m || b == m + 1 && d.start.column, x < w, w > C, b == v), h, b == v ? 0 : 1, p);
        }, u.prototype.drawMultiLineMarker = function(c, d, f, h, p) {
          var g = this.$padding, m = h.lineHeight, v = this.$getTop(d.start.row, h), b = g + d.start.column * h.characterWidth;
          if (p = p || "", this.session.$bidiHandler.isBidiRow(d.start.row)) {
            var x = d.clone();
            x.end.row = x.start.row, x.end.column = this.session.getLine(x.start.row).length, this.drawBidiSingleLineMarker(c, x, f + " ace_br1 ace_start", h, null, p);
          } else
            this.elt(f + " ace_br1 ace_start", "height:" + m + "px;right:0;top:" + v + "px;left:" + b + "px;" + (p || ""));
          if (this.session.$bidiHandler.isBidiRow(d.end.row)) {
            var x = d.clone();
            x.start.row = x.end.row, x.start.column = 0, this.drawBidiSingleLineMarker(c, x, f + " ace_br12", h, null, p);
          } else {
            v = this.$getTop(d.end.row, h);
            var w = d.end.column * h.characterWidth;
            this.elt(f + " ace_br12", "height:" + m + "px;width:" + w + "px;top:" + v + "px;left:" + g + "px;" + (p || ""));
          }
          if (m = (d.end.row - d.start.row - 1) * h.lineHeight, !(m <= 0)) {
            v = this.$getTop(d.start.row + 1, h);
            var C = (d.start.column ? 1 : 0) | (d.end.column ? 0 : 8);
            this.elt(f + (C ? " ace_br" + C : ""), "height:" + m + "px;right:0;top:" + v + "px;left:" + g + "px;" + (p || ""));
          }
        }, u.prototype.drawSingleLineMarker = function(c, d, f, h, p, g) {
          if (this.session.$bidiHandler.isBidiRow(d.start.row))
            return this.drawBidiSingleLineMarker(c, d, f, h, p, g);
          var m = h.lineHeight, v = (d.end.column + (p || 0) - d.start.column) * h.characterWidth, b = this.$getTop(d.start.row, h), x = this.$padding + d.start.column * h.characterWidth;
          this.elt(f, "height:" + m + "px;width:" + v + "px;top:" + b + "px;left:" + x + "px;" + (g || ""));
        }, u.prototype.drawBidiSingleLineMarker = function(c, d, f, h, p, g) {
          var m = h.lineHeight, v = this.$getTop(d.start.row, h), b = this.$padding, x = this.session.$bidiHandler.getSelections(d.start.column, d.end.column);
          x.forEach(function(w) {
            this.elt(f, "height:" + m + "px;width:" + (w.width + (p || 0)) + "px;top:" + v + "px;left:" + (b + w.left) + "px;" + (g || ""));
          }, this);
        }, u.prototype.drawFullLineMarker = function(c, d, f, h, p) {
          var g = this.$getTop(d.start.row, h), m = h.lineHeight;
          d.start.row != d.end.row && (m += this.$getTop(d.end.row, h) - g), this.elt(f, "height:" + m + "px;top:" + g + "px;left:0;right:0;" + (p || ""));
        }, u.prototype.drawScreenLineMarker = function(c, d, f, h, p) {
          var g = this.$getTop(d.start.row, h), m = h.lineHeight;
          this.elt(f, "height:" + m + "px;top:" + g + "px;left:0;right:0;" + (p || ""));
        }, u;
      }()
    );
    a.prototype.$padding = 0;
    function l(u, c, d, f) {
      return (u ? 1 : 0) | (c ? 2 : 0) | (d ? 4 : 0) | (f ? 8 : 0);
    }
    r.Marker = a;
  }), ace.define("ace/layer/text_util", ["require", "exports", "module"], function(n, r, i) {
    var o = /* @__PURE__ */ new Set(["text", "rparen", "lparen"]);
    r.isTextToken = function(s) {
      return o.has(s);
    };
  }), ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/layer/lines", "ace/lib/event_emitter", "ace/config", "ace/layer/text_util"], function(n, r, i) {
    var o = n("../lib/oop"), s = n("../lib/dom"), a = n("../lib/lang"), l = n("./lines").Lines, u = n("../lib/event_emitter").EventEmitter, c = n("../config").nls, d = n("./text_util").isTextToken, f = (
      /** @class */
      function() {
        function h(p) {
          this.dom = s, this.element = this.dom.createElement("div"), this.element.className = "ace_layer ace_text-layer", p.appendChild(this.element), this.$updateEolChar = this.$updateEolChar.bind(this), this.$lines = new l(this.element);
        }
        return h.prototype.$updateEolChar = function() {
          var p = this.session.doc, g = p.getNewLineCharacter() == `
` && p.getNewLineMode() != "windows", m = g ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
          if (this.EOL_CHAR != m)
            return this.EOL_CHAR = m, !0;
        }, h.prototype.setPadding = function(p) {
          this.$padding = p, this.element.style.margin = "0 " + p + "px";
        }, h.prototype.getLineHeight = function() {
          return this.$fontMetrics.$characterSize.height || 0;
        }, h.prototype.getCharacterWidth = function() {
          return this.$fontMetrics.$characterSize.width || 0;
        }, h.prototype.$setFontMetrics = function(p) {
          this.$fontMetrics = p, this.$fontMetrics.on(
            "changeCharacterSize",
            (function(g) {
              this._signal("changeCharacterSize", g);
            }).bind(this)
          ), this.$pollSizeChanges();
        }, h.prototype.checkForSizeChanges = function() {
          this.$fontMetrics.checkForSizeChanges();
        }, h.prototype.$pollSizeChanges = function() {
          return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
        }, h.prototype.setSession = function(p) {
          this.session = p, p && this.$computeTabString();
        }, h.prototype.setShowInvisibles = function(p) {
          return this.showInvisibles == p ? !1 : (this.showInvisibles = p, typeof p == "string" ? (this.showSpaces = /tab/i.test(p), this.showTabs = /space/i.test(p), this.showEOL = /eol/i.test(p)) : this.showSpaces = this.showTabs = this.showEOL = p, this.$computeTabString(), !0);
        }, h.prototype.setDisplayIndentGuides = function(p) {
          return this.displayIndentGuides == p ? !1 : (this.displayIndentGuides = p, this.$computeTabString(), !0);
        }, h.prototype.setHighlightIndentGuides = function(p) {
          return this.$highlightIndentGuides === p ? !1 : (this.$highlightIndentGuides = p, p);
        }, h.prototype.$computeTabString = function() {
          var p = this.session.getTabSize();
          this.tabSize = p;
          for (var g = this.$tabStrings = [0], m = 1; m < p + 1; m++)
            if (this.showTabs) {
              var v = this.dom.createElement("span");
              v.className = "ace_invisible ace_invisible_tab", v.textContent = a.stringRepeat(this.TAB_CHAR, m), g.push(v);
            } else
              g.push(this.dom.createTextNode(a.stringRepeat(" ", m), this.element));
          if (this.displayIndentGuides) {
            this.$indentGuideRe = /\s\S| \t|\t |\s$/;
            var b = "ace_indent-guide", x = this.showSpaces ? " ace_invisible ace_invisible_space" : "", w = this.showSpaces ? a.stringRepeat(this.SPACE_CHAR, this.tabSize) : a.stringRepeat(" ", this.tabSize), C = this.showTabs ? " ace_invisible ace_invisible_tab" : "", y = this.showTabs ? a.stringRepeat(this.TAB_CHAR, this.tabSize) : w, v = this.dom.createElement("span");
            v.className = b + x, v.textContent = w, this.$tabStrings[" "] = v;
            var v = this.dom.createElement("span");
            v.className = b + C, v.textContent = y, this.$tabStrings["	"] = v;
          }
        }, h.prototype.updateLines = function(p, g, m) {
          if (this.config.lastRow != p.lastRow || this.config.firstRow != p.firstRow)
            return this.update(p);
          this.config = p;
          for (var v = Math.max(g, p.firstRow), b = Math.min(m, p.lastRow), x = this.element.childNodes, w = 0, y = p.firstRow; y < v; y++) {
            var S = this.session.getFoldLine(y);
            if (S)
              if (S.containsRow(v)) {
                v = S.start.row;
                break;
              } else
                y = S.end.row;
            w++;
          }
          for (var C = !1, y = v, S = this.session.getNextFoldLine(y), A = S ? S.start.row : 1 / 0; y > A && (y = S.end.row + 1, S = this.session.getNextFoldLine(y, S), A = S ? S.start.row : 1 / 0), !(y > b); ) {
            var $ = x[w++];
            if ($) {
              this.dom.removeChildren($), this.$renderLine($, y, y == A ? S : !1), C && ($.style.top = this.$lines.computeLineTop(y, p, this.session) + "px");
              var M = p.lineHeight * this.session.getRowLength(y) + "px";
              $.style.height != M && (C = !0, $.style.height = M);
            }
            y++;
          }
          if (C)
            for (; w < this.$lines.cells.length; ) {
              var _ = this.$lines.cells[w++];
              _.element.style.top = this.$lines.computeLineTop(_.row, p, this.session) + "px";
            }
        }, h.prototype.scrollLines = function(p) {
          var g = this.config;
          if (this.config = p, this.$lines.pageChanged(g, p))
            return this.update(p);
          this.$lines.moveContainer(p);
          var m = p.lastRow, v = g ? g.lastRow : -1;
          if (!g || v < p.firstRow)
            return this.update(p);
          if (m < g.firstRow)
            return this.update(p);
          if (!g || g.lastRow < p.firstRow)
            return this.update(p);
          if (p.lastRow < g.firstRow)
            return this.update(p);
          if (g.firstRow < p.firstRow)
            for (var b = this.session.getFoldedRowCount(g.firstRow, p.firstRow - 1); b > 0; b--)
              this.$lines.shift();
          if (g.lastRow > p.lastRow)
            for (var b = this.session.getFoldedRowCount(p.lastRow + 1, g.lastRow); b > 0; b--)
              this.$lines.pop();
          p.firstRow < g.firstRow && this.$lines.unshift(this.$renderLinesFragment(p, p.firstRow, g.firstRow - 1)), p.lastRow > g.lastRow && this.$lines.push(this.$renderLinesFragment(p, g.lastRow + 1, p.lastRow)), this.$highlightIndentGuide();
        }, h.prototype.$renderLinesFragment = function(p, g, m) {
          for (var v = [], b = g, x = this.session.getNextFoldLine(b), w = x ? x.start.row : 1 / 0; b > w && (b = x.end.row + 1, x = this.session.getNextFoldLine(b, x), w = x ? x.start.row : 1 / 0), !(b > m); ) {
            var C = this.$lines.createCell(b, p, this.session), y = C.element;
            this.dom.removeChildren(y), s.setStyle(y.style, "height", this.$lines.computeLineHeight(b, p, this.session) + "px"), s.setStyle(y.style, "top", this.$lines.computeLineTop(b, p, this.session) + "px"), this.$renderLine(y, b, b == w ? x : !1), this.$useLineGroups() ? y.className = "ace_line_group" : y.className = "ace_line", v.push(C), b++;
          }
          return v;
        }, h.prototype.update = function(p) {
          this.$lines.moveContainer(p), this.config = p;
          for (var g = p.firstRow, m = p.lastRow, v = this.$lines; v.getLength(); )
            v.pop();
          v.push(this.$renderLinesFragment(p, g, m));
        }, h.prototype.$renderToken = function(p, g, m, v) {
          for (var b = this, x = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g, w = this.dom.createFragment(this.element), C, y = 0; C = x.exec(v); ) {
            var S = C[1], A = C[2], $ = C[3], M = C[4], _ = C[5];
            if (!(!b.showSpaces && A)) {
              var T = y != C.index ? v.slice(y, C.index) : "";
              if (y = C.index + C[0].length, T && w.appendChild(this.dom.createTextNode(T, this.element)), S) {
                var D = b.session.getScreenTabSize(g + C.index);
                w.appendChild(b.$tabStrings[D].cloneNode(!0)), g += D - 1;
              } else if (A)
                if (b.showSpaces) {
                  var E = this.dom.createElement("span");
                  E.className = "ace_invisible ace_invisible_space", E.textContent = a.stringRepeat(b.SPACE_CHAR, A.length), w.appendChild(E);
                } else
                  w.appendChild(this.dom.createTextNode(A, this.element));
              else if ($) {
                var E = this.dom.createElement("span");
                E.className = "ace_invisible ace_invisible_space ace_invalid", E.textContent = a.stringRepeat(b.SPACE_CHAR, $.length), w.appendChild(E);
              } else if (M) {
                g += 1;
                var E = this.dom.createElement("span");
                E.style.width = b.config.characterWidth * 2 + "px", E.className = b.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk", E.textContent = b.showSpaces ? b.SPACE_CHAR : M, w.appendChild(E);
              } else if (_) {
                g += 1;
                var E = this.dom.createElement("span");
                E.style.width = b.config.characterWidth * 2 + "px", E.className = "ace_cjk", E.textContent = _, w.appendChild(E);
              }
            }
          }
          if (w.appendChild(this.dom.createTextNode(y ? v.slice(y) : v, this.element)), d(m.type))
            p.appendChild(w);
          else {
            var R = "ace_" + m.type.replace(/\./g, " ace_"), E = this.dom.createElement("span");
            m.type == "fold" && (E.style.width = m.value.length * this.config.characterWidth + "px", E.setAttribute("title", c("inline-fold.closed.title", "Unfold code"))), E.className = R, E.appendChild(w), p.appendChild(E);
          }
          return g + v.length;
        }, h.prototype.renderIndentGuide = function(p, g, m) {
          var v = g.search(this.$indentGuideRe);
          if (v <= 0 || v >= m)
            return g;
          if (g[0] == " ") {
            v -= v % this.tabSize;
            for (var b = v / this.tabSize, x = 0; x < b; x++)
              p.appendChild(this.$tabStrings[" "].cloneNode(!0));
            return this.$highlightIndentGuide(), g.substr(v);
          } else if (g[0] == "	") {
            for (var x = 0; x < v; x++)
              p.appendChild(this.$tabStrings["	"].cloneNode(!0));
            return this.$highlightIndentGuide(), g.substr(v);
          }
          return this.$highlightIndentGuide(), g;
        }, h.prototype.$highlightIndentGuide = function() {
          if (!(!this.$highlightIndentGuides || !this.displayIndentGuides)) {
            this.$highlightIndentGuideMarker = {
              indentLevel: void 0,
              start: void 0,
              end: void 0,
              dir: void 0
            };
            var p = this.session.doc.$lines;
            if (p) {
              var g = this.session.selection.getCursor(), m = /^\s*/.exec(this.session.doc.getLine(g.row))[0].length, v = Math.floor(m / this.tabSize);
              this.$highlightIndentGuideMarker = {
                indentLevel: v,
                start: g.row
              };
              var b = this.session.$bracketHighlight;
              if (b) {
                for (var x = this.session.$bracketHighlight.ranges, w = 0; w < x.length; w++)
                  if (g.row !== x[w].start.row) {
                    this.$highlightIndentGuideMarker.end = x[w].start.row, g.row > x[w].start.row ? this.$highlightIndentGuideMarker.dir = -1 : this.$highlightIndentGuideMarker.dir = 1;
                    break;
                  }
              }
              if (!this.$highlightIndentGuideMarker.end && p[g.row] !== "" && g.column === p[g.row].length) {
                this.$highlightIndentGuideMarker.dir = 1;
                for (var w = g.row + 1; w < p.length; w++) {
                  var C = p[w], y = /^\s*/.exec(C)[0].length;
                  if (C !== "" && (this.$highlightIndentGuideMarker.end = w, y <= m))
                    break;
                }
              }
              this.$renderHighlightIndentGuide();
            }
          }
        }, h.prototype.$clearActiveIndentGuide = function() {
          for (var p = this.$lines.cells, g = 0; g < p.length; g++) {
            var m = p[g], v = m.element.childNodes;
            if (v.length > 0) {
              for (var b = 0; b < v.length; b++)
                if (v[b].classList && v[b].classList.contains("ace_indent-guide-active")) {
                  v[b].classList.remove("ace_indent-guide-active");
                  break;
                }
            }
          }
        }, h.prototype.$setIndentGuideActive = function(p, g) {
          var m = this.session.doc.getLine(p.row);
          if (m !== "") {
            var v = p.element.childNodes;
            if (v) {
              var b = v[g - 1];
              b && b.classList && b.classList.contains("ace_indent-guide") && b.classList.add("ace_indent-guide-active");
            }
          }
        }, h.prototype.$renderHighlightIndentGuide = function() {
          if (this.$lines) {
            var p = this.$lines.cells;
            this.$clearActiveIndentGuide();
            var g = this.$highlightIndentGuideMarker.indentLevel;
            if (g !== 0)
              if (this.$highlightIndentGuideMarker.dir === 1)
                for (var m = 0; m < p.length; m++) {
                  var v = p[m];
                  if (this.$highlightIndentGuideMarker.end && v.row >= this.$highlightIndentGuideMarker.start + 1) {
                    if (v.row >= this.$highlightIndentGuideMarker.end)
                      break;
                    this.$setIndentGuideActive(v, g);
                  }
                }
              else
                for (var m = p.length - 1; m >= 0; m--) {
                  var v = p[m];
                  if (this.$highlightIndentGuideMarker.end && v.row < this.$highlightIndentGuideMarker.start) {
                    if (v.row <= this.$highlightIndentGuideMarker.end)
                      break;
                    this.$setIndentGuideActive(v, g);
                  }
                }
          }
        }, h.prototype.$createLineElement = function(p) {
          var g = this.dom.createElement("div");
          return g.className = "ace_line", g.style.height = this.config.lineHeight + "px", g;
        }, h.prototype.$renderWrappedLine = function(p, g, m) {
          var v = 0, b = 0, x = m[0], w = 0, C = this.$createLineElement();
          p.appendChild(C);
          for (var y = 0; y < g.length; y++) {
            var S = g[y], A = S.value;
            if (y == 0 && this.displayIndentGuides) {
              if (v = A.length, A = this.renderIndentGuide(C, A, x), !A)
                continue;
              v -= A.length;
            }
            if (v + A.length < x)
              w = this.$renderToken(C, w, S, A), v += A.length;
            else {
              for (; v + A.length >= x; )
                w = this.$renderToken(C, w, S, A.substring(0, x - v)), A = A.substring(x - v), v = x, C = this.$createLineElement(), p.appendChild(C), C.appendChild(this.dom.createTextNode(a.stringRepeat("", m.indent), this.element)), b++, w = 0, x = m[b] || Number.MAX_VALUE;
              A.length != 0 && (v += A.length, w = this.$renderToken(C, w, S, A));
            }
          }
          m[m.length - 1] > this.MAX_LINE_LENGTH && this.$renderOverflowMessage(C, w, null, "", !0);
        }, h.prototype.$renderSimpleLine = function(p, g) {
          for (var m = 0, v = 0; v < g.length; v++) {
            var b = g[v], x = b.value;
            if (!(v == 0 && this.displayIndentGuides && (x = this.renderIndentGuide(p, x), !x))) {
              if (m + x.length > this.MAX_LINE_LENGTH)
                return this.$renderOverflowMessage(p, m, b, x);
              m = this.$renderToken(p, m, b, x);
            }
          }
        }, h.prototype.$renderOverflowMessage = function(p, g, m, v, b) {
          m && this.$renderToken(p, g, m, v.slice(0, this.MAX_LINE_LENGTH - g));
          var x = this.dom.createElement("span");
          x.className = "ace_inline_button ace_keyword ace_toggle_wrap", x.textContent = b ? "<hide>" : "<click to see more...>", p.appendChild(x);
        }, h.prototype.$renderLine = function(p, g, m) {
          if (!m && m != !1 && (m = this.session.getFoldLine(g)), m)
            var v = this.$getFoldLineTokens(g, m);
          else
            var v = this.session.getTokens(g);
          var b = p;
          if (v.length) {
            var x = this.session.getRowSplitData(g);
            if (x && x.length) {
              this.$renderWrappedLine(p, v, x);
              var b = p.lastChild;
            } else {
              var b = p;
              this.$useLineGroups() && (b = this.$createLineElement(), p.appendChild(b)), this.$renderSimpleLine(b, v);
            }
          } else
            this.$useLineGroups() && (b = this.$createLineElement(), p.appendChild(b));
          if (this.showEOL && b) {
            m && (g = m.end.row);
            var w = this.dom.createElement("span");
            w.className = "ace_invisible ace_invisible_eol", w.textContent = g == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR, b.appendChild(w);
          }
        }, h.prototype.$getFoldLineTokens = function(p, g) {
          var m = this.session, v = [];
          function b(w, C, y) {
            for (var S = 0, A = 0; A + w[S].value.length < C; )
              if (A += w[S].value.length, S++, S == w.length)
                return;
            if (A != C) {
              var $ = w[S].value.substring(C - A);
              $.length > y - C && ($ = $.substring(0, y - C)), v.push({
                type: w[S].type,
                value: $
              }), A = C + $.length, S += 1;
            }
            for (; A < y && S < w.length; ) {
              var $ = w[S].value;
              $.length + A > y ? v.push({
                type: w[S].type,
                value: $.substring(0, y - A)
              }) : v.push(w[S]), A += $.length, S += 1;
            }
          }
          var x = m.getTokens(p);
          return g.walk(function(w, C, y, S, A) {
            w != null ? v.push({
              type: "fold",
              value: w
            }) : (A && (x = m.getTokens(C)), x.length && b(x, S, y));
          }, g.end.row, this.session.getLine(g.end.row).length), v;
        }, h.prototype.$useLineGroups = function() {
          return this.session.getUseWrapMode();
        }, h;
      }()
    );
    f.prototype.EOF_CHAR = "", f.prototype.EOL_CHAR_LF = "", f.prototype.EOL_CHAR_CRLF = "", f.prototype.EOL_CHAR = f.prototype.EOL_CHAR_LF, f.prototype.TAB_CHAR = "", f.prototype.SPACE_CHAR = "", f.prototype.$padding = 0, f.prototype.MAX_LINE_LENGTH = 1e4, f.prototype.showInvisibles = !1, f.prototype.showSpaces = !1, f.prototype.showTabs = !1, f.prototype.showEOL = !1, f.prototype.displayIndentGuides = !0, f.prototype.$highlightIndentGuides = !0, f.prototype.$tabStrings = [], f.prototype.destroy = {}, f.prototype.onChangeTabSize = f.prototype.$computeTabString, o.implement(f.prototype, u), r.Text = f;
  }), ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function(n, r, i) {
    var o = n("../lib/dom"), s = (
      /** @class */
      function() {
        function a(l) {
          this.element = o.createElement("div"), this.element.className = "ace_layer ace_cursor-layer", l.appendChild(this.element), this.isVisible = !1, this.isBlinking = !0, this.blinkInterval = 1e3, this.smoothBlinking = !1, this.cursors = [], this.cursor = this.addCursor(), o.addCssClass(this.element, "ace_hidden-cursors"), this.$updateCursors = this.$updateOpacity.bind(this);
        }
        return a.prototype.$updateOpacity = function(l) {
          for (var u = this.cursors, c = u.length; c--; )
            o.setStyle(u[c].style, "opacity", l ? "" : "0");
        }, a.prototype.$startCssAnimation = function() {
          for (var l = this.cursors, u = l.length; u--; )
            l[u].style.animationDuration = this.blinkInterval + "ms";
          this.$isAnimating = !0, setTimeout((function() {
            this.$isAnimating && o.addCssClass(this.element, "ace_animate-blinking");
          }).bind(this));
        }, a.prototype.$stopCssAnimation = function() {
          this.$isAnimating = !1, o.removeCssClass(this.element, "ace_animate-blinking");
        }, a.prototype.setPadding = function(l) {
          this.$padding = l;
        }, a.prototype.setSession = function(l) {
          this.session = l;
        }, a.prototype.setBlinking = function(l) {
          l != this.isBlinking && (this.isBlinking = l, this.restartTimer());
        }, a.prototype.setBlinkInterval = function(l) {
          l != this.blinkInterval && (this.blinkInterval = l, this.restartTimer());
        }, a.prototype.setSmoothBlinking = function(l) {
          l != this.smoothBlinking && (this.smoothBlinking = l, o.setCssClass(this.element, "ace_smooth-blinking", l), this.$updateCursors(!0), this.restartTimer());
        }, a.prototype.addCursor = function() {
          var l = o.createElement("div");
          return l.className = "ace_cursor", this.element.appendChild(l), this.cursors.push(l), l;
        }, a.prototype.removeCursor = function() {
          if (this.cursors.length > 1) {
            var l = this.cursors.pop();
            return l.parentNode.removeChild(l), l;
          }
        }, a.prototype.hideCursor = function() {
          this.isVisible = !1, o.addCssClass(this.element, "ace_hidden-cursors"), this.restartTimer();
        }, a.prototype.showCursor = function() {
          this.isVisible = !0, o.removeCssClass(this.element, "ace_hidden-cursors"), this.restartTimer();
        }, a.prototype.restartTimer = function() {
          var l = this.$updateCursors;
          if (clearInterval(this.intervalId), clearTimeout(this.timeoutId), this.$stopCssAnimation(), this.smoothBlinking && (this.$isSmoothBlinking = !1, o.removeCssClass(this.element, "ace_smooth-blinking")), l(!0), !this.isBlinking || !this.blinkInterval || !this.isVisible) {
            this.$stopCssAnimation();
            return;
          }
          if (this.smoothBlinking && (this.$isSmoothBlinking = !0, setTimeout((function() {
            this.$isSmoothBlinking && o.addCssClass(this.element, "ace_smooth-blinking");
          }).bind(this))), o.HAS_CSS_ANIMATION)
            this.$startCssAnimation();
          else {
            var u = (
              /**@this{Cursor}*/
              (function() {
                this.timeoutId = setTimeout(function() {
                  l(!1);
                }, 0.6 * this.blinkInterval);
              }).bind(this)
            );
            this.intervalId = setInterval(function() {
              l(!0), u();
            }, this.blinkInterval), u();
          }
        }, a.prototype.getPixelPosition = function(l, u) {
          if (!this.config || !this.session)
            return { left: 0, top: 0 };
          l || (l = this.session.selection.getCursor());
          var c = this.session.documentToScreenPosition(l), d = this.$padding + (this.session.$bidiHandler.isBidiRow(c.row, l.row) ? this.session.$bidiHandler.getPosLeft(c.column) : c.column * this.config.characterWidth), f = (c.row - (u ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
          return { left: d, top: f };
        }, a.prototype.isCursorInView = function(l, u) {
          return l.top >= 0 && l.top < u.maxHeight;
        }, a.prototype.update = function(l) {
          this.config = l;
          var u = this.session.$selectionMarkers, c = 0, d = 0;
          (u === void 0 || u.length === 0) && (u = [{ cursor: null }]);
          for (var c = 0, f = u.length; c < f; c++) {
            var h = this.getPixelPosition(u[c].cursor, !0);
            if (!((h.top > l.height + l.offset || h.top < 0) && c > 1)) {
              var p = this.cursors[d++] || this.addCursor(), g = p.style;
              this.drawCursor ? this.drawCursor(p, h, l, u[c], this.session) : this.isCursorInView(h, l) ? (o.setStyle(g, "display", "block"), o.translate(p, h.left, h.top), o.setStyle(g, "width", Math.round(l.characterWidth) + "px"), o.setStyle(g, "height", l.lineHeight + "px")) : o.setStyle(g, "display", "none");
            }
          }
          for (; this.cursors.length > d; )
            this.removeCursor();
          var m = this.session.getOverwrite();
          this.$setOverwrite(m), this.$pixelPos = h, this.restartTimer();
        }, a.prototype.$setOverwrite = function(l) {
          l != this.overwrite && (this.overwrite = l, l ? o.addCssClass(this.element, "ace_overwrite-cursors") : o.removeCssClass(this.element, "ace_overwrite-cursors"));
        }, a.prototype.destroy = function() {
          clearInterval(this.intervalId), clearTimeout(this.timeoutId);
        }, a;
      }()
    );
    s.prototype.$padding = 0, s.prototype.drawCursor = null, r.Cursor = s;
  }), ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(n, r, i) {
    var o = this && this.__extends || /* @__PURE__ */ function() {
      var p = function(g, m) {
        return p = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(v, b) {
          v.__proto__ = b;
        } || function(v, b) {
          for (var x in b)
            Object.prototype.hasOwnProperty.call(b, x) && (v[x] = b[x]);
        }, p(g, m);
      };
      return function(g, m) {
        if (typeof m != "function" && m !== null)
          throw new TypeError("Class extends value " + String(m) + " is not a constructor or null");
        p(g, m);
        function v() {
          this.constructor = g;
        }
        g.prototype = m === null ? Object.create(m) : (v.prototype = m.prototype, new v());
      };
    }(), s = n("./lib/oop"), a = n("./lib/dom"), l = n("./lib/event"), u = n("./lib/event_emitter").EventEmitter, c = 32768, d = (
      /** @class */
      function() {
        function p(g, m) {
          this.element = a.createElement("div"), this.element.className = "ace_scrollbar ace_scrollbar" + m, this.inner = a.createElement("div"), this.inner.className = "ace_scrollbar-inner", this.inner.textContent = "", this.element.appendChild(this.inner), g.appendChild(this.element), this.setVisible(!1), this.skipEvent = !1, l.addListener(this.element, "scroll", this.onScroll.bind(this)), l.addListener(this.element, "mousedown", l.preventDefault);
        }
        return p.prototype.setVisible = function(g) {
          this.element.style.display = g ? "" : "none", this.isVisible = g, this.coeff = 1;
        }, p;
      }()
    );
    s.implement(d.prototype, u);
    var f = (
      /** @class */
      function(p) {
        o(g, p);
        function g(m, v) {
          var b = p.call(this, m, "-v") || this;
          return b.scrollTop = 0, b.scrollHeight = 0, v.$scrollbarWidth = b.width = a.scrollbarWidth(m.ownerDocument), b.inner.style.width = b.element.style.width = (b.width || 15) + 5 + "px", b.$minWidth = 0, b;
        }
        return g.prototype.onScroll = function() {
          if (!this.skipEvent) {
            if (this.scrollTop = this.element.scrollTop, this.coeff != 1) {
              var m = this.element.clientHeight / this.scrollHeight;
              this.scrollTop = this.scrollTop * (1 - m) / (this.coeff - m);
            }
            this._emit("scroll", { data: this.scrollTop });
          }
          this.skipEvent = !1;
        }, g.prototype.getWidth = function() {
          return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
        }, g.prototype.setHeight = function(m) {
          this.element.style.height = m + "px";
        }, g.prototype.setScrollHeight = function(m) {
          this.scrollHeight = m, m > c ? (this.coeff = c / m, m = c) : this.coeff != 1 && (this.coeff = 1), this.inner.style.height = m + "px";
        }, g.prototype.setScrollTop = function(m) {
          this.scrollTop != m && (this.skipEvent = !0, this.scrollTop = m, this.element.scrollTop = m * this.coeff);
        }, g;
      }(d)
    );
    f.prototype.setInnerHeight = f.prototype.setScrollHeight;
    var h = (
      /** @class */
      function(p) {
        o(g, p);
        function g(m, v) {
          var b = p.call(this, m, "-h") || this;
          return b.scrollLeft = 0, b.height = v.$scrollbarWidth, b.inner.style.height = b.element.style.height = (b.height || 15) + 5 + "px", b;
        }
        return g.prototype.onScroll = function() {
          this.skipEvent || (this.scrollLeft = this.element.scrollLeft, this._emit("scroll", { data: this.scrollLeft })), this.skipEvent = !1;
        }, g.prototype.getHeight = function() {
          return this.isVisible ? this.height : 0;
        }, g.prototype.setWidth = function(m) {
          this.element.style.width = m + "px";
        }, g.prototype.setInnerWidth = function(m) {
          this.inner.style.width = m + "px";
        }, g.prototype.setScrollWidth = function(m) {
          this.inner.style.width = m + "px";
        }, g.prototype.setScrollLeft = function(m) {
          this.scrollLeft != m && (this.skipEvent = !0, this.scrollLeft = this.element.scrollLeft = m);
        }, g;
      }(d)
    );
    r.ScrollBar = f, r.ScrollBarV = f, r.ScrollBarH = h, r.VScrollBar = f, r.HScrollBar = h;
  }), ace.define("ace/scrollbar_custom", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(n, r, i) {
    var o = this && this.__extends || /* @__PURE__ */ function() {
      var h = function(p, g) {
        return h = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(m, v) {
          m.__proto__ = v;
        } || function(m, v) {
          for (var b in v)
            Object.prototype.hasOwnProperty.call(v, b) && (m[b] = v[b]);
        }, h(p, g);
      };
      return function(p, g) {
        if (typeof g != "function" && g !== null)
          throw new TypeError("Class extends value " + String(g) + " is not a constructor or null");
        h(p, g);
        function m() {
          this.constructor = p;
        }
        p.prototype = g === null ? Object.create(g) : (m.prototype = g.prototype, new m());
      };
    }(), s = n("./lib/oop"), a = n("./lib/dom"), l = n("./lib/event"), u = n("./lib/event_emitter").EventEmitter;
    a.importCssString(`.ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{
  position: absolute;
  background: rgba(128, 128, 128, 0.6);
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  border: 1px solid #bbb;
  border-radius: 2px;
  z-index: 8;
}
.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {
  position: absolute;
  z-index: 6;
  background: none;
  overflow: hidden!important;
}
.ace_editor>.ace_sb-v {
  z-index: 6;
  right: 0;
  top: 0;
  width: 12px;
}
.ace_editor>.ace_sb-v div {
  z-index: 8;
  right: 0;
  width: 100%;
}
.ace_editor>.ace_sb-h {
  bottom: 0;
  left: 0;
  height: 12px;
}
.ace_editor>.ace_sb-h div {
  bottom: 0;
  height: 100%;
}
.ace_editor>.ace_sb_grabbed {
  z-index: 8;
  background: #000;
}`, "ace_scrollbar.css", !1);
    var c = (
      /** @class */
      function() {
        function h(p, g) {
          this.element = a.createElement("div"), this.element.className = "ace_sb" + g, this.inner = a.createElement("div"), this.inner.className = "", this.element.appendChild(this.inner), this.VScrollWidth = 12, this.HScrollHeight = 12, p.appendChild(this.element), this.setVisible(!1), this.skipEvent = !1, l.addMultiMouseDownListener(this.element, [500, 300, 300], this, "onMouseDown");
        }
        return h.prototype.setVisible = function(p) {
          this.element.style.display = p ? "" : "none", this.isVisible = p, this.coeff = 1;
        }, h;
      }()
    );
    s.implement(c.prototype, u);
    var d = (
      /** @class */
      function(h) {
        o(p, h);
        function p(g, m) {
          var v = h.call(this, g, "-v") || this;
          return v.scrollTop = 0, v.scrollHeight = 0, v.parent = g, v.width = v.VScrollWidth, v.renderer = m, v.inner.style.width = v.element.style.width = (v.width || 15) + "px", v.$minWidth = 0, v;
        }
        return p.prototype.onMouseDown = function(g, m) {
          if (g === "mousedown" && !(l.getButton(m) !== 0 || m.detail === 2)) {
            if (m.target === this.inner) {
              var v = this, b = m.clientY, x = function(M) {
                b = M.clientY;
              }, w = function() {
                clearInterval(A);
              }, C = m.clientY, y = this.thumbTop, S = function() {
                if (b !== void 0) {
                  var M = v.scrollTopFromThumbTop(y + b - C);
                  M !== v.scrollTop && v._emit("scroll", { data: M });
                }
              };
              l.capture(this.inner, x, w);
              var A = setInterval(S, 20);
              return l.preventDefault(m);
            }
            var $ = m.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;
            return this._emit("scroll", { data: this.scrollTopFromThumbTop($) }), l.preventDefault(m);
          }
        }, p.prototype.getHeight = function() {
          return this.height;
        }, p.prototype.scrollTopFromThumbTop = function(g) {
          var m = g * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);
          return m = m >> 0, m < 0 ? m = 0 : m > this.pageHeight - this.viewHeight && (m = this.pageHeight - this.viewHeight), m;
        }, p.prototype.getWidth = function() {
          return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
        }, p.prototype.setHeight = function(g) {
          this.height = Math.max(0, g), this.slideHeight = this.height, this.viewHeight = this.height, this.setScrollHeight(this.pageHeight, !0);
        }, p.prototype.setScrollHeight = function(g, m) {
          this.pageHeight === g && !m || (this.pageHeight = g, this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight, this.thumbHeight > this.slideHeight && (this.thumbHeight = this.slideHeight), this.thumbHeight < 15 && (this.thumbHeight = 15), this.inner.style.height = this.thumbHeight + "px", this.scrollTop > this.pageHeight - this.viewHeight && (this.scrollTop = this.pageHeight - this.viewHeight, this.scrollTop < 0 && (this.scrollTop = 0), this._emit("scroll", { data: this.scrollTop })));
        }, p.prototype.setScrollTop = function(g) {
          this.scrollTop = g, g < 0 && (g = 0), this.thumbTop = g * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight), this.inner.style.top = this.thumbTop + "px";
        }, p;
      }(c)
    );
    d.prototype.setInnerHeight = d.prototype.setScrollHeight;
    var f = (
      /** @class */
      function(h) {
        o(p, h);
        function p(g, m) {
          var v = h.call(this, g, "-h") || this;
          return v.scrollLeft = 0, v.scrollWidth = 0, v.height = v.HScrollHeight, v.inner.style.height = v.element.style.height = (v.height || 12) + "px", v.renderer = m, v;
        }
        return p.prototype.onMouseDown = function(g, m) {
          if (g === "mousedown" && !(l.getButton(m) !== 0 || m.detail === 2)) {
            if (m.target === this.inner) {
              var v = this, b = m.clientX, x = function(M) {
                b = M.clientX;
              }, w = function() {
                clearInterval(A);
              }, C = m.clientX, y = this.thumbLeft, S = function() {
                if (b !== void 0) {
                  var M = v.scrollLeftFromThumbLeft(y + b - C);
                  M !== v.scrollLeft && v._emit("scroll", { data: M });
                }
              };
              l.capture(this.inner, x, w);
              var A = setInterval(S, 20);
              return l.preventDefault(m);
            }
            var $ = m.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;
            return this._emit("scroll", { data: this.scrollLeftFromThumbLeft($) }), l.preventDefault(m);
          }
        }, p.prototype.getHeight = function() {
          return this.isVisible ? this.height : 0;
        }, p.prototype.scrollLeftFromThumbLeft = function(g) {
          var m = g * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);
          return m = m >> 0, m < 0 ? m = 0 : m > this.pageWidth - this.viewWidth && (m = this.pageWidth - this.viewWidth), m;
        }, p.prototype.setWidth = function(g) {
          this.width = Math.max(0, g), this.element.style.width = this.width + "px", this.slideWidth = this.width, this.viewWidth = this.width, this.setScrollWidth(this.pageWidth, !0);
        }, p.prototype.setScrollWidth = function(g, m) {
          this.pageWidth === g && !m || (this.pageWidth = g, this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth, this.thumbWidth > this.slideWidth && (this.thumbWidth = this.slideWidth), this.thumbWidth < 15 && (this.thumbWidth = 15), this.inner.style.width = this.thumbWidth + "px", this.scrollLeft > this.pageWidth - this.viewWidth && (this.scrollLeft = this.pageWidth - this.viewWidth, this.scrollLeft < 0 && (this.scrollLeft = 0), this._emit("scroll", { data: this.scrollLeft })));
        }, p.prototype.setScrollLeft = function(g) {
          this.scrollLeft = g, g < 0 && (g = 0), this.thumbLeft = g * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth), this.inner.style.left = this.thumbLeft + "px";
        }, p;
      }(c)
    );
    f.prototype.setInnerWidth = f.prototype.setScrollWidth, r.ScrollBar = d, r.ScrollBarV = d, r.ScrollBarH = f, r.VScrollBar = d, r.HScrollBar = f;
  }), ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function(n, r, i) {
    var o = n("./lib/event"), s = (
      /** @class */
      function() {
        function a(l, u) {
          this.onRender = l, this.pending = !1, this.changes = 0, this.$recursionLimit = 2, this.window = u || window;
          var c = this;
          this._flush = function(d) {
            c.pending = !1;
            var f = c.changes;
            if (f && (o.blockIdle(100), c.changes = 0, c.onRender(f)), c.changes) {
              if (c.$recursionLimit-- < 0)
                return;
              c.schedule();
            } else
              c.$recursionLimit = 2;
          };
        }
        return a.prototype.schedule = function(l) {
          this.changes = this.changes | l, this.changes && !this.pending && (o.nextFrame(this._flush), this.pending = !0);
        }, a.prototype.clear = function(l) {
          var u = this.changes;
          return this.changes = 0, u;
        }, a;
      }()
    );
    r.RenderLoop = s;
  }), ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/event", "ace/lib/useragent", "ace/lib/event_emitter"], function(n, r, i) {
    var o = n("../lib/oop"), s = n("../lib/dom"), a = n("../lib/lang"), l = n("../lib/event"), u = n("../lib/useragent"), c = n("../lib/event_emitter").EventEmitter, d = 512, f = typeof ResizeObserver == "function", h = 200, p = (
      /** @class */
      function() {
        function g(m) {
          this.el = s.createElement("div"), this.$setMeasureNodeStyles(this.el.style, !0), this.$main = s.createElement("div"), this.$setMeasureNodeStyles(this.$main.style), this.$measureNode = s.createElement("div"), this.$setMeasureNodeStyles(this.$measureNode.style), this.el.appendChild(this.$main), this.el.appendChild(this.$measureNode), m.appendChild(this.el), this.$measureNode.textContent = a.stringRepeat("X", d), this.$characterSize = { width: 0, height: 0 }, f ? this.$addObserver() : this.checkForSizeChanges();
        }
        return g.prototype.$setMeasureNodeStyles = function(m, v) {
          m.width = m.height = "auto", m.left = m.top = "0px", m.visibility = "hidden", m.position = "absolute", m.whiteSpace = "pre", u.isIE < 8 ? m["font-family"] = "inherit" : m.font = "inherit", m.overflow = v ? "hidden" : "visible";
        }, g.prototype.checkForSizeChanges = function(m) {
          if (m === void 0 && (m = this.$measureSizes()), m && (this.$characterSize.width !== m.width || this.$characterSize.height !== m.height)) {
            this.$measureNode.style.fontWeight = "bold";
            var v = this.$measureSizes();
            this.$measureNode.style.fontWeight = "", this.$characterSize = m, this.charSizes = /* @__PURE__ */ Object.create(null), this.allowBoldFonts = v && v.width === m.width && v.height === m.height, this._emit("changeCharacterSize", { data: m });
          }
        }, g.prototype.$addObserver = function() {
          var m = this;
          this.$observer = new window.ResizeObserver(function(v) {
            m.checkForSizeChanges();
          }), this.$observer.observe(this.$measureNode);
        }, g.prototype.$pollSizeChanges = function() {
          if (this.$pollSizeChangesTimer || this.$observer)
            return this.$pollSizeChangesTimer;
          var m = this;
          return this.$pollSizeChangesTimer = l.onIdle(function v() {
            m.checkForSizeChanges(), l.onIdle(v, 500);
          }, 500);
        }, g.prototype.setPolling = function(m) {
          m ? this.$pollSizeChanges() : this.$pollSizeChangesTimer && (clearInterval(this.$pollSizeChangesTimer), this.$pollSizeChangesTimer = 0);
        }, g.prototype.$measureSizes = function(m) {
          var v = {
            height: (m || this.$measureNode).clientHeight,
            width: (m || this.$measureNode).clientWidth / d
          };
          return v.width === 0 || v.height === 0 ? null : v;
        }, g.prototype.$measureCharWidth = function(m) {
          this.$main.textContent = a.stringRepeat(m, d);
          var v = this.$main.getBoundingClientRect();
          return v.width / d;
        }, g.prototype.getCharacterWidth = function(m) {
          var v = this.charSizes[m];
          return v === void 0 && (v = this.charSizes[m] = this.$measureCharWidth(m) / this.$characterSize.width), v;
        }, g.prototype.destroy = function() {
          clearInterval(this.$pollSizeChangesTimer), this.$observer && this.$observer.disconnect(), this.el && this.el.parentNode && this.el.parentNode.removeChild(this.el);
        }, g.prototype.$getZoom = function(m) {
          return !m || !m.parentElement ? 1 : (window.getComputedStyle(m).zoom || 1) * this.$getZoom(m.parentElement);
        }, g.prototype.$initTransformMeasureNodes = function() {
          var m = function(v, b) {
            return ["div", {
              style: "position: absolute;top:" + v + "px;left:" + b + "px;"
            }];
          };
          this.els = s.buildDom([m(0, 0), m(h, 0), m(0, h), m(h, h)], this.el);
        }, g.prototype.transformCoordinates = function(m, v) {
          if (m) {
            var b = this.$getZoom(this.el);
            m = y(1 / b, m);
          }
          function x(N, F, B) {
            var j = N[1] * F[0] - N[0] * F[1];
            return [
              (-F[1] * B[0] + F[0] * B[1]) / j,
              (+N[1] * B[0] - N[0] * B[1]) / j
            ];
          }
          function w(N, F) {
            return [N[0] - F[0], N[1] - F[1]];
          }
          function C(N, F) {
            return [N[0] + F[0], N[1] + F[1]];
          }
          function y(N, F) {
            return [N * F[0], N * F[1]];
          }
          this.els || this.$initTransformMeasureNodes();
          function S(N) {
            var F = N.getBoundingClientRect();
            return [F.left, F.top];
          }
          var A = S(this.els[0]), $ = S(this.els[1]), M = S(this.els[2]), _ = S(this.els[3]), T = x(w(_, $), w(_, M), w(C($, M), C(_, A))), D = y(1 + T[0], w($, A)), E = y(1 + T[1], w(M, A));
          if (v) {
            var R = v, I = T[0] * R[0] / h + T[1] * R[1] / h + 1, k = C(y(R[0], D), y(R[1], E));
            return C(y(1 / I / h, k), A);
          }
          var P = w(m, A), L = x(w(D, y(T[0], P)), w(E, y(T[1], P)), P);
          return y(h, L);
        }, g;
      }()
    );
    p.prototype.$characterSize = { width: 0, height: 0 }, o.implement(p.prototype, c), r.FontMetrics = p;
  }), ace.define("ace/css/editor-css", ["require", "exports", "module"], function(n, r, i) {
    i.exports = `
.ace_br1 {border-top-left-radius    : 3px;}
.ace_br2 {border-top-right-radius   : 3px;}
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}
.ace_br4 {border-bottom-right-radius: 3px;}
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}
.ace_br8 {border-bottom-left-radius : 3px;}
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}


.ace_editor {
    position: relative;
    overflow: hidden;
    padding: 0;
    font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Source Code Pro', 'source-code-pro', monospace;
    direction: ltr;
    text-align: left;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}

.ace_scroller {
    position: absolute;
    overflow: hidden;
    top: 0;
    bottom: 0;
    background-color: inherit;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: text;
}

.ace_content {
    position: absolute;
    box-sizing: border-box;
    min-width: 100%;
    contain: style size layout;
    font-variant-ligatures: no-common-ligatures;
}

.ace_keyboard-focus:focus {
    box-shadow: inset 0 0 0 2px #5E9ED6;
    outline: none;
}

.ace_dragging .ace_scroller:before{
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    content: '';
    background: rgba(250, 250, 250, 0.01);
    z-index: 1000;
}
.ace_dragging.ace_dark .ace_scroller:before{
    background: rgba(0, 0, 0, 0.01);
}

.ace_gutter {
    position: absolute;
    overflow : hidden;
    width: auto;
    top: 0;
    bottom: 0;
    left: 0;
    cursor: default;
    z-index: 4;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    contain: style size layout;
}

.ace_gutter-active-line {
    position: absolute;
    left: 0;
    right: 0;
}

.ace_scroller.ace_scroll-left:after {
    content: "";
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;
    pointer-events: none;
}

.ace_gutter-cell, .ace_gutter-cell_svg-icons {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding-left: 19px;
    padding-right: 6px;
    background-repeat: no-repeat;
}

.ace_gutter-cell_svg-icons .ace_gutter_annotation {
    margin-left: -14px;
    float: left;
}

.ace_gutter-cell .ace_gutter_annotation {
    margin-left: -19px;
    float: left;
}

.ace_gutter-cell.ace_error, .ace_icon.ace_error, .ace_icon.ace_error_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_warning, .ace_icon.ace_warning, .ace_icon.ace_warning_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_info, .ace_icon.ace_info {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");
    background-repeat: no-repeat;
    background-position: 2px center;
}
.ace_dark .ace_gutter-cell.ace_info, .ace_dark .ace_icon.ace_info {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");
}

.ace_icon_svg.ace_error {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJyZWQiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KPGNpcmNsZSBmaWxsPSJub25lIiBjeD0iOCIgY3k9IjgiIHI9IjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPGxpbmUgeDE9IjExIiB5MT0iNSIgeDI9IjUiIHkyPSIxMSIvPgo8bGluZSB4MT0iMTEiIHkxPSIxMSIgeDI9IjUiIHkyPSI1Ii8+CjwvZz4KPC9zdmc+");
    background-color: crimson;
}
.ace_icon_svg.ace_warning {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJkYXJrb3JhbmdlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+Cjxwb2x5Z29uIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiIHBvaW50cz0iOCAxIDE1IDE1IDEgMTUgOCAxIi8+CjxyZWN0IHg9IjgiIHk9IjEyIiB3aWR0aD0iMC4wMSIgaGVpZ2h0PSIwLjAxIi8+CjxsaW5lIHgxPSI4IiB5MT0iNiIgeDI9IjgiIHkyPSIxMCIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: darkorange;
}
.ace_icon_svg.ace_info {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJibHVlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CjxjaXJjbGUgZmlsbD0ibm9uZSIgY3g9IjgiIGN5PSI4IiByPSI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjxwb2x5bGluZSBwb2ludHM9IjggMTEgOCA4Ii8+Cjxwb2x5bGluZSBwb2ludHM9IjkgOCA2IDgiLz4KPGxpbmUgeDE9IjEwIiB5MT0iMTEiIHgyPSI2IiB5Mj0iMTEiLz4KPHJlY3QgeD0iOCIgeT0iNSIgd2lkdGg9IjAuMDEiIGhlaWdodD0iMC4wMSIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: royalblue;
}

.ace_icon_svg.ace_error_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSI+CiAgPHBhdGggZD0ibSAxOC45Mjk4NTEsNy44Mjk4MDc2IGMgMC4xNDYzNTMsNi4zMzc0NjA0IC02LjMyMzE0Nyw3Ljc3Nzg0NDQgLTcuNDc3OTEyLDcuNzc3ODQ0NCAtMi4xMDcyNzI2LC0wLjEyODc1IDUuMTE3Njc4LDAuMzU2MjQ5IDUuMDUxNjk4LC03Ljg3MDA2MTggLTAuNjA0NjcyLC04LjAwMzk3MzQ5IC03LjA3NzI3MDYsLTcuNTYzMTE4OSAtNC44NTczLC03LjQzMDM5NTU2IDEuNjA2LC0wLjExNTE0MjI1IDYuODk3NDg1LDEuMjYyNTQ1OTYgNy4yODM1MTQsNy41MjI2MTI5NiB6IiBmaWxsPSJjcmltc29uIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibSA4LjExNDc1NjIsMi4wNTI5ODI4IGMgMy4zNDkxNjk4LDAgNi4wNjQxMzI4LDIuNjc2ODYyNyA2LjA2NDEzMjgsNS45Nzg5NTMgMCwzLjMwMjExMjIgLTIuNzE0OTYzLDUuOTc4OTIwMiAtNi4wNjQxMzI4LDUuOTc4OTIwMiAtMy4zNDkxNDczLDAgLTYuMDY0MTc3MiwtMi42NzY4MDggLTYuMDY0MTc3MiwtNS45Nzg5MjAyIDAuMDA1MzksLTMuMjk5ODg2MSAyLjcxNzI2NTYsLTUuOTczNjQwOCA2LjA2NDE3NzIsLTUuOTc4OTUzIHogbSAwLC0xLjczNTgyNzE5IGMgLTQuMzIxNDgzNiwwIC03LjgyNDc0MDM4LDMuNDU0MDE4NDkgLTcuODI0NzQwMzgsNy43MTQ3ODAxOSAwLDQuMjYwNzI4MiAzLjUwMzI1Njc4LDcuNzE0NzQ1MiA3LjgyNDc0MDM4LDcuNzE0NzQ1MiA0LjMyMTQ0OTgsMCA3LjgyNDY5OTgsLTMuNDU0MDE3IDcuODI0Njk5OCwtNy43MTQ3NDUyIDAsLTIuMDQ2MDkxNCAtMC44MjQzOTIsLTQuMDA4MzY3MiAtMi4yOTE3NTYsLTUuNDU1MTc0NiBDIDEyLjE4MDIyNSwxLjEyOTk2NDggMTAuMTkwMDEzLDAuMzE3MTU1NjEgOC4xMTQ3NTYyLDAuMzE3MTU1NjEgWiBNIDYuOTM3NDU2Myw4LjI0MDU5ODUgNC42NzE4Njg1LDEwLjQ4NTg1MiA2LjAwODY4MTQsMTEuODc2NzI4IDguMzE3MDAzNSw5LjYwMDc5MTEgMTAuNjI1MzM3LDExLjg3NjcyOCAxMS45NjIxMzgsMTAuNDg1ODUyIDkuNjk2NTUwOCw4LjI0MDU5ODUgMTEuOTYyMTM4LDYuMDA2ODA2NiAxMC41NzMyNDYsNC42Mzc0MzM1IDguMzE3MDAzNSw2Ljg3MzQyOTcgNi4wNjA3NjA3LDQuNjM3NDMzNSA0LjY3MTg2ODUsNi4wMDY4MDY2IFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");
    background-color: crimson;
}
.ace_icon_svg.ace_warning_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC43NzY5IDE0LjczMzdMOC42NTE5MiAyLjQ4MzY5QzguMzI5NDYgMS44Mzg3NyA3LjQwOTEzIDEuODM4NzcgNy4wODY2NyAyLjQ4MzY5TDAuOTYxNjY5IDE0LjczMzdDMC42NzA3NzUgMTUuMzE1NSAxLjA5MzgzIDE2IDEuNzQ0MjkgMTZIMTMuOTk0M0MxNC42NDQ4IDE2IDE1LjA2NzggMTUuMzE1NSAxNC43NzY5IDE0LjczMzdaTTMuMTYwMDcgMTQuMjVMNy44NjkyOSA0LjgzMTU2TDEyLjU3ODUgMTQuMjVIMy4xNjAwN1pNOC43NDQyOSAxMS42MjVWMTMuMzc1SDYuOTk0MjlWMTEuNjI1SDguNzQ0MjlaTTYuOTk0MjkgMTAuNzVWNy4yNUg4Ljc0NDI5VjEwLjc1SDYuOTk0MjlaIiBmaWxsPSIjRUM3MjExIi8+CjxwYXRoIGQ9Ik0xMS4xOTkxIDIuOTUyMzhDMTAuODgwOSAyLjMxNDY3IDEwLjM1MzcgMS44MDUyNiA5LjcwNTUgMS41MDlMMTEuMDQxIDEuMDY5NzhDMTEuNjg4MyAwLjk0OTgxNCAxMi4zMzcgMS4yNzI2MyAxMi42MzE3IDEuODYxNDFMMTcuNjEzNiAxMS44MTYxQzE4LjM1MjcgMTMuMjkyOSAxNy41OTM4IDE1LjA4MDQgMTYuMDE4IDE1LjU3NDVDMTYuNDA0NCAxNC40NTA3IDE2LjMyMzEgMTMuMjE4OCAxNS43OTI0IDEyLjE1NTVMMTEuMTk5MSAyLjk1MjM4WiIgZmlsbD0iI0VDNzIxMSIvPgo8L3N2Zz4=");
    background-color: darkorange;
}

.ace_scrollbar {
    contain: strict;
    position: absolute;
    right: 0;
    bottom: 0;
    z-index: 6;
}

.ace_scrollbar-inner {
    position: absolute;
    cursor: text;
    left: 0;
    top: 0;
}

.ace_scrollbar-v{
    overflow-x: hidden;
    overflow-y: scroll;
    top: 0;
}

.ace_scrollbar-h {
    overflow-x: scroll;
    overflow-y: hidden;
    left: 0;
}

.ace_print-margin {
    position: absolute;
    height: 100%;
}

.ace_text-input {
    position: absolute;
    z-index: 0;
    width: 0.5em;
    height: 1em;
    opacity: 0;
    background: transparent;
    -moz-appearance: none;
    appearance: none;
    border: none;
    resize: none;
    outline: none;
    overflow: hidden;
    font: inherit;
    padding: 0 1px;
    margin: 0 -1px;
    contain: strict;
    -ms-user-select: text;
    -moz-user-select: text;
    -webkit-user-select: text;
    user-select: text;
    /*with \`pre-line\` chrome inserts &nbsp; instead of space*/
    white-space: pre!important;
}
.ace_text-input.ace_composition {
    background: transparent;
    color: inherit;
    z-index: 1000;
    opacity: 1;
}
.ace_composition_placeholder { color: transparent }
.ace_composition_marker { 
    border-bottom: 1px solid;
    position: absolute;
    border-radius: 0;
    margin-top: 1px;
}

[ace_nocontext=true] {
    transform: none!important;
    filter: none!important;
    clip-path: none!important;
    mask : none!important;
    contain: none!important;
    perspective: none!important;
    mix-blend-mode: initial!important;
    z-index: auto;
}

.ace_layer {
    z-index: 1;
    position: absolute;
    overflow: hidden;
    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/
    word-wrap: normal;
    white-space: pre;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
    /* setting pointer-events: auto; on node under the mouse, which changes
        during scroll, will break mouse wheel scrolling in Safari */
    pointer-events: none;
}

.ace_gutter-layer {
    position: relative;
    width: auto;
    text-align: right;
    pointer-events: auto;
    height: 1000000px;
    contain: style size layout;
}

.ace_text-layer {
    font: inherit !important;
    position: absolute;
    height: 1000000px;
    width: 1000000px;
    contain: style size layout;
}

.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {
    contain: style size layout;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
}

.ace_hidpi .ace_text-layer,
.ace_hidpi .ace_gutter-layer,
.ace_hidpi .ace_content,
.ace_hidpi .ace_gutter {
    contain: strict;
}
.ace_hidpi .ace_text-layer > .ace_line, 
.ace_hidpi .ace_text-layer > .ace_line_group {
    contain: strict;
}

.ace_cjk {
    display: inline-block;
    text-align: center;
}

.ace_cursor-layer {
    z-index: 4;
}

.ace_cursor {
    z-index: 4;
    position: absolute;
    box-sizing: border-box;
    border-left: 2px solid;
    /* workaround for smooth cursor repaintng whole screen in chrome */
    transform: translatez(0);
}

.ace_multiselect .ace_cursor {
    border-left-width: 1px;
}

.ace_slim-cursors .ace_cursor {
    border-left-width: 1px;
}

.ace_overwrite-cursors .ace_cursor {
    border-left-width: 0;
    border-bottom: 1px solid;
}

.ace_hidden-cursors .ace_cursor {
    opacity: 0.2;
}

.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {
    opacity: 0;
}

.ace_smooth-blinking .ace_cursor {
    transition: opacity 0.18s;
}

.ace_animate-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: step-end;
    animation-name: blink-ace-animate;
    animation-iteration-count: infinite;
}

.ace_animate-blinking.ace_smooth-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: ease-in-out;
    animation-name: blink-ace-animate-smooth;
}
    
@keyframes blink-ace-animate {
    from, to { opacity: 1; }
    60% { opacity: 0; }
}

@keyframes blink-ace-animate-smooth {
    from, to { opacity: 1; }
    45% { opacity: 1; }
    60% { opacity: 0; }
    85% { opacity: 0; }
}

.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {
    position: absolute;
    z-index: 3;
}

.ace_marker-layer .ace_selection {
    position: absolute;
    z-index: 5;
}

.ace_marker-layer .ace_bracket {
    position: absolute;
    z-index: 6;
}

.ace_marker-layer .ace_error_bracket {
    position: absolute;
    border-bottom: 1px solid #DE5555;
    border-radius: 0;
}

.ace_marker-layer .ace_active-line {
    position: absolute;
    z-index: 2;
}

.ace_marker-layer .ace_selected-word {
    position: absolute;
    z-index: 4;
    box-sizing: border-box;
}

.ace_line .ace_fold {
    box-sizing: border-box;

    display: inline-block;
    height: 11px;
    margin-top: -2px;
    vertical-align: middle;

    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");
    background-repeat: no-repeat, repeat-x;
    background-position: center center, top left;
    color: transparent;

    border: 1px solid black;
    border-radius: 2px;

    cursor: pointer;
    pointer-events: auto;
}

.ace_dark .ace_fold {
}

.ace_fold:hover{
    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");
}

.ace_tooltip {
    background-color: #f5f5f5;
    border: 1px solid gray;
    border-radius: 1px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    color: black;
    max-width: 100%;
    padding: 3px 4px;
    position: fixed;
    z-index: 999999;
    box-sizing: border-box;
    cursor: default;
    white-space: pre-wrap;
    word-wrap: break-word;
    line-height: normal;
    font-style: normal;
    font-weight: normal;
    letter-spacing: normal;
    pointer-events: none;
    overflow: auto;
    max-width: min(60em, 66vw);
    overscroll-behavior: contain;
}
.ace_tooltip pre {
    white-space: pre-wrap;
}

.ace_tooltip.ace_dark {
    background-color: #636363;
    color: #fff;
}

.ace_tooltip:focus {
    outline: 1px solid #5E9ED6;
}

.ace_icon {
    display: inline-block;
    width: 18px;
    vertical-align: top;
}

.ace_icon_svg {
    display: inline-block;
    width: 12px;
    vertical-align: top;
    -webkit-mask-repeat: no-repeat;
    -webkit-mask-size: 12px;
    -webkit-mask-position: center;
}

.ace_folding-enabled > .ace_gutter-cell, .ace_folding-enabled > .ace_gutter-cell_svg-icons {
    padding-right: 13px;
}

.ace_fold-widget {
    box-sizing: border-box;

    margin: 0 -12px 0 1px;
    display: none;
    width: 11px;
    vertical-align: top;

    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: center;

    border-radius: 3px;
    
    border: 1px solid transparent;
    cursor: pointer;
}

.ace_folding-enabled .ace_fold-widget {
    display: inline-block;   
}

.ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");
}

.ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");
}

.ace_fold-widget:hover {
    border: 1px solid rgba(0, 0, 0, 0.3);
    background-color: rgba(255, 255, 255, 0.2);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);
}

.ace_fold-widget:active {
    border: 1px solid rgba(0, 0, 0, 0.4);
    background-color: rgba(0, 0, 0, 0.05);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
}
/**
 * Dark version for fold widgets
 */
.ace_dark .ace_fold-widget {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");
}
.ace_dark .ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget:hover {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
    background-color: rgba(255, 255, 255, 0.1);
}
.ace_dark .ace_fold-widget:active {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
}

.ace_inline_button {
    border: 1px solid lightgray;
    display: inline-block;
    margin: -1px 8px;
    padding: 0 5px;
    pointer-events: auto;
    cursor: pointer;
}
.ace_inline_button:hover {
    border-color: gray;
    background: rgba(200,200,200,0.2);
    display: inline-block;
    pointer-events: auto;
}

.ace_fold-widget.ace_invalid {
    background-color: #FFB4B4;
    border-color: #DE5555;
}

.ace_fade-fold-widgets .ace_fold-widget {
    transition: opacity 0.4s ease 0.05s;
    opacity: 0;
}

.ace_fade-fold-widgets:hover .ace_fold-widget {
    transition: opacity 0.05s ease 0.05s;
    opacity:1;
}

.ace_underline {
    text-decoration: underline;
}

.ace_bold {
    font-weight: bold;
}

.ace_nobold .ace_bold {
    font-weight: normal;
}

.ace_italic {
    font-style: italic;
}


.ace_error-marker {
    background-color: rgba(255, 0, 0,0.2);
    position: absolute;
    z-index: 9;
}

.ace_highlight-marker {
    background-color: rgba(255, 255, 0,0.2);
    position: absolute;
    z-index: 8;
}

.ace_mobile-menu {
    position: absolute;
    line-height: 1.5;
    border-radius: 4px;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    background: white;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #dcdcdc;
    color: black;
}
.ace_dark > .ace_mobile-menu {
    background: #333;
    color: #ccc;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #444;

}
.ace_mobile-button {
    padding: 2px;
    cursor: pointer;
    overflow: hidden;
}
.ace_mobile-button:hover {
    background-color: #eee;
    opacity:1;
}
.ace_mobile-button:active {
    background-color: #ddd;
}

.ace_placeholder {
    font-family: arial;
    transform: scale(0.9);
    transform-origin: left;
    white-space: pre;
    opacity: 0.7;
    margin: 0 10px;
}

.ace_ghost_text {
    opacity: 0.5;
    font-style: italic;
    white-space: pre;
}

.ace_screenreader-only {
    position:absolute;
    left:-10000px;
    top:auto;
    width:1px;
    height:1px;
    overflow:hidden;
}`;
  }), ace.define("ace/layer/decorators", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event_emitter"], function(n, r, i) {
    var o = n("../lib/dom"), s = n("../lib/oop"), a = n("../lib/event_emitter").EventEmitter, l = (
      /** @class */
      function() {
        function u(c, d) {
          this.canvas = o.createElement("canvas"), this.renderer = d, this.pixelRatio = 1, this.maxHeight = d.layerConfig.maxHeight, this.lineHeight = d.layerConfig.lineHeight, this.canvasHeight = c.parent.scrollHeight, this.heightRatio = this.canvasHeight / this.maxHeight, this.canvasWidth = c.width, this.minDecorationHeight = 2 * this.pixelRatio | 0, this.halfMinDecorationHeight = this.minDecorationHeight / 2 | 0, this.canvas.width = this.canvasWidth, this.canvas.height = this.canvasHeight, this.canvas.style.top = "0px", this.canvas.style.right = "0px", this.canvas.style.zIndex = "7px", this.canvas.style.position = "absolute", this.colors = {}, this.colors.dark = {
            error: "rgba(255, 18, 18, 1)",
            warning: "rgba(18, 136, 18, 1)",
            info: "rgba(18, 18, 136, 1)"
          }, this.colors.light = {
            error: "rgb(255,51,51)",
            warning: "rgb(32,133,72)",
            info: "rgb(35,68,138)"
          }, c.element.appendChild(this.canvas);
        }
        return u.prototype.$updateDecorators = function(c) {
          var d = this.renderer.theme.isDark === !0 ? this.colors.dark : this.colors.light;
          if (c) {
            this.maxHeight = c.maxHeight, this.lineHeight = c.lineHeight, this.canvasHeight = c.height;
            var f = (c.lastRow + 1) * this.lineHeight;
            f < this.canvasHeight ? this.heightRatio = 1 : this.heightRatio = this.canvasHeight / this.maxHeight;
          }
          var h = this.canvas.getContext("2d");
          function p(_, T) {
            return _.priority < T.priority ? -1 : _.priority > T.priority ? 1 : 0;
          }
          var g = this.renderer.session.$annotations;
          if (h.clearRect(0, 0, this.canvas.width, this.canvas.height), g) {
            var m = {
              info: 1,
              warning: 2,
              error: 3
            };
            g.forEach(function(_) {
              _.priority = m[_.type] || null;
            }), g = g.sort(p);
            for (var v = this.renderer.session.$foldData, b = 0; b < g.length; b++) {
              var x = g[b].row, w = this.compensateFoldRows(x, v), C = Math.round((x - w) * this.lineHeight * this.heightRatio), y = Math.round((x - w) * this.lineHeight * this.heightRatio), S = Math.round(((x - w) * this.lineHeight + this.lineHeight) * this.heightRatio), A = S - y;
              if (A < this.minDecorationHeight) {
                var $ = (y + S) / 2 | 0;
                $ < this.halfMinDecorationHeight ? $ = this.halfMinDecorationHeight : $ + this.halfMinDecorationHeight > this.canvasHeight && ($ = this.canvasHeight - this.halfMinDecorationHeight), y = Math.round($ - this.halfMinDecorationHeight), S = Math.round($ + this.halfMinDecorationHeight);
              }
              h.fillStyle = d[g[b].type] || null, h.fillRect(0, C, this.canvasWidth, S - y);
            }
          }
          var M = this.renderer.session.selection.getCursor();
          if (M) {
            var w = this.compensateFoldRows(M.row, v), C = Math.round((M.row - w) * this.lineHeight * this.heightRatio);
            h.fillStyle = "rgba(0, 0, 0, 0.5)", h.fillRect(0, C, this.canvasWidth, 2);
          }
        }, u.prototype.compensateFoldRows = function(c, d) {
          var f = 0;
          if (d && d.length > 0)
            for (var h = 0; h < d.length; h++)
              c > d[h].start.row && c < d[h].end.row ? f += c - d[h].start.row : c >= d[h].end.row && (f += d[h].end.row - d[h].start.row);
          return f;
        }, u;
      }()
    );
    s.implement(l.prototype, a), r.Decorator = l;
  }), ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/config", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/scrollbar_custom", "ace/scrollbar_custom", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter", "ace/css/editor-css", "ace/layer/decorators", "ace/lib/useragent"], function(n, r, i) {
    var o = n("./lib/oop"), s = n("./lib/dom"), a = n("./lib/lang"), l = n("./config"), u = n("./layer/gutter").Gutter, c = n("./layer/marker").Marker, d = n("./layer/text").Text, f = n("./layer/cursor").Cursor, h = n("./scrollbar").HScrollBar, p = n("./scrollbar").VScrollBar, g = n("./scrollbar_custom").HScrollBar, m = n("./scrollbar_custom").VScrollBar, v = n("./renderloop").RenderLoop, b = n("./layer/font_metrics").FontMetrics, x = n("./lib/event_emitter").EventEmitter, w = n("./css/editor-css"), C = n("./layer/decorators").Decorator, y = n("./lib/useragent");
    s.importCssString(w, "ace_editor.css", !1);
    var S = (
      /** @class */
      function() {
        function A($, M) {
          var _ = this;
          this.container = $ || s.createElement("div"), s.addCssClass(this.container, "ace_editor"), s.HI_DPI && s.addCssClass(this.container, "ace_hidpi"), this.setTheme(M), l.get("useStrictCSP") == null && l.set("useStrictCSP", !1), this.$gutter = s.createElement("div"), this.$gutter.className = "ace_gutter", this.container.appendChild(this.$gutter), this.$gutter.setAttribute("aria-hidden", "true"), this.scroller = s.createElement("div"), this.scroller.className = "ace_scroller", this.container.appendChild(this.scroller), this.content = s.createElement("div"), this.content.className = "ace_content", this.scroller.appendChild(this.content), this.$gutterLayer = new u(this.$gutter), this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this)), this.$markerBack = new c(this.content);
          var T = this.$textLayer = new d(this.content);
          this.canvas = T.element, this.$markerFront = new c(this.content), this.$cursorLayer = new f(this.content), this.$horizScroll = !1, this.$vScroll = !1, this.scrollBar = this.scrollBarV = new p(this.container, this), this.scrollBarH = new h(this.container, this), this.scrollBarV.on("scroll", function(D) {
            _.$scrollAnimation || _.session.setScrollTop(D.data - _.scrollMargin.top);
          }), this.scrollBarH.on("scroll", function(D) {
            _.$scrollAnimation || _.session.setScrollLeft(D.data - _.scrollMargin.left);
          }), this.scrollTop = 0, this.scrollLeft = 0, this.cursorPos = {
            row: 0,
            column: 0
          }, this.$fontMetrics = new b(this.container), this.$textLayer.$setFontMetrics(this.$fontMetrics), this.$textLayer.on("changeCharacterSize", function(D) {
            _.updateCharacterSize(), _.onResize(!0, _.gutterWidth, _.$size.width, _.$size.height), _._signal("changeCharacterSize", D);
          }), this.$size = {
            width: 0,
            height: 0,
            scrollerHeight: 0,
            scrollerWidth: 0,
            $dirty: !0
          }, this.layerConfig = {
            width: 1,
            padding: 0,
            firstRow: 0,
            firstRowScreen: 0,
            lastRow: 0,
            lineHeight: 0,
            characterWidth: 0,
            minHeight: 1,
            maxHeight: 1,
            offset: 0,
            height: 1,
            gutterOffset: 1
          }, this.scrollMargin = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            v: 0,
            h: 0
          }, this.margin = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            v: 0,
            h: 0
          }, this.$keepTextAreaAtCursor = !y.isIOS, this.$loop = new v(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView), this.$loop.schedule(this.CHANGE_FULL), this.updateCharacterSize(), this.setPadding(4), this.$addResizeObserver(), l.resetOptions(this), l._signal("renderer", this);
        }
        return A.prototype.updateCharacterSize = function() {
          this.$textLayer.allowBoldFonts != this.$allowBoldFonts && (this.$allowBoldFonts = this.$textLayer.allowBoldFonts, this.setStyle("ace_nobold", !this.$allowBoldFonts)), this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth(), this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight(), this.$updatePrintMargin(), s.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
        }, A.prototype.setSession = function($) {
          this.session && this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode), this.session = $, $ && this.scrollMargin.top && $.getScrollTop() <= 0 && $.setScrollTop(-this.scrollMargin.top), this.$cursorLayer.setSession($), this.$markerBack.setSession($), this.$markerFront.setSession($), this.$gutterLayer.setSession($), this.$textLayer.setSession($), $ && (this.$loop.schedule(this.CHANGE_FULL), this.session.$setFontMetrics(this.$fontMetrics), this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null, this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this), this.onChangeNewLineMode(), this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode));
        }, A.prototype.updateLines = function($, M, _) {
          if (M === void 0 && (M = 1 / 0), this.$changedLines ? (this.$changedLines.firstRow > $ && (this.$changedLines.firstRow = $), this.$changedLines.lastRow < M && (this.$changedLines.lastRow = M)) : this.$changedLines = {
            firstRow: $,
            lastRow: M
          }, this.$changedLines.lastRow < this.layerConfig.firstRow)
            if (_)
              this.$changedLines.lastRow = this.layerConfig.lastRow;
            else
              return;
          this.$changedLines.firstRow > this.layerConfig.lastRow || this.$loop.schedule(this.CHANGE_LINES);
        }, A.prototype.onChangeNewLineMode = function() {
          this.$loop.schedule(this.CHANGE_TEXT), this.$textLayer.$updateEolChar(), this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
        }, A.prototype.onChangeTabSize = function() {
          this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER), this.$textLayer.onChangeTabSize();
        }, A.prototype.updateText = function() {
          this.$loop.schedule(this.CHANGE_TEXT);
        }, A.prototype.updateFull = function($) {
          $ ? this.$renderChanges(this.CHANGE_FULL, !0) : this.$loop.schedule(this.CHANGE_FULL);
        }, A.prototype.updateFontSize = function() {
          this.$textLayer.checkForSizeChanges();
        }, A.prototype.$updateSizeAsync = function() {
          this.$loop.pending ? this.$size.$dirty = !0 : this.onResize();
        }, A.prototype.onResize = function($, M, _, T) {
          if (!(this.resizing > 2)) {
            this.resizing > 0 ? this.resizing++ : this.resizing = $ ? 1 : 0;
            var D = this.container;
            T || (T = D.clientHeight || D.scrollHeight), _ || (_ = D.clientWidth || D.scrollWidth);
            var E = this.$updateCachedSize($, M, _, T);
            if (this.$resizeTimer && this.$resizeTimer.cancel(), !this.$size.scrollerHeight || !_ && !T)
              return this.resizing = 0;
            $ && (this.$gutterLayer.$padding = null), $ ? this.$renderChanges(E | this.$changes, !0) : this.$loop.schedule(E | this.$changes), this.resizing && (this.resizing = 0), this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null, this.$customScrollbar && this.$updateCustomScrollbar(!0);
          }
        }, A.prototype.$updateCachedSize = function($, M, _, T) {
          T -= this.$extraHeight || 0;
          var D = 0, E = this.$size, R = {
            width: E.width,
            height: E.height,
            scrollerHeight: E.scrollerHeight,
            scrollerWidth: E.scrollerWidth
          };
          if (T && ($ || E.height != T) && (E.height = T, D |= this.CHANGE_SIZE, E.scrollerHeight = E.height, this.$horizScroll && (E.scrollerHeight -= this.scrollBarH.getHeight()), this.scrollBarV.setHeight(E.scrollerHeight), this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px", D = D | this.CHANGE_SCROLL), _ && ($ || E.width != _)) {
            D |= this.CHANGE_SIZE, E.width = _, M == null && (M = this.$showGutter ? this.$gutter.offsetWidth : 0), this.gutterWidth = M, s.setStyle(this.scrollBarH.element.style, "left", M + "px"), s.setStyle(this.scroller.style, "left", M + this.margin.left + "px"), E.scrollerWidth = Math.max(0, _ - M - this.scrollBarV.getWidth() - this.margin.h), s.setStyle(this.$gutter.style, "left", this.margin.left + "px");
            var I = this.scrollBarV.getWidth() + "px";
            s.setStyle(this.scrollBarH.element.style, "right", I), s.setStyle(this.scroller.style, "right", I), s.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight()), this.scrollBarH.setWidth(E.scrollerWidth), (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || $) && (D |= this.CHANGE_FULL);
          }
          return E.$dirty = !_ || !T, D && this._signal("resize", R), D;
        }, A.prototype.onGutterResize = function($) {
          var M = this.$showGutter ? $ : 0;
          M != this.gutterWidth && (this.$changes |= this.$updateCachedSize(!0, M, this.$size.width, this.$size.height)), this.session.getUseWrapMode() && this.adjustWrapLimit() ? this.$loop.schedule(this.CHANGE_FULL) : this.$size.$dirty ? this.$loop.schedule(this.CHANGE_FULL) : this.$computeLayerConfig();
        }, A.prototype.adjustWrapLimit = function() {
          var $ = this.$size.scrollerWidth - this.$padding * 2, M = Math.floor($ / this.characterWidth);
          return this.session.adjustWrapLimit(M, this.$showPrintMargin && this.$printMarginColumn);
        }, A.prototype.setAnimatedScroll = function($) {
          this.setOption("animatedScroll", $);
        }, A.prototype.getAnimatedScroll = function() {
          return this.$animatedScroll;
        }, A.prototype.setShowInvisibles = function($) {
          this.setOption("showInvisibles", $), this.session.$bidiHandler.setShowInvisibles($);
        }, A.prototype.getShowInvisibles = function() {
          return this.getOption("showInvisibles");
        }, A.prototype.getDisplayIndentGuides = function() {
          return this.getOption("displayIndentGuides");
        }, A.prototype.setDisplayIndentGuides = function($) {
          this.setOption("displayIndentGuides", $);
        }, A.prototype.getHighlightIndentGuides = function() {
          return this.getOption("highlightIndentGuides");
        }, A.prototype.setHighlightIndentGuides = function($) {
          this.setOption("highlightIndentGuides", $);
        }, A.prototype.setShowPrintMargin = function($) {
          this.setOption("showPrintMargin", $);
        }, A.prototype.getShowPrintMargin = function() {
          return this.getOption("showPrintMargin");
        }, A.prototype.setPrintMarginColumn = function($) {
          this.setOption("printMarginColumn", $);
        }, A.prototype.getPrintMarginColumn = function() {
          return this.getOption("printMarginColumn");
        }, A.prototype.getShowGutter = function() {
          return this.getOption("showGutter");
        }, A.prototype.setShowGutter = function($) {
          return this.setOption("showGutter", $);
        }, A.prototype.getFadeFoldWidgets = function() {
          return this.getOption("fadeFoldWidgets");
        }, A.prototype.setFadeFoldWidgets = function($) {
          this.setOption("fadeFoldWidgets", $);
        }, A.prototype.setHighlightGutterLine = function($) {
          this.setOption("highlightGutterLine", $);
        }, A.prototype.getHighlightGutterLine = function() {
          return this.getOption("highlightGutterLine");
        }, A.prototype.$updatePrintMargin = function() {
          if (!(!this.$showPrintMargin && !this.$printMarginEl)) {
            if (!this.$printMarginEl) {
              var $ = s.createElement("div");
              $.className = "ace_layer ace_print-margin-layer", this.$printMarginEl = s.createElement("div"), this.$printMarginEl.className = "ace_print-margin", $.appendChild(this.$printMarginEl), this.content.insertBefore($, this.content.firstChild);
            }
            var M = this.$printMarginEl.style;
            M.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px", M.visibility = this.$showPrintMargin ? "visible" : "hidden", this.session && this.session.$wrap == -1 && this.adjustWrapLimit();
          }
        }, A.prototype.getContainerElement = function() {
          return this.container;
        }, A.prototype.getMouseEventTarget = function() {
          return this.scroller;
        }, A.prototype.getTextAreaContainer = function() {
          return this.container;
        }, A.prototype.$moveTextAreaToCursor = function() {
          if (!this.$isMousePressed) {
            var $ = this.textarea.style, M = this.$composition;
            if (!this.$keepTextAreaAtCursor && !M) {
              s.translate(this.textarea, -100, 0);
              return;
            }
            var _ = this.$cursorLayer.$pixelPos;
            if (_) {
              M && M.markerRange && (_ = this.$cursorLayer.getPixelPosition(M.markerRange.start, !0));
              var T = this.layerConfig, D = _.top, E = _.left;
              D -= T.offset;
              var R = M && M.useTextareaForIME || y.isMobile ? this.lineHeight : 1;
              if (D < 0 || D > T.height - R) {
                s.translate(this.textarea, 0, 0);
                return;
              }
              var I = 1, k = this.$size.height - R;
              if (!M)
                D += this.lineHeight;
              else if (M.useTextareaForIME) {
                var P = this.textarea.value;
                I = this.characterWidth * this.session.$getStringScreenWidth(P)[0];
              } else
                D += this.lineHeight + 2;
              E -= this.scrollLeft, E > this.$size.scrollerWidth - I && (E = this.$size.scrollerWidth - I), E += this.gutterWidth + this.margin.left, s.setStyle($, "height", R + "px"), s.setStyle($, "width", I + "px"), s.translate(this.textarea, Math.min(E, this.$size.scrollerWidth - I), Math.min(D, k));
            }
          }
        }, A.prototype.getFirstVisibleRow = function() {
          return this.layerConfig.firstRow;
        }, A.prototype.getFirstFullyVisibleRow = function() {
          return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
        }, A.prototype.getLastFullyVisibleRow = function() {
          var $ = this.layerConfig, M = $.lastRow, _ = this.session.documentToScreenRow(M, 0) * $.lineHeight;
          return _ - this.session.getScrollTop() > $.height - $.lineHeight ? M - 1 : M;
        }, A.prototype.getLastVisibleRow = function() {
          return this.layerConfig.lastRow;
        }, A.prototype.setPadding = function($) {
          this.$padding = $, this.$textLayer.setPadding($), this.$cursorLayer.setPadding($), this.$markerFront.setPadding($), this.$markerBack.setPadding($), this.$loop.schedule(this.CHANGE_FULL), this.$updatePrintMargin();
        }, A.prototype.setScrollMargin = function($, M, _, T) {
          var D = this.scrollMargin;
          D.top = $ | 0, D.bottom = M | 0, D.right = T | 0, D.left = _ | 0, D.v = D.top + D.bottom, D.h = D.left + D.right, D.top && this.scrollTop <= 0 && this.session && this.session.setScrollTop(-D.top), this.updateFull();
        }, A.prototype.setMargin = function($, M, _, T) {
          var D = this.margin;
          D.top = $ | 0, D.bottom = M | 0, D.right = T | 0, D.left = _ | 0, D.v = D.top + D.bottom, D.h = D.left + D.right, this.$updateCachedSize(!0, this.gutterWidth, this.$size.width, this.$size.height), this.updateFull();
        }, A.prototype.getHScrollBarAlwaysVisible = function() {
          return this.$hScrollBarAlwaysVisible;
        }, A.prototype.setHScrollBarAlwaysVisible = function($) {
          this.setOption("hScrollBarAlwaysVisible", $);
        }, A.prototype.getVScrollBarAlwaysVisible = function() {
          return this.$vScrollBarAlwaysVisible;
        }, A.prototype.setVScrollBarAlwaysVisible = function($) {
          this.setOption("vScrollBarAlwaysVisible", $);
        }, A.prototype.$updateScrollBarV = function() {
          var $ = this.layerConfig.maxHeight, M = this.$size.scrollerHeight;
          !this.$maxLines && this.$scrollPastEnd && ($ -= (M - this.lineHeight) * this.$scrollPastEnd, this.scrollTop > $ - M && ($ = this.scrollTop + M, this.scrollBarV.scrollTop = null)), this.scrollBarV.setScrollHeight($ + this.scrollMargin.v), this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
        }, A.prototype.$updateScrollBarH = function() {
          this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h), this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
        }, A.prototype.freeze = function() {
          this.$frozen = !0;
        }, A.prototype.unfreeze = function() {
          this.$frozen = !1;
        }, A.prototype.$renderChanges = function($, M) {
          if (this.$changes && ($ |= this.$changes, this.$changes = 0), !this.session || !this.container.offsetWidth || this.$frozen || !$ && !M) {
            this.$changes |= $;
            return;
          }
          if (this.$size.$dirty)
            return this.$changes |= $, this.onResize(!0);
          this.lineHeight || this.$textLayer.checkForSizeChanges(), this._signal("beforeRender", $), this.session && this.session.$bidiHandler && this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
          var _ = this.layerConfig;
          if ($ & this.CHANGE_FULL || $ & this.CHANGE_SIZE || $ & this.CHANGE_TEXT || $ & this.CHANGE_LINES || $ & this.CHANGE_SCROLL || $ & this.CHANGE_H_SCROLL) {
            if ($ |= this.$computeLayerConfig() | this.$loop.clear(), _.firstRow != this.layerConfig.firstRow && _.firstRowScreen == this.layerConfig.firstRowScreen) {
              var T = this.scrollTop + (_.firstRow - Math.max(this.layerConfig.firstRow, 0)) * this.lineHeight;
              T > 0 && (this.scrollTop = T, $ = $ | this.CHANGE_SCROLL, $ |= this.$computeLayerConfig() | this.$loop.clear());
            }
            _ = this.layerConfig, this.$updateScrollBarV(), $ & this.CHANGE_H_SCROLL && this.$updateScrollBarH(), s.translate(this.content, -this.scrollLeft, -_.offset);
            var D = _.width + 2 * this.$padding + "px", E = _.minHeight + "px";
            s.setStyle(this.content.style, "width", D), s.setStyle(this.content.style, "height", E);
          }
          if ($ & this.CHANGE_H_SCROLL && (s.translate(this.content, -this.scrollLeft, -_.offset), this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller " : "ace_scroller ace_scroll-left ", this.enableKeyboardAccessibility && (this.scroller.className += this.keyboardFocusClassName)), $ & this.CHANGE_FULL) {
            this.$changedLines = null, this.$textLayer.update(_), this.$showGutter && this.$gutterLayer.update(_), this.$customScrollbar && this.$scrollDecorator.$updateDecorators(_), this.$markerBack.update(_), this.$markerFront.update(_), this.$cursorLayer.update(_), this.$moveTextAreaToCursor(), this._signal("afterRender", $);
            return;
          }
          if ($ & this.CHANGE_SCROLL) {
            this.$changedLines = null, $ & this.CHANGE_TEXT || $ & this.CHANGE_LINES ? this.$textLayer.update(_) : this.$textLayer.scrollLines(_), this.$showGutter && ($ & this.CHANGE_GUTTER || $ & this.CHANGE_LINES ? this.$gutterLayer.update(_) : this.$gutterLayer.scrollLines(_)), this.$customScrollbar && this.$scrollDecorator.$updateDecorators(_), this.$markerBack.update(_), this.$markerFront.update(_), this.$cursorLayer.update(_), this.$moveTextAreaToCursor(), this._signal("afterRender", $);
            return;
          }
          $ & this.CHANGE_TEXT ? (this.$changedLines = null, this.$textLayer.update(_), this.$showGutter && this.$gutterLayer.update(_), this.$customScrollbar && this.$scrollDecorator.$updateDecorators(_)) : $ & this.CHANGE_LINES ? ((this.$updateLines() || $ & this.CHANGE_GUTTER && this.$showGutter) && this.$gutterLayer.update(_), this.$customScrollbar && this.$scrollDecorator.$updateDecorators(_)) : $ & this.CHANGE_TEXT || $ & this.CHANGE_GUTTER ? (this.$showGutter && this.$gutterLayer.update(_), this.$customScrollbar && this.$scrollDecorator.$updateDecorators(_)) : $ & this.CHANGE_CURSOR && (this.$highlightGutterLine && this.$gutterLayer.updateLineHighlight(_), this.$customScrollbar && this.$scrollDecorator.$updateDecorators(_)), $ & this.CHANGE_CURSOR && (this.$cursorLayer.update(_), this.$moveTextAreaToCursor()), $ & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT) && this.$markerFront.update(_), $ & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK) && this.$markerBack.update(_), this._signal("afterRender", $);
        }, A.prototype.$autosize = function() {
          var $ = this.session.getScreenLength() * this.lineHeight, M = this.$maxLines * this.lineHeight, _ = Math.min(M, Math.max((this.$minLines || 1) * this.lineHeight, $)) + this.scrollMargin.v + (this.$extraHeight || 0);
          this.$horizScroll && (_ += this.scrollBarH.getHeight()), this.$maxPixelHeight && _ > this.$maxPixelHeight && (_ = this.$maxPixelHeight);
          var T = _ <= 2 * this.lineHeight, D = !T && $ > M;
          if (_ != this.desiredHeight || this.$size.height != this.desiredHeight || D != this.$vScroll) {
            D != this.$vScroll && (this.$vScroll = D, this.scrollBarV.setVisible(D));
            var E = this.container.clientWidth;
            this.container.style.height = _ + "px", this.$updateCachedSize(!0, this.$gutterWidth, E, _), this.desiredHeight = _, this._signal("autosize");
          }
        }, A.prototype.$computeLayerConfig = function() {
          var $ = this.session, M = this.$size, _ = M.height <= 2 * this.lineHeight, T = this.session.getScreenLength(), D = T * this.lineHeight, E = this.$getLongestLine(), R = !_ && (this.$hScrollBarAlwaysVisible || M.scrollerWidth - E - 2 * this.$padding < 0), I = this.$horizScroll !== R;
          I && (this.$horizScroll = R, this.scrollBarH.setVisible(R));
          var k = this.$vScroll;
          this.$maxLines && this.lineHeight > 1 && this.$autosize();
          var P = M.scrollerHeight + this.lineHeight, L = !this.$maxLines && this.$scrollPastEnd ? (M.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
          D += L;
          var N = this.scrollMargin;
          this.session.setScrollTop(Math.max(-N.top, Math.min(this.scrollTop, D - M.scrollerHeight + N.bottom))), this.session.setScrollLeft(Math.max(-N.left, Math.min(this.scrollLeft, E + 2 * this.$padding - M.scrollerWidth + N.right)));
          var F = !_ && (this.$vScrollBarAlwaysVisible || M.scrollerHeight - D + L < 0 || this.scrollTop > N.top), B = k !== F;
          B && (this.$vScroll = F, this.scrollBarV.setVisible(F));
          var j = this.scrollTop % this.lineHeight, z = Math.ceil(P / this.lineHeight) - 1, H = Math.max(0, Math.round((this.scrollTop - j) / this.lineHeight)), W = H + z, G, K, Y = this.lineHeight;
          H = $.screenToDocumentRow(H, 0);
          var X = $.getFoldLine(H);
          X && (H = X.start.row), G = $.documentToScreenRow(H, 0), K = $.getRowLength(H) * Y, W = Math.min($.screenToDocumentRow(W, 0), $.getLength() - 1), P = M.scrollerHeight + $.getRowLength(W) * Y + K, j = this.scrollTop - G * Y;
          var Z = 0;
          return (this.layerConfig.width != E || I) && (Z = this.CHANGE_H_SCROLL), (I || B) && (Z |= this.$updateCachedSize(!0, this.gutterWidth, M.width, M.height), this._signal("scrollbarVisibilityChanged"), B && (E = this.$getLongestLine())), this.layerConfig = {
            width: E,
            padding: this.$padding,
            firstRow: H,
            firstRowScreen: G,
            lastRow: W,
            lineHeight: Y,
            characterWidth: this.characterWidth,
            minHeight: P,
            maxHeight: D,
            offset: j,
            gutterOffset: Y ? Math.max(0, Math.ceil((j + M.height - M.scrollerHeight) / Y)) : 0,
            height: this.$size.scrollerHeight
          }, this.session.$bidiHandler && this.session.$bidiHandler.setContentWidth(E - this.$padding), Z;
        }, A.prototype.$updateLines = function() {
          if (this.$changedLines) {
            var $ = this.$changedLines.firstRow, M = this.$changedLines.lastRow;
            this.$changedLines = null;
            var _ = this.layerConfig;
            if (!($ > _.lastRow + 1) && !(M < _.firstRow)) {
              if (M === 1 / 0) {
                this.$showGutter && this.$gutterLayer.update(_), this.$textLayer.update(_);
                return;
              }
              return this.$textLayer.updateLines(_, $, M), !0;
            }
          }
        }, A.prototype.$getLongestLine = function() {
          var $ = this.session.getScreenWidth();
          return this.showInvisibles && !this.session.$useWrapMode && ($ += 1), this.$textLayer && $ > this.$textLayer.MAX_LINE_LENGTH && ($ = this.$textLayer.MAX_LINE_LENGTH + 30), Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round($ * this.characterWidth));
        }, A.prototype.updateFrontMarkers = function() {
          this.$markerFront.setMarkers(this.session.getMarkers(!0)), this.$loop.schedule(this.CHANGE_MARKER_FRONT);
        }, A.prototype.updateBackMarkers = function() {
          this.$markerBack.setMarkers(this.session.getMarkers()), this.$loop.schedule(this.CHANGE_MARKER_BACK);
        }, A.prototype.addGutterDecoration = function($, M) {
          this.$gutterLayer.addGutterDecoration($, M);
        }, A.prototype.removeGutterDecoration = function($, M) {
          this.$gutterLayer.removeGutterDecoration($, M);
        }, A.prototype.updateBreakpoints = function($) {
          this._rows = $, this.$loop.schedule(this.CHANGE_GUTTER);
        }, A.prototype.setAnnotations = function($) {
          this.$gutterLayer.setAnnotations($), this.$loop.schedule(this.CHANGE_GUTTER);
        }, A.prototype.updateCursor = function() {
          this.$loop.schedule(this.CHANGE_CURSOR);
        }, A.prototype.hideCursor = function() {
          this.$cursorLayer.hideCursor();
        }, A.prototype.showCursor = function() {
          this.$cursorLayer.showCursor();
        }, A.prototype.scrollSelectionIntoView = function($, M, _) {
          this.scrollCursorIntoView($, _), this.scrollCursorIntoView(M, _);
        }, A.prototype.scrollCursorIntoView = function($, M, _) {
          if (this.$size.scrollerHeight !== 0) {
            var T = this.$cursorLayer.getPixelPosition($), D = T.left, E = T.top, R = _ && _.top || 0, I = _ && _.bottom || 0;
            this.$scrollAnimation && (this.$stopAnimation = !0);
            var k = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
            k + R > E ? (M && k + R > E + this.lineHeight && (E -= M * this.$size.scrollerHeight), E === 0 && (E = -this.scrollMargin.top), this.session.setScrollTop(E)) : k + this.$size.scrollerHeight - I < E + this.lineHeight && (M && k + this.$size.scrollerHeight - I < E - this.lineHeight && (E += M * this.$size.scrollerHeight), this.session.setScrollTop(E + this.lineHeight + I - this.$size.scrollerHeight));
            var P = this.scrollLeft, L = 2 * this.layerConfig.characterWidth;
            D - L < P ? (D -= L, D < this.$padding + L && (D = -this.scrollMargin.left), this.session.setScrollLeft(D)) : (D += L, P + this.$size.scrollerWidth < D + this.characterWidth ? this.session.setScrollLeft(Math.round(D + this.characterWidth - this.$size.scrollerWidth)) : P <= this.$padding && D - P < this.characterWidth && this.session.setScrollLeft(0));
          }
        }, A.prototype.getScrollTop = function() {
          return this.session.getScrollTop();
        }, A.prototype.getScrollLeft = function() {
          return this.session.getScrollLeft();
        }, A.prototype.getScrollTopRow = function() {
          return this.scrollTop / this.lineHeight;
        }, A.prototype.getScrollBottomRow = function() {
          return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
        }, A.prototype.scrollToRow = function($) {
          this.session.setScrollTop($ * this.lineHeight);
        }, A.prototype.alignCursor = function($, M) {
          typeof $ == "number" && ($ = { row: $, column: 0 });
          var _ = this.$cursorLayer.getPixelPosition($), T = this.$size.scrollerHeight - this.lineHeight, D = _.top - T * (M || 0);
          return this.session.setScrollTop(D), D;
        }, A.prototype.$calcSteps = function($, M) {
          var _ = 0, T = this.STEPS, D = [], E = function(R, I, k) {
            return k * (Math.pow(R - 1, 3) + 1) + I;
          };
          for (_ = 0; _ < T; ++_)
            D.push(E(_ / this.STEPS, $, M - $));
          return D;
        }, A.prototype.scrollToLine = function($, M, _, T) {
          var D = this.$cursorLayer.getPixelPosition({ row: $, column: 0 }), E = D.top;
          M && (E -= this.$size.scrollerHeight / 2);
          var R = this.scrollTop;
          this.session.setScrollTop(E), _ !== !1 && this.animateScrolling(R, T);
        }, A.prototype.animateScrolling = function($, M) {
          var _ = this.scrollTop;
          if (!this.$animatedScroll)
            return;
          var T = this;
          if ($ == _)
            return;
          if (this.$scrollAnimation) {
            var D = this.$scrollAnimation.steps;
            if (D.length && ($ = D[0], $ == _))
              return;
          }
          var E = T.$calcSteps($, _);
          this.$scrollAnimation = { from: $, to: _, steps: E }, clearInterval(this.$timer), T.session.setScrollTop(E.shift()), T.session.$scrollTop = _;
          function R() {
            T.$timer = clearInterval(T.$timer), T.$scrollAnimation = null, T.$stopAnimation = !1, M && M();
          }
          this.$timer = setInterval(function() {
            if (T.$stopAnimation) {
              R();
              return;
            }
            if (!T.session)
              return clearInterval(T.$timer);
            E.length ? (T.session.setScrollTop(E.shift()), T.session.$scrollTop = _) : _ != null ? (T.session.$scrollTop = -1, T.session.setScrollTop(_), _ = null) : R();
          }, 10);
        }, A.prototype.scrollToY = function($) {
          this.scrollTop !== $ && (this.$loop.schedule(this.CHANGE_SCROLL), this.scrollTop = $);
        }, A.prototype.scrollToX = function($) {
          this.scrollLeft !== $ && (this.scrollLeft = $), this.$loop.schedule(this.CHANGE_H_SCROLL);
        }, A.prototype.scrollTo = function($, M) {
          this.session.setScrollTop(M), this.session.setScrollLeft($);
        }, A.prototype.scrollBy = function($, M) {
          M && this.session.setScrollTop(this.session.getScrollTop() + M), $ && this.session.setScrollLeft(this.session.getScrollLeft() + $);
        }, A.prototype.isScrollableBy = function($, M) {
          if (M < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top || M > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom || $ < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left || $ > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right)
            return !0;
        }, A.prototype.pixelToScreenCoordinates = function($, M) {
          var _;
          if (this.$hasCssTransforms) {
            _ = { top: 0, left: 0 };
            var T = this.$fontMetrics.transformCoordinates([$, M]);
            $ = T[1] - this.gutterWidth - this.margin.left, M = T[0];
          } else
            _ = this.scroller.getBoundingClientRect();
          var D = $ + this.scrollLeft - _.left - this.$padding, E = D / this.characterWidth, R = Math.floor((M + this.scrollTop - _.top) / this.lineHeight), I = this.$blockCursor ? Math.floor(E) : Math.round(E);
          return { row: R, column: I, side: E - I > 0 ? 1 : -1, offsetX: D };
        }, A.prototype.screenToTextCoordinates = function($, M) {
          var _;
          if (this.$hasCssTransforms) {
            _ = { top: 0, left: 0 };
            var T = this.$fontMetrics.transformCoordinates([$, M]);
            $ = T[1] - this.gutterWidth - this.margin.left, M = T[0];
          } else
            _ = this.scroller.getBoundingClientRect();
          var D = $ + this.scrollLeft - _.left - this.$padding, E = D / this.characterWidth, R = this.$blockCursor ? Math.floor(E) : Math.round(E), I = Math.floor((M + this.scrollTop - _.top) / this.lineHeight);
          return this.session.screenToDocumentPosition(I, Math.max(R, 0), D);
        }, A.prototype.textToScreenCoordinates = function($, M) {
          var _ = this.scroller.getBoundingClientRect(), T = this.session.documentToScreenPosition($, M), D = this.$padding + (this.session.$bidiHandler.isBidiRow(T.row, $) ? this.session.$bidiHandler.getPosLeft(T.column) : Math.round(T.column * this.characterWidth)), E = T.row * this.lineHeight;
          return {
            pageX: _.left + D - this.scrollLeft,
            pageY: _.top + E - this.scrollTop
          };
        }, A.prototype.visualizeFocus = function() {
          s.addCssClass(this.container, "ace_focus");
        }, A.prototype.visualizeBlur = function() {
          s.removeCssClass(this.container, "ace_focus");
        }, A.prototype.showComposition = function($) {
          this.$composition = $, $.cssText || ($.cssText = this.textarea.style.cssText), $.useTextareaForIME == null && ($.useTextareaForIME = this.$useTextareaForIME), this.$useTextareaForIME ? (s.addCssClass(this.textarea, "ace_composition"), this.textarea.style.cssText = "", this.$moveTextAreaToCursor(), this.$cursorLayer.element.style.display = "none") : $.markerId = this.session.addMarker($.markerRange, "ace_composition_marker", "text");
        }, A.prototype.setCompositionText = function($) {
          var M = this.session.selection.cursor;
          this.addToken($, "composition_placeholder", M.row, M.column), this.$moveTextAreaToCursor();
        }, A.prototype.hideComposition = function() {
          if (this.$composition) {
            this.$composition.markerId && this.session.removeMarker(this.$composition.markerId), s.removeCssClass(this.textarea, "ace_composition"), this.textarea.style.cssText = this.$composition.cssText;
            var $ = this.session.selection.cursor;
            this.removeExtraToken($.row, $.column), this.$composition = null, this.$cursorLayer.element.style.display = "";
          }
        }, A.prototype.setGhostText = function($, M) {
          var _ = this.session.selection.cursor, T = M || { row: _.row, column: _.column };
          this.removeGhostText();
          var D = $.split(`
`);
          if (this.addToken(D[0], "ghost_text", T.row, T.column), this.$ghostText = {
            text: $,
            position: {
              row: T.row,
              column: T.column
            }
          }, D.length > 1) {
            this.$ghostTextWidget = {
              text: D.slice(1).join(`
`),
              row: T.row,
              column: T.column,
              className: "ace_ghost_text"
            }, this.session.widgetManager.addLineWidget(this.$ghostTextWidget);
            var E = this.$cursorLayer.getPixelPosition(T, !0), R = this.container, I = R.getBoundingClientRect().height, k = D.length * this.lineHeight, P = k < I - E.top;
            if (P)
              return;
            k < I ? this.scrollBy(0, (D.length - 1) * this.lineHeight) : this.scrollToRow(T.row);
          }
        }, A.prototype.removeGhostText = function() {
          if (this.$ghostText) {
            var $ = this.$ghostText.position;
            this.removeExtraToken($.row, $.column), this.$ghostTextWidget && (this.session.widgetManager.removeLineWidget(this.$ghostTextWidget), this.$ghostTextWidget = null), this.$ghostText = null;
          }
        }, A.prototype.addToken = function($, M, _, T) {
          var D = this.session;
          D.bgTokenizer.lines[_] = null;
          var E = { type: M, value: $ }, R = D.getTokens(_);
          if (T == null || !R.length)
            R.push(E);
          else
            for (var I = 0, k = 0; k < R.length; k++) {
              var P = R[k];
              if (I += P.value.length, T <= I) {
                var L = P.value.length - (I - T), N = P.value.slice(0, L), F = P.value.slice(L);
                R.splice(k, 1, { type: P.type, value: N }, E, { type: P.type, value: F });
                break;
              }
            }
          this.updateLines(_, _);
        }, A.prototype.removeExtraToken = function($, M) {
          this.session.bgTokenizer.lines[$] = null, this.updateLines($, $);
        }, A.prototype.setTheme = function($, M) {
          var _ = this;
          if (this.$themeId = $, _._dispatchEvent("themeChange", { theme: $ }), !$ || typeof $ == "string") {
            var T = $ || this.$options.theme.initialValue;
            l.loadModule(["theme", T], D);
          } else
            D($);
          function D(E) {
            if (_.$themeId != $)
              return M && M();
            if (!E || !E.cssClass)
              throw new Error("couldn't load module " + $ + " or it didn't call define");
            E.$id && (_.$themeId = E.$id), s.importCssString(E.cssText, E.cssClass, _.container), _.theme && s.removeCssClass(_.container, _.theme.cssClass);
            var R = "padding" in E ? E.padding : "padding" in (_.theme || {}) ? 4 : _.$padding;
            _.$padding && R != _.$padding && _.setPadding(R), _.$theme = E.cssClass, _.theme = E, s.addCssClass(_.container, E.cssClass), s.setCssClass(_.container, "ace_dark", E.isDark), _.$size && (_.$size.width = 0, _.$updateSizeAsync()), _._dispatchEvent("themeLoaded", { theme: E }), M && M();
          }
        }, A.prototype.getTheme = function() {
          return this.$themeId;
        }, A.prototype.setStyle = function($, M) {
          s.setCssClass(this.container, $, M !== !1);
        }, A.prototype.unsetStyle = function($) {
          s.removeCssClass(this.container, $);
        }, A.prototype.setCursorStyle = function($) {
          s.setStyle(this.scroller.style, "cursor", $);
        }, A.prototype.setMouseCursor = function($) {
          s.setStyle(this.scroller.style, "cursor", $);
        }, A.prototype.attachToShadowRoot = function() {
          s.importCssString(w, "ace_editor.css", this.container);
        }, A.prototype.destroy = function() {
          this.freeze(), this.$fontMetrics.destroy(), this.$cursorLayer.destroy(), this.removeAllListeners(), this.container.textContent = "", this.setOption("useResizeObserver", !1);
        }, A.prototype.$updateCustomScrollbar = function($) {
          var M = this;
          this.$horizScroll = this.$vScroll = null, this.scrollBarV.element.remove(), this.scrollBarH.element.remove(), this.$scrollDecorator && delete this.$scrollDecorator, $ === !0 ? (this.scrollBarV = new m(this.container, this), this.scrollBarH = new g(this.container, this), this.scrollBarV.setHeight(this.$size.scrollerHeight), this.scrollBarH.setWidth(this.$size.scrollerWidth), this.scrollBarV.addEventListener("scroll", function(_) {
            M.$scrollAnimation || M.session.setScrollTop(_.data - M.scrollMargin.top);
          }), this.scrollBarH.addEventListener("scroll", function(_) {
            M.$scrollAnimation || M.session.setScrollLeft(_.data - M.scrollMargin.left);
          }), this.$scrollDecorator = new C(this.scrollBarV, this), this.$scrollDecorator.$updateDecorators()) : (this.scrollBarV = new p(this.container, this), this.scrollBarH = new h(this.container, this), this.scrollBarV.addEventListener("scroll", function(_) {
            M.$scrollAnimation || M.session.setScrollTop(_.data - M.scrollMargin.top);
          }), this.scrollBarH.addEventListener("scroll", function(_) {
            M.$scrollAnimation || M.session.setScrollLeft(_.data - M.scrollMargin.left);
          }));
        }, A.prototype.$addResizeObserver = function() {
          if (!(!window.ResizeObserver || this.$resizeObserver)) {
            var $ = this;
            this.$resizeTimer = a.delayedCall(function() {
              $.destroyed || $.onResize();
            }, 50), this.$resizeObserver = new window.ResizeObserver(function(M) {
              var _ = M[0].contentRect.width, T = M[0].contentRect.height;
              Math.abs($.$size.width - _) > 1 || Math.abs($.$size.height - T) > 1 ? $.$resizeTimer.delay() : $.$resizeTimer.cancel();
            }), this.$resizeObserver.observe(this.container);
          }
        }, A;
      }()
    );
    S.prototype.CHANGE_CURSOR = 1, S.prototype.CHANGE_MARKER = 2, S.prototype.CHANGE_GUTTER = 4, S.prototype.CHANGE_SCROLL = 8, S.prototype.CHANGE_LINES = 16, S.prototype.CHANGE_TEXT = 32, S.prototype.CHANGE_SIZE = 64, S.prototype.CHANGE_MARKER_BACK = 128, S.prototype.CHANGE_MARKER_FRONT = 256, S.prototype.CHANGE_FULL = 512, S.prototype.CHANGE_H_SCROLL = 1024, S.prototype.$changes = 0, S.prototype.$padding = null, S.prototype.$frozen = !1, S.prototype.STEPS = 8, o.implement(S.prototype, x), l.defineOptions(S.prototype, "renderer", {
      useResizeObserver: {
        set: function(A) {
          !A && this.$resizeObserver ? (this.$resizeObserver.disconnect(), this.$resizeTimer.cancel(), this.$resizeTimer = this.$resizeObserver = null) : A && !this.$resizeObserver && this.$addResizeObserver();
        }
      },
      animatedScroll: { initialValue: !1 },
      showInvisibles: {
        set: function(A) {
          this.$textLayer.setShowInvisibles(A) && this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: !1
      },
      showPrintMargin: {
        set: function() {
          this.$updatePrintMargin();
        },
        initialValue: !0
      },
      printMarginColumn: {
        set: function() {
          this.$updatePrintMargin();
        },
        initialValue: 80
      },
      printMargin: {
        set: function(A) {
          typeof A == "number" && (this.$printMarginColumn = A), this.$showPrintMargin = !!A, this.$updatePrintMargin();
        },
        get: function() {
          return this.$showPrintMargin && this.$printMarginColumn;
        }
      },
      showGutter: {
        set: function(A) {
          this.$gutter.style.display = A ? "block" : "none", this.$loop.schedule(this.CHANGE_FULL), this.onGutterResize();
        },
        initialValue: !0
      },
      useSvgGutterIcons: {
        set: function(A) {
          this.$gutterLayer.$useSvgGutterIcons = A;
        },
        initialValue: !1
      },
      showFoldedAnnotations: {
        set: function(A) {
          this.$gutterLayer.$showFoldedAnnotations = A;
        },
        initialValue: !1
      },
      fadeFoldWidgets: {
        set: function(A) {
          s.setCssClass(this.$gutter, "ace_fade-fold-widgets", A);
        },
        initialValue: !1
      },
      showFoldWidgets: {
        set: function(A) {
          this.$gutterLayer.setShowFoldWidgets(A), this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: !0
      },
      displayIndentGuides: {
        set: function(A) {
          this.$textLayer.setDisplayIndentGuides(A) && this.$loop.schedule(this.CHANGE_TEXT);
        },
        initialValue: !0
      },
      highlightIndentGuides: {
        set: function(A) {
          this.$textLayer.setHighlightIndentGuides(A) == !0 ? this.$textLayer.$highlightIndentGuide() : this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);
        },
        initialValue: !0
      },
      highlightGutterLine: {
        set: function(A) {
          this.$gutterLayer.setHighlightGutterLine(A), this.$loop.schedule(this.CHANGE_GUTTER);
        },
        initialValue: !0
      },
      hScrollBarAlwaysVisible: {
        set: function(A) {
          (!this.$hScrollBarAlwaysVisible || !this.$horizScroll) && this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: !1
      },
      vScrollBarAlwaysVisible: {
        set: function(A) {
          (!this.$vScrollBarAlwaysVisible || !this.$vScroll) && this.$loop.schedule(this.CHANGE_SCROLL);
        },
        initialValue: !1
      },
      fontSize: {
        set: function(A) {
          typeof A == "number" && (A = A + "px"), this.container.style.fontSize = A, this.updateFontSize();
        },
        initialValue: 12
      },
      fontFamily: {
        set: function(A) {
          this.container.style.fontFamily = A, this.updateFontSize();
        }
      },
      maxLines: {
        set: function(A) {
          this.updateFull();
        }
      },
      minLines: {
        set: function(A) {
          this.$minLines < 562949953421311 || (this.$minLines = 0), this.updateFull();
        }
      },
      maxPixelHeight: {
        set: function(A) {
          this.updateFull();
        },
        initialValue: 0
      },
      scrollPastEnd: {
        set: function(A) {
          A = +A || 0, this.$scrollPastEnd != A && (this.$scrollPastEnd = A, this.$loop.schedule(this.CHANGE_SCROLL));
        },
        initialValue: 0,
        handlesSet: !0
      },
      fixedWidthGutter: {
        set: function(A) {
          this.$gutterLayer.$fixedWidth = !!A, this.$loop.schedule(this.CHANGE_GUTTER);
        }
      },
      customScrollbar: {
        set: function(A) {
          this.$updateCustomScrollbar(A);
        },
        initialValue: !1
      },
      theme: {
        set: function(A) {
          this.setTheme(A);
        },
        get: function() {
          return this.$themeId || this.theme;
        },
        initialValue: "./theme/textmate",
        handlesSet: !0
      },
      hasCssTransforms: {},
      useTextareaForIME: {
        initialValue: !y.isMobile && !y.isIE
      }
    }), r.VirtualRenderer = S;
  }), ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function(n, r, i) {
    var o = n("../lib/oop"), s = n("../lib/net"), a = n("../lib/event_emitter").EventEmitter, l = n("../config");
    function u(h) {
      var p = "importScripts('" + s.qualifyURL(h) + "');";
      try {
        return new Blob([p], { type: "application/javascript" });
      } catch {
        var g = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder, m = new g();
        return m.append(p), m.getBlob("application/javascript");
      }
    }
    function c(h) {
      if (typeof Worker > "u")
        return { postMessage: function() {
        }, terminate: function() {
        } };
      if (l.get("loadWorkerFromBlob")) {
        var p = u(h), g = window.URL || window.webkitURL, m = g.createObjectURL(p);
        return new Worker(m);
      }
      return new Worker(h);
    }
    var d = function(h) {
      h.postMessage || (h = this.$createWorkerFromOldConfig.apply(this, arguments)), this.$worker = h, this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this), this.changeListener = this.changeListener.bind(this), this.onMessage = this.onMessage.bind(this), this.callbackId = 1, this.callbacks = {}, this.$worker.onmessage = this.onMessage;
    };
    (function() {
      o.implement(this, a), this.$createWorkerFromOldConfig = function(h, p, g, m, v) {
        if (n.nameToUrl && !n.toUrl && (n.toUrl = n.nameToUrl), l.get("packaged") || !n.toUrl)
          m = m || l.moduleUrl(p, "worker");
        else {
          var b = this.$normalizePath;
          m = m || b(n.toUrl("ace/worker/worker.js", null, "_"));
          var x = {};
          h.forEach(function(w) {
            x[w] = b(n.toUrl(w, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
          });
        }
        return this.$worker = c(m), v && this.send("importScripts", v), this.$worker.postMessage({
          init: !0,
          tlns: x,
          module: p,
          classname: g
        }), this.$worker;
      }, this.onMessage = function(h) {
        var p = h.data;
        switch (p.type) {
          case "event":
            this._signal(p.name, { data: p.data });
            break;
          case "call":
            var g = this.callbacks[p.id];
            g && (g(p.data), delete this.callbacks[p.id]);
            break;
          case "error":
            this.reportError(p.data);
            break;
          case "log":
            window.console && console.log && console.log.apply(console, p.data);
            break;
        }
      }, this.reportError = function(h) {
        window.console && console.error && console.error(h);
      }, this.$normalizePath = function(h) {
        return s.qualifyURL(h);
      }, this.terminate = function() {
        this._signal("terminate", {}), this.deltaQueue = null, this.$worker.terminate(), this.$worker.onerror = function(h) {
          h.preventDefault();
        }, this.$worker = null, this.$doc && this.$doc.off("change", this.changeListener), this.$doc = null;
      }, this.send = function(h, p) {
        this.$worker.postMessage({ command: h, args: p });
      }, this.call = function(h, p, g) {
        if (g) {
          var m = this.callbackId++;
          this.callbacks[m] = g, p.push(m);
        }
        this.send(h, p);
      }, this.emit = function(h, p) {
        try {
          p.data && p.data.err && (p.data.err = { message: p.data.err.message, stack: p.data.err.stack, code: p.data.err.code }), this.$worker && this.$worker.postMessage({ event: h, data: { data: p.data } });
        } catch (g) {
          console.error(g.stack);
        }
      }, this.attachToDocument = function(h) {
        this.$doc && this.terminate(), this.$doc = h, this.call("setValue", [h.getValue()]), h.on("change", this.changeListener, !0);
      }, this.changeListener = function(h) {
        this.deltaQueue || (this.deltaQueue = [], setTimeout(this.$sendDeltaQueue, 0)), h.action == "insert" ? this.deltaQueue.push(h.start, h.lines) : this.deltaQueue.push(h.start, h.end);
      }, this.$sendDeltaQueue = function() {
        var h = this.deltaQueue;
        h && (this.deltaQueue = null, h.length > 50 && h.length > this.$doc.getLength() >> 1 ? this.call("setValue", [this.$doc.getValue()]) : this.emit("change", { data: h }));
      };
    }).call(d.prototype);
    var f = function(h, p, g) {
      var m = null, v = !1, b = Object.create(a), x = [], w = new d({
        messageBuffer: x,
        terminate: function() {
        },
        postMessage: function(y) {
          x.push(y), m && (v ? setTimeout(C) : C());
        }
      });
      w.setEmitSync = function(y) {
        v = y;
      };
      var C = function() {
        var y = x.shift();
        y.command ? m[y.command].apply(m, y.args) : y.event && b._signal(y.event, y.data);
      };
      return b.postMessage = function(y) {
        w.onMessage({ data: y });
      }, b.callback = function(y, S) {
        this.postMessage({ type: "call", id: S, data: y });
      }, b.emit = function(y, S) {
        this.postMessage({ type: "event", name: y, data: S });
      }, l.loadModule(["worker", p], function(y) {
        for (m = new y[g](b); x.length; )
          C();
      }), w;
    };
    r.UIWorkerClient = f, r.WorkerClient = d, r.createWorker = c;
  }), ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function(n, r, i) {
    var o = n("./range").Range, s = n("./lib/event_emitter").EventEmitter, a = n("./lib/oop"), l = (
      /** @class */
      function() {
        function u(c, d, f, h, p, g) {
          var m = this;
          this.length = d, this.session = c, this.doc = c.getDocument(), this.mainClass = p, this.othersClass = g, this.$onUpdate = this.onUpdate.bind(this), this.doc.on("change", this.$onUpdate, !0), this.$others = h, this.$onCursorChange = function() {
            setTimeout(function() {
              m.onCursorChange();
            });
          }, this.$pos = f;
          var v = c.getUndoManager().$undoStack || c.getUndoManager().$undostack || { length: -1 };
          this.$undoStackDepth = v.length, this.setup(), c.selection.on("changeCursor", this.$onCursorChange);
        }
        return u.prototype.setup = function() {
          var c = this, d = this.doc, f = this.session;
          this.selectionBefore = f.selection.toJSON(), f.selection.inMultiSelectMode && f.selection.toSingleRange(), this.pos = d.createAnchor(this.$pos.row, this.$pos.column);
          var h = this.pos;
          h.$insertRight = !0, h.detach(), h.markerId = f.addMarker(new o(h.row, h.column, h.row, h.column + this.length), this.mainClass, null, !1), this.others = [], this.$others.forEach(function(p) {
            var g = d.createAnchor(p.row, p.column);
            g.$insertRight = !0, g.detach(), c.others.push(g);
          }), f.setUndoSelect(!1);
        }, u.prototype.showOtherMarkers = function() {
          if (!this.othersActive) {
            var c = this.session, d = this;
            this.othersActive = !0, this.others.forEach(function(f) {
              f.markerId = c.addMarker(new o(f.row, f.column, f.row, f.column + d.length), d.othersClass, null, !1);
            });
          }
        }, u.prototype.hideOtherMarkers = function() {
          if (this.othersActive) {
            this.othersActive = !1;
            for (var c = 0; c < this.others.length; c++)
              this.session.removeMarker(this.others[c].markerId);
          }
        }, u.prototype.onUpdate = function(c) {
          if (this.$updating)
            return this.updateAnchors(c);
          var d = c;
          if (d.start.row === d.end.row && d.start.row === this.pos.row) {
            this.$updating = !0;
            var f = c.action === "insert" ? d.end.column - d.start.column : d.start.column - d.end.column, h = d.start.column >= this.pos.column && d.start.column <= this.pos.column + this.length + 1, p = d.start.column - this.pos.column;
            if (this.updateAnchors(c), h && (this.length += f), h && !this.session.$fromUndo) {
              if (c.action === "insert")
                for (var g = this.others.length - 1; g >= 0; g--) {
                  var m = this.others[g], v = { row: m.row, column: m.column + p };
                  this.doc.insertMergedLines(v, c.lines);
                }
              else if (c.action === "remove")
                for (var g = this.others.length - 1; g >= 0; g--) {
                  var m = this.others[g], v = { row: m.row, column: m.column + p };
                  this.doc.remove(new o(v.row, v.column, v.row, v.column - f));
                }
            }
            this.$updating = !1, this.updateMarkers();
          }
        }, u.prototype.updateAnchors = function(c) {
          this.pos.onChange(c);
          for (var d = this.others.length; d--; )
            this.others[d].onChange(c);
          this.updateMarkers();
        }, u.prototype.updateMarkers = function() {
          if (!this.$updating) {
            var c = this, d = this.session, f = function(p, g) {
              d.removeMarker(p.markerId), p.markerId = d.addMarker(new o(p.row, p.column, p.row, p.column + c.length), g, null, !1);
            };
            f(this.pos, this.mainClass);
            for (var h = this.others.length; h--; )
              f(this.others[h], this.othersClass);
          }
        }, u.prototype.onCursorChange = function(c) {
          if (!(this.$updating || !this.session)) {
            var d = this.session.selection.getCursor();
            d.row === this.pos.row && d.column >= this.pos.column && d.column <= this.pos.column + this.length ? (this.showOtherMarkers(), this._emit("cursorEnter", c)) : (this.hideOtherMarkers(), this._emit("cursorLeave", c));
          }
        }, u.prototype.detach = function() {
          this.session.removeMarker(this.pos && this.pos.markerId), this.hideOtherMarkers(), this.doc.off("change", this.$onUpdate), this.session.selection.off("changeCursor", this.$onCursorChange), this.session.setUndoSelect(!0), this.session = null;
        }, u.prototype.cancel = function() {
          if (this.$undoStackDepth !== -1) {
            for (var c = this.session.getUndoManager(), d = (c.$undoStack || c.$undostack).length - this.$undoStackDepth, f = 0; f < d; f++)
              c.undo(this.session, !0);
            this.selectionBefore && this.session.selection.fromJSON(this.selectionBefore);
          }
        }, u;
      }()
    );
    a.implement(l.prototype, s), r.PlaceHolder = l;
  }), ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(n, r, i) {
    var o = n("../lib/event"), s = n("../lib/useragent");
    function a(u, c) {
      return u.row == c.row && u.column == c.column;
    }
    function l(u) {
      var c = u.domEvent, d = c.altKey, f = c.shiftKey, h = c.ctrlKey, p = u.getAccelKey(), g = u.getButton();
      if (h && s.isMac && (g = c.button), u.editor.inMultiSelectMode && g == 2) {
        u.editor.textInput.onContextMenu(u.domEvent);
        return;
      }
      if (!h && !d && !p) {
        g === 0 && u.editor.inMultiSelectMode && u.editor.exitMultiSelectMode();
        return;
      }
      if (g === 0) {
        var m = u.editor, v = m.selection, b = m.inMultiSelectMode, x = u.getDocumentPosition(), w = v.getCursor(), C = u.inSelection() || v.isEmpty() && a(x, w), y = u.x, S = u.y, A = function(F) {
          y = F.clientX, S = F.clientY;
        }, $ = m.session, M = m.renderer.pixelToScreenCoordinates(y, S), _ = M, T;
        if (m.$mouseHandler.$enableJumpToDef)
          h && d || p && d ? T = f ? "block" : "add" : d && m.$blockSelectEnabled && (T = "block");
        else if (p && !d) {
          if (T = "add", !b && f)
            return;
        } else
          d && m.$blockSelectEnabled && (T = "block");
        if (T && s.isMac && c.ctrlKey && m.$mouseHandler.cancelContextMenu(), T == "add") {
          if (!b && C)
            return;
          if (!b) {
            var D = v.toOrientedRange();
            m.addSelectionMarker(D);
          }
          var E = v.rangeList.rangeAtPoint(x);
          m.inVirtualSelectionMode = !0, f && (E = null, D = v.ranges[0] || D, m.removeSelectionMarker(D)), m.once("mouseup", function() {
            var F = v.toOrientedRange();
            E && F.isEmpty() && a(E.cursor, F.cursor) ? v.substractPoint(F.cursor) : (f ? v.substractPoint(D.cursor) : D && (m.removeSelectionMarker(D), v.addRange(D)), v.addRange(F)), m.inVirtualSelectionMode = !1;
          });
        } else if (T == "block") {
          u.stop(), m.inVirtualSelectionMode = !0;
          var R, I = [], k = function() {
            var F = m.renderer.pixelToScreenCoordinates(y, S), B = $.screenToDocumentPosition(F.row, F.column, F.offsetX);
            a(_, F) && a(B, v.lead) || (_ = F, m.selection.moveToPosition(B), m.renderer.scrollCursorIntoView(), m.removeSelectionMarkers(I), I = v.rectangularRangeBlock(_, M), m.$mouseHandler.$clickSelection && I.length == 1 && I[0].isEmpty() && (I[0] = m.$mouseHandler.$clickSelection.clone()), I.forEach(m.addSelectionMarker, m), m.updateSelectionMarkers());
          };
          b && !p ? v.toSingleRange() : !b && p && (R = v.toOrientedRange(), m.addSelectionMarker(R)), f ? M = $.documentToScreenPosition(v.lead) : v.moveToPosition(x), _ = { row: -1, column: -1 };
          var P = function(F) {
            k(), clearInterval(N), m.removeSelectionMarkers(I), I.length || (I = [v.toOrientedRange()]), R && (m.removeSelectionMarker(R), v.toSingleRange(R));
            for (var B = 0; B < I.length; B++)
              v.addRange(I[B]);
            m.inVirtualSelectionMode = !1, m.$mouseHandler.$clickSelection = null;
          }, L = k;
          o.capture(m.container, A, P);
          var N = setInterval(function() {
            L();
          }, 20);
          return u.preventDefault();
        }
      }
    }
    r.onMouseDown = l;
  }), ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function(n, r, i) {
    r.defaultCommands = [{
      name: "addCursorAbove",
      description: "Add cursor above",
      exec: function(s) {
        s.selectMoreLines(-1);
      },
      bindKey: { win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up" },
      scrollIntoView: "cursor",
      readOnly: !0
    }, {
      name: "addCursorBelow",
      description: "Add cursor below",
      exec: function(s) {
        s.selectMoreLines(1);
      },
      bindKey: { win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down" },
      scrollIntoView: "cursor",
      readOnly: !0
    }, {
      name: "addCursorAboveSkipCurrent",
      description: "Add cursor above (skip current)",
      exec: function(s) {
        s.selectMoreLines(-1, !0);
      },
      bindKey: { win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up" },
      scrollIntoView: "cursor",
      readOnly: !0
    }, {
      name: "addCursorBelowSkipCurrent",
      description: "Add cursor below (skip current)",
      exec: function(s) {
        s.selectMoreLines(1, !0);
      },
      bindKey: { win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down" },
      scrollIntoView: "cursor",
      readOnly: !0
    }, {
      name: "selectMoreBefore",
      description: "Select more before",
      exec: function(s) {
        s.selectMore(-1);
      },
      bindKey: { win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left" },
      scrollIntoView: "cursor",
      readOnly: !0
    }, {
      name: "selectMoreAfter",
      description: "Select more after",
      exec: function(s) {
        s.selectMore(1);
      },
      bindKey: { win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right" },
      scrollIntoView: "cursor",
      readOnly: !0
    }, {
      name: "selectNextBefore",
      description: "Select next before",
      exec: function(s) {
        s.selectMore(-1, !0);
      },
      bindKey: { win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left" },
      scrollIntoView: "cursor",
      readOnly: !0
    }, {
      name: "selectNextAfter",
      description: "Select next after",
      exec: function(s) {
        s.selectMore(1, !0);
      },
      bindKey: { win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right" },
      scrollIntoView: "cursor",
      readOnly: !0
    }, {
      name: "toggleSplitSelectionIntoLines",
      description: "Split selection into lines",
      exec: function(s) {
        s.multiSelect.rangeCount > 1 ? s.multiSelect.joinSelections() : s.multiSelect.splitIntoLines();
      },
      bindKey: { win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L" },
      readOnly: !0
    }, {
      name: "splitSelectionIntoLines",
      description: "Split into lines",
      exec: function(s) {
        s.multiSelect.splitIntoLines();
      },
      readOnly: !0
    }, {
      name: "alignCursors",
      description: "Align cursors",
      exec: function(s) {
        s.alignCursors();
      },
      bindKey: { win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A" },
      scrollIntoView: "cursor"
    }, {
      name: "findAll",
      description: "Find all",
      exec: function(s) {
        s.findAll();
      },
      bindKey: { win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G" },
      scrollIntoView: "cursor",
      readOnly: !0
    }], r.multiSelectCommands = [{
      name: "singleSelection",
      description: "Single selection",
      bindKey: "esc",
      exec: function(s) {
        s.exitMultiSelectMode();
      },
      scrollIntoView: "cursor",
      readOnly: !0,
      isAvailable: function(s) {
        return s && s.inMultiSelectMode;
      }
    }];
    var o = n("../keyboard/hash_handler").HashHandler;
    r.keyboardHandler = new o(r.multiSelectCommands);
  }), ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function(n, r, i) {
    var o = n("./range_list").RangeList, s = n("./range").Range, a = n("./selection").Selection, l = n("./mouse/multi_select_handler").onMouseDown, u = n("./lib/event"), c = n("./lib/lang"), d = n("./commands/multi_select_commands");
    r.commands = d.defaultCommands.concat(d.multiSelectCommands);
    var f = n("./search").Search, h = new f();
    function p(w, C, y) {
      return h.$options.wrap = !0, h.$options.needle = C, h.$options.backwards = y == -1, h.find(w);
    }
    var g = n("./edit_session").EditSession;
    (function() {
      this.getSelectionMarkers = function() {
        return this.$selectionMarkers;
      };
    }).call(g.prototype), (function() {
      this.ranges = null, this.rangeList = null, this.addRange = function(w, C) {
        if (w) {
          if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var y = this.toOrientedRange();
            if (this.rangeList.add(y), this.rangeList.add(w), this.rangeList.ranges.length != 2)
              return this.rangeList.removeAll(), C || this.fromOrientedRange(w);
            this.rangeList.removeAll(), this.rangeList.add(y), this.$onAddRange(y);
          }
          w.cursor || (w.cursor = w.end);
          var S = this.rangeList.add(w);
          return this.$onAddRange(w), S.length && this.$onRemoveRange(S), this.rangeCount > 1 && !this.inMultiSelectMode && (this._signal("multiSelect"), this.inMultiSelectMode = !0, this.session.$undoSelect = !1, this.rangeList.attach(this.session)), C || this.fromOrientedRange(w);
        }
      }, this.toSingleRange = function(w) {
        w = w || this.ranges[0];
        var C = this.rangeList.removeAll();
        C.length && this.$onRemoveRange(C), w && this.fromOrientedRange(w);
      }, this.substractPoint = function(w) {
        var C = this.rangeList.substractPoint(w);
        if (C)
          return this.$onRemoveRange(C), C[0];
      }, this.mergeOverlappingRanges = function() {
        var w = this.rangeList.merge();
        w.length && this.$onRemoveRange(w);
      }, this.$onAddRange = function(w) {
        this.rangeCount = this.rangeList.ranges.length, this.ranges.unshift(w), this._signal("addRange", { range: w });
      }, this.$onRemoveRange = function(w) {
        if (this.rangeCount = this.rangeList.ranges.length, this.rangeCount == 1 && this.inMultiSelectMode) {
          var C = this.rangeList.ranges.pop();
          w.push(C), this.rangeCount = 0;
        }
        for (var y = w.length; y--; ) {
          var S = this.ranges.indexOf(w[y]);
          this.ranges.splice(S, 1);
        }
        this._signal("removeRange", { ranges: w }), this.rangeCount === 0 && this.inMultiSelectMode && (this.inMultiSelectMode = !1, this._signal("singleSelect"), this.session.$undoSelect = !0, this.rangeList.detach(this.session)), C = C || this.ranges[0], C && !C.isEqual(this.getRange()) && this.fromOrientedRange(C);
      }, this.$initRangeList = function() {
        this.rangeList || (this.rangeList = new o(), this.ranges = [], this.rangeCount = 0);
      }, this.getAllRanges = function() {
        return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
      }, this.splitIntoLines = function() {
        for (var w = this.ranges.length ? this.ranges : [this.getRange()], C = [], y = 0; y < w.length; y++) {
          var S = w[y], A = S.start.row, $ = S.end.row;
          if (A === $)
            C.push(S.clone());
          else {
            for (C.push(new s(A, S.start.column, A, this.session.getLine(A).length)); ++A < $; )
              C.push(this.getLineRange(A, !0));
            C.push(new s($, 0, $, S.end.column));
          }
          y == 0 && !this.isBackwards() && (C = C.reverse());
        }
        this.toSingleRange();
        for (var y = C.length; y--; )
          this.addRange(C[y]);
      }, this.joinSelections = function() {
        var w = this.rangeList.ranges, C = w[w.length - 1], y = s.fromPoints(w[0].start, C.end);
        this.toSingleRange(), this.setSelectionRange(y, C.cursor == C.start);
      }, this.toggleBlockSelection = function() {
        if (this.rangeCount > 1) {
          var w = this.rangeList.ranges, C = w[w.length - 1], y = s.fromPoints(w[0].start, C.end);
          this.toSingleRange(), this.setSelectionRange(y, C.cursor == C.start);
        } else {
          var S = this.session.documentToScreenPosition(this.cursor), A = this.session.documentToScreenPosition(this.anchor), $ = this.rectangularRangeBlock(S, A);
          $.forEach(this.addRange, this);
        }
      }, this.rectangularRangeBlock = function(w, C, y) {
        var S = [], A = w.column < C.column;
        if (A)
          var $ = w.column, M = C.column, _ = w.offsetX, T = C.offsetX;
        else
          var $ = C.column, M = w.column, _ = C.offsetX, T = w.offsetX;
        var D = w.row < C.row;
        if (D)
          var E = w.row, R = C.row;
        else
          var E = C.row, R = w.row;
        $ < 0 && ($ = 0), E < 0 && (E = 0), E == R && (y = !0);
        for (var I, k = E; k <= R; k++) {
          var P = s.fromPoints(this.session.screenToDocumentPosition(k, $, _), this.session.screenToDocumentPosition(k, M, T));
          if (P.isEmpty()) {
            if (I && v(P.end, I))
              break;
            I = P.end;
          }
          P.cursor = A ? P.start : P.end, S.push(P);
        }
        if (D && S.reverse(), !y) {
          for (var L = S.length - 1; S[L].isEmpty() && L > 0; )
            L--;
          if (L > 0)
            for (var N = 0; S[N].isEmpty(); )
              N++;
          for (var F = L; F >= N; F--)
            S[F].isEmpty() && S.splice(F, 1);
        }
        return S;
      };
    }).call(a.prototype);
    var m = n("./editor").Editor;
    (function() {
      this.updateSelectionMarkers = function() {
        this.renderer.updateCursor(), this.renderer.updateBackMarkers();
      }, this.addSelectionMarker = function(w) {
        w.cursor || (w.cursor = w.end);
        var C = this.getSelectionStyle();
        return w.marker = this.session.addMarker(w, "ace_selection", C), this.session.$selectionMarkers.push(w), this.session.selectionMarkerCount = this.session.$selectionMarkers.length, w;
      }, this.removeSelectionMarker = function(w) {
        if (w.marker) {
          this.session.removeMarker(w.marker);
          var C = this.session.$selectionMarkers.indexOf(w);
          C != -1 && this.session.$selectionMarkers.splice(C, 1), this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        }
      }, this.removeSelectionMarkers = function(w) {
        for (var C = this.session.$selectionMarkers, y = w.length; y--; ) {
          var S = w[y];
          if (S.marker) {
            this.session.removeMarker(S.marker);
            var A = C.indexOf(S);
            A != -1 && C.splice(A, 1);
          }
        }
        this.session.selectionMarkerCount = C.length;
      }, this.$onAddRange = function(w) {
        this.addSelectionMarker(w.range), this.renderer.updateCursor(), this.renderer.updateBackMarkers();
      }, this.$onRemoveRange = function(w) {
        this.removeSelectionMarkers(w.ranges), this.renderer.updateCursor(), this.renderer.updateBackMarkers();
      }, this.$onMultiSelect = function(w) {
        this.inMultiSelectMode || (this.inMultiSelectMode = !0, this.setStyle("ace_multiselect"), this.keyBinding.addKeyboardHandler(d.keyboardHandler), this.commands.setDefaultHandler("exec", this.$onMultiSelectExec), this.renderer.updateCursor(), this.renderer.updateBackMarkers());
      }, this.$onSingleSelect = function(w) {
        this.session.multiSelect.inVirtualMode || (this.inMultiSelectMode = !1, this.unsetStyle("ace_multiselect"), this.keyBinding.removeKeyboardHandler(d.keyboardHandler), this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec), this.renderer.updateCursor(), this.renderer.updateBackMarkers(), this._emit("changeSelection"));
      }, this.$onMultiSelectExec = function(w) {
        var C = w.command, y = w.editor;
        if (y.multiSelect) {
          if (C.multiSelectAction)
            C.multiSelectAction == "forEach" ? S = y.forEachSelection(C, w.args) : C.multiSelectAction == "forEachLine" ? S = y.forEachSelection(C, w.args, !0) : C.multiSelectAction == "single" ? (y.exitMultiSelectMode(), S = C.exec(y, w.args || {})) : S = C.multiSelectAction(y, w.args || {});
          else {
            var S = C.exec(y, w.args || {});
            y.multiSelect.addRange(y.multiSelect.toOrientedRange()), y.multiSelect.mergeOverlappingRanges();
          }
          return S;
        }
      }, this.forEachSelection = function(w, C, y) {
        if (!this.inVirtualSelectionMode) {
          var S = y && y.keepOrder, A = y == !0 || y && y.$byLines, $ = this.session, M = this.selection, _ = M.rangeList, T = (S ? M : _).ranges, D;
          if (!T.length)
            return w.exec ? w.exec(this, C || {}) : w(this, C || {});
          var E = M._eventRegistry;
          M._eventRegistry = {};
          var R = new a($);
          this.inVirtualSelectionMode = !0;
          for (var I = T.length; I--; ) {
            if (A)
              for (; I > 0 && T[I].start.row == T[I - 1].end.row; )
                I--;
            R.fromOrientedRange(T[I]), R.index = I, this.selection = $.selection = R;
            var k = w.exec ? w.exec(this, C || {}) : w(this, C || {});
            !D && k !== void 0 && (D = k), R.toOrientedRange(T[I]);
          }
          R.detach(), this.selection = $.selection = M, this.inVirtualSelectionMode = !1, M._eventRegistry = E, M.mergeOverlappingRanges(), M.ranges[0] && M.fromOrientedRange(M.ranges[0]);
          var P = this.renderer.$scrollAnimation;
          return this.onCursorChange(), this.onSelectionChange(), P && P.from == P.to && this.renderer.animateScrolling(P.from), D;
        }
      }, this.exitMultiSelectMode = function() {
        !this.inMultiSelectMode || this.inVirtualSelectionMode || this.multiSelect.toSingleRange();
      }, this.getSelectedText = function() {
        var w = "";
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
          for (var C = this.multiSelect.rangeList.ranges, y = [], S = 0; S < C.length; S++)
            y.push(this.session.getTextRange(C[S]));
          var A = this.session.getDocument().getNewLineCharacter();
          w = y.join(A), w.length == (y.length - 1) * A.length && (w = "");
        } else
          this.selection.isEmpty() || (w = this.session.getTextRange(this.getSelectionRange()));
        return w;
      }, this.$checkMultiselectChange = function(w, C) {
        if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
          var y = this.multiSelect.ranges[0];
          if (this.multiSelect.isEmpty() && C == this.multiSelect.anchor)
            return;
          var S = C == this.multiSelect.anchor ? y.cursor == y.start ? y.end : y.start : y.cursor;
          S.row != C.row || this.session.$clipPositionToDocument(S.row, S.column).column != C.column ? this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange()) : this.multiSelect.mergeOverlappingRanges();
        }
      }, this.findAll = function(w, C, y) {
        if (C = C || {}, C.needle = w || C.needle, C.needle == null) {
          var S = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
          C.needle = this.session.getTextRange(S);
        }
        this.$search.set(C);
        var A = this.$search.findAll(this.session);
        if (!A.length)
          return 0;
        var $ = this.multiSelect;
        y || $.toSingleRange(A[0]);
        for (var M = A.length; M--; )
          $.addRange(A[M], !0);
        return S && $.rangeList.rangeAtPoint(S.start) && $.addRange(S, !0), A.length;
      }, this.selectMoreLines = function(w, C) {
        var y = this.selection.toOrientedRange(), S = y.cursor == y.end, A = this.session.documentToScreenPosition(y.cursor);
        this.selection.$desiredColumn && (A.column = this.selection.$desiredColumn);
        var $ = this.session.screenToDocumentPosition(A.row + w, A.column);
        if (y.isEmpty())
          var _ = $;
        else
          var M = this.session.documentToScreenPosition(S ? y.end : y.start), _ = this.session.screenToDocumentPosition(M.row + w, M.column);
        if (S) {
          var T = s.fromPoints($, _);
          T.cursor = T.start;
        } else {
          var T = s.fromPoints(_, $);
          T.cursor = T.end;
        }
        if (T.desiredColumn = A.column, !this.selection.inMultiSelectMode)
          this.selection.addRange(y);
        else if (C)
          var D = y.cursor;
        this.selection.addRange(T), D && this.selection.substractPoint(D);
      }, this.transposeSelections = function(w) {
        for (var C = this.session, y = C.multiSelect, S = y.ranges, A = S.length; A--; ) {
          var $ = S[A];
          if ($.isEmpty()) {
            var M = C.getWordRange($.start.row, $.start.column);
            $.start.row = M.start.row, $.start.column = M.start.column, $.end.row = M.end.row, $.end.column = M.end.column;
          }
        }
        y.mergeOverlappingRanges();
        for (var _ = [], A = S.length; A--; ) {
          var $ = S[A];
          _.unshift(C.getTextRange($));
        }
        w < 0 ? _.unshift(_.pop()) : _.push(_.shift());
        for (var A = S.length; A--; ) {
          var $ = S[A], T = $.clone();
          C.replace($, _[A]), $.start.row = T.start.row, $.start.column = T.start.column;
        }
        y.fromOrientedRange(y.ranges[0]);
      }, this.selectMore = function(w, C, y) {
        var S = this.session, A = S.multiSelect, $ = A.toOrientedRange();
        if (!($.isEmpty() && ($ = S.getWordRange($.start.row, $.start.column), $.cursor = w == -1 ? $.start : $.end, this.multiSelect.addRange($), y))) {
          var M = S.getTextRange($), _ = p(S, M, w);
          _ && (_.cursor = w == -1 ? _.start : _.end, this.session.unfold(_), this.multiSelect.addRange(_), this.renderer.scrollCursorIntoView(null, 0.5)), C && this.multiSelect.substractPoint($.cursor);
        }
      }, this.alignCursors = function() {
        var w = this.session, C = w.multiSelect, y = C.ranges, S = -1, A = y.filter(function(L) {
          if (L.cursor.row == S)
            return !0;
          S = L.cursor.row;
        });
        if (!y.length || A.length == y.length - 1) {
          var $ = this.selection.getRange(), M = $.start.row, _ = $.end.row, T = M == _;
          if (T) {
            var D = this.session.getLength(), E;
            do
              E = this.session.getLine(_);
            while (/[=:]/.test(E) && ++_ < D);
            do
              E = this.session.getLine(M);
            while (/[=:]/.test(E) && --M > 0);
            M < 0 && (M = 0), _ >= D && (_ = D - 1);
          }
          var R = this.session.removeFullLines(M, _);
          R = this.$reAlignText(R, T), this.session.insert({ row: M, column: 0 }, R.join(`
`) + `
`), T || ($.start.column = 0, $.end.column = R[R.length - 1].length), this.selection.setRange($);
        } else {
          A.forEach(function(L) {
            C.substractPoint(L.cursor);
          });
          var I = 0, k = 1 / 0, P = y.map(function(L) {
            var N = L.cursor, F = w.getLine(N.row), B = F.substr(N.column).search(/\S/g);
            return B == -1 && (B = 0), N.column > I && (I = N.column), B < k && (k = B), B;
          });
          y.forEach(function(L, N) {
            var F = L.cursor, B = I - F.column, j = P[N] - k;
            B > j ? w.insert(F, c.stringRepeat(" ", B - j)) : w.remove(new s(F.row, F.column, F.row, F.column - B + j)), L.start.column = L.end.column = I, L.start.row = L.end.row = F.row, L.cursor = L.end;
          }), C.fromOrientedRange(y[0]), this.renderer.updateCursor(), this.renderer.updateBackMarkers();
        }
      }, this.$reAlignText = function(w, C) {
        var y = !0, S = !0, A, $, M;
        return w.map(function(R) {
          var I = R.match(/(\s*)(.*?)(\s*)([=:].*)/);
          return I ? A == null ? (A = I[1].length, $ = I[2].length, M = I[3].length, I) : (A + $ + M != I[1].length + I[2].length + I[3].length && (S = !1), A != I[1].length && (y = !1), A > I[1].length && (A = I[1].length), $ < I[2].length && ($ = I[2].length), M > I[3].length && (M = I[3].length), I) : [R];
        }).map(C ? T : y ? S ? D : T : E);
        function _(R) {
          return c.stringRepeat(" ", R);
        }
        function T(R) {
          return R[2] ? _(A) + R[2] + _($ - R[2].length + M) + R[4].replace(/^([=:])\s+/, "$1 ") : R[0];
        }
        function D(R) {
          return R[2] ? _(A + $ - R[2].length) + R[2] + _(M) + R[4].replace(/^([=:])\s+/, "$1 ") : R[0];
        }
        function E(R) {
          return R[2] ? _(A) + R[2] + _(M) + R[4].replace(/^([=:])\s+/, "$1 ") : R[0];
        }
      };
    }).call(m.prototype);
    function v(w, C) {
      return w.row == C.row && w.column == C.column;
    }
    r.onSessionChange = function(w) {
      var C = w.session;
      C && !C.multiSelect && (C.$selectionMarkers = [], C.selection.$initRangeList(), C.multiSelect = C.selection), this.multiSelect = C && C.multiSelect;
      var y = w.oldSession;
      y && (y.multiSelect.off("addRange", this.$onAddRange), y.multiSelect.off("removeRange", this.$onRemoveRange), y.multiSelect.off("multiSelect", this.$onMultiSelect), y.multiSelect.off("singleSelect", this.$onSingleSelect), y.multiSelect.lead.off("change", this.$checkMultiselectChange), y.multiSelect.anchor.off("change", this.$checkMultiselectChange)), C && (C.multiSelect.on("addRange", this.$onAddRange), C.multiSelect.on("removeRange", this.$onRemoveRange), C.multiSelect.on("multiSelect", this.$onMultiSelect), C.multiSelect.on("singleSelect", this.$onSingleSelect), C.multiSelect.lead.on("change", this.$checkMultiselectChange), C.multiSelect.anchor.on("change", this.$checkMultiselectChange)), C && this.inMultiSelectMode != C.selection.inMultiSelectMode && (C.selection.inMultiSelectMode ? this.$onMultiSelect() : this.$onSingleSelect());
    };
    function b(w) {
      w.$multiselectOnSessionChange || (w.$onAddRange = w.$onAddRange.bind(w), w.$onRemoveRange = w.$onRemoveRange.bind(w), w.$onMultiSelect = w.$onMultiSelect.bind(w), w.$onSingleSelect = w.$onSingleSelect.bind(w), w.$multiselectOnSessionChange = r.onSessionChange.bind(w), w.$checkMultiselectChange = w.$checkMultiselectChange.bind(w), w.$multiselectOnSessionChange(w), w.on("changeSession", w.$multiselectOnSessionChange), w.on("mousedown", l), w.commands.addCommands(d.defaultCommands), x(w));
    }
    function x(w) {
      if (!w.textInput)
        return;
      var C = w.textInput.getElement(), y = !1;
      u.addListener(C, "keydown", function(A) {
        var $ = A.keyCode == 18 && !(A.ctrlKey || A.shiftKey || A.metaKey);
        w.$blockSelectEnabled && $ ? y || (w.renderer.setMouseCursor("crosshair"), y = !0) : y && S();
      }, w), u.addListener(C, "keyup", S, w), u.addListener(C, "blur", S, w);
      function S(A) {
        y && (w.renderer.setMouseCursor(""), y = !1);
      }
    }
    r.MultiSelect = b, n("./config").defineOptions(m.prototype, "editor", {
      enableMultiselect: {
        set: function(w) {
          b(this), w ? this.on("mousedown", l) : this.off("mousedown", l);
        },
        value: !0
      },
      enableBlockSelect: {
        set: function(w) {
          this.$blockSelectEnabled = w;
        },
        value: !0
      }
    });
  }), ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function(n, r, i) {
    var o = n("../../range").Range, s = r.FoldMode = function() {
    };
    (function() {
      this.foldingStartMarker = null, this.foldingStopMarker = null, this.getFoldWidget = function(a, l, u) {
        var c = a.getLine(u);
        return this.foldingStartMarker.test(c) ? "start" : l == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(c) ? "end" : "";
      }, this.getFoldWidgetRange = function(a, l, u) {
        return null;
      }, this.indentationBlock = function(a, l, u) {
        var c = /\S/, d = a.getLine(l), f = d.search(c);
        if (f != -1) {
          for (var h = u || d.length, p = a.getLength(), g = l, m = l; ++l < p; ) {
            var v = a.getLine(l).search(c);
            if (v != -1) {
              if (v <= f) {
                var b = a.getTokenAt(l, 0);
                if (!b || b.type !== "string")
                  break;
              }
              m = l;
            }
          }
          if (m > g) {
            var x = a.getLine(m).length;
            return new o(g, h, m, x);
          }
        }
      }, this.openingBracketBlock = function(a, l, u, c, d) {
        var f = { row: u, column: c + 1 }, h = a.$findClosingBracket(l, f, d);
        if (h) {
          var p = a.foldWidgets[h.row];
          return p == null && (p = a.getFoldWidget(h.row)), p == "start" && h.row > f.row && (h.row--, h.column = a.getLine(h.row).length), o.fromPoints(f, h);
        }
      }, this.closingBracketBlock = function(a, l, u, c, d) {
        var f = { row: u, column: c }, h = a.$findOpeningBracket(l, f);
        if (h)
          return h.column++, f.column--, o.fromPoints(h, f);
      };
    }).call(s.prototype);
  }), ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/line_widgets", "ace/lib/dom", "ace/range", "ace/config"], function(n, r, i) {
    var o = n("../line_widgets").LineWidgets, s = n("../lib/dom"), a = n("../range").Range, l = n("../config").nls;
    function u(d, f, h) {
      for (var p = 0, g = d.length - 1; p <= g; ) {
        var m = p + g >> 1, v = h(f, d[m]);
        if (v > 0)
          p = m + 1;
        else if (v < 0)
          g = m - 1;
        else
          return m;
      }
      return -(p + 1);
    }
    function c(d, f, h) {
      var p = d.getAnnotations().sort(a.comparePoints);
      if (p.length) {
        var g = u(p, { row: f, column: -1 }, a.comparePoints);
        g < 0 && (g = -g - 1), g >= p.length ? g = h > 0 ? 0 : p.length - 1 : g === 0 && h < 0 && (g = p.length - 1);
        var m = p[g];
        if (!(!m || !h)) {
          if (m.row === f) {
            do
              m = p[g += h];
            while (m && m.row === f);
            if (!m)
              return p.slice();
          }
          var v = [];
          f = m.row;
          do
            v[h < 0 ? "unshift" : "push"](m), m = p[g += h];
          while (m && m.row == f);
          return v.length && v;
        }
      }
    }
    r.showErrorMarker = function(d, f) {
      var h = d.session;
      h.widgetManager || (h.widgetManager = new o(h), h.widgetManager.attach(d));
      var p = d.getCursorPosition(), g = p.row, m = h.widgetManager.getWidgetsAtRow(g).filter(function($) {
        return $.type == "errorMarker";
      })[0];
      m ? m.destroy() : g -= f;
      var v = c(h, g, f), b;
      if (v) {
        var x = v[0];
        p.column = (x.pos && typeof x.column != "number" ? x.pos.sc : x.column) || 0, p.row = x.row, b = d.renderer.$gutterLayer.$annotations[p.row];
      } else {
        if (m)
          return;
        b = {
          text: [l("error-marker.good-state", "Looks good!")],
          className: "ace_ok"
        };
      }
      d.session.unfold(p.row), d.selection.moveToPosition(p);
      var w = {
        row: p.row,
        fixedWidth: !0,
        coverGutter: !0,
        el: s.createElement("div"),
        type: "errorMarker"
      }, C = w.el.appendChild(s.createElement("div")), y = w.el.appendChild(s.createElement("div"));
      y.className = "error_widget_arrow " + b.className;
      var S = d.renderer.$cursorLayer.getPixelPosition(p).left;
      y.style.left = S + d.renderer.gutterWidth - 5 + "px", w.el.className = "error_widget_wrapper", C.className = "error_widget " + b.className, C.innerHTML = b.text.join("<br>"), C.appendChild(s.createElement("div"));
      var A = function($, M, _) {
        if (M === 0 && (_ === "esc" || _ === "return"))
          return w.destroy(), { command: "null" };
      };
      w.destroy = function() {
        d.$mouseHandler.isMousePressed || (d.keyBinding.removeKeyboardHandler(A), h.widgetManager.removeLineWidget(w), d.off("changeSelection", w.destroy), d.off("changeSession", w.destroy), d.off("mouseup", w.destroy), d.off("change", w.destroy));
      }, d.keyBinding.addKeyboardHandler(A), d.on("changeSelection", w.destroy), d.on("changeSession", w.destroy), d.on("mouseup", w.destroy), d.on("change", w.destroy), d.session.widgetManager.addLineWidget(w), w.el.onmousedown = d.focus.bind(d), d.renderer.scrollCursorIntoView(null, 0.5, { bottom: w.el.offsetHeight });
    }, s.importCssString(`
    .error_widget_wrapper {
        background: inherit;
        color: inherit;
        border:none
    }
    .error_widget {
        border-top: solid 2px;
        border-bottom: solid 2px;
        margin: 5px 0;
        padding: 10px 40px;
        white-space: pre-wrap;
    }
    .error_widget.ace_error, .error_widget_arrow.ace_error{
        border-color: #ff5a5a
    }
    .error_widget.ace_warning, .error_widget_arrow.ace_warning{
        border-color: #F1D817
    }
    .error_widget.ace_info, .error_widget_arrow.ace_info{
        border-color: #5a5a5a
    }
    .error_widget.ace_ok, .error_widget_arrow.ace_ok{
        border-color: #5aaa5a
    }
    .error_widget_arrow {
        position: absolute;
        border: solid 5px;
        border-top-color: transparent!important;
        border-right-color: transparent!important;
        border-left-color: transparent!important;
        top: -5px;
    }
`, "error_marker.css", !1);
  }), ace.define("ace/ace", ["require", "exports", "module", "ace/lib/dom", "ace/range", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config", "ace/loader_build"], function(n, r, i) {
    n("./loader_build")(r);
    var o = n("./lib/dom"), s = n("./range").Range, a = n("./editor").Editor, l = n("./edit_session").EditSession, u = n("./undomanager").UndoManager, c = n("./virtual_renderer").VirtualRenderer;
    n("./worker/worker_client"), n("./keyboard/hash_handler"), n("./placeholder"), n("./multi_select"), n("./mode/folding/fold_mode"), n("./theme/textmate"), n("./ext/error_marker"), r.config = n("./config"), r.edit = function(d, f) {
      if (typeof d == "string") {
        var h = d;
        if (d = document.getElementById(h), !d)
          throw new Error("ace.edit can't find div #" + h);
      }
      if (d && d.env && d.env.editor instanceof a)
        return d.env.editor;
      var p = "";
      if (d && /input|textarea/i.test(d.tagName)) {
        var g = d;
        p = g.value, d = o.createElement("pre"), g.parentNode.replaceChild(d, g);
      } else
        d && (p = d.textContent, d.innerHTML = "");
      var m = r.createEditSession(p), v = new a(new c(d), m, f), b = {
        document: m,
        editor: v,
        onResize: v.resize.bind(v, null)
      };
      return g && (b.textarea = g), v.on("destroy", function() {
        b.editor.container.env = null;
      }), v.container.env = v.env = b, v;
    }, r.createEditSession = function(d, f) {
      var h = new l(d, f);
      return h.setUndoManager(new u()), h;
    }, r.Range = s, r.Editor = a, r.EditSession = l, r.UndoManager = u, r.VirtualRenderer = c, r.version = r.config.version;
  }), function() {
    ace.require(["ace/ace"], function(n) {
      n && (n.config.init(!0), n.define = ace.define);
      var r = /* @__PURE__ */ function() {
        return this;
      }();
      !r && typeof window < "u" && (r = window), !r && typeof self < "u" && (r = self), r.ace || (r.ace = n);
      for (var i in n)
        n.hasOwnProperty(i) && (r.ace[i] = n[i]);
      r.ace.default = r.ace, e && (e.exports = r.ace);
    });
  }();
})(WP);
var lg = WP.exports, jy = { exports: {} }, Th = { exports: {} }, cn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var s2;
function _re() {
  if (s2)
    return cn;
  s2 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, f = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, p = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, m = e ? Symbol.for("react.fundamental") : 60117, v = e ? Symbol.for("react.responder") : 60118, b = e ? Symbol.for("react.scope") : 60119;
  function x(C) {
    if (typeof C == "object" && C !== null) {
      var y = C.$$typeof;
      switch (y) {
        case t:
          switch (C = C.type, C) {
            case l:
            case u:
            case r:
            case o:
            case i:
            case d:
              return C;
            default:
              switch (C = C && C.$$typeof, C) {
                case a:
                case c:
                case p:
                case h:
                case s:
                  return C;
                default:
                  return y;
              }
          }
        case n:
          return y;
      }
    }
  }
  function w(C) {
    return x(C) === u;
  }
  return cn.AsyncMode = l, cn.ConcurrentMode = u, cn.ContextConsumer = a, cn.ContextProvider = s, cn.Element = t, cn.ForwardRef = c, cn.Fragment = r, cn.Lazy = p, cn.Memo = h, cn.Portal = n, cn.Profiler = o, cn.StrictMode = i, cn.Suspense = d, cn.isAsyncMode = function(C) {
    return w(C) || x(C) === l;
  }, cn.isConcurrentMode = w, cn.isContextConsumer = function(C) {
    return x(C) === a;
  }, cn.isContextProvider = function(C) {
    return x(C) === s;
  }, cn.isElement = function(C) {
    return typeof C == "object" && C !== null && C.$$typeof === t;
  }, cn.isForwardRef = function(C) {
    return x(C) === c;
  }, cn.isFragment = function(C) {
    return x(C) === r;
  }, cn.isLazy = function(C) {
    return x(C) === p;
  }, cn.isMemo = function(C) {
    return x(C) === h;
  }, cn.isPortal = function(C) {
    return x(C) === n;
  }, cn.isProfiler = function(C) {
    return x(C) === o;
  }, cn.isStrictMode = function(C) {
    return x(C) === i;
  }, cn.isSuspense = function(C) {
    return x(C) === d;
  }, cn.isValidElementType = function(C) {
    return typeof C == "string" || typeof C == "function" || C === r || C === u || C === o || C === i || C === d || C === f || typeof C == "object" && C !== null && (C.$$typeof === p || C.$$typeof === h || C.$$typeof === s || C.$$typeof === a || C.$$typeof === c || C.$$typeof === m || C.$$typeof === v || C.$$typeof === b || C.$$typeof === g);
  }, cn.typeOf = x, cn;
}
var un = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var a2;
function Tre() {
  return a2 || (a2 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, f = e ? Symbol.for("react.suspense_list") : 60120, h = e ? Symbol.for("react.memo") : 60115, p = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, m = e ? Symbol.for("react.fundamental") : 60117, v = e ? Symbol.for("react.responder") : 60118, b = e ? Symbol.for("react.scope") : 60119;
    function x(Q) {
      return typeof Q == "string" || typeof Q == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      Q === r || Q === u || Q === o || Q === i || Q === d || Q === f || typeof Q == "object" && Q !== null && (Q.$$typeof === p || Q.$$typeof === h || Q.$$typeof === s || Q.$$typeof === a || Q.$$typeof === c || Q.$$typeof === m || Q.$$typeof === v || Q.$$typeof === b || Q.$$typeof === g);
    }
    function w(Q) {
      if (typeof Q == "object" && Q !== null) {
        var ne = Q.$$typeof;
        switch (ne) {
          case t:
            var q = Q.type;
            switch (q) {
              case l:
              case u:
              case r:
              case o:
              case i:
              case d:
                return q;
              default:
                var te = q && q.$$typeof;
                switch (te) {
                  case a:
                  case c:
                  case p:
                  case h:
                  case s:
                    return te;
                  default:
                    return ne;
                }
            }
          case n:
            return ne;
        }
      }
    }
    var C = l, y = u, S = a, A = s, $ = t, M = c, _ = r, T = p, D = h, E = n, R = o, I = i, k = d, P = !1;
    function L(Q) {
      return P || (P = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), N(Q) || w(Q) === l;
    }
    function N(Q) {
      return w(Q) === u;
    }
    function F(Q) {
      return w(Q) === a;
    }
    function B(Q) {
      return w(Q) === s;
    }
    function j(Q) {
      return typeof Q == "object" && Q !== null && Q.$$typeof === t;
    }
    function z(Q) {
      return w(Q) === c;
    }
    function H(Q) {
      return w(Q) === r;
    }
    function W(Q) {
      return w(Q) === p;
    }
    function G(Q) {
      return w(Q) === h;
    }
    function K(Q) {
      return w(Q) === n;
    }
    function Y(Q) {
      return w(Q) === o;
    }
    function X(Q) {
      return w(Q) === i;
    }
    function Z(Q) {
      return w(Q) === d;
    }
    un.AsyncMode = C, un.ConcurrentMode = y, un.ContextConsumer = S, un.ContextProvider = A, un.Element = $, un.ForwardRef = M, un.Fragment = _, un.Lazy = T, un.Memo = D, un.Portal = E, un.Profiler = R, un.StrictMode = I, un.Suspense = k, un.isAsyncMode = L, un.isConcurrentMode = N, un.isContextConsumer = F, un.isContextProvider = B, un.isElement = j, un.isForwardRef = z, un.isFragment = H, un.isLazy = W, un.isMemo = G, un.isPortal = K, un.isProfiler = Y, un.isStrictMode = X, un.isSuspense = Z, un.isValidElementType = x, un.typeOf = w;
  }()), un;
}
var l2;
function UP() {
  return l2 || (l2 = 1, process.env.NODE_ENV === "production" ? Th.exports = _re() : Th.exports = Tre()), Th.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var i0, c2;
function Rre() {
  if (c2)
    return i0;
  c2 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(o) {
    if (o == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(o);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var o = new String("abc");
      if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return i0 = i() ? Object.assign : function(o, s) {
    for (var a, l = r(o), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var d in a)
        t.call(a, d) && (l[d] = a[d]);
      if (e) {
        u = e(a);
        for (var f = 0; f < u.length; f++)
          n.call(a, u[f]) && (l[u[f]] = a[u[f]]);
      }
    }
    return l;
  }, i0;
}
var o0, u2;
function EC() {
  if (u2)
    return o0;
  u2 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return o0 = e, o0;
}
var s0, d2;
function GP() {
  return d2 || (d2 = 1, s0 = Function.call.bind(Object.prototype.hasOwnProperty)), s0;
}
var a0, f2;
function Mre() {
  if (f2)
    return a0;
  f2 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = EC(), n = {}, r = GP();
    e = function(o) {
      var s = "Warning: " + o;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function i(o, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in o)
        if (r(o, c)) {
          var d;
          try {
            if (typeof o[c] != "function") {
              var f = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw f.name = "Invariant Violation", f;
            }
            d = o[c](s, c, l, a, null, t);
          } catch (p) {
            d = p;
          }
          if (d && !(d instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in n)) {
            n[d.message] = !0;
            var h = u ? u() : "";
            e(
              "Failed " + a + " type: " + d.message + (h ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, a0 = i, a0;
}
var l0, h2;
function Ire() {
  if (h2)
    return l0;
  h2 = 1;
  var e = UP(), t = Rre(), n = EC(), r = GP(), i = Mre(), o = function() {
  };
  process.env.NODE_ENV !== "production" && (o = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return l0 = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function d(N) {
      var F = N && (u && N[u] || N[c]);
      if (typeof F == "function")
        return F;
    }
    var f = "<<anonymous>>", h = {
      array: v("array"),
      bigint: v("bigint"),
      bool: v("boolean"),
      func: v("function"),
      number: v("number"),
      object: v("object"),
      string: v("string"),
      symbol: v("symbol"),
      any: b(),
      arrayOf: x,
      element: w(),
      elementType: C(),
      instanceOf: y,
      node: M(),
      objectOf: A,
      oneOf: S,
      oneOfType: $,
      shape: T,
      exact: D
    };
    function p(N, F) {
      return N === F ? N !== 0 || 1 / N === 1 / F : N !== N && F !== F;
    }
    function g(N, F) {
      this.message = N, this.data = F && typeof F == "object" ? F : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function m(N) {
      if (process.env.NODE_ENV !== "production")
        var F = {}, B = 0;
      function j(H, W, G, K, Y, X, Z) {
        if (K = K || f, X = X || G, Z !== n) {
          if (l) {
            var Q = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw Q.name = "Invariant Violation", Q;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ne = K + ":" + G;
            !F[ne] && // Avoid spamming the console because they are often not actionable except for lib authors
            B < 3 && (o(
              "You are manually calling a React.PropTypes validation function for the `" + X + "` prop on `" + K + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), F[ne] = !0, B++);
          }
        }
        return W[G] == null ? H ? W[G] === null ? new g("The " + Y + " `" + X + "` is marked as required " + ("in `" + K + "`, but its value is `null`.")) : new g("The " + Y + " `" + X + "` is marked as required in " + ("`" + K + "`, but its value is `undefined`.")) : null : N(W, G, K, Y, X);
      }
      var z = j.bind(null, !1);
      return z.isRequired = j.bind(null, !0), z;
    }
    function v(N) {
      function F(B, j, z, H, W, G) {
        var K = B[j], Y = I(K);
        if (Y !== N) {
          var X = k(K);
          return new g(
            "Invalid " + H + " `" + W + "` of type " + ("`" + X + "` supplied to `" + z + "`, expected ") + ("`" + N + "`."),
            { expectedType: N }
          );
        }
        return null;
      }
      return m(F);
    }
    function b() {
      return m(s);
    }
    function x(N) {
      function F(B, j, z, H, W) {
        if (typeof N != "function")
          return new g("Property `" + W + "` of component `" + z + "` has invalid PropType notation inside arrayOf.");
        var G = B[j];
        if (!Array.isArray(G)) {
          var K = I(G);
          return new g("Invalid " + H + " `" + W + "` of type " + ("`" + K + "` supplied to `" + z + "`, expected an array."));
        }
        for (var Y = 0; Y < G.length; Y++) {
          var X = N(G, Y, z, H, W + "[" + Y + "]", n);
          if (X instanceof Error)
            return X;
        }
        return null;
      }
      return m(F);
    }
    function w() {
      function N(F, B, j, z, H) {
        var W = F[B];
        if (!a(W)) {
          var G = I(W);
          return new g("Invalid " + z + " `" + H + "` of type " + ("`" + G + "` supplied to `" + j + "`, expected a single ReactElement."));
        }
        return null;
      }
      return m(N);
    }
    function C() {
      function N(F, B, j, z, H) {
        var W = F[B];
        if (!e.isValidElementType(W)) {
          var G = I(W);
          return new g("Invalid " + z + " `" + H + "` of type " + ("`" + G + "` supplied to `" + j + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return m(N);
    }
    function y(N) {
      function F(B, j, z, H, W) {
        if (!(B[j] instanceof N)) {
          var G = N.name || f, K = L(B[j]);
          return new g("Invalid " + H + " `" + W + "` of type " + ("`" + K + "` supplied to `" + z + "`, expected ") + ("instance of `" + G + "`."));
        }
        return null;
      }
      return m(F);
    }
    function S(N) {
      if (!Array.isArray(N))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? o(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o("Invalid argument supplied to oneOf, expected an array.")), s;
      function F(B, j, z, H, W) {
        for (var G = B[j], K = 0; K < N.length; K++)
          if (p(G, N[K]))
            return null;
        var Y = JSON.stringify(N, function(Z, Q) {
          var ne = k(Q);
          return ne === "symbol" ? String(Q) : Q;
        });
        return new g("Invalid " + H + " `" + W + "` of value `" + String(G) + "` " + ("supplied to `" + z + "`, expected one of " + Y + "."));
      }
      return m(F);
    }
    function A(N) {
      function F(B, j, z, H, W) {
        if (typeof N != "function")
          return new g("Property `" + W + "` of component `" + z + "` has invalid PropType notation inside objectOf.");
        var G = B[j], K = I(G);
        if (K !== "object")
          return new g("Invalid " + H + " `" + W + "` of type " + ("`" + K + "` supplied to `" + z + "`, expected an object."));
        for (var Y in G)
          if (r(G, Y)) {
            var X = N(G, Y, z, H, W + "." + Y, n);
            if (X instanceof Error)
              return X;
          }
        return null;
      }
      return m(F);
    }
    function $(N) {
      if (!Array.isArray(N))
        return process.env.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var F = 0; F < N.length; F++) {
        var B = N[F];
        if (typeof B != "function")
          return o(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + P(B) + " at index " + F + "."
          ), s;
      }
      function j(z, H, W, G, K) {
        for (var Y = [], X = 0; X < N.length; X++) {
          var Z = N[X], Q = Z(z, H, W, G, K, n);
          if (Q == null)
            return null;
          Q.data && r(Q.data, "expectedType") && Y.push(Q.data.expectedType);
        }
        var ne = Y.length > 0 ? ", expected one of type [" + Y.join(", ") + "]" : "";
        return new g("Invalid " + G + " `" + K + "` supplied to " + ("`" + W + "`" + ne + "."));
      }
      return m(j);
    }
    function M() {
      function N(F, B, j, z, H) {
        return E(F[B]) ? null : new g("Invalid " + z + " `" + H + "` supplied to " + ("`" + j + "`, expected a ReactNode."));
      }
      return m(N);
    }
    function _(N, F, B, j, z) {
      return new g(
        (N || "React class") + ": " + F + " type `" + B + "." + j + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + z + "`."
      );
    }
    function T(N) {
      function F(B, j, z, H, W) {
        var G = B[j], K = I(G);
        if (K !== "object")
          return new g("Invalid " + H + " `" + W + "` of type `" + K + "` " + ("supplied to `" + z + "`, expected `object`."));
        for (var Y in N) {
          var X = N[Y];
          if (typeof X != "function")
            return _(z, H, W, Y, k(X));
          var Z = X(G, Y, z, H, W + "." + Y, n);
          if (Z)
            return Z;
        }
        return null;
      }
      return m(F);
    }
    function D(N) {
      function F(B, j, z, H, W) {
        var G = B[j], K = I(G);
        if (K !== "object")
          return new g("Invalid " + H + " `" + W + "` of type `" + K + "` " + ("supplied to `" + z + "`, expected `object`."));
        var Y = t({}, B[j], N);
        for (var X in Y) {
          var Z = N[X];
          if (r(N, X) && typeof Z != "function")
            return _(z, H, W, X, k(Z));
          if (!Z)
            return new g(
              "Invalid " + H + " `" + W + "` key `" + X + "` supplied to `" + z + "`.\nBad object: " + JSON.stringify(B[j], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(N), null, "  ")
            );
          var Q = Z(G, X, z, H, W + "." + X, n);
          if (Q)
            return Q;
        }
        return null;
      }
      return m(F);
    }
    function E(N) {
      switch (typeof N) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !N;
        case "object":
          if (Array.isArray(N))
            return N.every(E);
          if (N === null || a(N))
            return !0;
          var F = d(N);
          if (F) {
            var B = F.call(N), j;
            if (F !== N.entries) {
              for (; !(j = B.next()).done; )
                if (!E(j.value))
                  return !1;
            } else
              for (; !(j = B.next()).done; ) {
                var z = j.value;
                if (z && !E(z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function R(N, F) {
      return N === "symbol" ? !0 : F ? F["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && F instanceof Symbol : !1;
    }
    function I(N) {
      var F = typeof N;
      return Array.isArray(N) ? "array" : N instanceof RegExp ? "object" : R(F, N) ? "symbol" : F;
    }
    function k(N) {
      if (typeof N > "u" || N === null)
        return "" + N;
      var F = I(N);
      if (F === "object") {
        if (N instanceof Date)
          return "date";
        if (N instanceof RegExp)
          return "regexp";
      }
      return F;
    }
    function P(N) {
      var F = k(N);
      switch (F) {
        case "array":
        case "object":
          return "an " + F;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + F;
        default:
          return F;
      }
    }
    function L(N) {
      return !N.constructor || !N.constructor.name ? f : N.constructor.name;
    }
    return h.checkPropTypes = i, h.resetWarningCache = i.resetWarningCache, h.PropTypes = h, h;
  }, l0;
}
var c0, p2;
function kre() {
  if (p2)
    return c0;
  p2 = 1;
  var e = EC();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, c0 = function() {
    function r(s, a, l, u, c, d) {
      if (d !== e) {
        var f = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw f.name = "Invariant Violation", f;
      }
    }
    r.isRequired = r;
    function i() {
      return r;
    }
    var o = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: i,
      element: r,
      elementType: r,
      instanceOf: i,
      node: r,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return o.PropTypes = o, o;
  }, c0;
}
if (process.env.NODE_ENV !== "production") {
  var Pre = UP(), Nre = !0;
  jy.exports = Ire()(Pre.isElement, Nre);
} else
  jy.exports = kre()();
var $C = jy.exports, cg = { exports: {} };
cg.exports;
(function(e, t) {
  var n = 200, r = "__lodash_hash_undefined__", i = 1, o = 2, s = 9007199254740991, a = "[object Arguments]", l = "[object Array]", u = "[object AsyncFunction]", c = "[object Boolean]", d = "[object Date]", f = "[object Error]", h = "[object Function]", p = "[object GeneratorFunction]", g = "[object Map]", m = "[object Number]", v = "[object Null]", b = "[object Object]", x = "[object Promise]", w = "[object Proxy]", C = "[object RegExp]", y = "[object Set]", S = "[object String]", A = "[object Symbol]", $ = "[object Undefined]", M = "[object WeakMap]", _ = "[object ArrayBuffer]", T = "[object DataView]", D = "[object Float32Array]", E = "[object Float64Array]", R = "[object Int8Array]", I = "[object Int16Array]", k = "[object Int32Array]", P = "[object Uint8Array]", L = "[object Uint8ClampedArray]", N = "[object Uint16Array]", F = "[object Uint32Array]", B = /[\\^$.*+?()[\]{}|]/g, j = /^\[object .+?Constructor\]$/, z = /^(?:0|[1-9]\d*)$/, H = {};
  H[D] = H[E] = H[R] = H[I] = H[k] = H[P] = H[L] = H[N] = H[F] = !0, H[a] = H[l] = H[_] = H[c] = H[T] = H[d] = H[f] = H[h] = H[g] = H[m] = H[b] = H[C] = H[y] = H[S] = H[M] = !1;
  var W = typeof Bn == "object" && Bn && Bn.Object === Object && Bn, G = typeof self == "object" && self && self.Object === Object && self, K = W || G || Function("return this")(), Y = t && !t.nodeType && t, X = Y && !0 && e && !e.nodeType && e, Z = X && X.exports === Y, Q = Z && W.process, ne = function() {
    try {
      return Q && Q.binding && Q.binding("util");
    } catch {
    }
  }(), q = ne && ne.isTypedArray;
  function te(J, ue) {
    for (var ke = -1, ut = J == null ? 0 : J.length, Dn = 0, Ht = []; ++ke < ut; ) {
      var Yn = J[ke];
      ue(Yn, ke, J) && (Ht[Dn++] = Yn);
    }
    return Ht;
  }
  function fe(J, ue) {
    for (var ke = -1, ut = ue.length, Dn = J.length; ++ke < ut; )
      J[Dn + ke] = ue[ke];
    return J;
  }
  function Se(J, ue) {
    for (var ke = -1, ut = J == null ? 0 : J.length; ++ke < ut; )
      if (ue(J[ke], ke, J))
        return !0;
    return !1;
  }
  function de(J, ue) {
    for (var ke = -1, ut = Array(J); ++ke < J; )
      ut[ke] = ue(ke);
    return ut;
  }
  function ce(J) {
    return function(ue) {
      return J(ue);
    };
  }
  function pe(J, ue) {
    return J.has(ue);
  }
  function Oe(J, ue) {
    return J == null ? void 0 : J[ue];
  }
  function Re(J) {
    var ue = -1, ke = Array(J.size);
    return J.forEach(function(ut, Dn) {
      ke[++ue] = [Dn, ut];
    }), ke;
  }
  function De(J, ue) {
    return function(ke) {
      return J(ue(ke));
    };
  }
  function Me(J) {
    var ue = -1, ke = Array(J.size);
    return J.forEach(function(ut) {
      ke[++ue] = ut;
    }), ke;
  }
  var Ue = Array.prototype, oe = Function.prototype, Ce = Object.prototype, ge = K["__core-js_shared__"], ve = oe.toString, me = Ce.hasOwnProperty, Fe = function() {
    var J = /[^.]+$/.exec(ge && ge.keys && ge.keys.IE_PROTO || "");
    return J ? "Symbol(src)_1." + J : "";
  }(), Be = Ce.toString, qe = RegExp(
    "^" + ve.call(me).replace(B, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), Ve = Z ? K.Buffer : void 0, We = K.Symbol, Ge = K.Uint8Array, $e = Ce.propertyIsEnumerable, ze = Ue.splice, at = We ? We.toStringTag : void 0, xt = Object.getOwnPropertySymbols, jt = Ve ? Ve.isBuffer : void 0, Lt = De(Object.keys, Object), At = Jn(K, "DataView"), Et = Jn(K, "Map"), nt = Jn(K, "Promise"), it = Jn(K, "Set"), je = Jn(K, "WeakMap"), Le = Jn(Object, "create"), ot = Hi(At), yt = Hi(Et), He = Hi(nt), Je = Hi(it), Qe = Hi(je), lt = We ? We.prototype : void 0, pt = lt ? lt.valueOf : void 0;
  function vt(J) {
    var ue = -1, ke = J == null ? 0 : J.length;
    for (this.clear(); ++ue < ke; ) {
      var ut = J[ue];
      this.set(ut[0], ut[1]);
    }
  }
  function ee() {
    this.__data__ = Le ? Le(null) : {}, this.size = 0;
  }
  function be(J) {
    var ue = this.has(J) && delete this.__data__[J];
    return this.size -= ue ? 1 : 0, ue;
  }
  function Ee(J) {
    var ue = this.__data__;
    if (Le) {
      var ke = ue[J];
      return ke === r ? void 0 : ke;
    }
    return me.call(ue, J) ? ue[J] : void 0;
  }
  function ye(J) {
    var ue = this.__data__;
    return Le ? ue[J] !== void 0 : me.call(ue, J);
  }
  function Ke(J, ue) {
    var ke = this.__data__;
    return this.size += this.has(J) ? 0 : 1, ke[J] = Le && ue === void 0 ? r : ue, this;
  }
  vt.prototype.clear = ee, vt.prototype.delete = be, vt.prototype.get = Ee, vt.prototype.has = ye, vt.prototype.set = Ke;
  function et(J) {
    var ue = -1, ke = J == null ? 0 : J.length;
    for (this.clear(); ++ue < ke; ) {
      var ut = J[ue];
      this.set(ut[0], ut[1]);
    }
  }
  function Ie() {
    this.__data__ = [], this.size = 0;
  }
  function Ae(J) {
    var ue = this.__data__, ke = Zr(ue, J);
    if (ke < 0)
      return !1;
    var ut = ue.length - 1;
    return ke == ut ? ue.pop() : ze.call(ue, ke, 1), --this.size, !0;
  }
  function tt(J) {
    var ue = this.__data__, ke = Zr(ue, J);
    return ke < 0 ? void 0 : ue[ke][1];
  }
  function dt(J) {
    return Zr(this.__data__, J) > -1;
  }
  function Tt(J, ue) {
    var ke = this.__data__, ut = Zr(ke, J);
    return ut < 0 ? (++this.size, ke.push([J, ue])) : ke[ut][1] = ue, this;
  }
  et.prototype.clear = Ie, et.prototype.delete = Ae, et.prototype.get = tt, et.prototype.has = dt, et.prototype.set = Tt;
  function Ct(J) {
    var ue = -1, ke = J == null ? 0 : J.length;
    for (this.clear(); ++ue < ke; ) {
      var ut = J[ue];
      this.set(ut[0], ut[1]);
    }
  }
  function vn() {
    this.size = 0, this.__data__ = {
      hash: new vt(),
      map: new (Et || et)(),
      string: new vt()
    };
  }
  function Hn(J) {
    var ue = vr(this, J).delete(J);
    return this.size -= ue ? 1 : 0, ue;
  }
  function pn(J) {
    return vr(this, J).get(J);
  }
  function Qn(J) {
    return vr(this, J).has(J);
  }
  function Fr(J, ue) {
    var ke = vr(this, J), ut = ke.size;
    return ke.set(J, ue), this.size += ke.size == ut ? 0 : 1, this;
  }
  Ct.prototype.clear = vn, Ct.prototype.delete = Hn, Ct.prototype.get = pn, Ct.prototype.has = Qn, Ct.prototype.set = Fr;
  function Qr(J) {
    var ue = -1, ke = J == null ? 0 : J.length;
    for (this.__data__ = new Ct(); ++ue < ke; )
      this.add(J[ue]);
  }
  function Br(J) {
    return this.__data__.set(J, r), this;
  }
  function gr(J) {
    return this.__data__.has(J);
  }
  Qr.prototype.add = Qr.prototype.push = Br, Qr.prototype.has = gr;
  function Er(J) {
    var ue = this.__data__ = new et(J);
    this.size = ue.size;
  }
  function jr() {
    this.__data__ = new et(), this.size = 0;
  }
  function zr(J) {
    var ue = this.__data__, ke = ue.delete(J);
    return this.size = ue.size, ke;
  }
  function zi(J) {
    return this.__data__.get(J);
  }
  function Mo(J) {
    return this.__data__.has(J);
  }
  function fi(J, ue) {
    var ke = this.__data__;
    if (ke instanceof et) {
      var ut = ke.__data__;
      if (!Et || ut.length < n - 1)
        return ut.push([J, ue]), this.size = ++ke.size, this;
      ke = this.__data__ = new Ct(ut);
    }
    return ke.set(J, ue), this.size = ke.size, this;
  }
  Er.prototype.clear = jr, Er.prototype.delete = zr, Er.prototype.get = zi, Er.prototype.has = Mo, Er.prototype.set = fi;
  function Ei(J, ue) {
    var ke = Ps(J), ut = !ke && pu(J), Dn = !ke && !ut && ct(J), Ht = !ke && !ut && !Dn && Rl(J), Yn = ke || ut || Dn || Ht, br = Yn ? de(J.length, String) : [], Or = br.length;
    for (var Vn in J)
      me.call(J, Vn) && !(Yn && // Safari 9 has enumerable `arguments.length` in strict mode.
      (Vn == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
      Dn && (Vn == "offset" || Vn == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
      Ht && (Vn == "buffer" || Vn == "byteLength" || Vn == "byteOffset") || // Skip index properties.
      Is(Vn, Or))) && br.push(Vn);
    return br;
  }
  function Zr(J, ue) {
    for (var ke = J.length; ke--; )
      if (Tl(J[ke][0], ue))
        return ke;
    return -1;
  }
  function hi(J, ue, ke) {
    var ut = ue(J);
    return Ps(J) ? ut : fe(ut, ke(J));
  }
  function Ze(J) {
    return J == null ? J === void 0 ? $ : v : at && at in Object(J) ? Ol(J) : Ca(J);
  }
  function Ye(J) {
    return Io(J) && Ze(J) == a;
  }
  function Dt(J, ue, ke, ut, Dn) {
    return J === ue ? !0 : J == null || ue == null || !Io(J) && !Io(ue) ? J !== J && ue !== ue : en(J, ue, ke, ut, Dt, Dn);
  }
  function en(J, ue, ke, ut, Dn, Ht) {
    var Yn = Ps(J), br = Ps(ue), Or = Yn ? l : er(J), Vn = br ? l : er(ue);
    Or = Or == a ? b : Or, Vn = Vn == a ? b : Vn;
    var $i = Or == b, ao = Vn == b, Hr = Or == Vn;
    if (Hr && ct(J)) {
      if (!ct(ue))
        return !1;
      Yn = !0, $i = !1;
    }
    if (Hr && !$i)
      return Ht || (Ht = new Er()), Yn || Rl(J) ? $r(J, ue, ke, ut, Dn, Ht) : mr(J, ue, Or, ke, ut, Dn, Ht);
    if (!(ke & i)) {
      var Vi = $i && me.call(J, "__wrapped__"), Wi = ao && me.call(ue, "__wrapped__");
      if (Vi || Wi) {
        var Ns = Vi ? J.value() : J, es = Wi ? ue.value() : ue;
        return Ht || (Ht = new Er()), Dn(Ns, es, ke, ut, Ht);
      }
    }
    return Hr ? (Ht || (Ht = new Er()), Jr(J, ue, ke, ut, Dn, Ht)) : !1;
  }
  function zt(J) {
    if (!An(J) || ks(J))
      return !1;
    var ue = On(J) ? qe : j;
    return ue.test(Hi(J));
  }
  function xn(J) {
    return Io(J) && Xn(J.length) && !!H[Ze(J)];
  }
  function or(J) {
    if (!_l(J))
      return Lt(J);
    var ue = [];
    for (var ke in Object(J))
      me.call(J, ke) && ke != "constructor" && ue.push(ke);
    return ue;
  }
  function $r(J, ue, ke, ut, Dn, Ht) {
    var Yn = ke & i, br = J.length, Or = ue.length;
    if (br != Or && !(Yn && Or > br))
      return !1;
    var Vn = Ht.get(J);
    if (Vn && Ht.get(ue))
      return Vn == ue;
    var $i = -1, ao = !0, Hr = ke & o ? new Qr() : void 0;
    for (Ht.set(J, ue), Ht.set(ue, J); ++$i < br; ) {
      var Vi = J[$i], Wi = ue[$i];
      if (ut)
        var Ns = Yn ? ut(Wi, Vi, $i, ue, J, Ht) : ut(Vi, Wi, $i, J, ue, Ht);
      if (Ns !== void 0) {
        if (Ns)
          continue;
        ao = !1;
        break;
      }
      if (Hr) {
        if (!Se(ue, function(es, Sa) {
          if (!pe(Hr, Sa) && (Vi === es || Dn(Vi, es, ke, ut, Ht)))
            return Hr.push(Sa);
        })) {
          ao = !1;
          break;
        }
      } else if (!(Vi === Wi || Dn(Vi, Wi, ke, ut, Ht))) {
        ao = !1;
        break;
      }
    }
    return Ht.delete(J), Ht.delete(ue), ao;
  }
  function mr(J, ue, ke, ut, Dn, Ht, Yn) {
    switch (ke) {
      case T:
        if (J.byteLength != ue.byteLength || J.byteOffset != ue.byteOffset)
          return !1;
        J = J.buffer, ue = ue.buffer;
      case _:
        return !(J.byteLength != ue.byteLength || !Ht(new Ge(J), new Ge(ue)));
      case c:
      case d:
      case m:
        return Tl(+J, +ue);
      case f:
        return J.name == ue.name && J.message == ue.message;
      case C:
      case S:
        return J == ue + "";
      case g:
        var br = Re;
      case y:
        var Or = ut & i;
        if (br || (br = Me), J.size != ue.size && !Or)
          return !1;
        var Vn = Yn.get(J);
        if (Vn)
          return Vn == ue;
        ut |= o, Yn.set(J, ue);
        var $i = $r(br(J), br(ue), ut, Dn, Ht, Yn);
        return Yn.delete(J), $i;
      case A:
        if (pt)
          return pt.call(J) == pt.call(ue);
    }
    return !1;
  }
  function Jr(J, ue, ke, ut, Dn, Ht) {
    var Yn = ke & i, br = Zn(J), Or = br.length, Vn = Zn(ue), $i = Vn.length;
    if (Or != $i && !Yn)
      return !1;
    for (var ao = Or; ao--; ) {
      var Hr = br[ao];
      if (!(Yn ? Hr in ue : me.call(ue, Hr)))
        return !1;
    }
    var Vi = Ht.get(J);
    if (Vi && Ht.get(ue))
      return Vi == ue;
    var Wi = !0;
    Ht.set(J, ue), Ht.set(ue, J);
    for (var Ns = Yn; ++ao < Or; ) {
      Hr = br[ao];
      var es = J[Hr], Sa = ue[Hr];
      if (ut)
        var aS = Yn ? ut(Sa, es, Hr, ue, J, Ht) : ut(es, Sa, Hr, J, ue, Ht);
      if (!(aS === void 0 ? es === Sa || Dn(es, Sa, ke, ut, Ht) : aS)) {
        Wi = !1;
        break;
      }
      Ns || (Ns = Hr == "constructor");
    }
    if (Wi && !Ns) {
      var Ff = J.constructor, Bf = ue.constructor;
      Ff != Bf && "constructor" in J && "constructor" in ue && !(typeof Ff == "function" && Ff instanceof Ff && typeof Bf == "function" && Bf instanceof Bf) && (Wi = !1);
    }
    return Ht.delete(J), Ht.delete(ue), Wi;
  }
  function Zn(J) {
    return hi(J, Lf, Al);
  }
  function vr(J, ue) {
    var ke = J.__data__;
    return Dl(ue) ? ke[typeof ue == "string" ? "string" : "hash"] : ke.map;
  }
  function Jn(J, ue) {
    var ke = Oe(J, ue);
    return zt(ke) ? ke : void 0;
  }
  function Ol(J) {
    var ue = me.call(J, at), ke = J[at];
    try {
      J[at] = void 0;
      var ut = !0;
    } catch {
    }
    var Dn = Be.call(J);
    return ut && (ue ? J[at] = ke : delete J[at]), Dn;
  }
  var Al = xt ? function(J) {
    return J == null ? [] : (J = Object(J), te(xt(J), function(ue) {
      return $e.call(J, ue);
    }));
  } : Ml, er = Ze;
  (At && er(new At(new ArrayBuffer(1))) != T || Et && er(new Et()) != g || nt && er(nt.resolve()) != x || it && er(new it()) != y || je && er(new je()) != M) && (er = function(J) {
    var ue = Ze(J), ke = ue == b ? J.constructor : void 0, ut = ke ? Hi(ke) : "";
    if (ut)
      switch (ut) {
        case ot:
          return T;
        case yt:
          return g;
        case He:
          return x;
        case Je:
          return y;
        case Qe:
          return M;
      }
    return ue;
  });
  function Is(J, ue) {
    return ue = ue ?? s, !!ue && (typeof J == "number" || z.test(J)) && J > -1 && J % 1 == 0 && J < ue;
  }
  function Dl(J) {
    var ue = typeof J;
    return ue == "string" || ue == "number" || ue == "symbol" || ue == "boolean" ? J !== "__proto__" : J === null;
  }
  function ks(J) {
    return !!Fe && Fe in J;
  }
  function _l(J) {
    var ue = J && J.constructor, ke = typeof ue == "function" && ue.prototype || Ce;
    return J === ke;
  }
  function Ca(J) {
    return Be.call(J);
  }
  function Hi(J) {
    if (J != null) {
      try {
        return ve.call(J);
      } catch {
      }
      try {
        return J + "";
      } catch {
      }
    }
    return "";
  }
  function Tl(J, ue) {
    return J === ue || J !== J && ue !== ue;
  }
  var pu = Ye(/* @__PURE__ */ function() {
    return arguments;
  }()) ? Ye : function(J) {
    return Io(J) && me.call(J, "callee") && !$e.call(J, "callee");
  }, Ps = Array.isArray;
  function Pm(J) {
    return J != null && Xn(J.length) && !On(J);
  }
  var ct = jt || iF;
  function _t(J, ue) {
    return Dt(J, ue);
  }
  function On(J) {
    if (!An(J))
      return !1;
    var ue = Ze(J);
    return ue == h || ue == p || ue == u || ue == w;
  }
  function Xn(J) {
    return typeof J == "number" && J > -1 && J % 1 == 0 && J <= s;
  }
  function An(J) {
    var ue = typeof J;
    return J != null && (ue == "object" || ue == "function");
  }
  function Io(J) {
    return J != null && typeof J == "object";
  }
  var Rl = q ? ce(q) : xn;
  function Lf(J) {
    return Pm(J) ? Ei(J) : or(J);
  }
  function Ml() {
    return [];
  }
  function iF() {
    return !1;
  }
  e.exports = _t;
})(cg, cg.exports);
var KP = cg.exports, vo = {};
Object.defineProperty(vo, "__esModule", { value: !0 });
vo.getAceInstance = vo.debounce = vo.editorEvents = vo.editorOptions = void 0;
var Lre = [
  "minLines",
  "maxLines",
  "readOnly",
  "highlightActiveLine",
  "tabSize",
  "enableBasicAutocompletion",
  "enableLiveAutocompletion",
  "enableSnippets"
];
vo.editorOptions = Lre;
var Fre = [
  "onChange",
  "onFocus",
  "onInput",
  "onBlur",
  "onCopy",
  "onPaste",
  "onSelectionChange",
  "onCursorChange",
  "onScroll",
  "handleOptions",
  "updateRef"
];
vo.editorEvents = Fre;
var Bre = function() {
  var e;
  return typeof window > "u" ? (Bn.window = {}, e = lg, delete Bn.window) : window.ace ? (e = window.ace, e.acequire = window.ace.require || window.ace.acequire) : e = lg, e;
};
vo.getAceInstance = Bre;
var jre = function(e, t) {
  var n = null;
  return function() {
    var r = this, i = arguments;
    clearTimeout(n), n = setTimeout(function() {
      e.apply(r, i);
    }, t);
  };
};
vo.debounce = jre;
var zre = Bn && Bn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
      r.__proto__ = i;
    } || function(r, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), zy = Bn && Bn.__assign || function() {
  return zy = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, zy.apply(this, arguments);
};
Object.defineProperty(xC, "__esModule", { value: !0 });
var Hre = lg, St = $C, g2 = U, Rh = KP, tc = vo, m2 = (0, tc.getAceInstance)(), Vre = (
  /** @class */
  function(e) {
    zre(t, e);
    function t(n) {
      var r = e.call(this, n) || this;
      return tc.editorEvents.forEach(function(i) {
        r[i] = r[i].bind(r);
      }), r.debounce = tc.debounce, r;
    }
    return t.prototype.isInShadow = function(n) {
      for (var r = n && n.parentNode; r; ) {
        if (r.toString() === "[object ShadowRoot]")
          return !0;
        r = r.parentNode;
      }
      return !1;
    }, t.prototype.componentDidMount = function() {
      var n = this, r = this.props, i = r.className, o = r.onBeforeLoad, s = r.onValidate, a = r.mode, l = r.focus, u = r.theme, c = r.fontSize, d = r.value, f = r.defaultValue, h = r.showGutter, p = r.wrapEnabled, g = r.showPrintMargin, m = r.scrollMargin, v = m === void 0 ? [0, 0, 0, 0] : m, b = r.keyboardHandler, x = r.onLoad, w = r.commands, C = r.annotations, y = r.markers, S = r.placeholder;
      this.editor = m2.edit(this.refEditor), o && o(m2);
      for (var A = Object.keys(this.props.editorProps), $ = 0; $ < A.length; $++)
        this.editor[A[$]] = this.props.editorProps[A[$]];
      this.props.debounceChangePeriod && (this.onChange = this.debounce(this.onChange, this.props.debounceChangePeriod)), this.editor.renderer.setScrollMargin(v[0], v[1], v[2], v[3]), this.isInShadow(this.refEditor) && this.editor.renderer.attachToShadowRoot(), this.editor.getSession().setMode(typeof a == "string" ? "ace/mode/".concat(a) : a), u && u !== "" && this.editor.setTheme("ace/theme/".concat(u)), this.editor.setFontSize(typeof c == "number" ? "".concat(c, "px") : c), this.editor.getSession().setValue(f || d || ""), this.props.navigateToFileEnd && this.editor.navigateFileEnd(), this.editor.renderer.setShowGutter(h), this.editor.getSession().setUseWrapMode(p), this.editor.setShowPrintMargin(g), this.editor.on("focus", this.onFocus), this.editor.on("blur", this.onBlur), this.editor.on("copy", this.onCopy), this.editor.on("paste", this.onPaste), this.editor.on("change", this.onChange), this.editor.on("input", this.onInput), S && this.updatePlaceholder(), this.editor.getSession().selection.on("changeSelection", this.onSelectionChange), this.editor.getSession().selection.on("changeCursor", this.onCursorChange), s && this.editor.getSession().on("changeAnnotation", function() {
        var _ = n.editor.getSession().getAnnotations();
        n.props.onValidate(_);
      }), this.editor.session.on("changeScrollTop", this.onScroll), this.editor.getSession().setAnnotations(C || []), y && y.length > 0 && this.handleMarkers(y);
      var M = this.editor.$options;
      tc.editorOptions.forEach(function(_) {
        M.hasOwnProperty(_) ? n.editor.setOption(_, n.props[_]) : n.props[_] && console.warn("ReactAce: editor option ".concat(_, " was activated but not found. Did you need to import a related tool or did you possibly mispell the option?"));
      }), this.handleOptions(this.props), Array.isArray(w) && w.forEach(function(_) {
        typeof _.exec == "string" ? n.editor.commands.bindKey(_.bindKey, _.exec) : n.editor.commands.addCommand(_);
      }), b && this.editor.setKeyboardHandler("ace/keyboard/" + b), i && (this.refEditor.className += " " + i), x && x(this.editor), this.editor.resize(), l && this.editor.focus();
    }, t.prototype.componentDidUpdate = function(n) {
      for (var r = n, i = this.props, o = 0; o < tc.editorOptions.length; o++) {
        var s = tc.editorOptions[o];
        i[s] !== r[s] && this.editor.setOption(s, i[s]);
      }
      if (i.className !== r.className) {
        var a = this.refEditor.className, l = a.trim().split(" "), u = r.className.trim().split(" ");
        u.forEach(function(f) {
          var h = l.indexOf(f);
          l.splice(h, 1);
        }), this.refEditor.className = " " + i.className + " " + l.join(" ");
      }
      var c = this.editor && i.value != null && this.editor.getValue() !== i.value;
      if (c) {
        this.silent = !0;
        var d = this.editor.session.selection.toJSON();
        this.editor.setValue(i.value, i.cursorStart), this.editor.session.selection.fromJSON(d), this.silent = !1;
      }
      i.placeholder !== r.placeholder && this.updatePlaceholder(), i.mode !== r.mode && this.editor.getSession().setMode(typeof i.mode == "string" ? "ace/mode/".concat(i.mode) : i.mode), i.theme !== r.theme && this.editor.setTheme("ace/theme/" + i.theme), i.keyboardHandler !== r.keyboardHandler && (i.keyboardHandler ? this.editor.setKeyboardHandler("ace/keyboard/" + i.keyboardHandler) : this.editor.setKeyboardHandler(null)), i.fontSize !== r.fontSize && this.editor.setFontSize(typeof i.fontSize == "number" ? "".concat(i.fontSize, "px") : i.fontSize), i.wrapEnabled !== r.wrapEnabled && this.editor.getSession().setUseWrapMode(i.wrapEnabled), i.showPrintMargin !== r.showPrintMargin && this.editor.setShowPrintMargin(i.showPrintMargin), i.showGutter !== r.showGutter && this.editor.renderer.setShowGutter(i.showGutter), Rh(i.setOptions, r.setOptions) || this.handleOptions(i), (c || !Rh(i.annotations, r.annotations)) && this.editor.getSession().setAnnotations(i.annotations || []), !Rh(i.markers, r.markers) && Array.isArray(i.markers) && this.handleMarkers(i.markers), Rh(i.scrollMargin, r.scrollMargin) || this.handleScrollMargins(i.scrollMargin), (n.height !== this.props.height || n.width !== this.props.width) && this.editor.resize(), this.props.focus && !n.focus && this.editor.focus();
    }, t.prototype.handleScrollMargins = function(n) {
      n === void 0 && (n = [0, 0, 0, 0]), this.editor.renderer.setScrollMargin(n[0], n[1], n[2], n[3]);
    }, t.prototype.componentWillUnmount = function() {
      this.editor && (this.editor.destroy(), this.editor = null);
    }, t.prototype.onChange = function(n) {
      if (this.props.onChange && !this.silent) {
        var r = this.editor.getValue();
        this.props.onChange(r, n);
      }
    }, t.prototype.onSelectionChange = function(n) {
      if (this.props.onSelectionChange) {
        var r = this.editor.getSelection();
        this.props.onSelectionChange(r, n);
      }
    }, t.prototype.onCursorChange = function(n) {
      if (this.props.onCursorChange) {
        var r = this.editor.getSelection();
        this.props.onCursorChange(r, n);
      }
    }, t.prototype.onInput = function(n) {
      this.props.onInput && this.props.onInput(n), this.props.placeholder && this.updatePlaceholder();
    }, t.prototype.onFocus = function(n) {
      this.props.onFocus && this.props.onFocus(n, this.editor);
    }, t.prototype.onBlur = function(n) {
      this.props.onBlur && this.props.onBlur(n, this.editor);
    }, t.prototype.onCopy = function(n) {
      var r = n.text;
      this.props.onCopy && this.props.onCopy(r);
    }, t.prototype.onPaste = function(n) {
      var r = n.text;
      this.props.onPaste && this.props.onPaste(r);
    }, t.prototype.onScroll = function() {
      this.props.onScroll && this.props.onScroll(this.editor);
    }, t.prototype.handleOptions = function(n) {
      for (var r = Object.keys(n.setOptions), i = 0; i < r.length; i++)
        this.editor.setOption(r[i], n.setOptions[r[i]]);
    }, t.prototype.handleMarkers = function(n) {
      var r = this, i = this.editor.getSession().getMarkers(!0);
      for (var o in i)
        i.hasOwnProperty(o) && this.editor.getSession().removeMarker(i[o].id);
      i = this.editor.getSession().getMarkers(!1);
      for (var o in i)
        i.hasOwnProperty(o) && i[o].clazz !== "ace_active-line" && i[o].clazz !== "ace_selected-word" && this.editor.getSession().removeMarker(i[o].id);
      n.forEach(function(s) {
        var a = s.startRow, l = s.startCol, u = s.endRow, c = s.endCol, d = s.className, f = s.type, h = s.inFront, p = h === void 0 ? !1 : h, g = new Hre.Range(a, l, u, c);
        r.editor.getSession().addMarker(g, d, f, p);
      });
    }, t.prototype.updatePlaceholder = function() {
      var n = this.editor, r = this.props.placeholder, i = !n.session.getValue().length, o = n.renderer.placeholderNode;
      !i && o ? (n.renderer.scroller.removeChild(n.renderer.placeholderNode), n.renderer.placeholderNode = null) : i && !o ? (o = n.renderer.placeholderNode = document.createElement("div"), o.textContent = r || "", o.className = "ace_comment ace_placeholder", o.style.padding = "0 9px", o.style.position = "absolute", o.style.zIndex = "3", n.renderer.scroller.appendChild(o)) : i && o && (o.textContent = r);
    }, t.prototype.updateRef = function(n) {
      this.refEditor = n;
    }, t.prototype.render = function() {
      var n = this.props, r = n.name, i = n.width, o = n.height, s = n.style, a = zy({ width: i, height: o }, s);
      return g2.createElement("div", { ref: this.updateRef, id: r, style: a });
    }, t.propTypes = {
      mode: St.oneOfType([St.string, St.object]),
      focus: St.bool,
      theme: St.string,
      name: St.string,
      className: St.string,
      height: St.string,
      width: St.string,
      fontSize: St.oneOfType([St.number, St.string]),
      showGutter: St.bool,
      onChange: St.func,
      onCopy: St.func,
      onPaste: St.func,
      onFocus: St.func,
      onInput: St.func,
      onBlur: St.func,
      onScroll: St.func,
      value: St.string,
      defaultValue: St.string,
      onLoad: St.func,
      onSelectionChange: St.func,
      onCursorChange: St.func,
      onBeforeLoad: St.func,
      onValidate: St.func,
      minLines: St.number,
      maxLines: St.number,
      readOnly: St.bool,
      highlightActiveLine: St.bool,
      tabSize: St.number,
      showPrintMargin: St.bool,
      cursorStart: St.number,
      debounceChangePeriod: St.number,
      editorProps: St.object,
      setOptions: St.object,
      style: St.object,
      scrollMargin: St.array,
      annotations: St.array,
      markers: St.array,
      keyboardHandler: St.string,
      wrapEnabled: St.bool,
      enableSnippets: St.bool,
      enableBasicAutocompletion: St.oneOfType([
        St.bool,
        St.array
      ]),
      enableLiveAutocompletion: St.oneOfType([
        St.bool,
        St.array
      ]),
      navigateToFileEnd: St.bool,
      commands: St.array,
      placeholder: St.string
    }, t.defaultProps = {
      name: "ace-editor",
      focus: !1,
      mode: "",
      theme: "",
      height: "500px",
      width: "500px",
      fontSize: 12,
      enableSnippets: !1,
      showGutter: !0,
      onChange: null,
      onPaste: null,
      onLoad: null,
      onScroll: null,
      minLines: null,
      maxLines: null,
      readOnly: !1,
      highlightActiveLine: !0,
      showPrintMargin: !0,
      tabSize: 4,
      cursorStart: 1,
      editorProps: {},
      style: {},
      scrollMargin: [0, 0, 0, 0],
      setOptions: {},
      wrapEnabled: !1,
      enableBasicAutocompletion: !1,
      enableLiveAutocompletion: !1,
      placeholder: null,
      navigateToFileEnd: !0
    }, t;
  }(g2.Component)
);
xC.default = Vre;
var OC = {}, Em = {}, XP = { exports: {} };
(function(e, t) {
  ace.define("ace/split", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/editor", "ace/virtual_renderer", "ace/edit_session"], function(n, r, i) {
    var o = n("./lib/oop");
    n("./lib/lang");
    var s = n("./lib/event_emitter").EventEmitter, a = n("./editor").Editor, l = n("./virtual_renderer").VirtualRenderer, u = n("./edit_session").EditSession, c;
    c = function(d, f, h) {
      this.BELOW = 1, this.BESIDE = 0, this.$container = d, this.$theme = f, this.$splits = 0, this.$editorCSS = "", this.$editors = [], this.$orientation = this.BESIDE, this.setSplits(h || 1), this.$cEditor = this.$editors[0], this.on("focus", (function(p) {
        this.$cEditor = p;
      }).bind(this));
    }, (function() {
      o.implement(this, s), this.$createEditor = function() {
        var d = document.createElement("div");
        d.className = this.$editorCSS, d.style.cssText = "position: absolute; top:0px; bottom:0px", this.$container.appendChild(d);
        var f = new a(new l(d, this.$theme));
        return f.on("focus", (function() {
          this._emit("focus", f);
        }).bind(this)), this.$editors.push(f), f.setFontSize(this.$fontSize), f;
      }, this.setSplits = function(d) {
        var f;
        if (d < 1)
          throw "The number of splits have to be > 0!";
        if (d != this.$splits) {
          if (d > this.$splits) {
            for (; this.$splits < this.$editors.length && this.$splits < d; )
              f = this.$editors[this.$splits], this.$container.appendChild(f.container), f.setFontSize(this.$fontSize), this.$splits++;
            for (; this.$splits < d; )
              this.$createEditor(), this.$splits++;
          } else
            for (; this.$splits > d; )
              f = this.$editors[this.$splits - 1], this.$container.removeChild(f.container), this.$splits--;
          this.resize();
        }
      }, this.getSplits = function() {
        return this.$splits;
      }, this.getEditor = function(d) {
        return this.$editors[d];
      }, this.getCurrentEditor = function() {
        return this.$cEditor;
      }, this.focus = function() {
        this.$cEditor.focus();
      }, this.blur = function() {
        this.$cEditor.blur();
      }, this.setTheme = function(d) {
        this.$editors.forEach(function(f) {
          f.setTheme(d);
        });
      }, this.setKeyboardHandler = function(d) {
        this.$editors.forEach(function(f) {
          f.setKeyboardHandler(d);
        });
      }, this.forEach = function(d, f) {
        this.$editors.forEach(d, f);
      }, this.$fontSize = "", this.setFontSize = function(d) {
        this.$fontSize = d, this.forEach(function(f) {
          f.setFontSize(d);
        });
      }, this.$cloneSession = function(d) {
        var f = new u(d.getDocument(), d.getMode()), h = d.getUndoManager();
        return f.setUndoManager(h), f.setTabSize(d.getTabSize()), f.setUseSoftTabs(d.getUseSoftTabs()), f.setOverwrite(d.getOverwrite()), f.setBreakpoints(d.getBreakpoints()), f.setUseWrapMode(d.getUseWrapMode()), f.setUseWorker(d.getUseWorker()), f.setWrapLimitRange(d.$wrapLimitRange.min, d.$wrapLimitRange.max), f.$foldData = d.$cloneFoldData(), f;
      }, this.setSession = function(d, f) {
        var h;
        f == null ? h = this.$cEditor : h = this.$editors[f];
        var p = this.$editors.some(function(g) {
          return g.session === d;
        });
        return p && (d = this.$cloneSession(d)), h.setSession(d), d;
      }, this.getOrientation = function() {
        return this.$orientation;
      }, this.setOrientation = function(d) {
        this.$orientation != d && (this.$orientation = d, this.resize());
      }, this.resize = function() {
        var d = this.$container.clientWidth, f = this.$container.clientHeight, h;
        if (this.$orientation == this.BESIDE)
          for (var p = d / this.$splits, g = 0; g < this.$splits; g++)
            h = this.$editors[g], h.container.style.width = p + "px", h.container.style.top = "0px", h.container.style.left = g * p + "px", h.container.style.height = f + "px", h.resize();
        else
          for (var m = f / this.$splits, g = 0; g < this.$splits; g++)
            h = this.$editors[g], h.container.style.width = d + "px", h.container.style.top = g * m + "px", h.container.style.left = "0px", h.container.style.height = m + "px", h.resize();
      };
    }).call(c.prototype), r.Split = c;
  }), ace.define("ace/ext/split", ["require", "exports", "module", "ace/split"], function(n, r, i) {
    i.exports = n("../split");
  }), function() {
    ace.require(["ace/ext/split"], function(n) {
      e && (e.exports = n);
    });
  }();
})(XP);
var Wre = XP.exports, Ure = "Expected a function", YP = "__lodash_hash_undefined__", qP = 1 / 0, Gre = "[object Function]", Kre = "[object GeneratorFunction]", Xre = "[object Symbol]", Yre = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, qre = /^\w*$/, Qre = /^\./, Zre = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Jre = /[\\^$.*+?()[\]{}|]/g, eie = /\\(\\)?/g, tie = /^\[object .+?Constructor\]$/, nie = typeof Bn == "object" && Bn && Bn.Object === Object && Bn, rie = typeof self == "object" && self && self.Object === Object && self, AC = nie || rie || Function("return this")();
function iie(e, t) {
  return e == null ? void 0 : e[t];
}
function oie(e) {
  var t = !1;
  if (e != null && typeof e.toString != "function")
    try {
      t = !!(e + "");
    } catch {
    }
  return t;
}
var sie = Array.prototype, aie = Function.prototype, QP = Object.prototype, u0 = AC["__core-js_shared__"], v2 = function() {
  var e = /[^.]+$/.exec(u0 && u0.keys && u0.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}(), ZP = aie.toString, DC = QP.hasOwnProperty, JP = QP.toString, lie = RegExp(
  "^" + ZP.call(DC).replace(Jre, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
), b2 = AC.Symbol, cie = sie.splice, uie = eN(AC, "Map"), Kd = eN(Object, "create"), y2 = b2 ? b2.prototype : void 0, w2 = y2 ? y2.toString : void 0;
function al(e) {
  var t = -1, n = e ? e.length : 0;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
function die() {
  this.__data__ = Kd ? Kd(null) : {};
}
function fie(e) {
  return this.has(e) && delete this.__data__[e];
}
function hie(e) {
  var t = this.__data__;
  if (Kd) {
    var n = t[e];
    return n === YP ? void 0 : n;
  }
  return DC.call(t, e) ? t[e] : void 0;
}
function pie(e) {
  var t = this.__data__;
  return Kd ? t[e] !== void 0 : DC.call(t, e);
}
function gie(e, t) {
  var n = this.__data__;
  return n[e] = Kd && t === void 0 ? YP : t, this;
}
al.prototype.clear = die;
al.prototype.delete = fie;
al.prototype.get = hie;
al.prototype.has = pie;
al.prototype.set = gie;
function du(e) {
  var t = -1, n = e ? e.length : 0;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
function mie() {
  this.__data__ = [];
}
function vie(e) {
  var t = this.__data__, n = $m(t, e);
  if (n < 0)
    return !1;
  var r = t.length - 1;
  return n == r ? t.pop() : cie.call(t, n, 1), !0;
}
function bie(e) {
  var t = this.__data__, n = $m(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function yie(e) {
  return $m(this.__data__, e) > -1;
}
function wie(e, t) {
  var n = this.__data__, r = $m(n, e);
  return r < 0 ? n.push([e, t]) : n[r][1] = t, this;
}
du.prototype.clear = mie;
du.prototype.delete = vie;
du.prototype.get = bie;
du.prototype.has = yie;
du.prototype.set = wie;
function $l(e) {
  var t = -1, n = e ? e.length : 0;
  for (this.clear(); ++t < n; ) {
    var r = e[t];
    this.set(r[0], r[1]);
  }
}
function Cie() {
  this.__data__ = {
    hash: new al(),
    map: new (uie || du)(),
    string: new al()
  };
}
function Sie(e) {
  return Om(this, e).delete(e);
}
function xie(e) {
  return Om(this, e).get(e);
}
function Eie(e) {
  return Om(this, e).has(e);
}
function $ie(e, t) {
  return Om(this, e).set(e, t), this;
}
$l.prototype.clear = Cie;
$l.prototype.delete = Sie;
$l.prototype.get = xie;
$l.prototype.has = Eie;
$l.prototype.set = $ie;
function $m(e, t) {
  for (var n = e.length; n--; )
    if (Nie(e[n][0], t))
      return n;
  return -1;
}
function Oie(e, t) {
  t = Tie(t, e) ? [t] : _ie(t);
  for (var n = 0, r = t.length; e != null && n < r; )
    e = e[kie(t[n++])];
  return n && n == r ? e : void 0;
}
function Aie(e) {
  if (!nN(e) || Mie(e))
    return !1;
  var t = Lie(e) || oie(e) ? lie : tie;
  return t.test(Pie(e));
}
function Die(e) {
  if (typeof e == "string")
    return e;
  if (TC(e))
    return w2 ? w2.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -qP ? "-0" : t;
}
function _ie(e) {
  return tN(e) ? e : Iie(e);
}
function Om(e, t) {
  var n = e.__data__;
  return Rie(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function eN(e, t) {
  var n = iie(e, t);
  return Aie(n) ? n : void 0;
}
function Tie(e, t) {
  if (tN(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || TC(e) ? !0 : qre.test(e) || !Yre.test(e) || t != null && e in Object(t);
}
function Rie(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function Mie(e) {
  return !!v2 && v2 in e;
}
var Iie = _C(function(e) {
  e = Bie(e);
  var t = [];
  return Qre.test(e) && t.push(""), e.replace(Zre, function(n, r, i, o) {
    t.push(i ? o.replace(eie, "$1") : r || n);
  }), t;
});
function kie(e) {
  if (typeof e == "string" || TC(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -qP ? "-0" : t;
}
function Pie(e) {
  if (e != null) {
    try {
      return ZP.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
function _C(e, t) {
  if (typeof e != "function" || t && typeof t != "function")
    throw new TypeError(Ure);
  var n = function() {
    var r = arguments, i = t ? t.apply(this, r) : r[0], o = n.cache;
    if (o.has(i))
      return o.get(i);
    var s = e.apply(this, r);
    return n.cache = o.set(i, s), s;
  };
  return n.cache = new (_C.Cache || $l)(), n;
}
_C.Cache = $l;
function Nie(e, t) {
  return e === t || e !== e && t !== t;
}
var tN = Array.isArray;
function Lie(e) {
  var t = nN(e) ? JP.call(e) : "";
  return t == Gre || t == Kre;
}
function nN(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Fie(e) {
  return !!e && typeof e == "object";
}
function TC(e) {
  return typeof e == "symbol" || Fie(e) && JP.call(e) == Xre;
}
function Bie(e) {
  return e == null ? "" : Die(e);
}
function jie(e, t, n) {
  var r = e == null ? void 0 : Oie(e, t);
  return r === void 0 ? n : r;
}
var zie = jie, Hie = Bn && Bn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
      r.__proto__ = i;
    } || function(r, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Hy = Bn && Bn.__assign || function() {
  return Hy = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var i in t)
        Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, Hy.apply(this, arguments);
};
Object.defineProperty(Em, "__esModule", { value: !0 });
var Ra = vo, d0 = (0, Ra.getAceInstance)(), Vie = lg, Wie = Wre, Ot = $C, C2 = U, f0 = KP, is = zie, Uie = (
  /** @class */
  function(e) {
    Hie(t, e);
    function t(n) {
      var r = e.call(this, n) || this;
      return Ra.editorEvents.forEach(function(i) {
        r[i] = r[i].bind(r);
      }), r.debounce = Ra.debounce, r;
    }
    return t.prototype.isInShadow = function(n) {
      for (var r = n && n.parentNode; r; ) {
        if (r.toString() === "[object ShadowRoot]")
          return !0;
        r = r.parentNode;
      }
      return !1;
    }, t.prototype.componentDidMount = function() {
      var n = this, r = this.props, i = r.className, o = r.onBeforeLoad, s = r.mode, a = r.focus, l = r.theme, u = r.fontSize, c = r.value, d = r.defaultValue, f = r.cursorStart, h = r.showGutter, p = r.wrapEnabled, g = r.showPrintMargin, m = r.scrollMargin, v = m === void 0 ? [0, 0, 0, 0] : m, b = r.keyboardHandler, x = r.onLoad, w = r.commands, C = r.annotations, y = r.markers, S = r.splits;
      this.editor = d0.edit(this.refEditor), this.isInShadow(this.refEditor) && this.editor.renderer.attachToShadowRoot(), this.editor.setTheme("ace/theme/".concat(l)), o && o(d0);
      var A = Object.keys(this.props.editorProps), $ = new Wie.Split(this.editor.container, "ace/theme/".concat(l), S);
      this.editor.env.split = $, this.splitEditor = $.getEditor(0), this.split = $, this.editor.setShowPrintMargin(!1), this.editor.renderer.setShowGutter(!1);
      var M = this.splitEditor.$options;
      this.props.debounceChangePeriod && (this.onChange = this.debounce(this.onChange, this.props.debounceChangePeriod)), $.forEach(function(T, D) {
        for (var E = 0; E < A.length; E++)
          T[A[E]] = n.props.editorProps[A[E]];
        var R = is(d, D), I = is(c, D, "");
        T.session.setUndoManager(new d0.UndoManager()), T.setTheme("ace/theme/".concat(l)), T.renderer.setScrollMargin(v[0], v[1], v[2], v[3]), T.getSession().setMode("ace/mode/".concat(s)), T.setFontSize(u), T.renderer.setShowGutter(h), T.getSession().setUseWrapMode(p), T.setShowPrintMargin(g), T.on("focus", n.onFocus), T.on("blur", n.onBlur), T.on("input", n.onInput), T.on("copy", n.onCopy), T.on("paste", n.onPaste), T.on("change", n.onChange), T.getSession().selection.on("changeSelection", n.onSelectionChange), T.getSession().selection.on("changeCursor", n.onCursorChange), T.session.on("changeScrollTop", n.onScroll), T.setValue(R === void 0 ? I : R, f);
        var k = is(C, D, []), P = is(y, D, []);
        T.getSession().setAnnotations(k), P && P.length > 0 && n.handleMarkers(P, T);
        for (var E = 0; E < Ra.editorOptions.length; E++) {
          var L = Ra.editorOptions[E];
          M.hasOwnProperty(L) ? T.setOption(L, n.props[L]) : n.props[L] && console.warn("ReaceAce: editor option ".concat(L, " was activated but not found. Did you need to import a related tool or did you possibly mispell the option?"));
        }
        n.handleOptions(n.props, T), Array.isArray(w) && w.forEach(function(N) {
          typeof N.exec == "string" ? T.commands.bindKey(N.bindKey, N.exec) : T.commands.addCommand(N);
        }), b && T.setKeyboardHandler("ace/keyboard/" + b);
      }), i && (this.refEditor.className += " " + i), a && this.splitEditor.focus();
      var _ = this.editor.env.split;
      _.setOrientation(this.props.orientation === "below" ? _.BELOW : _.BESIDE), _.resize(!0), x && x(_);
    }, t.prototype.componentDidUpdate = function(n) {
      var r = this, i = n, o = this.props, s = this.editor.env.split;
      if (o.splits !== i.splits && s.setSplits(o.splits), o.orientation !== i.orientation && s.setOrientation(o.orientation === "below" ? s.BELOW : s.BESIDE), s.forEach(function(c, d) {
        o.mode !== i.mode && c.getSession().setMode("ace/mode/" + o.mode), o.keyboardHandler !== i.keyboardHandler && (o.keyboardHandler ? c.setKeyboardHandler("ace/keyboard/" + o.keyboardHandler) : c.setKeyboardHandler(null)), o.fontSize !== i.fontSize && c.setFontSize(o.fontSize), o.wrapEnabled !== i.wrapEnabled && c.getSession().setUseWrapMode(o.wrapEnabled), o.showPrintMargin !== i.showPrintMargin && c.setShowPrintMargin(o.showPrintMargin), o.showGutter !== i.showGutter && c.renderer.setShowGutter(o.showGutter);
        for (var f = 0; f < Ra.editorOptions.length; f++) {
          var h = Ra.editorOptions[f];
          o[h] !== i[h] && c.setOption(h, o[h]);
        }
        f0(o.setOptions, i.setOptions) || r.handleOptions(o, c);
        var p = is(o.value, d, "");
        if (c.getValue() !== p) {
          r.silent = !0;
          var g = c.session.selection.toJSON();
          c.setValue(p, o.cursorStart), c.session.selection.fromJSON(g), r.silent = !1;
        }
        var m = is(o.annotations, d, []), v = is(i.annotations, d, []);
        f0(m, v) || c.getSession().setAnnotations(m);
        var b = is(o.markers, d, []), x = is(i.markers, d, []);
        !f0(b, x) && Array.isArray(b) && r.handleMarkers(b, c);
      }), o.className !== i.className) {
        var a = this.refEditor.className, l = a.trim().split(" "), u = i.className.trim().split(" ");
        u.forEach(function(c) {
          var d = l.indexOf(c);
          l.splice(d, 1);
        }), this.refEditor.className = " " + o.className + " " + l.join(" ");
      }
      o.theme !== i.theme && s.setTheme("ace/theme/" + o.theme), o.focus && !i.focus && this.splitEditor.focus(), (o.height !== this.props.height || o.width !== this.props.width) && this.editor.resize();
    }, t.prototype.componentWillUnmount = function() {
      this.editor.destroy(), this.editor = null;
    }, t.prototype.onChange = function(n) {
      if (this.props.onChange && !this.silent) {
        var r = [];
        this.editor.env.split.forEach(function(i) {
          r.push(i.getValue());
        }), this.props.onChange(r, n);
      }
    }, t.prototype.onSelectionChange = function(n) {
      if (this.props.onSelectionChange) {
        var r = [];
        this.editor.env.split.forEach(function(i) {
          r.push(i.getSelection());
        }), this.props.onSelectionChange(r, n);
      }
    }, t.prototype.onCursorChange = function(n) {
      if (this.props.onCursorChange) {
        var r = [];
        this.editor.env.split.forEach(function(i) {
          r.push(i.getSelection());
        }), this.props.onCursorChange(r, n);
      }
    }, t.prototype.onFocus = function(n) {
      this.props.onFocus && this.props.onFocus(n);
    }, t.prototype.onInput = function(n) {
      this.props.onInput && this.props.onInput(n);
    }, t.prototype.onBlur = function(n) {
      this.props.onBlur && this.props.onBlur(n);
    }, t.prototype.onCopy = function(n) {
      this.props.onCopy && this.props.onCopy(n);
    }, t.prototype.onPaste = function(n) {
      this.props.onPaste && this.props.onPaste(n);
    }, t.prototype.onScroll = function() {
      this.props.onScroll && this.props.onScroll(this.editor);
    }, t.prototype.handleOptions = function(n, r) {
      for (var i = Object.keys(n.setOptions), o = 0; o < i.length; o++)
        r.setOption(i[o], n.setOptions[i[o]]);
    }, t.prototype.handleMarkers = function(n, r) {
      var i = r.getSession().getMarkers(!0);
      for (var o in i)
        i.hasOwnProperty(o) && r.getSession().removeMarker(i[o].id);
      i = r.getSession().getMarkers(!1);
      for (var o in i)
        i.hasOwnProperty(o) && r.getSession().removeMarker(i[o].id);
      n.forEach(function(s) {
        var a = s.startRow, l = s.startCol, u = s.endRow, c = s.endCol, d = s.className, f = s.type, h = s.inFront, p = h === void 0 ? !1 : h, g = new Vie.Range(a, l, u, c);
        r.getSession().addMarker(g, d, f, p);
      });
    }, t.prototype.updateRef = function(n) {
      this.refEditor = n;
    }, t.prototype.render = function() {
      var n = this.props, r = n.name, i = n.width, o = n.height, s = n.style, a = Hy({ width: i, height: o }, s);
      return C2.createElement("div", { ref: this.updateRef, id: r, style: a });
    }, t.propTypes = {
      className: Ot.string,
      debounceChangePeriod: Ot.number,
      defaultValue: Ot.arrayOf(Ot.string),
      focus: Ot.bool,
      fontSize: Ot.oneOfType([Ot.number, Ot.string]),
      height: Ot.string,
      mode: Ot.string,
      name: Ot.string,
      onBlur: Ot.func,
      onChange: Ot.func,
      onCopy: Ot.func,
      onFocus: Ot.func,
      onInput: Ot.func,
      onLoad: Ot.func,
      onPaste: Ot.func,
      onScroll: Ot.func,
      orientation: Ot.string,
      showGutter: Ot.bool,
      splits: Ot.number,
      theme: Ot.string,
      value: Ot.arrayOf(Ot.string),
      width: Ot.string,
      onSelectionChange: Ot.func,
      onCursorChange: Ot.func,
      onBeforeLoad: Ot.func,
      minLines: Ot.number,
      maxLines: Ot.number,
      readOnly: Ot.bool,
      highlightActiveLine: Ot.bool,
      tabSize: Ot.number,
      showPrintMargin: Ot.bool,
      cursorStart: Ot.number,
      editorProps: Ot.object,
      setOptions: Ot.object,
      style: Ot.object,
      scrollMargin: Ot.array,
      annotations: Ot.array,
      markers: Ot.array,
      keyboardHandler: Ot.string,
      wrapEnabled: Ot.bool,
      enableBasicAutocompletion: Ot.oneOfType([
        Ot.bool,
        Ot.array
      ]),
      enableLiveAutocompletion: Ot.oneOfType([
        Ot.bool,
        Ot.array
      ]),
      commands: Ot.array
    }, t.defaultProps = {
      name: "ace-editor",
      focus: !1,
      orientation: "beside",
      splits: 2,
      mode: "",
      theme: "",
      height: "500px",
      width: "500px",
      value: [],
      fontSize: 12,
      showGutter: !0,
      onChange: null,
      onPaste: null,
      onLoad: null,
      onScroll: null,
      minLines: null,
      maxLines: null,
      readOnly: !1,
      highlightActiveLine: !0,
      showPrintMargin: !0,
      tabSize: 4,
      cursorStart: 1,
      editorProps: {},
      style: {},
      scrollMargin: [0, 0, 0, 0],
      setOptions: {},
      wrapEnabled: !1,
      enableBasicAutocompletion: !1,
      enableLiveAutocompletion: !1
    }, t;
  }(C2.Component)
);
Em.default = Uie;
var rN = { exports: {} };
(function(e) {
  var t = function() {
    this.Diff_Timeout = 1, this.Diff_EditCost = 4, this.Match_Threshold = 0.5, this.Match_Distance = 1e3, this.Patch_DeleteThreshold = 0.5, this.Patch_Margin = 4, this.Match_MaxBits = 32;
  }, n = -1, r = 1, i = 0;
  t.Diff = function(o, s) {
    return [o, s];
  }, t.prototype.diff_main = function(o, s, a, l) {
    typeof l > "u" && (this.Diff_Timeout <= 0 ? l = Number.MAX_VALUE : l = (/* @__PURE__ */ new Date()).getTime() + this.Diff_Timeout * 1e3);
    var u = l;
    if (o == null || s == null)
      throw new Error("Null input. (diff_main)");
    if (o == s)
      return o ? [new t.Diff(i, o)] : [];
    typeof a > "u" && (a = !0);
    var c = a, d = this.diff_commonPrefix(o, s), f = o.substring(0, d);
    o = o.substring(d), s = s.substring(d), d = this.diff_commonSuffix(o, s);
    var h = o.substring(o.length - d);
    o = o.substring(0, o.length - d), s = s.substring(0, s.length - d);
    var p = this.diff_compute_(o, s, c, u);
    return f && p.unshift(new t.Diff(i, f)), h && p.push(new t.Diff(i, h)), this.diff_cleanupMerge(p), p;
  }, t.prototype.diff_compute_ = function(o, s, a, l) {
    var u;
    if (!o)
      return [new t.Diff(r, s)];
    if (!s)
      return [new t.Diff(n, o)];
    var c = o.length > s.length ? o : s, d = o.length > s.length ? s : o, f = c.indexOf(d);
    if (f != -1)
      return u = [
        new t.Diff(r, c.substring(0, f)),
        new t.Diff(i, d),
        new t.Diff(
          r,
          c.substring(f + d.length)
        )
      ], o.length > s.length && (u[0][0] = u[2][0] = n), u;
    if (d.length == 1)
      return [
        new t.Diff(n, o),
        new t.Diff(r, s)
      ];
    var h = this.diff_halfMatch_(o, s);
    if (h) {
      var p = h[0], g = h[1], m = h[2], v = h[3], b = h[4], x = this.diff_main(p, m, a, l), w = this.diff_main(g, v, a, l);
      return x.concat(
        [new t.Diff(i, b)],
        w
      );
    }
    return a && o.length > 100 && s.length > 100 ? this.diff_lineMode_(o, s, l) : this.diff_bisect_(o, s, l);
  }, t.prototype.diff_lineMode_ = function(o, s, a) {
    var l = this.diff_linesToChars_(o, s);
    o = l.chars1, s = l.chars2;
    var u = l.lineArray, c = this.diff_main(o, s, !1, a);
    this.diff_charsToLines_(c, u), this.diff_cleanupSemantic(c), c.push(new t.Diff(i, ""));
    for (var d = 0, f = 0, h = 0, p = "", g = ""; d < c.length; ) {
      switch (c[d][0]) {
        case r:
          h++, g += c[d][1];
          break;
        case n:
          f++, p += c[d][1];
          break;
        case i:
          if (f >= 1 && h >= 1) {
            c.splice(
              d - f - h,
              f + h
            ), d = d - f - h;
            for (var m = this.diff_main(p, g, !1, a), v = m.length - 1; v >= 0; v--)
              c.splice(d, 0, m[v]);
            d = d + m.length;
          }
          h = 0, f = 0, p = "", g = "";
          break;
      }
      d++;
    }
    return c.pop(), c;
  }, t.prototype.diff_bisect_ = function(o, s, a) {
    for (var l = o.length, u = s.length, c = Math.ceil((l + u) / 2), d = c, f = 2 * c, h = new Array(f), p = new Array(f), g = 0; g < f; g++)
      h[g] = -1, p[g] = -1;
    h[d + 1] = 0, p[d + 1] = 0;
    for (var m = l - u, v = m % 2 != 0, b = 0, x = 0, w = 0, C = 0, y = 0; y < c && !((/* @__PURE__ */ new Date()).getTime() > a); y++) {
      for (var S = -y + b; S <= y - x; S += 2) {
        var A = d + S, $;
        S == -y || S != y && h[A - 1] < h[A + 1] ? $ = h[A + 1] : $ = h[A - 1] + 1;
        for (var M = $ - S; $ < l && M < u && o.charAt($) == s.charAt(M); )
          $++, M++;
        if (h[A] = $, $ > l)
          x += 2;
        else if (M > u)
          b += 2;
        else if (v) {
          var _ = d + m - S;
          if (_ >= 0 && _ < f && p[_] != -1) {
            var T = l - p[_];
            if ($ >= T)
              return this.diff_bisectSplit_(o, s, $, M, a);
          }
        }
      }
      for (var D = -y + w; D <= y - C; D += 2) {
        var _ = d + D, T;
        D == -y || D != y && p[_ - 1] < p[_ + 1] ? T = p[_ + 1] : T = p[_ - 1] + 1;
        for (var E = T - D; T < l && E < u && o.charAt(l - T - 1) == s.charAt(u - E - 1); )
          T++, E++;
        if (p[_] = T, T > l)
          C += 2;
        else if (E > u)
          w += 2;
        else if (!v) {
          var A = d + m - D;
          if (A >= 0 && A < f && h[A] != -1) {
            var $ = h[A], M = d + $ - A;
            if (T = l - T, $ >= T)
              return this.diff_bisectSplit_(o, s, $, M, a);
          }
        }
      }
    }
    return [
      new t.Diff(n, o),
      new t.Diff(r, s)
    ];
  }, t.prototype.diff_bisectSplit_ = function(o, s, a, l, u) {
    var c = o.substring(0, a), d = s.substring(0, l), f = o.substring(a), h = s.substring(l), p = this.diff_main(c, d, !1, u), g = this.diff_main(f, h, !1, u);
    return p.concat(g);
  }, t.prototype.diff_linesToChars_ = function(o, s) {
    var a = [], l = {};
    a[0] = "";
    function u(h) {
      for (var p = "", g = 0, m = -1, v = a.length; m < h.length - 1; ) {
        m = h.indexOf(`
`, g), m == -1 && (m = h.length - 1);
        var b = h.substring(g, m + 1);
        (l.hasOwnProperty ? l.hasOwnProperty(b) : l[b] !== void 0) ? p += String.fromCharCode(l[b]) : (v == c && (b = h.substring(g), m = h.length), p += String.fromCharCode(v), l[b] = v, a[v++] = b), g = m + 1;
      }
      return p;
    }
    var c = 4e4, d = u(o);
    c = 65535;
    var f = u(s);
    return { chars1: d, chars2: f, lineArray: a };
  }, t.prototype.diff_charsToLines_ = function(o, s) {
    for (var a = 0; a < o.length; a++) {
      for (var l = o[a][1], u = [], c = 0; c < l.length; c++)
        u[c] = s[l.charCodeAt(c)];
      o[a][1] = u.join("");
    }
  }, t.prototype.diff_commonPrefix = function(o, s) {
    if (!o || !s || o.charAt(0) != s.charAt(0))
      return 0;
    for (var a = 0, l = Math.min(o.length, s.length), u = l, c = 0; a < u; )
      o.substring(c, u) == s.substring(c, u) ? (a = u, c = a) : l = u, u = Math.floor((l - a) / 2 + a);
    return u;
  }, t.prototype.diff_commonSuffix = function(o, s) {
    if (!o || !s || o.charAt(o.length - 1) != s.charAt(s.length - 1))
      return 0;
    for (var a = 0, l = Math.min(o.length, s.length), u = l, c = 0; a < u; )
      o.substring(o.length - u, o.length - c) == s.substring(s.length - u, s.length - c) ? (a = u, c = a) : l = u, u = Math.floor((l - a) / 2 + a);
    return u;
  }, t.prototype.diff_commonOverlap_ = function(o, s) {
    var a = o.length, l = s.length;
    if (a == 0 || l == 0)
      return 0;
    a > l ? o = o.substring(a - l) : a < l && (s = s.substring(0, a));
    var u = Math.min(a, l);
    if (o == s)
      return u;
    for (var c = 0, d = 1; ; ) {
      var f = o.substring(u - d), h = s.indexOf(f);
      if (h == -1)
        return c;
      d += h, (h == 0 || o.substring(u - d) == s.substring(0, d)) && (c = d, d++);
    }
  }, t.prototype.diff_halfMatch_ = function(o, s) {
    if (this.Diff_Timeout <= 0)
      return null;
    var a = o.length > s.length ? o : s, l = o.length > s.length ? s : o;
    if (a.length < 4 || l.length * 2 < a.length)
      return null;
    var u = this;
    function c(x, w, C) {
      for (var y = x.substring(C, C + Math.floor(x.length / 4)), S = -1, A = "", $, M, _, T; (S = w.indexOf(y, S + 1)) != -1; ) {
        var D = u.diff_commonPrefix(
          x.substring(C),
          w.substring(S)
        ), E = u.diff_commonSuffix(
          x.substring(0, C),
          w.substring(0, S)
        );
        A.length < E + D && (A = w.substring(S - E, S) + w.substring(S, S + D), $ = x.substring(0, C - E), M = x.substring(C + D), _ = w.substring(0, S - E), T = w.substring(S + D));
      }
      return A.length * 2 >= x.length ? [
        $,
        M,
        _,
        T,
        A
      ] : null;
    }
    var d = c(
      a,
      l,
      Math.ceil(a.length / 4)
    ), f = c(
      a,
      l,
      Math.ceil(a.length / 2)
    ), h;
    if (!d && !f)
      return null;
    f ? d ? h = d[4].length > f[4].length ? d : f : h = f : h = d;
    var p, g, m, v;
    o.length > s.length ? (p = h[0], g = h[1], m = h[2], v = h[3]) : (m = h[0], v = h[1], p = h[2], g = h[3]);
    var b = h[4];
    return [p, g, m, v, b];
  }, t.prototype.diff_cleanupSemantic = function(o) {
    for (var s = !1, a = [], l = 0, u = null, c = 0, d = 0, f = 0, h = 0, p = 0; c < o.length; )
      o[c][0] == i ? (a[l++] = c, d = h, f = p, h = 0, p = 0, u = o[c][1]) : (o[c][0] == r ? h += o[c][1].length : p += o[c][1].length, u && u.length <= Math.max(d, f) && u.length <= Math.max(
        h,
        p
      ) && (o.splice(
        a[l - 1],
        0,
        new t.Diff(n, u)
      ), o[a[l - 1] + 1][0] = r, l--, l--, c = l > 0 ? a[l - 1] : -1, d = 0, f = 0, h = 0, p = 0, u = null, s = !0)), c++;
    for (s && this.diff_cleanupMerge(o), this.diff_cleanupSemanticLossless(o), c = 1; c < o.length; ) {
      if (o[c - 1][0] == n && o[c][0] == r) {
        var g = o[c - 1][1], m = o[c][1], v = this.diff_commonOverlap_(g, m), b = this.diff_commonOverlap_(m, g);
        v >= b ? (v >= g.length / 2 || v >= m.length / 2) && (o.splice(c, 0, new t.Diff(
          i,
          m.substring(0, v)
        )), o[c - 1][1] = g.substring(0, g.length - v), o[c + 1][1] = m.substring(v), c++) : (b >= g.length / 2 || b >= m.length / 2) && (o.splice(c, 0, new t.Diff(
          i,
          g.substring(0, b)
        )), o[c - 1][0] = r, o[c - 1][1] = m.substring(0, m.length - b), o[c + 1][0] = n, o[c + 1][1] = g.substring(b), c++), c++;
      }
      c++;
    }
  }, t.prototype.diff_cleanupSemanticLossless = function(o) {
    function s(b, x) {
      if (!b || !x)
        return 6;
      var w = b.charAt(b.length - 1), C = x.charAt(0), y = w.match(t.nonAlphaNumericRegex_), S = C.match(t.nonAlphaNumericRegex_), A = y && w.match(t.whitespaceRegex_), $ = S && C.match(t.whitespaceRegex_), M = A && w.match(t.linebreakRegex_), _ = $ && C.match(t.linebreakRegex_), T = M && b.match(t.blanklineEndRegex_), D = _ && x.match(t.blanklineStartRegex_);
      return T || D ? 5 : M || _ ? 4 : y && !A && $ ? 3 : A || $ ? 2 : y || S ? 1 : 0;
    }
    for (var a = 1; a < o.length - 1; ) {
      if (o[a - 1][0] == i && o[a + 1][0] == i) {
        var l = o[a - 1][1], u = o[a][1], c = o[a + 1][1], d = this.diff_commonSuffix(l, u);
        if (d) {
          var f = u.substring(u.length - d);
          l = l.substring(0, l.length - d), u = f + u.substring(0, u.length - d), c = f + c;
        }
        for (var h = l, p = u, g = c, m = s(l, u) + s(u, c); u.charAt(0) === c.charAt(0); ) {
          l += u.charAt(0), u = u.substring(1) + c.charAt(0), c = c.substring(1);
          var v = s(l, u) + s(u, c);
          v >= m && (m = v, h = l, p = u, g = c);
        }
        o[a - 1][1] != h && (h ? o[a - 1][1] = h : (o.splice(a - 1, 1), a--), o[a][1] = p, g ? o[a + 1][1] = g : (o.splice(a + 1, 1), a--));
      }
      a++;
    }
  }, t.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/, t.whitespaceRegex_ = /\s/, t.linebreakRegex_ = /[\r\n]/, t.blanklineEndRegex_ = /\n\r?\n$/, t.blanklineStartRegex_ = /^\r?\n\r?\n/, t.prototype.diff_cleanupEfficiency = function(o) {
    for (var s = !1, a = [], l = 0, u = null, c = 0, d = !1, f = !1, h = !1, p = !1; c < o.length; )
      o[c][0] == i ? (o[c][1].length < this.Diff_EditCost && (h || p) ? (a[l++] = c, d = h, f = p, u = o[c][1]) : (l = 0, u = null), h = p = !1) : (o[c][0] == n ? p = !0 : h = !0, u && (d && f && h && p || u.length < this.Diff_EditCost / 2 && d + f + h + p == 3) && (o.splice(
        a[l - 1],
        0,
        new t.Diff(n, u)
      ), o[a[l - 1] + 1][0] = r, l--, u = null, d && f ? (h = p = !0, l = 0) : (l--, c = l > 0 ? a[l - 1] : -1, h = p = !1), s = !0)), c++;
    s && this.diff_cleanupMerge(o);
  }, t.prototype.diff_cleanupMerge = function(o) {
    o.push(new t.Diff(i, ""));
    for (var s = 0, a = 0, l = 0, u = "", c = "", d; s < o.length; )
      switch (o[s][0]) {
        case r:
          l++, c += o[s][1], s++;
          break;
        case n:
          a++, u += o[s][1], s++;
          break;
        case i:
          a + l > 1 ? (a !== 0 && l !== 0 && (d = this.diff_commonPrefix(c, u), d !== 0 && (s - a - l > 0 && o[s - a - l - 1][0] == i ? o[s - a - l - 1][1] += c.substring(0, d) : (o.splice(0, 0, new t.Diff(
            i,
            c.substring(0, d)
          )), s++), c = c.substring(d), u = u.substring(d)), d = this.diff_commonSuffix(c, u), d !== 0 && (o[s][1] = c.substring(c.length - d) + o[s][1], c = c.substring(0, c.length - d), u = u.substring(0, u.length - d))), s -= a + l, o.splice(s, a + l), u.length && (o.splice(
            s,
            0,
            new t.Diff(n, u)
          ), s++), c.length && (o.splice(
            s,
            0,
            new t.Diff(r, c)
          ), s++), s++) : s !== 0 && o[s - 1][0] == i ? (o[s - 1][1] += o[s][1], o.splice(s, 1)) : s++, l = 0, a = 0, u = "", c = "";
          break;
      }
    o[o.length - 1][1] === "" && o.pop();
    var f = !1;
    for (s = 1; s < o.length - 1; )
      o[s - 1][0] == i && o[s + 1][0] == i && (o[s][1].substring(o[s][1].length - o[s - 1][1].length) == o[s - 1][1] ? (o[s][1] = o[s - 1][1] + o[s][1].substring(0, o[s][1].length - o[s - 1][1].length), o[s + 1][1] = o[s - 1][1] + o[s + 1][1], o.splice(s - 1, 1), f = !0) : o[s][1].substring(0, o[s + 1][1].length) == o[s + 1][1] && (o[s - 1][1] += o[s + 1][1], o[s][1] = o[s][1].substring(o[s + 1][1].length) + o[s + 1][1], o.splice(s + 1, 1), f = !0)), s++;
    f && this.diff_cleanupMerge(o);
  }, t.prototype.diff_xIndex = function(o, s) {
    var a = 0, l = 0, u = 0, c = 0, d;
    for (d = 0; d < o.length && (o[d][0] !== r && (a += o[d][1].length), o[d][0] !== n && (l += o[d][1].length), !(a > s)); d++)
      u = a, c = l;
    return o.length != d && o[d][0] === n ? c : c + (s - u);
  }, t.prototype.diff_prettyHtml = function(o) {
    for (var s = [], a = /&/g, l = /</g, u = />/g, c = /\n/g, d = 0; d < o.length; d++) {
      var f = o[d][0], h = o[d][1], p = h.replace(a, "&amp;").replace(l, "&lt;").replace(u, "&gt;").replace(c, "&para;<br>");
      switch (f) {
        case r:
          s[d] = '<ins style="background:#e6ffe6;">' + p + "</ins>";
          break;
        case n:
          s[d] = '<del style="background:#ffe6e6;">' + p + "</del>";
          break;
        case i:
          s[d] = "<span>" + p + "</span>";
          break;
      }
    }
    return s.join("");
  }, t.prototype.diff_text1 = function(o) {
    for (var s = [], a = 0; a < o.length; a++)
      o[a][0] !== r && (s[a] = o[a][1]);
    return s.join("");
  }, t.prototype.diff_text2 = function(o) {
    for (var s = [], a = 0; a < o.length; a++)
      o[a][0] !== n && (s[a] = o[a][1]);
    return s.join("");
  }, t.prototype.diff_levenshtein = function(o) {
    for (var s = 0, a = 0, l = 0, u = 0; u < o.length; u++) {
      var c = o[u][0], d = o[u][1];
      switch (c) {
        case r:
          a += d.length;
          break;
        case n:
          l += d.length;
          break;
        case i:
          s += Math.max(a, l), a = 0, l = 0;
          break;
      }
    }
    return s += Math.max(a, l), s;
  }, t.prototype.diff_toDelta = function(o) {
    for (var s = [], a = 0; a < o.length; a++)
      switch (o[a][0]) {
        case r:
          s[a] = "+" + encodeURI(o[a][1]);
          break;
        case n:
          s[a] = "-" + o[a][1].length;
          break;
        case i:
          s[a] = "=" + o[a][1].length;
          break;
      }
    return s.join("	").replace(/%20/g, " ");
  }, t.prototype.diff_fromDelta = function(o, s) {
    for (var a = [], l = 0, u = 0, c = s.split(/\t/g), d = 0; d < c.length; d++) {
      var f = c[d].substring(1);
      switch (c[d].charAt(0)) {
        case "+":
          try {
            a[l++] = new t.Diff(r, decodeURI(f));
          } catch {
            throw new Error("Illegal escape in diff_fromDelta: " + f);
          }
          break;
        case "-":
        case "=":
          var h = parseInt(f, 10);
          if (isNaN(h) || h < 0)
            throw new Error("Invalid number in diff_fromDelta: " + f);
          var p = o.substring(u, u += h);
          c[d].charAt(0) == "=" ? a[l++] = new t.Diff(i, p) : a[l++] = new t.Diff(n, p);
          break;
        default:
          if (c[d])
            throw new Error("Invalid diff operation in diff_fromDelta: " + c[d]);
      }
    }
    if (u != o.length)
      throw new Error("Delta length (" + u + ") does not equal source text length (" + o.length + ").");
    return a;
  }, t.prototype.match_main = function(o, s, a) {
    if (o == null || s == null || a == null)
      throw new Error("Null input. (match_main)");
    return a = Math.max(0, Math.min(a, o.length)), o == s ? 0 : o.length ? o.substring(a, a + s.length) == s ? a : this.match_bitap_(o, s, a) : -1;
  }, t.prototype.match_bitap_ = function(o, s, a) {
    if (s.length > this.Match_MaxBits)
      throw new Error("Pattern too long for this browser.");
    var l = this.match_alphabet_(s), u = this;
    function c($, M) {
      var _ = $ / s.length, T = Math.abs(a - M);
      return u.Match_Distance ? _ + T / u.Match_Distance : T ? 1 : _;
    }
    var d = this.Match_Threshold, f = o.indexOf(s, a);
    f != -1 && (d = Math.min(c(0, f), d), f = o.lastIndexOf(s, a + s.length), f != -1 && (d = Math.min(c(0, f), d)));
    var h = 1 << s.length - 1;
    f = -1;
    for (var p, g, m = s.length + o.length, v, b = 0; b < s.length; b++) {
      for (p = 0, g = m; p < g; )
        c(b, a + g) <= d ? p = g : m = g, g = Math.floor((m - p) / 2 + p);
      m = g;
      var x = Math.max(1, a - g + 1), w = Math.min(a + g, o.length) + s.length, C = Array(w + 2);
      C[w + 1] = (1 << b) - 1;
      for (var y = w; y >= x; y--) {
        var S = l[o.charAt(y - 1)];
        if (b === 0 ? C[y] = (C[y + 1] << 1 | 1) & S : C[y] = (C[y + 1] << 1 | 1) & S | ((v[y + 1] | v[y]) << 1 | 1) | v[y + 1], C[y] & h) {
          var A = c(b, y - 1);
          if (A <= d)
            if (d = A, f = y - 1, f > a)
              x = Math.max(1, 2 * a - f);
            else
              break;
        }
      }
      if (c(b + 1, a) > d)
        break;
      v = C;
    }
    return f;
  }, t.prototype.match_alphabet_ = function(o) {
    for (var s = {}, a = 0; a < o.length; a++)
      s[o.charAt(a)] = 0;
    for (var a = 0; a < o.length; a++)
      s[o.charAt(a)] |= 1 << o.length - a - 1;
    return s;
  }, t.prototype.patch_addContext_ = function(o, s) {
    if (s.length != 0) {
      if (o.start2 === null)
        throw Error("patch not initialized");
      for (var a = s.substring(o.start2, o.start2 + o.length1), l = 0; s.indexOf(a) != s.lastIndexOf(a) && a.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin; )
        l += this.Patch_Margin, a = s.substring(
          o.start2 - l,
          o.start2 + o.length1 + l
        );
      l += this.Patch_Margin;
      var u = s.substring(o.start2 - l, o.start2);
      u && o.diffs.unshift(new t.Diff(i, u));
      var c = s.substring(
        o.start2 + o.length1,
        o.start2 + o.length1 + l
      );
      c && o.diffs.push(new t.Diff(i, c)), o.start1 -= u.length, o.start2 -= u.length, o.length1 += u.length + c.length, o.length2 += u.length + c.length;
    }
  }, t.prototype.patch_make = function(o, s, a) {
    var l, u;
    if (typeof o == "string" && typeof s == "string" && typeof a > "u")
      l = /** @type {string} */
      o, u = this.diff_main(
        l,
        /** @type {string} */
        s,
        !0
      ), u.length > 2 && (this.diff_cleanupSemantic(u), this.diff_cleanupEfficiency(u));
    else if (o && typeof o == "object" && typeof s > "u" && typeof a > "u")
      u = /** @type {!Array.<!diff_match_patch.Diff>} */
      o, l = this.diff_text1(u);
    else if (typeof o == "string" && s && typeof s == "object" && typeof a > "u")
      l = /** @type {string} */
      o, u = /** @type {!Array.<!diff_match_patch.Diff>} */
      s;
    else if (typeof o == "string" && typeof s == "string" && a && typeof a == "object")
      l = /** @type {string} */
      o, u = /** @type {!Array.<!diff_match_patch.Diff>} */
      a;
    else
      throw new Error("Unknown call format to patch_make.");
    if (u.length === 0)
      return [];
    for (var c = [], d = new t.patch_obj(), f = 0, h = 0, p = 0, g = l, m = l, v = 0; v < u.length; v++) {
      var b = u[v][0], x = u[v][1];
      switch (!f && b !== i && (d.start1 = h, d.start2 = p), b) {
        case r:
          d.diffs[f++] = u[v], d.length2 += x.length, m = m.substring(0, p) + x + m.substring(p);
          break;
        case n:
          d.length1 += x.length, d.diffs[f++] = u[v], m = m.substring(0, p) + m.substring(p + x.length);
          break;
        case i:
          x.length <= 2 * this.Patch_Margin && f && u.length != v + 1 ? (d.diffs[f++] = u[v], d.length1 += x.length, d.length2 += x.length) : x.length >= 2 * this.Patch_Margin && f && (this.patch_addContext_(d, g), c.push(d), d = new t.patch_obj(), f = 0, g = m, h = p);
          break;
      }
      b !== r && (h += x.length), b !== n && (p += x.length);
    }
    return f && (this.patch_addContext_(d, g), c.push(d)), c;
  }, t.prototype.patch_deepCopy = function(o) {
    for (var s = [], a = 0; a < o.length; a++) {
      var l = o[a], u = new t.patch_obj();
      u.diffs = [];
      for (var c = 0; c < l.diffs.length; c++)
        u.diffs[c] = new t.Diff(l.diffs[c][0], l.diffs[c][1]);
      u.start1 = l.start1, u.start2 = l.start2, u.length1 = l.length1, u.length2 = l.length2, s[a] = u;
    }
    return s;
  }, t.prototype.patch_apply = function(o, s) {
    if (o.length == 0)
      return [s, []];
    o = this.patch_deepCopy(o);
    var a = this.patch_addPadding(o);
    s = a + s + a, this.patch_splitMax(o);
    for (var l = 0, u = [], c = 0; c < o.length; c++) {
      var d = o[c].start2 + l, f = this.diff_text1(o[c].diffs), h, p = -1;
      if (f.length > this.Match_MaxBits ? (h = this.match_main(
        s,
        f.substring(0, this.Match_MaxBits),
        d
      ), h != -1 && (p = this.match_main(
        s,
        f.substring(f.length - this.Match_MaxBits),
        d + f.length - this.Match_MaxBits
      ), (p == -1 || h >= p) && (h = -1))) : h = this.match_main(s, f, d), h == -1)
        u[c] = !1, l -= o[c].length2 - o[c].length1;
      else {
        u[c] = !0, l = h - d;
        var g;
        if (p == -1 ? g = s.substring(h, h + f.length) : g = s.substring(h, p + this.Match_MaxBits), f == g)
          s = s.substring(0, h) + this.diff_text2(o[c].diffs) + s.substring(h + f.length);
        else {
          var m = this.diff_main(f, g, !1);
          if (f.length > this.Match_MaxBits && this.diff_levenshtein(m) / f.length > this.Patch_DeleteThreshold)
            u[c] = !1;
          else {
            this.diff_cleanupSemanticLossless(m);
            for (var v = 0, b, x = 0; x < o[c].diffs.length; x++) {
              var w = o[c].diffs[x];
              w[0] !== i && (b = this.diff_xIndex(m, v)), w[0] === r ? s = s.substring(0, h + b) + w[1] + s.substring(h + b) : w[0] === n && (s = s.substring(0, h + b) + s.substring(h + this.diff_xIndex(
                m,
                v + w[1].length
              ))), w[0] !== n && (v += w[1].length);
            }
          }
        }
      }
    }
    return s = s.substring(a.length, s.length - a.length), [s, u];
  }, t.prototype.patch_addPadding = function(o) {
    for (var s = this.Patch_Margin, a = "", l = 1; l <= s; l++)
      a += String.fromCharCode(l);
    for (var l = 0; l < o.length; l++)
      o[l].start1 += s, o[l].start2 += s;
    var u = o[0], c = u.diffs;
    if (c.length == 0 || c[0][0] != i)
      c.unshift(new t.Diff(i, a)), u.start1 -= s, u.start2 -= s, u.length1 += s, u.length2 += s;
    else if (s > c[0][1].length) {
      var d = s - c[0][1].length;
      c[0][1] = a.substring(c[0][1].length) + c[0][1], u.start1 -= d, u.start2 -= d, u.length1 += d, u.length2 += d;
    }
    if (u = o[o.length - 1], c = u.diffs, c.length == 0 || c[c.length - 1][0] != i)
      c.push(new t.Diff(i, a)), u.length1 += s, u.length2 += s;
    else if (s > c[c.length - 1][1].length) {
      var d = s - c[c.length - 1][1].length;
      c[c.length - 1][1] += a.substring(0, d), u.length1 += d, u.length2 += d;
    }
    return a;
  }, t.prototype.patch_splitMax = function(o) {
    for (var s = this.Match_MaxBits, a = 0; a < o.length; a++)
      if (!(o[a].length1 <= s)) {
        var l = o[a];
        o.splice(a--, 1);
        for (var u = l.start1, c = l.start2, d = ""; l.diffs.length !== 0; ) {
          var f = new t.patch_obj(), h = !0;
          for (f.start1 = u - d.length, f.start2 = c - d.length, d !== "" && (f.length1 = f.length2 = d.length, f.diffs.push(new t.Diff(i, d))); l.diffs.length !== 0 && f.length1 < s - this.Patch_Margin; ) {
            var p = l.diffs[0][0], g = l.diffs[0][1];
            p === r ? (f.length2 += g.length, c += g.length, f.diffs.push(l.diffs.shift()), h = !1) : p === n && f.diffs.length == 1 && f.diffs[0][0] == i && g.length > 2 * s ? (f.length1 += g.length, u += g.length, h = !1, f.diffs.push(new t.Diff(p, g)), l.diffs.shift()) : (g = g.substring(
              0,
              s - f.length1 - this.Patch_Margin
            ), f.length1 += g.length, u += g.length, p === i ? (f.length2 += g.length, c += g.length) : h = !1, f.diffs.push(new t.Diff(p, g)), g == l.diffs[0][1] ? l.diffs.shift() : l.diffs[0][1] = l.diffs[0][1].substring(g.length));
          }
          d = this.diff_text2(f.diffs), d = d.substring(d.length - this.Patch_Margin);
          var m = this.diff_text1(l.diffs).substring(0, this.Patch_Margin);
          m !== "" && (f.length1 += m.length, f.length2 += m.length, f.diffs.length !== 0 && f.diffs[f.diffs.length - 1][0] === i ? f.diffs[f.diffs.length - 1][1] += m : f.diffs.push(new t.Diff(i, m))), h || o.splice(++a, 0, f);
        }
      }
  }, t.prototype.patch_toText = function(o) {
    for (var s = [], a = 0; a < o.length; a++)
      s[a] = o[a];
    return s.join("");
  }, t.prototype.patch_fromText = function(o) {
    var s = [];
    if (!o)
      return s;
    for (var a = o.split(`
`), l = 0, u = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/; l < a.length; ) {
      var c = a[l].match(u);
      if (!c)
        throw new Error("Invalid patch string: " + a[l]);
      var d = new t.patch_obj();
      for (s.push(d), d.start1 = parseInt(c[1], 10), c[2] === "" ? (d.start1--, d.length1 = 1) : c[2] == "0" ? d.length1 = 0 : (d.start1--, d.length1 = parseInt(c[2], 10)), d.start2 = parseInt(c[3], 10), c[4] === "" ? (d.start2--, d.length2 = 1) : c[4] == "0" ? d.length2 = 0 : (d.start2--, d.length2 = parseInt(c[4], 10)), l++; l < a.length; ) {
        var f = a[l].charAt(0);
        try {
          var h = decodeURI(a[l].substring(1));
        } catch {
          throw new Error("Illegal escape in patch_fromText: " + h);
        }
        if (f == "-")
          d.diffs.push(new t.Diff(n, h));
        else if (f == "+")
          d.diffs.push(new t.Diff(r, h));
        else if (f == " ")
          d.diffs.push(new t.Diff(i, h));
        else {
          if (f == "@")
            break;
          if (f !== "")
            throw new Error('Invalid patch mode "' + f + '" in: ' + h);
        }
        l++;
      }
    }
    return s;
  }, t.patch_obj = function() {
    this.diffs = [], this.start1 = null, this.start2 = null, this.length1 = 0, this.length2 = 0;
  }, t.patch_obj.prototype.toString = function() {
    var o, s;
    this.length1 === 0 ? o = this.start1 + ",0" : this.length1 == 1 ? o = this.start1 + 1 : o = this.start1 + 1 + "," + this.length1, this.length2 === 0 ? s = this.start2 + ",0" : this.length2 == 1 ? s = this.start2 + 1 : s = this.start2 + 1 + "," + this.length2;
    for (var a = ["@@ -" + o + " +" + s + ` @@
`], l, u = 0; u < this.diffs.length; u++) {
      switch (this.diffs[u][0]) {
        case r:
          l = "+";
          break;
        case n:
          l = "-";
          break;
        case i:
          l = " ";
          break;
      }
      a[u + 1] = l + encodeURI(this.diffs[u][1]) + `
`;
    }
    return a.join("").replace(/%20/g, " ");
  }, e.exports = t, e.exports.diff_match_patch = t, e.exports.DIFF_DELETE = n, e.exports.DIFF_INSERT = r, e.exports.DIFF_EQUAL = i;
})(rN);
var Gie = rN.exports, Kie = Bn && Bn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, i) {
      r.__proto__ = i;
    } || function(r, i) {
      for (var o in i)
        Object.prototype.hasOwnProperty.call(i, o) && (r[o] = i[o]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}();
Object.defineProperty(OC, "__esModule", { value: !0 });
var dn = $C, S2 = U, Xie = Em, Yie = Gie, qie = (
  /** @class */
  function(e) {
    Kie(t, e);
    function t(n) {
      var r = e.call(this, n) || this;
      return r.state = {
        value: r.props.value
      }, r.onChange = r.onChange.bind(r), r.diff = r.diff.bind(r), r;
    }
    return t.prototype.componentDidUpdate = function() {
      var n = this.props.value;
      n !== this.state.value && this.setState({ value: n });
    }, t.prototype.onChange = function(n) {
      this.setState({
        value: n
      }), this.props.onChange && this.props.onChange(n);
    }, t.prototype.diff = function() {
      var n = new Yie(), r = this.state.value[0], i = this.state.value[1];
      if (r.length === 0 && i.length === 0)
        return [];
      var o = n.diff_main(r, i);
      n.diff_cleanupSemantic(o);
      var s = this.generateDiffedLines(o), a = this.setCodeMarkers(s);
      return a;
    }, t.prototype.generateDiffedLines = function(n) {
      var r = {
        DIFF_EQUAL: 0,
        DIFF_DELETE: -1,
        DIFF_INSERT: 1
      }, i = {
        left: [],
        right: []
      }, o = {
        left: 1,
        right: 1
      };
      return n.forEach(function(s) {
        var a = s[0], l = s[1], u = l.split(`
`).length - 1;
        if (l.length !== 0) {
          var c = l[0], d = l[l.length - 1], f = 0;
          switch (a) {
            case r.DIFF_EQUAL:
              o.left += u, o.right += u;
              break;
            case r.DIFF_DELETE:
              c === `
` && (o.left++, u--), f = u, f === 0 && i.right.push({
                startLine: o.right,
                endLine: o.right
              }), d === `
` && (f -= 1), i.left.push({
                startLine: o.left,
                endLine: o.left + f
              }), o.left += u;
              break;
            case r.DIFF_INSERT:
              c === `
` && (o.right++, u--), f = u, f === 0 && i.left.push({
                startLine: o.left,
                endLine: o.left
              }), d === `
` && (f -= 1), i.right.push({
                startLine: o.right,
                endLine: o.right + f
              }), o.right += u;
              break;
            default:
              throw new Error("Diff type was not defined.");
          }
        }
      }), i;
    }, t.prototype.setCodeMarkers = function(n) {
      n === void 0 && (n = { left: [], right: [] });
      for (var r = [], i = {
        left: [],
        right: []
      }, o = 0; o < n.left.length; o++) {
        var s = {
          startRow: n.left[o].startLine - 1,
          endRow: n.left[o].endLine,
          type: "text",
          className: "codeMarker"
        };
        i.left.push(s);
      }
      for (var o = 0; o < n.right.length; o++) {
        var s = {
          startRow: n.right[o].startLine - 1,
          endRow: n.right[o].endLine,
          type: "text",
          className: "codeMarker"
        };
        i.right.push(s);
      }
      return r[0] = i.left, r[1] = i.right, r;
    }, t.prototype.render = function() {
      var n = this.diff();
      return S2.createElement(Xie.default, { name: this.props.name, className: this.props.className, focus: this.props.focus, orientation: this.props.orientation, splits: this.props.splits, mode: this.props.mode, theme: this.props.theme, height: this.props.height, width: this.props.width, fontSize: this.props.fontSize, showGutter: this.props.showGutter, onChange: this.onChange, onPaste: this.props.onPaste, onLoad: this.props.onLoad, onScroll: this.props.onScroll, minLines: this.props.minLines, maxLines: this.props.maxLines, readOnly: this.props.readOnly, highlightActiveLine: this.props.highlightActiveLine, showPrintMargin: this.props.showPrintMargin, tabSize: this.props.tabSize, cursorStart: this.props.cursorStart, editorProps: this.props.editorProps, style: this.props.style, scrollMargin: this.props.scrollMargin, setOptions: this.props.setOptions, wrapEnabled: this.props.wrapEnabled, enableBasicAutocompletion: this.props.enableBasicAutocompletion, enableLiveAutocompletion: this.props.enableLiveAutocompletion, value: this.state.value, markers: n });
    }, t.propTypes = {
      cursorStart: dn.number,
      editorProps: dn.object,
      enableBasicAutocompletion: dn.bool,
      enableLiveAutocompletion: dn.bool,
      focus: dn.bool,
      fontSize: dn.number,
      height: dn.string,
      highlightActiveLine: dn.bool,
      maxLines: dn.number,
      minLines: dn.number,
      mode: dn.string,
      name: dn.string,
      className: dn.string,
      onLoad: dn.func,
      onPaste: dn.func,
      onScroll: dn.func,
      onChange: dn.func,
      orientation: dn.string,
      readOnly: dn.bool,
      scrollMargin: dn.array,
      setOptions: dn.object,
      showGutter: dn.bool,
      showPrintMargin: dn.bool,
      splits: dn.number,
      style: dn.object,
      tabSize: dn.number,
      theme: dn.string,
      value: dn.array,
      width: dn.string,
      wrapEnabled: dn.bool
    }, t.defaultProps = {
      cursorStart: 1,
      editorProps: {},
      enableBasicAutocompletion: !1,
      enableLiveAutocompletion: !1,
      focus: !1,
      fontSize: 12,
      height: "500px",
      highlightActiveLine: !0,
      maxLines: null,
      minLines: null,
      mode: "",
      name: "ace-editor",
      onLoad: null,
      onScroll: null,
      onPaste: null,
      onChange: null,
      orientation: "beside",
      readOnly: !1,
      scrollMargin: [0, 0, 0, 0],
      setOptions: {},
      showGutter: !0,
      showPrintMargin: !0,
      splits: 2,
      style: {},
      tabSize: 4,
      theme: "github",
      value: ["", ""],
      width: "500px",
      wrapEnabled: !0
    }, t;
  }(S2.Component)
);
OC.default = qie;
Object.defineProperty(Wc, "__esModule", { value: !0 });
Wc.diff = Wc.split = void 0;
var Qie = xC, Zie = OC;
Wc.diff = Zie.default;
var Jie = Em;
Wc.split = Jie.default;
var x2 = Wc.default = Qie.default;
function di(e) {
  if (typeof e == "string" || typeof e == "number")
    return "" + e;
  let t = "";
  if (Array.isArray(e))
    for (let n = 0, r; n < e.length; n++)
      (r = di(e[n])) !== "" && (t += (t && " ") + r);
  else
    for (let n in e)
      e[n] && (t += (t && " ") + n);
  return t;
}
const { useDebugValue: eoe } = U, { useSyncExternalStoreWithSelector: toe } = xI, noe = (e) => e;
function iN(e, t = noe, n) {
  const r = toe(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return eoe(r), r;
}
const E2 = (e, t) => {
  const n = CI(e), r = (i, o = t) => iN(n, i, o);
  return Object.assign(r, n), r;
}, roe = (e, t) => e ? E2(e, t) : E2;
function Pr(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size)
      return !1;
    for (const [r, i] of e)
      if (!Object.is(i, t.get(r)))
        return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size)
      return !1;
    for (const r of e)
      if (!t.has(r))
        return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (const r of n)
    if (!Object.prototype.hasOwnProperty.call(t, r) || !Object.is(e[r], t[r]))
      return !1;
  return !0;
}
var ioe = { value: () => {
} };
function Am() {
  for (var e = 0, t = arguments.length, n = {}, r; e < t; ++e) {
    if (!(r = arguments[e] + "") || r in n || /[\s.]/.test(r))
      throw new Error("illegal type: " + r);
    n[r] = [];
  }
  return new vp(n);
}
function vp(e) {
  this._ = e;
}
function ooe(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var r = "", i = n.indexOf(".");
    if (i >= 0 && (r = n.slice(i + 1), n = n.slice(0, i)), n && !t.hasOwnProperty(n))
      throw new Error("unknown type: " + n);
    return { type: n, name: r };
  });
}
vp.prototype = Am.prototype = {
  constructor: vp,
  on: function(e, t) {
    var n = this._, r = ooe(e + "", n), i, o = -1, s = r.length;
    if (arguments.length < 2) {
      for (; ++o < s; )
        if ((i = (e = r[o]).type) && (i = soe(n[i], e.name)))
          return i;
      return;
    }
    if (t != null && typeof t != "function")
      throw new Error("invalid callback: " + t);
    for (; ++o < s; )
      if (i = (e = r[o]).type)
        n[i] = $2(n[i], e.name, t);
      else if (t == null)
        for (i in n)
          n[i] = $2(n[i], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t)
      e[n] = t[n].slice();
    return new vp(e);
  },
  call: function(e, t) {
    if ((i = arguments.length - 2) > 0)
      for (var n = new Array(i), r = 0, i, o; r < i; ++r)
        n[r] = arguments[r + 2];
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (o = this._[e], r = 0, i = o.length; r < i; ++r)
      o[r].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e))
      throw new Error("unknown type: " + e);
    for (var r = this._[e], i = 0, o = r.length; i < o; ++i)
      r[i].value.apply(t, n);
  }
};
function soe(e, t) {
  for (var n = 0, r = e.length, i; n < r; ++n)
    if ((i = e[n]).name === t)
      return i.value;
}
function $2(e, t, n) {
  for (var r = 0, i = e.length; r < i; ++r)
    if (e[r].name === t) {
      e[r] = ioe, e = e.slice(0, r).concat(e.slice(r + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Vy = "http://www.w3.org/1999/xhtml";
const O2 = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Vy,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Dm(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), O2.hasOwnProperty(t) ? { space: O2[t], local: e } : e;
}
function aoe(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Vy && t.documentElement.namespaceURI === Vy ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function loe(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function oN(e) {
  var t = Dm(e);
  return (t.local ? loe : aoe)(t);
}
function coe() {
}
function RC(e) {
  return e == null ? coe : function() {
    return this.querySelector(e);
  };
}
function uoe(e) {
  typeof e != "function" && (e = RC(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var o = t[i], s = o.length, a = r[i] = new Array(s), l, u, c = 0; c < s; ++c)
      (l = o[c]) && (u = e.call(l, l.__data__, c, o)) && ("__data__" in l && (u.__data__ = l.__data__), a[c] = u);
  return new ji(r, this._parents);
}
function doe(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function foe() {
  return [];
}
function sN(e) {
  return e == null ? foe : function() {
    return this.querySelectorAll(e);
  };
}
function hoe(e) {
  return function() {
    return doe(e.apply(this, arguments));
  };
}
function poe(e) {
  typeof e == "function" ? e = hoe(e) : e = sN(e);
  for (var t = this._groups, n = t.length, r = [], i = [], o = 0; o < n; ++o)
    for (var s = t[o], a = s.length, l, u = 0; u < a; ++u)
      (l = s[u]) && (r.push(e.call(l, l.__data__, u, s)), i.push(l));
  return new ji(r, i);
}
function aN(e) {
  return function() {
    return this.matches(e);
  };
}
function lN(e) {
  return function(t) {
    return t.matches(e);
  };
}
var goe = Array.prototype.find;
function moe(e) {
  return function() {
    return goe.call(this.children, e);
  };
}
function voe() {
  return this.firstElementChild;
}
function boe(e) {
  return this.select(e == null ? voe : moe(typeof e == "function" ? e : lN(e)));
}
var yoe = Array.prototype.filter;
function woe() {
  return Array.from(this.children);
}
function Coe(e) {
  return function() {
    return yoe.call(this.children, e);
  };
}
function Soe(e) {
  return this.selectAll(e == null ? woe : Coe(typeof e == "function" ? e : lN(e)));
}
function xoe(e) {
  typeof e != "function" && (e = aN(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var o = t[i], s = o.length, a = r[i] = [], l, u = 0; u < s; ++u)
      (l = o[u]) && e.call(l, l.__data__, u, o) && a.push(l);
  return new ji(r, this._parents);
}
function cN(e) {
  return new Array(e.length);
}
function Eoe() {
  return new ji(this._enter || this._groups.map(cN), this._parents);
}
function ug(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
ug.prototype = {
  constructor: ug,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function $oe(e) {
  return function() {
    return e;
  };
}
function Ooe(e, t, n, r, i, o) {
  for (var s = 0, a, l = t.length, u = o.length; s < u; ++s)
    (a = t[s]) ? (a.__data__ = o[s], r[s] = a) : n[s] = new ug(e, o[s]);
  for (; s < l; ++s)
    (a = t[s]) && (i[s] = a);
}
function Aoe(e, t, n, r, i, o, s) {
  var a, l, u = /* @__PURE__ */ new Map(), c = t.length, d = o.length, f = new Array(c), h;
  for (a = 0; a < c; ++a)
    (l = t[a]) && (f[a] = h = s.call(l, l.__data__, a, t) + "", u.has(h) ? i[a] = l : u.set(h, l));
  for (a = 0; a < d; ++a)
    h = s.call(e, o[a], a, o) + "", (l = u.get(h)) ? (r[a] = l, l.__data__ = o[a], u.delete(h)) : n[a] = new ug(e, o[a]);
  for (a = 0; a < c; ++a)
    (l = t[a]) && u.get(f[a]) === l && (i[a] = l);
}
function Doe(e) {
  return e.__data__;
}
function _oe(e, t) {
  if (!arguments.length)
    return Array.from(this, Doe);
  var n = t ? Aoe : Ooe, r = this._parents, i = this._groups;
  typeof e != "function" && (e = $oe(e));
  for (var o = i.length, s = new Array(o), a = new Array(o), l = new Array(o), u = 0; u < o; ++u) {
    var c = r[u], d = i[u], f = d.length, h = Toe(e.call(c, c && c.__data__, u, r)), p = h.length, g = a[u] = new Array(p), m = s[u] = new Array(p), v = l[u] = new Array(f);
    n(c, d, g, m, v, h, t);
    for (var b = 0, x = 0, w, C; b < p; ++b)
      if (w = g[b]) {
        for (b >= x && (x = b + 1); !(C = m[x]) && ++x < p; )
          ;
        w._next = C || null;
      }
  }
  return s = new ji(s, r), s._enter = a, s._exit = l, s;
}
function Toe(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function Roe() {
  return new ji(this._exit || this._groups.map(cN), this._parents);
}
function Moe(e, t, n) {
  var r = this.enter(), i = this, o = this.exit();
  return typeof e == "function" ? (r = e(r), r && (r = r.selection())) : r = r.append(e + ""), t != null && (i = t(i), i && (i = i.selection())), n == null ? o.remove() : n(o), r && i ? r.merge(i).order() : i;
}
function Ioe(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, r = t._groups, i = n.length, o = r.length, s = Math.min(i, o), a = new Array(i), l = 0; l < s; ++l)
    for (var u = n[l], c = r[l], d = u.length, f = a[l] = new Array(d), h, p = 0; p < d; ++p)
      (h = u[p] || c[p]) && (f[p] = h);
  for (; l < i; ++l)
    a[l] = n[l];
  return new ji(a, this._parents);
}
function koe() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var r = e[t], i = r.length - 1, o = r[i], s; --i >= 0; )
      (s = r[i]) && (o && s.compareDocumentPosition(o) ^ 4 && o.parentNode.insertBefore(s, o), o = s);
  return this;
}
function Poe(e) {
  e || (e = Noe);
  function t(d, f) {
    return d && f ? e(d.__data__, f.__data__) : !d - !f;
  }
  for (var n = this._groups, r = n.length, i = new Array(r), o = 0; o < r; ++o) {
    for (var s = n[o], a = s.length, l = i[o] = new Array(a), u, c = 0; c < a; ++c)
      (u = s[c]) && (l[c] = u);
    l.sort(t);
  }
  return new ji(i, this._parents).order();
}
function Noe(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function Loe() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function Foe() {
  return Array.from(this);
}
function Boe() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, o = r.length; i < o; ++i) {
      var s = r[i];
      if (s)
        return s;
    }
  return null;
}
function joe() {
  let e = 0;
  for (const t of this)
    ++e;
  return e;
}
function zoe() {
  return !this.node();
}
function Hoe(e) {
  for (var t = this._groups, n = 0, r = t.length; n < r; ++n)
    for (var i = t[n], o = 0, s = i.length, a; o < s; ++o)
      (a = i[o]) && e.call(a, a.__data__, o, i);
  return this;
}
function Voe(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function Woe(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function Uoe(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function Goe(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function Koe(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function Xoe(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function Yoe(e, t) {
  var n = Dm(e);
  if (arguments.length < 2) {
    var r = this.node();
    return n.local ? r.getAttributeNS(n.space, n.local) : r.getAttribute(n);
  }
  return this.each((t == null ? n.local ? Woe : Voe : typeof t == "function" ? n.local ? Xoe : Koe : n.local ? Goe : Uoe)(n, t));
}
function uN(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function qoe(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function Qoe(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function Zoe(e, t, n) {
  return function() {
    var r = t.apply(this, arguments);
    r == null ? this.style.removeProperty(e) : this.style.setProperty(e, r, n);
  };
}
function Joe(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? qoe : typeof t == "function" ? Zoe : Qoe)(e, t, n ?? "")) : Uc(this.node(), e);
}
function Uc(e, t) {
  return e.style.getPropertyValue(t) || uN(e).getComputedStyle(e, null).getPropertyValue(t);
}
function ese(e) {
  return function() {
    delete this[e];
  };
}
function tse(e, t) {
  return function() {
    this[e] = t;
  };
}
function nse(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function rse(e, t) {
  return arguments.length > 1 ? this.each((t == null ? ese : typeof t == "function" ? nse : tse)(e, t)) : this.node()[e];
}
function dN(e) {
  return e.trim().split(/^|\s+/);
}
function MC(e) {
  return e.classList || new fN(e);
}
function fN(e) {
  this._node = e, this._names = dN(e.getAttribute("class") || "");
}
fN.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function hN(e, t) {
  for (var n = MC(e), r = -1, i = t.length; ++r < i; )
    n.add(t[r]);
}
function pN(e, t) {
  for (var n = MC(e), r = -1, i = t.length; ++r < i; )
    n.remove(t[r]);
}
function ise(e) {
  return function() {
    hN(this, e);
  };
}
function ose(e) {
  return function() {
    pN(this, e);
  };
}
function sse(e, t) {
  return function() {
    (t.apply(this, arguments) ? hN : pN)(this, e);
  };
}
function ase(e, t) {
  var n = dN(e + "");
  if (arguments.length < 2) {
    for (var r = MC(this.node()), i = -1, o = n.length; ++i < o; )
      if (!r.contains(n[i]))
        return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? sse : t ? ise : ose)(n, t));
}
function lse() {
  this.textContent = "";
}
function cse(e) {
  return function() {
    this.textContent = e;
  };
}
function use(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function dse(e) {
  return arguments.length ? this.each(e == null ? lse : (typeof e == "function" ? use : cse)(e)) : this.node().textContent;
}
function fse() {
  this.innerHTML = "";
}
function hse(e) {
  return function() {
    this.innerHTML = e;
  };
}
function pse(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function gse(e) {
  return arguments.length ? this.each(e == null ? fse : (typeof e == "function" ? pse : hse)(e)) : this.node().innerHTML;
}
function mse() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function vse() {
  return this.each(mse);
}
function bse() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function yse() {
  return this.each(bse);
}
function wse(e) {
  var t = typeof e == "function" ? e : oN(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function Cse() {
  return null;
}
function Sse(e, t) {
  var n = typeof e == "function" ? e : oN(e), r = t == null ? Cse : typeof t == "function" ? t : RC(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), r.apply(this, arguments) || null);
  });
}
function xse() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function Ese() {
  return this.each(xse);
}
function $se() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function Ose() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function Ase(e) {
  return this.select(e ? Ose : $se);
}
function Dse(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function _se(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function Tse(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", r = t.indexOf(".");
    return r >= 0 && (n = t.slice(r + 1), t = t.slice(0, r)), { type: t, name: n };
  });
}
function Rse(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, r = -1, i = t.length, o; n < i; ++n)
        o = t[n], (!e.type || o.type === e.type) && o.name === e.name ? this.removeEventListener(o.type, o.listener, o.options) : t[++r] = o;
      ++r ? t.length = r : delete this.__on;
    }
  };
}
function Mse(e, t, n) {
  return function() {
    var r = this.__on, i, o = _se(t);
    if (r) {
      for (var s = 0, a = r.length; s < a; ++s)
        if ((i = r[s]).type === e.type && i.name === e.name) {
          this.removeEventListener(i.type, i.listener, i.options), this.addEventListener(i.type, i.listener = o, i.options = n), i.value = t;
          return;
        }
    }
    this.addEventListener(e.type, o, n), i = { type: e.type, name: e.name, value: t, listener: o, options: n }, r ? r.push(i) : this.__on = [i];
  };
}
function Ise(e, t, n) {
  var r = Tse(e + ""), i, o = r.length, s;
  if (arguments.length < 2) {
    var a = this.node().__on;
    if (a) {
      for (var l = 0, u = a.length, c; l < u; ++l)
        for (i = 0, c = a[l]; i < o; ++i)
          if ((s = r[i]).type === c.type && s.name === c.name)
            return c.value;
    }
    return;
  }
  for (a = t ? Mse : Rse, i = 0; i < o; ++i)
    this.each(a(r[i], t, n));
  return this;
}
function gN(e, t, n) {
  var r = uN(e), i = r.CustomEvent;
  typeof i == "function" ? i = new i(t, n) : (i = r.document.createEvent("Event"), n ? (i.initEvent(t, n.bubbles, n.cancelable), i.detail = n.detail) : i.initEvent(t, !1, !1)), e.dispatchEvent(i);
}
function kse(e, t) {
  return function() {
    return gN(this, e, t);
  };
}
function Pse(e, t) {
  return function() {
    return gN(this, e, t.apply(this, arguments));
  };
}
function Nse(e, t) {
  return this.each((typeof t == "function" ? Pse : kse)(e, t));
}
function* Lse() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var r = e[t], i = 0, o = r.length, s; i < o; ++i)
      (s = r[i]) && (yield s);
}
var mN = [null];
function ji(e, t) {
  this._groups = e, this._parents = t;
}
function Mf() {
  return new ji([[document.documentElement]], mN);
}
function Fse() {
  return this;
}
ji.prototype = Mf.prototype = {
  constructor: ji,
  select: uoe,
  selectAll: poe,
  selectChild: boe,
  selectChildren: Soe,
  filter: xoe,
  data: _oe,
  enter: Eoe,
  exit: Roe,
  join: Moe,
  merge: Ioe,
  selection: Fse,
  order: koe,
  sort: Poe,
  call: Loe,
  nodes: Foe,
  node: Boe,
  size: joe,
  empty: zoe,
  each: Hoe,
  attr: Yoe,
  style: Joe,
  property: rse,
  classed: ase,
  text: dse,
  html: gse,
  raise: vse,
  lower: yse,
  append: wse,
  insert: Sse,
  remove: Ese,
  clone: Ase,
  datum: Dse,
  on: Ise,
  dispatch: Nse,
  [Symbol.iterator]: Lse
};
function po(e) {
  return typeof e == "string" ? new ji([[document.querySelector(e)]], [document.documentElement]) : new ji([[e]], mN);
}
function Bse(e) {
  let t;
  for (; t = e.sourceEvent; )
    e = t;
  return e;
}
function jo(e, t) {
  if (e = Bse(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var r = n.createSVGPoint();
      return r.x = e.clientX, r.y = e.clientY, r = r.matrixTransform(t.getScreenCTM().inverse()), [r.x, r.y];
    }
    if (t.getBoundingClientRect) {
      var i = t.getBoundingClientRect();
      return [e.clientX - i.left - t.clientLeft, e.clientY - i.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const jse = { passive: !1 }, Xd = { capture: !0, passive: !1 };
function h0(e) {
  e.stopImmediatePropagation();
}
function Cc(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function vN(e) {
  var t = e.document.documentElement, n = po(e).on("dragstart.drag", Cc, Xd);
  "onselectstart" in t ? n.on("selectstart.drag", Cc, Xd) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function bN(e, t) {
  var n = e.document.documentElement, r = po(e).on("dragstart.drag", null);
  t && (r.on("click.drag", Cc, Xd), setTimeout(function() {
    r.on("click.drag", null);
  }, 0)), "onselectstart" in n ? r.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
const Mh = (e) => () => e;
function Wy(e, {
  sourceEvent: t,
  subject: n,
  target: r,
  identifier: i,
  active: o,
  x: s,
  y: a,
  dx: l,
  dy: u,
  dispatch: c
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: r, enumerable: !0, configurable: !0 },
    identifier: { value: i, enumerable: !0, configurable: !0 },
    active: { value: o, enumerable: !0, configurable: !0 },
    x: { value: s, enumerable: !0, configurable: !0 },
    y: { value: a, enumerable: !0, configurable: !0 },
    dx: { value: l, enumerable: !0, configurable: !0 },
    dy: { value: u, enumerable: !0, configurable: !0 },
    _: { value: c }
  });
}
Wy.prototype.on = function() {
  var e = this._.on.apply(this._, arguments);
  return e === this._ ? this : e;
};
function zse(e) {
  return !e.ctrlKey && !e.button;
}
function Hse() {
  return this.parentNode;
}
function Vse(e, t) {
  return t ?? { x: e.x, y: e.y };
}
function Wse() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Use() {
  var e = zse, t = Hse, n = Vse, r = Wse, i = {}, o = Am("start", "drag", "end"), s = 0, a, l, u, c, d = 0;
  function f(w) {
    w.on("mousedown.drag", h).filter(r).on("touchstart.drag", m).on("touchmove.drag", v, jse).on("touchend.drag touchcancel.drag", b).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function h(w, C) {
    if (!(c || !e.call(this, w, C))) {
      var y = x(this, t.call(this, w, C), w, C, "mouse");
      y && (po(w.view).on("mousemove.drag", p, Xd).on("mouseup.drag", g, Xd), vN(w.view), h0(w), u = !1, a = w.clientX, l = w.clientY, y("start", w));
    }
  }
  function p(w) {
    if (Cc(w), !u) {
      var C = w.clientX - a, y = w.clientY - l;
      u = C * C + y * y > d;
    }
    i.mouse("drag", w);
  }
  function g(w) {
    po(w.view).on("mousemove.drag mouseup.drag", null), bN(w.view, u), Cc(w), i.mouse("end", w);
  }
  function m(w, C) {
    if (e.call(this, w, C)) {
      var y = w.changedTouches, S = t.call(this, w, C), A = y.length, $, M;
      for ($ = 0; $ < A; ++$)
        (M = x(this, S, w, C, y[$].identifier, y[$])) && (h0(w), M("start", w, y[$]));
    }
  }
  function v(w) {
    var C = w.changedTouches, y = C.length, S, A;
    for (S = 0; S < y; ++S)
      (A = i[C[S].identifier]) && (Cc(w), A("drag", w, C[S]));
  }
  function b(w) {
    var C = w.changedTouches, y = C.length, S, A;
    for (c && clearTimeout(c), c = setTimeout(function() {
      c = null;
    }, 500), S = 0; S < y; ++S)
      (A = i[C[S].identifier]) && (h0(w), A("end", w, C[S]));
  }
  function x(w, C, y, S, A, $) {
    var M = o.copy(), _ = jo($ || y, C), T, D, E;
    if ((E = n.call(w, new Wy("beforestart", {
      sourceEvent: y,
      target: f,
      identifier: A,
      active: s,
      x: _[0],
      y: _[1],
      dx: 0,
      dy: 0,
      dispatch: M
    }), S)) != null)
      return T = E.x - _[0] || 0, D = E.y - _[1] || 0, function R(I, k, P) {
        var L = _, N;
        switch (I) {
          case "start":
            i[A] = R, N = s++;
            break;
          case "end":
            delete i[A], --s;
          case "drag":
            _ = jo(P || k, C), N = s;
            break;
        }
        M.call(
          I,
          w,
          new Wy(I, {
            sourceEvent: k,
            subject: E,
            target: f,
            identifier: A,
            active: N,
            x: _[0] + T,
            y: _[1] + D,
            dx: _[0] - L[0],
            dy: _[1] - L[1],
            dispatch: M
          }),
          S
        );
      };
  }
  return f.filter = function(w) {
    return arguments.length ? (e = typeof w == "function" ? w : Mh(!!w), f) : e;
  }, f.container = function(w) {
    return arguments.length ? (t = typeof w == "function" ? w : Mh(w), f) : t;
  }, f.subject = function(w) {
    return arguments.length ? (n = typeof w == "function" ? w : Mh(w), f) : n;
  }, f.touchable = function(w) {
    return arguments.length ? (r = typeof w == "function" ? w : Mh(!!w), f) : r;
  }, f.on = function() {
    var w = o.on.apply(o, arguments);
    return w === o ? f : w;
  }, f.clickDistance = function(w) {
    return arguments.length ? (d = (w = +w) * w, f) : Math.sqrt(d);
  }, f;
}
function IC(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function yN(e, t) {
  var n = Object.create(e.prototype);
  for (var r in t)
    n[r] = t[r];
  return n;
}
function If() {
}
var Yd = 0.7, dg = 1 / Yd, Sc = "\\s*([+-]?\\d+)\\s*", qd = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Go = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", Gse = /^#([0-9a-f]{3,8})$/, Kse = new RegExp(`^rgb\\(${Sc},${Sc},${Sc}\\)$`), Xse = new RegExp(`^rgb\\(${Go},${Go},${Go}\\)$`), Yse = new RegExp(`^rgba\\(${Sc},${Sc},${Sc},${qd}\\)$`), qse = new RegExp(`^rgba\\(${Go},${Go},${Go},${qd}\\)$`), Qse = new RegExp(`^hsl\\(${qd},${Go},${Go}\\)$`), Zse = new RegExp(`^hsla\\(${qd},${Go},${Go},${qd}\\)$`), A2 = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
IC(If, Qd, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: D2,
  // Deprecated! Use color.formatHex.
  formatHex: D2,
  formatHex8: Jse,
  formatHsl: eae,
  formatRgb: _2,
  toString: _2
});
function D2() {
  return this.rgb().formatHex();
}
function Jse() {
  return this.rgb().formatHex8();
}
function eae() {
  return wN(this).formatHsl();
}
function _2() {
  return this.rgb().formatRgb();
}
function Qd(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = Gse.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? T2(t) : n === 3 ? new yi(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? Ih(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? Ih(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = Kse.exec(e)) ? new yi(t[1], t[2], t[3], 1) : (t = Xse.exec(e)) ? new yi(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = Yse.exec(e)) ? Ih(t[1], t[2], t[3], t[4]) : (t = qse.exec(e)) ? Ih(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = Qse.exec(e)) ? I2(t[1], t[2] / 100, t[3] / 100, 1) : (t = Zse.exec(e)) ? I2(t[1], t[2] / 100, t[3] / 100, t[4]) : A2.hasOwnProperty(e) ? T2(A2[e]) : e === "transparent" ? new yi(NaN, NaN, NaN, 0) : null;
}
function T2(e) {
  return new yi(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function Ih(e, t, n, r) {
  return r <= 0 && (e = t = n = NaN), new yi(e, t, n, r);
}
function tae(e) {
  return e instanceof If || (e = Qd(e)), e ? (e = e.rgb(), new yi(e.r, e.g, e.b, e.opacity)) : new yi();
}
function Uy(e, t, n, r) {
  return arguments.length === 1 ? tae(e) : new yi(e, t, n, r ?? 1);
}
function yi(e, t, n, r) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +r;
}
IC(yi, Uy, yN(If, {
  brighter(e) {
    return e = e == null ? dg : Math.pow(dg, e), new yi(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Yd : Math.pow(Yd, e), new yi(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new yi(Xa(this.r), Xa(this.g), Xa(this.b), fg(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: R2,
  // Deprecated! Use color.formatHex.
  formatHex: R2,
  formatHex8: nae,
  formatRgb: M2,
  toString: M2
}));
function R2() {
  return `#${Ha(this.r)}${Ha(this.g)}${Ha(this.b)}`;
}
function nae() {
  return `#${Ha(this.r)}${Ha(this.g)}${Ha(this.b)}${Ha((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function M2() {
  const e = fg(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${Xa(this.r)}, ${Xa(this.g)}, ${Xa(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function fg(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function Xa(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Ha(e) {
  return e = Xa(e), (e < 16 ? "0" : "") + e.toString(16);
}
function I2(e, t, n, r) {
  return r <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new go(e, t, n, r);
}
function wN(e) {
  if (e instanceof go)
    return new go(e.h, e.s, e.l, e.opacity);
  if (e instanceof If || (e = Qd(e)), !e)
    return new go();
  if (e instanceof go)
    return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, r = e.b / 255, i = Math.min(t, n, r), o = Math.max(t, n, r), s = NaN, a = o - i, l = (o + i) / 2;
  return a ? (t === o ? s = (n - r) / a + (n < r) * 6 : n === o ? s = (r - t) / a + 2 : s = (t - n) / a + 4, a /= l < 0.5 ? o + i : 2 - o - i, s *= 60) : a = l > 0 && l < 1 ? 0 : s, new go(s, a, l, e.opacity);
}
function rae(e, t, n, r) {
  return arguments.length === 1 ? wN(e) : new go(e, t, n, r ?? 1);
}
function go(e, t, n, r) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +r;
}
IC(go, rae, yN(If, {
  brighter(e) {
    return e = e == null ? dg : Math.pow(dg, e), new go(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? Yd : Math.pow(Yd, e), new go(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, r = n + (n < 0.5 ? n : 1 - n) * t, i = 2 * n - r;
    return new yi(
      p0(e >= 240 ? e - 240 : e + 120, i, r),
      p0(e, i, r),
      p0(e < 120 ? e + 240 : e - 120, i, r),
      this.opacity
    );
  },
  clamp() {
    return new go(k2(this.h), kh(this.s), kh(this.l), fg(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = fg(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${k2(this.h)}, ${kh(this.s) * 100}%, ${kh(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function k2(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function kh(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function p0(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const CN = (e) => () => e;
function iae(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function oae(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(r) {
    return Math.pow(e + r * t, n);
  };
}
function sae(e) {
  return (e = +e) == 1 ? SN : function(t, n) {
    return n - t ? oae(t, n, e) : CN(isNaN(t) ? n : t);
  };
}
function SN(e, t) {
  var n = t - e;
  return n ? iae(e, n) : CN(isNaN(e) ? t : e);
}
const P2 = function e(t) {
  var n = sae(t);
  function r(i, o) {
    var s = n((i = Uy(i)).r, (o = Uy(o)).r), a = n(i.g, o.g), l = n(i.b, o.b), u = SN(i.opacity, o.opacity);
    return function(c) {
      return i.r = s(c), i.g = a(c), i.b = l(c), i.opacity = u(c), i + "";
    };
  }
  return r.gamma = e, r;
}(1);
function Vs(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
var Gy = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, g0 = new RegExp(Gy.source, "g");
function aae(e) {
  return function() {
    return e;
  };
}
function lae(e) {
  return function(t) {
    return e(t) + "";
  };
}
function cae(e, t) {
  var n = Gy.lastIndex = g0.lastIndex = 0, r, i, o, s = -1, a = [], l = [];
  for (e = e + "", t = t + ""; (r = Gy.exec(e)) && (i = g0.exec(t)); )
    (o = i.index) > n && (o = t.slice(n, o), a[s] ? a[s] += o : a[++s] = o), (r = r[0]) === (i = i[0]) ? a[s] ? a[s] += i : a[++s] = i : (a[++s] = null, l.push({ i: s, x: Vs(r, i) })), n = g0.lastIndex;
  return n < t.length && (o = t.slice(n), a[s] ? a[s] += o : a[++s] = o), a.length < 2 ? l[0] ? lae(l[0].x) : aae(t) : (t = l.length, function(u) {
    for (var c = 0, d; c < t; ++c)
      a[(d = l[c]).i] = d.x(u);
    return a.join("");
  });
}
var N2 = 180 / Math.PI, Ky = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function xN(e, t, n, r, i, o) {
  var s, a, l;
  return (s = Math.sqrt(e * e + t * t)) && (e /= s, t /= s), (l = e * n + t * r) && (n -= e * l, r -= t * l), (a = Math.sqrt(n * n + r * r)) && (n /= a, r /= a, l /= a), e * r < t * n && (e = -e, t = -t, l = -l, s = -s), {
    translateX: i,
    translateY: o,
    rotate: Math.atan2(t, e) * N2,
    skewX: Math.atan(l) * N2,
    scaleX: s,
    scaleY: a
  };
}
var Ph;
function uae(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? Ky : xN(t.a, t.b, t.c, t.d, t.e, t.f);
}
function dae(e) {
  return e == null || (Ph || (Ph = document.createElementNS("http://www.w3.org/2000/svg", "g")), Ph.setAttribute("transform", e), !(e = Ph.transform.baseVal.consolidate())) ? Ky : (e = e.matrix, xN(e.a, e.b, e.c, e.d, e.e, e.f));
}
function EN(e, t, n, r) {
  function i(u) {
    return u.length ? u.pop() + " " : "";
  }
  function o(u, c, d, f, h, p) {
    if (u !== d || c !== f) {
      var g = h.push("translate(", null, t, null, n);
      p.push({ i: g - 4, x: Vs(u, d) }, { i: g - 2, x: Vs(c, f) });
    } else
      (d || f) && h.push("translate(" + d + t + f + n);
  }
  function s(u, c, d, f) {
    u !== c ? (u - c > 180 ? c += 360 : c - u > 180 && (u += 360), f.push({ i: d.push(i(d) + "rotate(", null, r) - 2, x: Vs(u, c) })) : c && d.push(i(d) + "rotate(" + c + r);
  }
  function a(u, c, d, f) {
    u !== c ? f.push({ i: d.push(i(d) + "skewX(", null, r) - 2, x: Vs(u, c) }) : c && d.push(i(d) + "skewX(" + c + r);
  }
  function l(u, c, d, f, h, p) {
    if (u !== d || c !== f) {
      var g = h.push(i(h) + "scale(", null, ",", null, ")");
      p.push({ i: g - 4, x: Vs(u, d) }, { i: g - 2, x: Vs(c, f) });
    } else
      (d !== 1 || f !== 1) && h.push(i(h) + "scale(" + d + "," + f + ")");
  }
  return function(u, c) {
    var d = [], f = [];
    return u = e(u), c = e(c), o(u.translateX, u.translateY, c.translateX, c.translateY, d, f), s(u.rotate, c.rotate, d, f), a(u.skewX, c.skewX, d, f), l(u.scaleX, u.scaleY, c.scaleX, c.scaleY, d, f), u = c = null, function(h) {
      for (var p = -1, g = f.length, m; ++p < g; )
        d[(m = f[p]).i] = m.x(h);
      return d.join("");
    };
  };
}
var fae = EN(uae, "px, ", "px)", "deg)"), hae = EN(dae, ", ", ")", ")"), pae = 1e-12;
function L2(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function gae(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function mae(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const vae = function e(t, n, r) {
  function i(o, s) {
    var a = o[0], l = o[1], u = o[2], c = s[0], d = s[1], f = s[2], h = c - a, p = d - l, g = h * h + p * p, m, v;
    if (g < pae)
      v = Math.log(f / u) / t, m = function(S) {
        return [
          a + S * h,
          l + S * p,
          u * Math.exp(t * S * v)
        ];
      };
    else {
      var b = Math.sqrt(g), x = (f * f - u * u + r * g) / (2 * u * n * b), w = (f * f - u * u - r * g) / (2 * f * n * b), C = Math.log(Math.sqrt(x * x + 1) - x), y = Math.log(Math.sqrt(w * w + 1) - w);
      v = (y - C) / t, m = function(S) {
        var A = S * v, $ = L2(C), M = u / (n * b) * ($ * mae(t * A + C) - gae(C));
        return [
          a + M * h,
          l + M * p,
          u * $ / L2(t * A + C)
        ];
      };
    }
    return m.duration = v * 1e3 * t / Math.SQRT2, m;
  }
  return i.rho = function(o) {
    var s = Math.max(1e-3, +o), a = s * s, l = a * a;
    return e(s, a, l);
  }, i;
}(Math.SQRT2, 2, 4);
var Gc = 0, Hu = 0, Tu = 0, $N = 1e3, hg, Vu, pg = 0, ll = 0, _m = 0, Zd = typeof performance == "object" && performance.now ? performance : Date, ON = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function kC() {
  return ll || (ON(bae), ll = Zd.now() + _m);
}
function bae() {
  ll = 0;
}
function gg() {
  this._call = this._time = this._next = null;
}
gg.prototype = AN.prototype = {
  constructor: gg,
  restart: function(e, t, n) {
    if (typeof e != "function")
      throw new TypeError("callback is not a function");
    n = (n == null ? kC() : +n) + (t == null ? 0 : +t), !this._next && Vu !== this && (Vu ? Vu._next = this : hg = this, Vu = this), this._call = e, this._time = n, Xy();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Xy());
  }
};
function AN(e, t, n) {
  var r = new gg();
  return r.restart(e, t, n), r;
}
function yae() {
  kC(), ++Gc;
  for (var e = hg, t; e; )
    (t = ll - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --Gc;
}
function F2() {
  ll = (pg = Zd.now()) + _m, Gc = Hu = 0;
  try {
    yae();
  } finally {
    Gc = 0, Cae(), ll = 0;
  }
}
function wae() {
  var e = Zd.now(), t = e - pg;
  t > $N && (_m -= t, pg = e);
}
function Cae() {
  for (var e, t = hg, n, r = 1 / 0; t; )
    t._call ? (r > t._time && (r = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : hg = n);
  Vu = e, Xy(r);
}
function Xy(e) {
  if (!Gc) {
    Hu && (Hu = clearTimeout(Hu));
    var t = e - ll;
    t > 24 ? (e < 1 / 0 && (Hu = setTimeout(F2, e - Zd.now() - _m)), Tu && (Tu = clearInterval(Tu))) : (Tu || (pg = Zd.now(), Tu = setInterval(wae, $N)), Gc = 1, ON(F2));
  }
}
function B2(e, t, n) {
  var r = new gg();
  return t = t == null ? 0 : +t, r.restart((i) => {
    r.stop(), e(i + t);
  }, t, n), r;
}
var Sae = Am("start", "end", "cancel", "interrupt"), xae = [], DN = 0, j2 = 1, Yy = 2, bp = 3, z2 = 4, qy = 5, yp = 6;
function Tm(e, t, n, r, i, o) {
  var s = e.__transition;
  if (!s)
    e.__transition = {};
  else if (n in s)
    return;
  Eae(e, n, {
    name: t,
    index: r,
    // For context during callback.
    group: i,
    // For context during callback.
    on: Sae,
    tween: xae,
    time: o.time,
    delay: o.delay,
    duration: o.duration,
    ease: o.ease,
    timer: null,
    state: DN
  });
}
function PC(e, t) {
  var n = Ro(e, t);
  if (n.state > DN)
    throw new Error("too late; already scheduled");
  return n;
}
function Jo(e, t) {
  var n = Ro(e, t);
  if (n.state > bp)
    throw new Error("too late; already running");
  return n;
}
function Ro(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t]))
    throw new Error("transition not found");
  return n;
}
function Eae(e, t, n) {
  var r = e.__transition, i;
  r[t] = n, n.timer = AN(o, 0, n.time);
  function o(u) {
    n.state = j2, n.timer.restart(s, n.delay, n.time), n.delay <= u && s(u - n.delay);
  }
  function s(u) {
    var c, d, f, h;
    if (n.state !== j2)
      return l();
    for (c in r)
      if (h = r[c], h.name === n.name) {
        if (h.state === bp)
          return B2(s);
        h.state === z2 ? (h.state = yp, h.timer.stop(), h.on.call("interrupt", e, e.__data__, h.index, h.group), delete r[c]) : +c < t && (h.state = yp, h.timer.stop(), h.on.call("cancel", e, e.__data__, h.index, h.group), delete r[c]);
      }
    if (B2(function() {
      n.state === bp && (n.state = z2, n.timer.restart(a, n.delay, n.time), a(u));
    }), n.state = Yy, n.on.call("start", e, e.__data__, n.index, n.group), n.state === Yy) {
      for (n.state = bp, i = new Array(f = n.tween.length), c = 0, d = -1; c < f; ++c)
        (h = n.tween[c].value.call(e, e.__data__, n.index, n.group)) && (i[++d] = h);
      i.length = d + 1;
    }
  }
  function a(u) {
    for (var c = u < n.duration ? n.ease.call(null, u / n.duration) : (n.timer.restart(l), n.state = qy, 1), d = -1, f = i.length; ++d < f; )
      i[d].call(e, c);
    n.state === qy && (n.on.call("end", e, e.__data__, n.index, n.group), l());
  }
  function l() {
    n.state = yp, n.timer.stop(), delete r[t];
    for (var u in r)
      return;
    delete e.__transition;
  }
}
function wp(e, t) {
  var n = e.__transition, r, i, o = !0, s;
  if (n) {
    t = t == null ? null : t + "";
    for (s in n) {
      if ((r = n[s]).name !== t) {
        o = !1;
        continue;
      }
      i = r.state > Yy && r.state < qy, r.state = yp, r.timer.stop(), r.on.call(i ? "interrupt" : "cancel", e, e.__data__, r.index, r.group), delete n[s];
    }
    o && delete e.__transition;
  }
}
function $ae(e) {
  return this.each(function() {
    wp(this, e);
  });
}
function Oae(e, t) {
  var n, r;
  return function() {
    var i = Jo(this, e), o = i.tween;
    if (o !== n) {
      r = n = o;
      for (var s = 0, a = r.length; s < a; ++s)
        if (r[s].name === t) {
          r = r.slice(), r.splice(s, 1);
          break;
        }
    }
    i.tween = r;
  };
}
function Aae(e, t, n) {
  var r, i;
  if (typeof n != "function")
    throw new Error();
  return function() {
    var o = Jo(this, e), s = o.tween;
    if (s !== r) {
      i = (r = s).slice();
      for (var a = { name: t, value: n }, l = 0, u = i.length; l < u; ++l)
        if (i[l].name === t) {
          i[l] = a;
          break;
        }
      l === u && i.push(a);
    }
    o.tween = i;
  };
}
function Dae(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var r = Ro(this.node(), n).tween, i = 0, o = r.length, s; i < o; ++i)
      if ((s = r[i]).name === e)
        return s.value;
    return null;
  }
  return this.each((t == null ? Oae : Aae)(n, e, t));
}
function NC(e, t, n) {
  var r = e._id;
  return e.each(function() {
    var i = Jo(this, r);
    (i.value || (i.value = {}))[t] = n.apply(this, arguments);
  }), function(i) {
    return Ro(i, r).value[t];
  };
}
function _N(e, t) {
  var n;
  return (typeof t == "number" ? Vs : t instanceof Qd ? P2 : (n = Qd(t)) ? (t = n, P2) : cae)(e, t);
}
function _ae(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function Tae(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function Rae(e, t, n) {
  var r, i = n + "", o;
  return function() {
    var s = this.getAttribute(e);
    return s === i ? null : s === r ? o : o = t(r = s, n);
  };
}
function Mae(e, t, n) {
  var r, i = n + "", o;
  return function() {
    var s = this.getAttributeNS(e.space, e.local);
    return s === i ? null : s === r ? o : o = t(r = s, n);
  };
}
function Iae(e, t, n) {
  var r, i, o;
  return function() {
    var s, a = n(this), l;
    return a == null ? void this.removeAttribute(e) : (s = this.getAttribute(e), l = a + "", s === l ? null : s === r && l === i ? o : (i = l, o = t(r = s, a)));
  };
}
function kae(e, t, n) {
  var r, i, o;
  return function() {
    var s, a = n(this), l;
    return a == null ? void this.removeAttributeNS(e.space, e.local) : (s = this.getAttributeNS(e.space, e.local), l = a + "", s === l ? null : s === r && l === i ? o : (i = l, o = t(r = s, a)));
  };
}
function Pae(e, t) {
  var n = Dm(e), r = n === "transform" ? hae : _N;
  return this.attrTween(e, typeof t == "function" ? (n.local ? kae : Iae)(n, r, NC(this, "attr." + e, t)) : t == null ? (n.local ? Tae : _ae)(n) : (n.local ? Mae : Rae)(n, r, t));
}
function Nae(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function Lae(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function Fae(e, t) {
  var n, r;
  function i() {
    var o = t.apply(this, arguments);
    return o !== r && (n = (r = o) && Lae(e, o)), n;
  }
  return i._value = t, i;
}
function Bae(e, t) {
  var n, r;
  function i() {
    var o = t.apply(this, arguments);
    return o !== r && (n = (r = o) && Nae(e, o)), n;
  }
  return i._value = t, i;
}
function jae(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2)
    return (n = this.tween(n)) && n._value;
  if (t == null)
    return this.tween(n, null);
  if (typeof t != "function")
    throw new Error();
  var r = Dm(e);
  return this.tween(n, (r.local ? Fae : Bae)(r, t));
}
function zae(e, t) {
  return function() {
    PC(this, e).delay = +t.apply(this, arguments);
  };
}
function Hae(e, t) {
  return t = +t, function() {
    PC(this, e).delay = t;
  };
}
function Vae(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? zae : Hae)(t, e)) : Ro(this.node(), t).delay;
}
function Wae(e, t) {
  return function() {
    Jo(this, e).duration = +t.apply(this, arguments);
  };
}
function Uae(e, t) {
  return t = +t, function() {
    Jo(this, e).duration = t;
  };
}
function Gae(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? Wae : Uae)(t, e)) : Ro(this.node(), t).duration;
}
function Kae(e, t) {
  if (typeof t != "function")
    throw new Error();
  return function() {
    Jo(this, e).ease = t;
  };
}
function Xae(e) {
  var t = this._id;
  return arguments.length ? this.each(Kae(t, e)) : Ro(this.node(), t).ease;
}
function Yae(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function")
      throw new Error();
    Jo(this, e).ease = n;
  };
}
function qae(e) {
  if (typeof e != "function")
    throw new Error();
  return this.each(Yae(this._id, e));
}
function Qae(e) {
  typeof e != "function" && (e = aN(e));
  for (var t = this._groups, n = t.length, r = new Array(n), i = 0; i < n; ++i)
    for (var o = t[i], s = o.length, a = r[i] = [], l, u = 0; u < s; ++u)
      (l = o[u]) && e.call(l, l.__data__, u, o) && a.push(l);
  return new Rs(r, this._parents, this._name, this._id);
}
function Zae(e) {
  if (e._id !== this._id)
    throw new Error();
  for (var t = this._groups, n = e._groups, r = t.length, i = n.length, o = Math.min(r, i), s = new Array(r), a = 0; a < o; ++a)
    for (var l = t[a], u = n[a], c = l.length, d = s[a] = new Array(c), f, h = 0; h < c; ++h)
      (f = l[h] || u[h]) && (d[h] = f);
  for (; a < r; ++a)
    s[a] = t[a];
  return new Rs(s, this._parents, this._name, this._id);
}
function Jae(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function ele(e, t, n) {
  var r, i, o = Jae(t) ? PC : Jo;
  return function() {
    var s = o(this, e), a = s.on;
    a !== r && (i = (r = a).copy()).on(t, n), s.on = i;
  };
}
function tle(e, t) {
  var n = this._id;
  return arguments.length < 2 ? Ro(this.node(), n).on.on(e) : this.each(ele(n, e, t));
}
function nle(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition)
      if (+n !== e)
        return;
    t && t.removeChild(this);
  };
}
function rle() {
  return this.on("end.remove", nle(this._id));
}
function ile(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = RC(e));
  for (var r = this._groups, i = r.length, o = new Array(i), s = 0; s < i; ++s)
    for (var a = r[s], l = a.length, u = o[s] = new Array(l), c, d, f = 0; f < l; ++f)
      (c = a[f]) && (d = e.call(c, c.__data__, f, a)) && ("__data__" in c && (d.__data__ = c.__data__), u[f] = d, Tm(u[f], t, n, f, u, Ro(c, n)));
  return new Rs(o, this._parents, t, n);
}
function ole(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = sN(e));
  for (var r = this._groups, i = r.length, o = [], s = [], a = 0; a < i; ++a)
    for (var l = r[a], u = l.length, c, d = 0; d < u; ++d)
      if (c = l[d]) {
        for (var f = e.call(c, c.__data__, d, l), h, p = Ro(c, n), g = 0, m = f.length; g < m; ++g)
          (h = f[g]) && Tm(h, t, n, g, f, p);
        o.push(f), s.push(c);
      }
  return new Rs(o, s, t, n);
}
var sle = Mf.prototype.constructor;
function ale() {
  return new sle(this._groups, this._parents);
}
function lle(e, t) {
  var n, r, i;
  return function() {
    var o = Uc(this, e), s = (this.style.removeProperty(e), Uc(this, e));
    return o === s ? null : o === n && s === r ? i : i = t(n = o, r = s);
  };
}
function TN(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function cle(e, t, n) {
  var r, i = n + "", o;
  return function() {
    var s = Uc(this, e);
    return s === i ? null : s === r ? o : o = t(r = s, n);
  };
}
function ule(e, t, n) {
  var r, i, o;
  return function() {
    var s = Uc(this, e), a = n(this), l = a + "";
    return a == null && (l = a = (this.style.removeProperty(e), Uc(this, e))), s === l ? null : s === r && l === i ? o : (i = l, o = t(r = s, a));
  };
}
function dle(e, t) {
  var n, r, i, o = "style." + t, s = "end." + o, a;
  return function() {
    var l = Jo(this, e), u = l.on, c = l.value[o] == null ? a || (a = TN(t)) : void 0;
    (u !== n || i !== c) && (r = (n = u).copy()).on(s, i = c), l.on = r;
  };
}
function fle(e, t, n) {
  var r = (e += "") == "transform" ? fae : _N;
  return t == null ? this.styleTween(e, lle(e, r)).on("end.style." + e, TN(e)) : typeof t == "function" ? this.styleTween(e, ule(e, r, NC(this, "style." + e, t))).each(dle(this._id, e)) : this.styleTween(e, cle(e, r, t), n).on("end.style." + e, null);
}
function hle(e, t, n) {
  return function(r) {
    this.style.setProperty(e, t.call(this, r), n);
  };
}
function ple(e, t, n) {
  var r, i;
  function o() {
    var s = t.apply(this, arguments);
    return s !== i && (r = (i = s) && hle(e, s, n)), r;
  }
  return o._value = t, o;
}
function gle(e, t, n) {
  var r = "style." + (e += "");
  if (arguments.length < 2)
    return (r = this.tween(r)) && r._value;
  if (t == null)
    return this.tween(r, null);
  if (typeof t != "function")
    throw new Error();
  return this.tween(r, ple(e, t, n ?? ""));
}
function mle(e) {
  return function() {
    this.textContent = e;
  };
}
function vle(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function ble(e) {
  return this.tween("text", typeof e == "function" ? vle(NC(this, "text", e)) : mle(e == null ? "" : e + ""));
}
function yle(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function wle(e) {
  var t, n;
  function r() {
    var i = e.apply(this, arguments);
    return i !== n && (t = (n = i) && yle(i)), t;
  }
  return r._value = e, r;
}
function Cle(e) {
  var t = "text";
  if (arguments.length < 1)
    return (t = this.tween(t)) && t._value;
  if (e == null)
    return this.tween(t, null);
  if (typeof e != "function")
    throw new Error();
  return this.tween(t, wle(e));
}
function Sle() {
  for (var e = this._name, t = this._id, n = RN(), r = this._groups, i = r.length, o = 0; o < i; ++o)
    for (var s = r[o], a = s.length, l, u = 0; u < a; ++u)
      if (l = s[u]) {
        var c = Ro(l, t);
        Tm(l, e, n, u, s, {
          time: c.time + c.delay + c.duration,
          delay: 0,
          duration: c.duration,
          ease: c.ease
        });
      }
  return new Rs(r, this._parents, e, n);
}
function xle() {
  var e, t, n = this, r = n._id, i = n.size();
  return new Promise(function(o, s) {
    var a = { value: s }, l = { value: function() {
      --i === 0 && o();
    } };
    n.each(function() {
      var u = Jo(this, r), c = u.on;
      c !== e && (t = (e = c).copy(), t._.cancel.push(a), t._.interrupt.push(a), t._.end.push(l)), u.on = t;
    }), i === 0 && o();
  });
}
var Ele = 0;
function Rs(e, t, n, r) {
  this._groups = e, this._parents = t, this._name = n, this._id = r;
}
function RN() {
  return ++Ele;
}
var os = Mf.prototype;
Rs.prototype = {
  constructor: Rs,
  select: ile,
  selectAll: ole,
  selectChild: os.selectChild,
  selectChildren: os.selectChildren,
  filter: Qae,
  merge: Zae,
  selection: ale,
  transition: Sle,
  call: os.call,
  nodes: os.nodes,
  node: os.node,
  size: os.size,
  empty: os.empty,
  each: os.each,
  on: tle,
  attr: Pae,
  attrTween: jae,
  style: fle,
  styleTween: gle,
  text: ble,
  textTween: Cle,
  remove: rle,
  tween: Dae,
  delay: Vae,
  duration: Gae,
  ease: Xae,
  easeVarying: qae,
  end: xle,
  [Symbol.iterator]: os[Symbol.iterator]
};
function $le(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var Ole = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: $le
};
function Ale(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function Dle(e) {
  var t, n;
  e instanceof Rs ? (t = e._id, e = e._name) : (t = RN(), (n = Ole).time = kC(), e = e == null ? null : e + "");
  for (var r = this._groups, i = r.length, o = 0; o < i; ++o)
    for (var s = r[o], a = s.length, l, u = 0; u < a; ++u)
      (l = s[u]) && Tm(l, e, t, u, s, n || Ale(l, t));
  return new Rs(r, this._parents, e, t);
}
Mf.prototype.interrupt = $ae;
Mf.prototype.transition = Dle;
const Nh = (e) => () => e;
function _le(e, {
  sourceEvent: t,
  target: n,
  transform: r,
  dispatch: i
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: r, enumerable: !0, configurable: !0 },
    _: { value: i }
  });
}
function ms(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
ms.prototype = {
  constructor: ms,
  scale: function(e) {
    return e === 1 ? this : new ms(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new ms(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var ia = new ms(1, 0, 0);
ms.prototype;
function m0(e) {
  e.stopImmediatePropagation();
}
function Ru(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function Tle(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function Rle() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function H2() {
  return this.__zoom || ia;
}
function Mle(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function Ile() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function kle(e, t, n) {
  var r = e.invertX(t[0][0]) - n[0][0], i = e.invertX(t[1][0]) - n[1][0], o = e.invertY(t[0][1]) - n[0][1], s = e.invertY(t[1][1]) - n[1][1];
  return e.translate(
    i > r ? (r + i) / 2 : Math.min(0, r) || Math.max(0, i),
    s > o ? (o + s) / 2 : Math.min(0, o) || Math.max(0, s)
  );
}
function Ple() {
  var e = Tle, t = Rle, n = kle, r = Mle, i = Ile, o = [0, 1 / 0], s = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], a = 250, l = vae, u = Am("start", "zoom", "end"), c, d, f, h = 500, p = 150, g = 0, m = 10;
  function v(E) {
    E.property("__zoom", H2).on("wheel.zoom", A, { passive: !1 }).on("mousedown.zoom", $).on("dblclick.zoom", M).filter(i).on("touchstart.zoom", _).on("touchmove.zoom", T).on("touchend.zoom touchcancel.zoom", D).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  v.transform = function(E, R, I, k) {
    var P = E.selection ? E.selection() : E;
    P.property("__zoom", H2), E !== P ? C(E, R, I, k) : P.interrupt().each(function() {
      y(this, arguments).event(k).start().zoom(null, typeof R == "function" ? R.apply(this, arguments) : R).end();
    });
  }, v.scaleBy = function(E, R, I, k) {
    v.scaleTo(E, function() {
      var P = this.__zoom.k, L = typeof R == "function" ? R.apply(this, arguments) : R;
      return P * L;
    }, I, k);
  }, v.scaleTo = function(E, R, I, k) {
    v.transform(E, function() {
      var P = t.apply(this, arguments), L = this.__zoom, N = I == null ? w(P) : typeof I == "function" ? I.apply(this, arguments) : I, F = L.invert(N), B = typeof R == "function" ? R.apply(this, arguments) : R;
      return n(x(b(L, B), N, F), P, s);
    }, I, k);
  }, v.translateBy = function(E, R, I, k) {
    v.transform(E, function() {
      return n(this.__zoom.translate(
        typeof R == "function" ? R.apply(this, arguments) : R,
        typeof I == "function" ? I.apply(this, arguments) : I
      ), t.apply(this, arguments), s);
    }, null, k);
  }, v.translateTo = function(E, R, I, k, P) {
    v.transform(E, function() {
      var L = t.apply(this, arguments), N = this.__zoom, F = k == null ? w(L) : typeof k == "function" ? k.apply(this, arguments) : k;
      return n(ia.translate(F[0], F[1]).scale(N.k).translate(
        typeof R == "function" ? -R.apply(this, arguments) : -R,
        typeof I == "function" ? -I.apply(this, arguments) : -I
      ), L, s);
    }, k, P);
  };
  function b(E, R) {
    return R = Math.max(o[0], Math.min(o[1], R)), R === E.k ? E : new ms(R, E.x, E.y);
  }
  function x(E, R, I) {
    var k = R[0] - I[0] * E.k, P = R[1] - I[1] * E.k;
    return k === E.x && P === E.y ? E : new ms(E.k, k, P);
  }
  function w(E) {
    return [(+E[0][0] + +E[1][0]) / 2, (+E[0][1] + +E[1][1]) / 2];
  }
  function C(E, R, I, k) {
    E.on("start.zoom", function() {
      y(this, arguments).event(k).start();
    }).on("interrupt.zoom end.zoom", function() {
      y(this, arguments).event(k).end();
    }).tween("zoom", function() {
      var P = this, L = arguments, N = y(P, L).event(k), F = t.apply(P, L), B = I == null ? w(F) : typeof I == "function" ? I.apply(P, L) : I, j = Math.max(F[1][0] - F[0][0], F[1][1] - F[0][1]), z = P.__zoom, H = typeof R == "function" ? R.apply(P, L) : R, W = l(z.invert(B).concat(j / z.k), H.invert(B).concat(j / H.k));
      return function(G) {
        if (G === 1)
          G = H;
        else {
          var K = W(G), Y = j / K[2];
          G = new ms(Y, B[0] - K[0] * Y, B[1] - K[1] * Y);
        }
        N.zoom(null, G);
      };
    });
  }
  function y(E, R, I) {
    return !I && E.__zooming || new S(E, R);
  }
  function S(E, R) {
    this.that = E, this.args = R, this.active = 0, this.sourceEvent = null, this.extent = t.apply(E, R), this.taps = 0;
  }
  S.prototype = {
    event: function(E) {
      return E && (this.sourceEvent = E), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(E, R) {
      return this.mouse && E !== "mouse" && (this.mouse[1] = R.invert(this.mouse[0])), this.touch0 && E !== "touch" && (this.touch0[1] = R.invert(this.touch0[0])), this.touch1 && E !== "touch" && (this.touch1[1] = R.invert(this.touch1[0])), this.that.__zoom = R, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(E) {
      var R = po(this.that).datum();
      u.call(
        E,
        this.that,
        new _le(E, {
          sourceEvent: this.sourceEvent,
          target: v,
          type: E,
          transform: this.that.__zoom,
          dispatch: u
        }),
        R
      );
    }
  };
  function A(E, ...R) {
    if (!e.apply(this, arguments))
      return;
    var I = y(this, R).event(E), k = this.__zoom, P = Math.max(o[0], Math.min(o[1], k.k * Math.pow(2, r.apply(this, arguments)))), L = jo(E);
    if (I.wheel)
      (I.mouse[0][0] !== L[0] || I.mouse[0][1] !== L[1]) && (I.mouse[1] = k.invert(I.mouse[0] = L)), clearTimeout(I.wheel);
    else {
      if (k.k === P)
        return;
      I.mouse = [L, k.invert(L)], wp(this), I.start();
    }
    Ru(E), I.wheel = setTimeout(N, p), I.zoom("mouse", n(x(b(k, P), I.mouse[0], I.mouse[1]), I.extent, s));
    function N() {
      I.wheel = null, I.end();
    }
  }
  function $(E, ...R) {
    if (f || !e.apply(this, arguments))
      return;
    var I = E.currentTarget, k = y(this, R, !0).event(E), P = po(E.view).on("mousemove.zoom", B, !0).on("mouseup.zoom", j, !0), L = jo(E, I), N = E.clientX, F = E.clientY;
    vN(E.view), m0(E), k.mouse = [L, this.__zoom.invert(L)], wp(this), k.start();
    function B(z) {
      if (Ru(z), !k.moved) {
        var H = z.clientX - N, W = z.clientY - F;
        k.moved = H * H + W * W > g;
      }
      k.event(z).zoom("mouse", n(x(k.that.__zoom, k.mouse[0] = jo(z, I), k.mouse[1]), k.extent, s));
    }
    function j(z) {
      P.on("mousemove.zoom mouseup.zoom", null), bN(z.view, k.moved), Ru(z), k.event(z).end();
    }
  }
  function M(E, ...R) {
    if (e.apply(this, arguments)) {
      var I = this.__zoom, k = jo(E.changedTouches ? E.changedTouches[0] : E, this), P = I.invert(k), L = I.k * (E.shiftKey ? 0.5 : 2), N = n(x(b(I, L), k, P), t.apply(this, R), s);
      Ru(E), a > 0 ? po(this).transition().duration(a).call(C, N, k, E) : po(this).call(v.transform, N, k, E);
    }
  }
  function _(E, ...R) {
    if (e.apply(this, arguments)) {
      var I = E.touches, k = I.length, P = y(this, R, E.changedTouches.length === k).event(E), L, N, F, B;
      for (m0(E), N = 0; N < k; ++N)
        F = I[N], B = jo(F, this), B = [B, this.__zoom.invert(B), F.identifier], P.touch0 ? !P.touch1 && P.touch0[2] !== B[2] && (P.touch1 = B, P.taps = 0) : (P.touch0 = B, L = !0, P.taps = 1 + !!c);
      c && (c = clearTimeout(c)), L && (P.taps < 2 && (d = B[0], c = setTimeout(function() {
        c = null;
      }, h)), wp(this), P.start());
    }
  }
  function T(E, ...R) {
    if (this.__zooming) {
      var I = y(this, R).event(E), k = E.changedTouches, P = k.length, L, N, F, B;
      for (Ru(E), L = 0; L < P; ++L)
        N = k[L], F = jo(N, this), I.touch0 && I.touch0[2] === N.identifier ? I.touch0[0] = F : I.touch1 && I.touch1[2] === N.identifier && (I.touch1[0] = F);
      if (N = I.that.__zoom, I.touch1) {
        var j = I.touch0[0], z = I.touch0[1], H = I.touch1[0], W = I.touch1[1], G = (G = H[0] - j[0]) * G + (G = H[1] - j[1]) * G, K = (K = W[0] - z[0]) * K + (K = W[1] - z[1]) * K;
        N = b(N, Math.sqrt(G / K)), F = [(j[0] + H[0]) / 2, (j[1] + H[1]) / 2], B = [(z[0] + W[0]) / 2, (z[1] + W[1]) / 2];
      } else if (I.touch0)
        F = I.touch0[0], B = I.touch0[1];
      else
        return;
      I.zoom("touch", n(x(N, F, B), I.extent, s));
    }
  }
  function D(E, ...R) {
    if (this.__zooming) {
      var I = y(this, R).event(E), k = E.changedTouches, P = k.length, L, N;
      for (m0(E), f && clearTimeout(f), f = setTimeout(function() {
        f = null;
      }, h), L = 0; L < P; ++L)
        N = k[L], I.touch0 && I.touch0[2] === N.identifier ? delete I.touch0 : I.touch1 && I.touch1[2] === N.identifier && delete I.touch1;
      if (I.touch1 && !I.touch0 && (I.touch0 = I.touch1, delete I.touch1), I.touch0)
        I.touch0[1] = this.__zoom.invert(I.touch0[0]);
      else if (I.end(), I.taps === 2 && (N = jo(N, this), Math.hypot(d[0] - N[0], d[1] - N[1]) < m)) {
        var F = po(this).on("dblclick.zoom");
        F && F.apply(this, arguments);
      }
    }
  }
  return v.wheelDelta = function(E) {
    return arguments.length ? (r = typeof E == "function" ? E : Nh(+E), v) : r;
  }, v.filter = function(E) {
    return arguments.length ? (e = typeof E == "function" ? E : Nh(!!E), v) : e;
  }, v.touchable = function(E) {
    return arguments.length ? (i = typeof E == "function" ? E : Nh(!!E), v) : i;
  }, v.extent = function(E) {
    return arguments.length ? (t = typeof E == "function" ? E : Nh([[+E[0][0], +E[0][1]], [+E[1][0], +E[1][1]]]), v) : t;
  }, v.scaleExtent = function(E) {
    return arguments.length ? (o[0] = +E[0], o[1] = +E[1], v) : [o[0], o[1]];
  }, v.translateExtent = function(E) {
    return arguments.length ? (s[0][0] = +E[0][0], s[1][0] = +E[1][0], s[0][1] = +E[0][1], s[1][1] = +E[1][1], v) : [[s[0][0], s[0][1]], [s[1][0], s[1][1]]];
  }, v.constrain = function(E) {
    return arguments.length ? (n = E, v) : n;
  }, v.duration = function(E) {
    return arguments.length ? (a = +E, v) : a;
  }, v.interpolate = function(E) {
    return arguments.length ? (l = E, v) : l;
  }, v.on = function() {
    var E = u.on.apply(u, arguments);
    return E === u ? v : E;
  }, v.clickDistance = function(E) {
    return arguments.length ? (g = (E = +E) * E, v) : Math.sqrt(g);
  }, v.tapDistance = function(E) {
    return arguments.length ? (m = +E, v) : m;
  }, v;
}
const Rm = Yo(null), Nle = Rm.Provider, _o = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (e) => `Node type "${e}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (e) => `The old edge with id=${e} does not exist.`,
  error009: (e) => `Marker type "${e}" doesn't exist.`,
  error008: (e, t) => `Couldn't create edge for ${e ? "target" : "source"} handle id: "${e ? t.targetHandle : t.sourceHandle}", edge id: ${t.id}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (e) => `Edge type "${e}" not found. Using fallback type "default".`,
  error012: (e) => `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`
}, MN = _o.error001();
function jn(e, t) {
  const n = Yt(Rm);
  if (n === null)
    throw new Error(MN);
  return iN(n, e, t);
}
const xr = () => {
  const e = Yt(Rm);
  if (e === null)
    throw new Error(MN);
  return mt(() => ({
    getState: e.getState,
    setState: e.setState,
    subscribe: e.subscribe,
    destroy: e.destroy
  }), [e]);
}, Lle = (e) => e.userSelectionActive ? "none" : "all";
function IN({ position: e, children: t, className: n, style: r, ...i }) {
  const o = jn(Lle), s = `${e}`.split("-");
  return U.createElement("div", { className: di(["react-flow__panel", n, ...s]), style: { ...r, pointerEvents: o }, ...i }, t);
}
function Fle({ proOptions: e, position: t = "bottom-right" }) {
  return e != null && e.hideAttribution ? null : U.createElement(
    IN,
    { position: t, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://reactflow.dev/pro" },
    U.createElement("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution" }, "React Flow")
  );
}
const Ble = ({ x: e, y: t, label: n, labelStyle: r = {}, labelShowBg: i = !0, labelBgStyle: o = {}, labelBgPadding: s = [2, 4], labelBgBorderRadius: a = 2, children: l, className: u, ...c }) => {
  const d = he(null), [f, h] = ht({ x: 0, y: 0, width: 0, height: 0 }), p = di(["react-flow__edge-textwrapper", u]);
  return Pe(() => {
    if (d.current) {
      const g = d.current.getBBox();
      h({
        x: g.x,
        y: g.y,
        width: g.width,
        height: g.height
      });
    }
  }, [n]), typeof n > "u" || !n ? null : U.createElement(
    "g",
    { transform: `translate(${e - f.width / 2} ${t - f.height / 2})`, className: p, visibility: f.width ? "visible" : "hidden", ...c },
    i && U.createElement("rect", { width: f.width + 2 * s[0], x: -s[0], y: -s[1], height: f.height + 2 * s[1], className: "react-flow__edge-textbg", style: o, rx: a, ry: a }),
    U.createElement("text", { className: "react-flow__edge-text", y: f.height / 2, dy: "0.3em", ref: d, style: r }, n),
    l
  );
};
var jle = Sn(Ble);
const LC = (e) => ({
  width: e.offsetWidth,
  height: e.offsetHeight
}), Kc = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n), FC = (e = { x: 0, y: 0 }, t) => ({
  x: Kc(e.x, t[0][0], t[1][0]),
  y: Kc(e.y, t[0][1], t[1][1])
}), V2 = (e, t, n) => e < t ? Kc(Math.abs(e - t), 1, 50) / 50 : e > n ? -Kc(Math.abs(e - n), 1, 50) / 50 : 0, kN = (e, t) => {
  const n = V2(e.x, 35, t.width - 35) * 20, r = V2(e.y, 35, t.height - 35) * 20;
  return [n, r];
}, PN = (e) => {
  var t;
  return ((t = e.getRootNode) == null ? void 0 : t.call(e)) || (window == null ? void 0 : window.document);
}, zle = (e, t) => ({
  x: Math.min(e.x, t.x),
  y: Math.min(e.y, t.y),
  x2: Math.max(e.x2, t.x2),
  y2: Math.max(e.y2, t.y2)
}), BC = ({ x: e, y: t, width: n, height: r }) => ({
  x: e,
  y: t,
  x2: e + n,
  y2: t + r
}), Hle = ({ x: e, y: t, x2: n, y2: r }) => ({
  x: e,
  y: t,
  width: n - e,
  height: r - t
}), W2 = (e) => ({
  ...e.positionAbsolute || { x: 0, y: 0 },
  width: e.width || 0,
  height: e.height || 0
}), Qy = (e, t) => {
  const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), r = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y));
  return Math.ceil(n * r);
}, Vle = (e) => Ji(e.width) && Ji(e.height) && Ji(e.x) && Ji(e.y), Ji = (e) => !isNaN(e) && isFinite(e), fr = Symbol.for("internals"), NN = ["Enter", " ", "Escape"], LN = (e, t) => {
  process.env.NODE_ENV === "development" && console.warn(`[React Flow]: ${t} Help: https://reactflow.dev/error#${e}`);
}, Wle = (e) => "nativeEvent" in e;
function Zy(e) {
  var i, o;
  const t = Wle(e) ? e.nativeEvent : e, n = ((o = (i = t.composedPath) == null ? void 0 : i.call(t)) == null ? void 0 : o[0]) || e.target;
  return ["INPUT", "SELECT", "TEXTAREA"].includes(n == null ? void 0 : n.nodeName) || (n == null ? void 0 : n.hasAttribute("contenteditable")) || !!(n != null && n.closest(".nokey"));
}
const FN = (e) => "clientX" in e, oa = (e, t) => {
  var o, s;
  const n = FN(e), r = n ? e.clientX : (o = e.touches) == null ? void 0 : o[0].clientX, i = n ? e.clientY : (s = e.touches) == null ? void 0 : s[0].clientY;
  return {
    x: r - ((t == null ? void 0 : t.left) ?? 0),
    y: i - ((t == null ? void 0 : t.top) ?? 0)
  };
}, mg = () => {
  var e;
  return typeof navigator < "u" && ((e = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : e.indexOf("Mac")) >= 0;
}, fu = ({ id: e, path: t, labelX: n, labelY: r, label: i, labelStyle: o, labelShowBg: s, labelBgStyle: a, labelBgPadding: l, labelBgBorderRadius: u, style: c, markerEnd: d, markerStart: f, interactionWidth: h = 20 }) => U.createElement(
  U.Fragment,
  null,
  U.createElement("path", { id: e, style: c, d: t, fill: "none", className: "react-flow__edge-path", markerEnd: d, markerStart: f }),
  h && U.createElement("path", { d: t, fill: "none", strokeOpacity: 0, strokeWidth: h, className: "react-flow__edge-interaction" }),
  i && Ji(n) && Ji(r) ? U.createElement(jle, { x: n, y: r, label: i, labelStyle: o, labelShowBg: s, labelBgStyle: a, labelBgPadding: l, labelBgBorderRadius: u }) : null
);
fu.displayName = "BaseEdge";
function Mu(e, t, n) {
  return n === void 0 ? n : (r) => {
    const i = t().edges.find((o) => o.id === e);
    i && n(r, { ...i });
  };
}
function BN({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const i = Math.abs(n - e) / 2, o = n < e ? n + i : n - i, s = Math.abs(r - t) / 2, a = r < t ? r + s : r - s;
  return [o, a, i, s];
}
function jN({ sourceX: e, sourceY: t, targetX: n, targetY: r, sourceControlX: i, sourceControlY: o, targetControlX: s, targetControlY: a }) {
  const l = e * 0.125 + i * 0.375 + s * 0.375 + n * 0.125, u = t * 0.125 + o * 0.375 + a * 0.375 + r * 0.125, c = Math.abs(l - e), d = Math.abs(u - t);
  return [l, u, c, d];
}
var cl;
(function(e) {
  e.Strict = "strict", e.Loose = "loose";
})(cl || (cl = {}));
var Va;
(function(e) {
  e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal";
})(Va || (Va = {}));
var Jd;
(function(e) {
  e.Partial = "partial", e.Full = "full";
})(Jd || (Jd = {}));
var Ks;
(function(e) {
  e.Bezier = "default", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e.SimpleBezier = "simplebezier";
})(Ks || (Ks = {}));
var ef;
(function(e) {
  e.Arrow = "arrow", e.ArrowClosed = "arrowclosed";
})(ef || (ef = {}));
var bt;
(function(e) {
  e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom";
})(bt || (bt = {}));
function U2({ pos: e, x1: t, y1: n, x2: r, y2: i }) {
  return e === bt.Left || e === bt.Right ? [0.5 * (t + r), n] : [t, 0.5 * (n + i)];
}
function zN({ sourceX: e, sourceY: t, sourcePosition: n = bt.Bottom, targetX: r, targetY: i, targetPosition: o = bt.Top }) {
  const [s, a] = U2({
    pos: n,
    x1: e,
    y1: t,
    x2: r,
    y2: i
  }), [l, u] = U2({
    pos: o,
    x1: r,
    y1: i,
    x2: e,
    y2: t
  }), [c, d, f, h] = jN({
    sourceX: e,
    sourceY: t,
    targetX: r,
    targetY: i,
    sourceControlX: s,
    sourceControlY: a,
    targetControlX: l,
    targetControlY: u
  });
  return [
    `M${e},${t} C${s},${a} ${l},${u} ${r},${i}`,
    c,
    d,
    f,
    h
  ];
}
const jC = Sn(({ sourceX: e, sourceY: t, targetX: n, targetY: r, sourcePosition: i = bt.Bottom, targetPosition: o = bt.Top, label: s, labelStyle: a, labelShowBg: l, labelBgStyle: u, labelBgPadding: c, labelBgBorderRadius: d, style: f, markerEnd: h, markerStart: p, interactionWidth: g }) => {
  const [m, v, b] = zN({
    sourceX: e,
    sourceY: t,
    sourcePosition: i,
    targetX: n,
    targetY: r,
    targetPosition: o
  });
  return U.createElement(fu, { path: m, labelX: v, labelY: b, label: s, labelStyle: a, labelShowBg: l, labelBgStyle: u, labelBgPadding: c, labelBgBorderRadius: d, style: f, markerEnd: h, markerStart: p, interactionWidth: g });
});
jC.displayName = "SimpleBezierEdge";
const G2 = {
  [bt.Left]: { x: -1, y: 0 },
  [bt.Right]: { x: 1, y: 0 },
  [bt.Top]: { x: 0, y: -1 },
  [bt.Bottom]: { x: 0, y: 1 }
}, Ule = ({ source: e, sourcePosition: t = bt.Bottom, target: n }) => t === bt.Left || t === bt.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, K2 = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
function Gle({ source: e, sourcePosition: t = bt.Bottom, target: n, targetPosition: r = bt.Top, center: i, offset: o }) {
  const s = G2[t], a = G2[r], l = { x: e.x + s.x * o, y: e.y + s.y * o }, u = { x: n.x + a.x * o, y: n.y + a.y * o }, c = Ule({
    source: l,
    sourcePosition: t,
    target: u
  }), d = c.x !== 0 ? "x" : "y", f = c[d];
  let h = [], p, g;
  const m = { x: 0, y: 0 }, v = { x: 0, y: 0 }, [b, x, w, C] = BN({
    sourceX: e.x,
    sourceY: e.y,
    targetX: n.x,
    targetY: n.y
  });
  if (s[d] * a[d] === -1) {
    p = i.x || b, g = i.y || x;
    const S = [
      { x: p, y: l.y },
      { x: p, y: u.y }
    ], A = [
      { x: l.x, y: g },
      { x: u.x, y: g }
    ];
    s[d] === f ? h = d === "x" ? S : A : h = d === "x" ? A : S;
  } else {
    const S = [{ x: l.x, y: u.y }], A = [{ x: u.x, y: l.y }];
    if (d === "x" ? h = s.x === f ? A : S : h = s.y === f ? S : A, t === r) {
      const D = Math.abs(e[d] - n[d]);
      if (D <= o) {
        const E = Math.min(o - 1, o - D);
        s[d] === f ? m[d] = (l[d] > e[d] ? -1 : 1) * E : v[d] = (u[d] > n[d] ? -1 : 1) * E;
      }
    }
    if (t !== r) {
      const D = d === "x" ? "y" : "x", E = s[d] === a[D], R = l[D] > u[D], I = l[D] < u[D];
      (s[d] === 1 && (!E && R || E && I) || s[d] !== 1 && (!E && I || E && R)) && (h = d === "x" ? S : A);
    }
    const $ = { x: l.x + m.x, y: l.y + m.y }, M = { x: u.x + v.x, y: u.y + v.y }, _ = Math.max(Math.abs($.x - h[0].x), Math.abs(M.x - h[0].x)), T = Math.max(Math.abs($.y - h[0].y), Math.abs(M.y - h[0].y));
    _ >= T ? (p = ($.x + M.x) / 2, g = h[0].y) : (p = h[0].x, g = ($.y + M.y) / 2);
  }
  return [[
    e,
    { x: l.x + m.x, y: l.y + m.y },
    ...h,
    { x: u.x + v.x, y: u.y + v.y },
    n
  ], p, g, w, C];
}
function Kle(e, t, n, r) {
  const i = Math.min(K2(e, t) / 2, K2(t, n) / 2, r), { x: o, y: s } = t;
  if (e.x === o && o === n.x || e.y === s && s === n.y)
    return `L${o} ${s}`;
  if (e.y === s) {
    const u = e.x < n.x ? -1 : 1, c = e.y < n.y ? 1 : -1;
    return `L ${o + i * u},${s}Q ${o},${s} ${o},${s + i * c}`;
  }
  const a = e.x < n.x ? 1 : -1, l = e.y < n.y ? -1 : 1;
  return `L ${o},${s + i * l}Q ${o},${s} ${o + i * a},${s}`;
}
function Jy({ sourceX: e, sourceY: t, sourcePosition: n = bt.Bottom, targetX: r, targetY: i, targetPosition: o = bt.Top, borderRadius: s = 5, centerX: a, centerY: l, offset: u = 20 }) {
  const [c, d, f, h, p] = Gle({
    source: { x: e, y: t },
    sourcePosition: n,
    target: { x: r, y: i },
    targetPosition: o,
    center: { x: a, y: l },
    offset: u
  });
  return [c.reduce((m, v, b) => {
    let x = "";
    return b > 0 && b < c.length - 1 ? x = Kle(c[b - 1], v, c[b + 1], s) : x = `${b === 0 ? "M" : "L"}${v.x} ${v.y}`, m += x, m;
  }, ""), d, f, h, p];
}
const Mm = Sn(({ sourceX: e, sourceY: t, targetX: n, targetY: r, label: i, labelStyle: o, labelShowBg: s, labelBgStyle: a, labelBgPadding: l, labelBgBorderRadius: u, style: c, sourcePosition: d = bt.Bottom, targetPosition: f = bt.Top, markerEnd: h, markerStart: p, pathOptions: g, interactionWidth: m }) => {
  const [v, b, x] = Jy({
    sourceX: e,
    sourceY: t,
    sourcePosition: d,
    targetX: n,
    targetY: r,
    targetPosition: f,
    borderRadius: g == null ? void 0 : g.borderRadius,
    offset: g == null ? void 0 : g.offset
  });
  return U.createElement(fu, { path: v, labelX: b, labelY: x, label: i, labelStyle: o, labelShowBg: s, labelBgStyle: a, labelBgPadding: l, labelBgBorderRadius: u, style: c, markerEnd: h, markerStart: p, interactionWidth: m });
});
Mm.displayName = "SmoothStepEdge";
const zC = Sn((e) => {
  var t;
  return U.createElement(Mm, { ...e, pathOptions: mt(() => {
    var n;
    return { borderRadius: 0, offset: (n = e.pathOptions) == null ? void 0 : n.offset };
  }, [(t = e.pathOptions) == null ? void 0 : t.offset]) });
});
zC.displayName = "StepEdge";
function Xle({ sourceX: e, sourceY: t, targetX: n, targetY: r }) {
  const [i, o, s, a] = BN({
    sourceX: e,
    sourceY: t,
    targetX: n,
    targetY: r
  });
  return [`M ${e},${t}L ${n},${r}`, i, o, s, a];
}
const HC = Sn(({ sourceX: e, sourceY: t, targetX: n, targetY: r, label: i, labelStyle: o, labelShowBg: s, labelBgStyle: a, labelBgPadding: l, labelBgBorderRadius: u, style: c, markerEnd: d, markerStart: f, interactionWidth: h }) => {
  const [p, g, m] = Xle({ sourceX: e, sourceY: t, targetX: n, targetY: r });
  return U.createElement(fu, { path: p, labelX: g, labelY: m, label: i, labelStyle: o, labelShowBg: s, labelBgStyle: a, labelBgPadding: l, labelBgBorderRadius: u, style: c, markerEnd: d, markerStart: f, interactionWidth: h });
});
HC.displayName = "StraightEdge";
function Lh(e, t) {
  return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e);
}
function X2({ pos: e, x1: t, y1: n, x2: r, y2: i, c: o }) {
  switch (e) {
    case bt.Left:
      return [t - Lh(t - r, o), n];
    case bt.Right:
      return [t + Lh(r - t, o), n];
    case bt.Top:
      return [t, n - Lh(n - i, o)];
    case bt.Bottom:
      return [t, n + Lh(i - n, o)];
  }
}
function VC({ sourceX: e, sourceY: t, sourcePosition: n = bt.Bottom, targetX: r, targetY: i, targetPosition: o = bt.Top, curvature: s = 0.25 }) {
  const [a, l] = X2({
    pos: n,
    x1: e,
    y1: t,
    x2: r,
    y2: i,
    c: s
  }), [u, c] = X2({
    pos: o,
    x1: r,
    y1: i,
    x2: e,
    y2: t,
    c: s
  }), [d, f, h, p] = jN({
    sourceX: e,
    sourceY: t,
    targetX: r,
    targetY: i,
    sourceControlX: a,
    sourceControlY: l,
    targetControlX: u,
    targetControlY: c
  });
  return [
    `M${e},${t} C${a},${l} ${u},${c} ${r},${i}`,
    d,
    f,
    h,
    p
  ];
}
const vg = Sn(({ sourceX: e, sourceY: t, targetX: n, targetY: r, sourcePosition: i = bt.Bottom, targetPosition: o = bt.Top, label: s, labelStyle: a, labelShowBg: l, labelBgStyle: u, labelBgPadding: c, labelBgBorderRadius: d, style: f, markerEnd: h, markerStart: p, pathOptions: g, interactionWidth: m }) => {
  const [v, b, x] = VC({
    sourceX: e,
    sourceY: t,
    sourcePosition: i,
    targetX: n,
    targetY: r,
    targetPosition: o,
    curvature: g == null ? void 0 : g.curvature
  });
  return U.createElement(fu, { path: v, labelX: b, labelY: x, label: s, labelStyle: a, labelShowBg: l, labelBgStyle: u, labelBgPadding: c, labelBgBorderRadius: d, style: f, markerEnd: h, markerStart: p, interactionWidth: m });
});
vg.displayName = "BezierEdge";
const WC = Yo(null), Yle = WC.Provider;
WC.Consumer;
const qle = () => Yt(WC), Qle = (e) => "id" in e && "source" in e && "target" in e, Zle = ({ source: e, sourceHandle: t, target: n, targetHandle: r }) => `reactflow__edge-${e}${t || ""}-${n}${r || ""}`, ew = (e, t) => typeof e > "u" ? "" : typeof e == "string" ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map((r) => `${r}=${e[r]}`).join("&")}`, Jle = (e, t) => t.some((n) => n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || !n.sourceHandle && !e.sourceHandle) && (n.targetHandle === e.targetHandle || !n.targetHandle && !e.targetHandle)), ece = (e, t) => {
  if (!e.source || !e.target)
    return LN("006", _o.error006()), t;
  let n;
  return Qle(e) ? n = { ...e } : n = {
    ...e,
    id: Zle(e)
  }, Jle(n, t) ? t : t.concat(n);
}, tw = ({ x: e, y: t }, [n, r, i], o, [s, a]) => {
  const l = {
    x: (e - n) / i,
    y: (t - r) / i
  };
  return o ? {
    x: s * Math.round(l.x / s),
    y: a * Math.round(l.y / a)
  } : l;
}, HN = ({ x: e, y: t }, [n, r, i]) => ({
  x: e * i + n,
  y: t * i + r
}), xc = (e, t = [0, 0]) => {
  if (!e)
    return {
      x: 0,
      y: 0,
      positionAbsolute: {
        x: 0,
        y: 0
      }
    };
  const n = (e.width ?? 0) * t[0], r = (e.height ?? 0) * t[1], i = {
    x: e.position.x - n,
    y: e.position.y - r
  };
  return {
    ...i,
    positionAbsolute: e.positionAbsolute ? {
      x: e.positionAbsolute.x - n,
      y: e.positionAbsolute.y - r
    } : i
  };
}, UC = (e, t = [0, 0]) => {
  if (e.length === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  const n = e.reduce((r, i) => {
    const { x: o, y: s } = xc(i, t).positionAbsolute;
    return zle(r, BC({
      x: o,
      y: s,
      width: i.width || 0,
      height: i.height || 0
    }));
  }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
  return Hle(n);
}, VN = (e, t, [n, r, i] = [0, 0, 1], o = !1, s = !1, a = [0, 0]) => {
  const l = {
    x: (t.x - n) / i,
    y: (t.y - r) / i,
    width: t.width / i,
    height: t.height / i
  }, u = [];
  return e.forEach((c) => {
    const { width: d, height: f, selectable: h = !0, hidden: p = !1 } = c;
    if (s && !h || p)
      return !1;
    const { positionAbsolute: g } = xc(c, a), m = {
      x: g.x,
      y: g.y,
      width: d || 0,
      height: f || 0
    }, v = Qy(l, m), b = typeof d > "u" || typeof f > "u" || d === null || f === null, x = o && v > 0, w = (d || 0) * (f || 0);
    (b || x || v >= w || c.dragging) && u.push(c);
  }), u;
}, WN = (e, t) => {
  const n = e.map((r) => r.id);
  return t.filter((r) => n.includes(r.source) || n.includes(r.target));
}, UN = (e, t, n, r, i, o = 0.1) => {
  const s = t / (e.width * (1 + o)), a = n / (e.height * (1 + o)), l = Math.min(s, a), u = Kc(l, r, i), c = e.x + e.width / 2, d = e.y + e.height / 2, f = t / 2 - c * u, h = n / 2 - d * u;
  return { x: f, y: h, zoom: u };
}, Ma = (e, t = 0) => e.transition().duration(t);
function Y2(e, t, n, r) {
  return (t[n] || []).reduce((i, o) => {
    var s, a;
    return `${e.id}-${o.id}-${n}` !== r && i.push({
      id: o.id || null,
      type: n,
      nodeId: e.id,
      x: (((s = e.positionAbsolute) == null ? void 0 : s.x) ?? 0) + o.x + o.width / 2,
      y: (((a = e.positionAbsolute) == null ? void 0 : a.y) ?? 0) + o.y + o.height / 2
    }), i;
  }, []);
}
function tce(e, t, n, r, i, o) {
  const { x: s, y: a } = oa(e), u = t.elementsFromPoint(s, a).find((p) => p.classList.contains("react-flow__handle"));
  if (u) {
    const p = u.getAttribute("data-nodeid");
    if (p) {
      const g = GC(void 0, u), m = u.getAttribute("data-handleid"), v = o({ nodeId: p, id: m, type: g });
      if (v) {
        const b = i.find((x) => x.nodeId === p && x.type === g && x.id === m);
        return {
          handle: {
            id: m,
            type: g,
            nodeId: p,
            x: (b == null ? void 0 : b.x) || n.x,
            y: (b == null ? void 0 : b.y) || n.y
          },
          validHandleResult: v
        };
      }
    }
  }
  let c = [], d = 1 / 0;
  if (i.forEach((p) => {
    const g = Math.sqrt((p.x - n.x) ** 2 + (p.y - n.y) ** 2);
    if (g <= r) {
      const m = o(p);
      g <= d && (g < d ? c = [{ handle: p, validHandleResult: m }] : g === d && c.push({
        handle: p,
        validHandleResult: m
      }), d = g);
    }
  }), !c.length)
    return { handle: null, validHandleResult: GN() };
  if (c.length === 1)
    return c[0];
  const f = c.some(({ validHandleResult: p }) => p.isValid), h = c.some(({ handle: p }) => p.type === "target");
  return c.find(({ handle: p, validHandleResult: g }) => h ? p.type === "target" : f ? g.isValid : !0) || c[0];
}
const nce = { source: null, target: null, sourceHandle: null, targetHandle: null }, GN = () => ({
  handleDomNode: null,
  isValid: !1,
  connection: nce,
  endHandle: null
});
function KN(e, t, n, r, i, o, s) {
  const a = i === "target", l = s.querySelector(`.react-flow__handle[data-id="${e == null ? void 0 : e.nodeId}-${e == null ? void 0 : e.id}-${e == null ? void 0 : e.type}"]`), u = {
    ...GN(),
    handleDomNode: l
  };
  if (l) {
    const c = GC(void 0, l), d = l.getAttribute("data-nodeid"), f = l.getAttribute("data-handleid"), h = l.classList.contains("connectable"), p = l.classList.contains("connectableend"), g = {
      source: a ? d : n,
      sourceHandle: a ? f : r,
      target: a ? n : d,
      targetHandle: a ? r : f
    };
    u.connection = g, h && p && (t === cl.Strict ? a && c === "source" || !a && c === "target" : d !== n || f !== r) && (u.endHandle = {
      nodeId: d,
      handleId: f,
      type: c
    }, u.isValid = o(g));
  }
  return u;
}
function rce({ nodes: e, nodeId: t, handleId: n, handleType: r }) {
  return e.reduce((i, o) => {
    if (o[fr]) {
      const { handleBounds: s } = o[fr];
      let a = [], l = [];
      s && (a = Y2(o, s, "source", `${t}-${n}-${r}`), l = Y2(o, s, "target", `${t}-${n}-${r}`)), i.push(...a, ...l);
    }
    return i;
  }, []);
}
function GC(e, t) {
  return e || (t != null && t.classList.contains("target") ? "target" : t != null && t.classList.contains("source") ? "source" : null);
}
function v0(e) {
  e == null || e.classList.remove("valid", "connecting", "react-flow__handle-valid", "react-flow__handle-connecting");
}
function ice(e, t) {
  let n = null;
  return t ? n = "valid" : e && !t && (n = "invalid"), n;
}
function XN({ event: e, handleId: t, nodeId: n, onConnect: r, isTarget: i, getState: o, setState: s, isValidConnection: a, edgeUpdaterType: l, onEdgeUpdateEnd: u }) {
  const c = PN(e.target), { connectionMode: d, domNode: f, autoPanOnConnect: h, connectionRadius: p, onConnectStart: g, panBy: m, getNodes: v, cancelConnection: b } = o();
  let x = 0, w;
  const { x: C, y } = oa(e), S = c == null ? void 0 : c.elementFromPoint(C, y), A = GC(l, S), $ = f == null ? void 0 : f.getBoundingClientRect();
  if (!$ || !A)
    return;
  let M, _ = oa(e, $), T = !1, D = null, E = !1, R = null;
  const I = rce({
    nodes: v(),
    nodeId: n,
    handleId: t,
    handleType: A
  }), k = () => {
    if (!h)
      return;
    const [N, F] = kN(_, $);
    m({ x: N, y: F }), x = requestAnimationFrame(k);
  };
  s({
    connectionPosition: _,
    connectionStatus: null,
    // connectionNodeId etc will be removed in the next major in favor of connectionStartHandle
    connectionNodeId: n,
    connectionHandleId: t,
    connectionHandleType: A,
    connectionStartHandle: {
      nodeId: n,
      handleId: t,
      type: A
    },
    connectionEndHandle: null
  }), g == null || g(e, { nodeId: n, handleId: t, handleType: A });
  function P(N) {
    const { transform: F } = o();
    _ = oa(N, $);
    const { handle: B, validHandleResult: j } = tce(N, c, tw(_, F, !1, [1, 1]), p, I, (z) => KN(z, d, n, t, i ? "target" : "source", a, c));
    if (w = B, T || (k(), T = !0), R = j.handleDomNode, D = j.connection, E = j.isValid, s({
      connectionPosition: w && E ? HN({
        x: w.x,
        y: w.y
      }, F) : _,
      connectionStatus: ice(!!w, E),
      connectionEndHandle: j.endHandle
    }), !w && !E && !R)
      return v0(M);
    D.source !== D.target && R && (v0(M), M = R, R.classList.add("connecting", "react-flow__handle-connecting"), R.classList.toggle("valid", E), R.classList.toggle("react-flow__handle-valid", E));
  }
  function L(N) {
    var F, B;
    (w || R) && D && E && (r == null || r(D)), (B = (F = o()).onConnectEnd) == null || B.call(F, N), l && (u == null || u(N)), v0(M), b(), cancelAnimationFrame(x), T = !1, E = !1, D = null, R = null, c.removeEventListener("mousemove", P), c.removeEventListener("mouseup", L), c.removeEventListener("touchmove", P), c.removeEventListener("touchend", L);
  }
  c.addEventListener("mousemove", P), c.addEventListener("mouseup", L), c.addEventListener("touchmove", P), c.addEventListener("touchend", L);
}
const q2 = () => !0, oce = (e) => ({
  connectionStartHandle: e.connectionStartHandle,
  connectOnClick: e.connectOnClick,
  noPanClassName: e.noPanClassName
}), sce = (e, t, n) => (r) => {
  const { connectionStartHandle: i, connectionEndHandle: o, connectionClickStartHandle: s } = r;
  return {
    connecting: (i == null ? void 0 : i.nodeId) === e && (i == null ? void 0 : i.handleId) === t && (i == null ? void 0 : i.type) === n || (o == null ? void 0 : o.nodeId) === e && (o == null ? void 0 : o.handleId) === t && (o == null ? void 0 : o.type) === n,
    clickConnecting: (s == null ? void 0 : s.nodeId) === e && (s == null ? void 0 : s.handleId) === t && (s == null ? void 0 : s.type) === n
  };
}, YN = li(({ type: e = "source", position: t = bt.Top, isValidConnection: n, isConnectable: r = !0, isConnectableStart: i = !0, isConnectableEnd: o = !0, id: s, onConnect: a, children: l, className: u, onMouseDown: c, onTouchStart: d, ...f }, h) => {
  var $, M;
  const p = s || null, g = e === "target", m = xr(), v = qle(), { connectOnClick: b, noPanClassName: x } = jn(oce, Pr), { connecting: w, clickConnecting: C } = jn(sce(v, p, e), Pr);
  v || (M = ($ = m.getState()).onError) == null || M.call($, "010", _o.error010());
  const y = (_) => {
    const { defaultEdgeOptions: T, onConnect: D, hasDefaultEdges: E } = m.getState(), R = {
      ...T,
      ..._
    };
    if (E) {
      const { edges: I, setEdges: k } = m.getState();
      k(ece(R, I));
    }
    D == null || D(R), a == null || a(R);
  }, S = (_) => {
    if (!v)
      return;
    const T = FN(_);
    i && (T && _.button === 0 || !T) && XN({
      event: _,
      handleId: p,
      nodeId: v,
      onConnect: y,
      isTarget: g,
      getState: m.getState,
      setState: m.setState,
      isValidConnection: n || m.getState().isValidConnection || q2
    }), T ? c == null || c(_) : d == null || d(_);
  }, A = (_) => {
    const { onClickConnectStart: T, onClickConnectEnd: D, connectionClickStartHandle: E, connectionMode: R, isValidConnection: I } = m.getState();
    if (!v || !E && !i)
      return;
    if (!E) {
      T == null || T(_, { nodeId: v, handleId: p, handleType: e }), m.setState({ connectionClickStartHandle: { nodeId: v, type: e, handleId: p } });
      return;
    }
    const k = PN(_.target), P = n || I || q2, { connection: L, isValid: N } = KN({
      nodeId: v,
      id: p,
      type: e
    }, R, E.nodeId, E.handleId || null, E.type, P, k);
    N && y(L), D == null || D(_), m.setState({ connectionClickStartHandle: null });
  };
  return U.createElement("div", { "data-handleid": p, "data-nodeid": v, "data-handlepos": t, "data-id": `${v}-${p}-${e}`, className: di([
    "react-flow__handle",
    `react-flow__handle-${t}`,
    "nodrag",
    x,
    u,
    {
      source: !g,
      target: g,
      connectable: r,
      connectablestart: i,
      connectableend: o,
      connecting: C,
      // this class is used to style the handle when the user is connecting
      connectionindicator: r && (i && !w || o && w)
    }
  ]), onMouseDown: S, onTouchStart: S, onClick: b ? A : void 0, ref: h, ...f }, l);
});
YN.displayName = "Handle";
var ul = Sn(YN);
const qN = ({ data: e, isConnectable: t, targetPosition: n = bt.Top, sourcePosition: r = bt.Bottom }) => U.createElement(
  U.Fragment,
  null,
  U.createElement(ul, { type: "target", position: n, isConnectable: t }),
  e == null ? void 0 : e.label,
  U.createElement(ul, { type: "source", position: r, isConnectable: t })
);
qN.displayName = "DefaultNode";
var nw = Sn(qN);
const QN = ({ data: e, isConnectable: t, sourcePosition: n = bt.Bottom }) => U.createElement(
  U.Fragment,
  null,
  e == null ? void 0 : e.label,
  U.createElement(ul, { type: "source", position: n, isConnectable: t })
);
QN.displayName = "InputNode";
var ZN = Sn(QN);
const JN = ({ data: e, isConnectable: t, targetPosition: n = bt.Top }) => U.createElement(
  U.Fragment,
  null,
  U.createElement(ul, { type: "target", position: n, isConnectable: t }),
  e == null ? void 0 : e.label
);
JN.displayName = "OutputNode";
var eL = Sn(JN);
const KC = () => null;
KC.displayName = "GroupNode";
const lce = (e) => ({
  selectedNodes: e.getNodes().filter((t) => t.selected),
  selectedEdges: e.edges.filter((t) => t.selected)
}), Fh = (e) => e.id;
function cce(e, t) {
  return Pr(e.selectedNodes.map(Fh), t.selectedNodes.map(Fh)) && Pr(e.selectedEdges.map(Fh), t.selectedEdges.map(Fh));
}
const tL = Sn(({ onSelectionChange: e }) => {
  const t = xr(), { selectedNodes: n, selectedEdges: r } = jn(lce, cce);
  return Pe(() => {
    const i = { nodes: n, edges: r };
    e == null || e(i), t.getState().onSelectionChange.forEach((o) => o(i));
  }, [n, r, e]), null;
});
tL.displayName = "SelectionListener";
const uce = (e) => !!e.onSelectionChange;
function dce({ onSelectionChange: e }) {
  const t = jn(uce);
  return e || t ? U.createElement(tL, { onSelectionChange: e }) : null;
}
const fce = (e) => ({
  setNodes: e.setNodes,
  setEdges: e.setEdges,
  setDefaultNodesAndEdges: e.setDefaultNodesAndEdges,
  setMinZoom: e.setMinZoom,
  setMaxZoom: e.setMaxZoom,
  setTranslateExtent: e.setTranslateExtent,
  setNodeExtent: e.setNodeExtent,
  reset: e.reset
});
function Xl(e, t) {
  Pe(() => {
    typeof e < "u" && t(e);
  }, [e]);
}
function Xt(e, t, n) {
  Pe(() => {
    typeof t < "u" && n({ [e]: t });
  }, [t]);
}
const hce = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, onConnect: i, onConnectStart: o, onConnectEnd: s, onClickConnectStart: a, onClickConnectEnd: l, nodesDraggable: u, nodesConnectable: c, nodesFocusable: d, edgesFocusable: f, edgesUpdatable: h, elevateNodesOnSelect: p, minZoom: g, maxZoom: m, nodeExtent: v, onNodesChange: b, onEdgesChange: x, elementsSelectable: w, connectionMode: C, snapGrid: y, snapToGrid: S, translateExtent: A, connectOnClick: $, defaultEdgeOptions: M, fitView: _, fitViewOptions: T, onNodesDelete: D, onEdgesDelete: E, onNodeDrag: R, onNodeDragStart: I, onNodeDragStop: k, onSelectionDrag: P, onSelectionDragStart: L, onSelectionDragStop: N, noPanClassName: F, nodeOrigin: B, rfId: j, autoPanOnConnect: z, autoPanOnNodeDrag: H, onError: W, connectionRadius: G, isValidConnection: K, nodeDragThreshold: Y }) => {
  const { setNodes: X, setEdges: Z, setDefaultNodesAndEdges: Q, setMinZoom: ne, setMaxZoom: q, setTranslateExtent: te, setNodeExtent: fe, reset: Se } = jn(fce, Pr), de = xr();
  return Pe(() => {
    const ce = r == null ? void 0 : r.map((pe) => ({ ...pe, ...M }));
    return Q(n, ce), () => {
      Se();
    };
  }, []), Xt("defaultEdgeOptions", M, de.setState), Xt("connectionMode", C, de.setState), Xt("onConnect", i, de.setState), Xt("onConnectStart", o, de.setState), Xt("onConnectEnd", s, de.setState), Xt("onClickConnectStart", a, de.setState), Xt("onClickConnectEnd", l, de.setState), Xt("nodesDraggable", u, de.setState), Xt("nodesConnectable", c, de.setState), Xt("nodesFocusable", d, de.setState), Xt("edgesFocusable", f, de.setState), Xt("edgesUpdatable", h, de.setState), Xt("elementsSelectable", w, de.setState), Xt("elevateNodesOnSelect", p, de.setState), Xt("snapToGrid", S, de.setState), Xt("snapGrid", y, de.setState), Xt("onNodesChange", b, de.setState), Xt("onEdgesChange", x, de.setState), Xt("connectOnClick", $, de.setState), Xt("fitViewOnInit", _, de.setState), Xt("fitViewOnInitOptions", T, de.setState), Xt("onNodesDelete", D, de.setState), Xt("onEdgesDelete", E, de.setState), Xt("onNodeDrag", R, de.setState), Xt("onNodeDragStart", I, de.setState), Xt("onNodeDragStop", k, de.setState), Xt("onSelectionDrag", P, de.setState), Xt("onSelectionDragStart", L, de.setState), Xt("onSelectionDragStop", N, de.setState), Xt("noPanClassName", F, de.setState), Xt("nodeOrigin", B, de.setState), Xt("rfId", j, de.setState), Xt("autoPanOnConnect", z, de.setState), Xt("autoPanOnNodeDrag", H, de.setState), Xt("onError", W, de.setState), Xt("connectionRadius", G, de.setState), Xt("isValidConnection", K, de.setState), Xt("nodeDragThreshold", Y, de.setState), Xl(e, X), Xl(t, Z), Xl(g, ne), Xl(m, q), Xl(A, te), Xl(v, fe), null;
}, Q2 = { display: "none" }, pce = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
}, nL = "react-flow__node-desc", rL = "react-flow__edge-desc", gce = "react-flow__aria-live", mce = (e) => e.ariaLiveMessage;
function vce({ rfId: e }) {
  const t = jn(mce);
  return U.createElement("div", { id: `${gce}-${e}`, "aria-live": "assertive", "aria-atomic": "true", style: pce }, t);
}
function bce({ rfId: e, disableKeyboardA11y: t }) {
  return U.createElement(
    U.Fragment,
    null,
    U.createElement(
      "div",
      { id: `${nL}-${e}`, style: Q2 },
      "Press enter or space to select a node.",
      !t && "You can then use the arrow keys to move the node around.",
      " Press delete to remove it and escape to cancel.",
      " "
    ),
    U.createElement("div", { id: `${rL}-${e}`, style: Q2 }, "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel."),
    !t && U.createElement(vce, { rfId: e })
  );
}
var tf = (e = null, t = { actInsideInputWithModifier: !0 }) => {
  const [n, r] = ht(!1), i = he(!1), o = he(/* @__PURE__ */ new Set([])), [s, a] = mt(() => {
    if (e !== null) {
      const u = (Array.isArray(e) ? e : [e]).filter((d) => typeof d == "string").map((d) => d.split("+")), c = u.reduce((d, f) => d.concat(...f), []);
      return [u, c];
    }
    return [[], []];
  }, [e]);
  return Pe(() => {
    const l = typeof document < "u" ? document : null, u = (t == null ? void 0 : t.target) || l;
    if (e !== null) {
      const c = (h) => {
        if (i.current = h.ctrlKey || h.metaKey || h.shiftKey, (!i.current || i.current && !t.actInsideInputWithModifier) && Zy(h))
          return !1;
        const g = J2(h.code, a);
        o.current.add(h[g]), Z2(s, o.current, !1) && (h.preventDefault(), r(!0));
      }, d = (h) => {
        if ((!i.current || i.current && !t.actInsideInputWithModifier) && Zy(h))
          return !1;
        const g = J2(h.code, a);
        Z2(s, o.current, !0) ? (r(!1), o.current.clear()) : o.current.delete(h[g]), h.key === "Meta" && o.current.clear(), i.current = !1;
      }, f = () => {
        o.current.clear(), r(!1);
      };
      return u == null || u.addEventListener("keydown", c), u == null || u.addEventListener("keyup", d), window.addEventListener("blur", f), () => {
        u == null || u.removeEventListener("keydown", c), u == null || u.removeEventListener("keyup", d), window.removeEventListener("blur", f);
      };
    }
  }, [e, r]), n;
};
function Z2(e, t, n) {
  return e.filter((r) => n || r.length === t.size).some((r) => r.every((i) => t.has(i)));
}
function J2(e, t) {
  return t.includes(e) ? "code" : "key";
}
function iL(e, t, n, r) {
  var s, a;
  if (!e.parentNode)
    return n;
  const i = t.get(e.parentNode), o = xc(i, r);
  return iL(i, t, {
    x: (n.x ?? 0) + o.x,
    y: (n.y ?? 0) + o.y,
    z: (((s = i[fr]) == null ? void 0 : s.z) ?? 0) > (n.z ?? 0) ? ((a = i[fr]) == null ? void 0 : a.z) ?? 0 : n.z ?? 0
  }, r);
}
function oL(e, t, n) {
  e.forEach((r) => {
    var i;
    if (r.parentNode && !e.has(r.parentNode))
      throw new Error(`Parent node ${r.parentNode} not found`);
    if (r.parentNode || n != null && n[r.id]) {
      const { x: o, y: s, z: a } = iL(r, e, {
        ...r.position,
        z: ((i = r[fr]) == null ? void 0 : i.z) ?? 0
      }, t);
      r.positionAbsolute = {
        x: o,
        y: s
      }, r[fr].z = a, n != null && n[r.id] && (r[fr].isParent = !0);
    }
  });
}
function b0(e, t, n, r) {
  const i = /* @__PURE__ */ new Map(), o = {}, s = r ? 1e3 : 0;
  return e.forEach((a) => {
    var d;
    const l = (Ji(a.zIndex) ? a.zIndex : 0) + (a.selected ? s : 0), u = t.get(a.id), c = {
      width: u == null ? void 0 : u.width,
      height: u == null ? void 0 : u.height,
      ...a,
      positionAbsolute: {
        x: a.position.x,
        y: a.position.y
      }
    };
    a.parentNode && (c.parentNode = a.parentNode, o[a.parentNode] = !0), Object.defineProperty(c, fr, {
      enumerable: !1,
      value: {
        handleBounds: (d = u == null ? void 0 : u[fr]) == null ? void 0 : d.handleBounds,
        z: l
      }
    }), i.set(a.id, c);
  }), oL(i, n, o), i;
}
function sL(e, t = {}) {
  const { getNodes: n, width: r, height: i, minZoom: o, maxZoom: s, d3Zoom: a, d3Selection: l, fitViewOnInitDone: u, fitViewOnInit: c, nodeOrigin: d } = e(), f = t.initial && !u && c;
  if (a && l && (f || !t.initial)) {
    const p = n().filter((m) => {
      var b;
      const v = t.includeHiddenNodes ? m.width && m.height : !m.hidden;
      return (b = t.nodes) != null && b.length ? v && t.nodes.some((x) => x.id === m.id) : v;
    }), g = p.every((m) => m.width && m.height);
    if (p.length > 0 && g) {
      const m = UC(p, d), { x: v, y: b, zoom: x } = UN(m, r, i, t.minZoom ?? o, t.maxZoom ?? s, t.padding ?? 0.1), w = ia.translate(v, b).scale(x);
      return typeof t.duration == "number" && t.duration > 0 ? a.transform(Ma(l, t.duration), w) : a.transform(l, w), !0;
    }
  }
  return !1;
}
function yce(e, t) {
  return e.forEach((n) => {
    const r = t.get(n.id);
    r && t.set(r.id, {
      ...r,
      [fr]: r[fr],
      selected: n.selected
    });
  }), new Map(t);
}
function wce(e, t) {
  return t.map((n) => {
    const r = e.find((i) => i.id === n.id);
    return r && (n.selected = r.selected), n;
  });
}
function Bh({ changedNodes: e, changedEdges: t, get: n, set: r }) {
  const { nodeInternals: i, edges: o, onNodesChange: s, onEdgesChange: a, hasDefaultNodes: l, hasDefaultEdges: u } = n();
  e != null && e.length && (l && r({ nodeInternals: yce(e, i) }), s == null || s(e)), t != null && t.length && (u && r({ edges: wce(t, o) }), a == null || a(t));
}
const Yl = () => {
}, Cce = {
  zoomIn: Yl,
  zoomOut: Yl,
  zoomTo: Yl,
  getZoom: () => 1,
  setViewport: Yl,
  getViewport: () => ({ x: 0, y: 0, zoom: 1 }),
  fitView: () => !1,
  setCenter: Yl,
  fitBounds: Yl,
  project: (e) => e,
  screenToFlowPosition: (e) => e,
  flowToScreenPosition: (e) => e,
  viewportInitialized: !1
}, Sce = (e) => ({
  d3Zoom: e.d3Zoom,
  d3Selection: e.d3Selection
}), xce = () => {
  const e = xr(), { d3Zoom: t, d3Selection: n } = jn(Sce, Pr);
  return mt(() => n && t ? {
    zoomIn: (i) => t.scaleBy(Ma(n, i == null ? void 0 : i.duration), 1.2),
    zoomOut: (i) => t.scaleBy(Ma(n, i == null ? void 0 : i.duration), 1 / 1.2),
    zoomTo: (i, o) => t.scaleTo(Ma(n, o == null ? void 0 : o.duration), i),
    getZoom: () => e.getState().transform[2],
    setViewport: (i, o) => {
      const [s, a, l] = e.getState().transform, u = ia.translate(i.x ?? s, i.y ?? a).scale(i.zoom ?? l);
      t.transform(Ma(n, o == null ? void 0 : o.duration), u);
    },
    getViewport: () => {
      const [i, o, s] = e.getState().transform;
      return { x: i, y: o, zoom: s };
    },
    fitView: (i) => sL(e.getState, i),
    setCenter: (i, o, s) => {
      const { width: a, height: l, maxZoom: u } = e.getState(), c = typeof (s == null ? void 0 : s.zoom) < "u" ? s.zoom : u, d = a / 2 - i * c, f = l / 2 - o * c, h = ia.translate(d, f).scale(c);
      t.transform(Ma(n, s == null ? void 0 : s.duration), h);
    },
    fitBounds: (i, o) => {
      const { width: s, height: a, minZoom: l, maxZoom: u } = e.getState(), { x: c, y: d, zoom: f } = UN(i, s, a, l, u, (o == null ? void 0 : o.padding) ?? 0.1), h = ia.translate(c, d).scale(f);
      t.transform(Ma(n, o == null ? void 0 : o.duration), h);
    },
    // @deprecated Use `screenToFlowPosition`.
    project: (i) => {
      const { transform: o, snapToGrid: s, snapGrid: a } = e.getState();
      return console.warn("[DEPRECATED] `project` is deprecated. Instead use `screenToFlowPosition`. There is no need to subtract the react flow bounds anymore! https://reactflow.dev/api-reference/types/react-flow-instance#screen-to-flow-position"), tw(i, o, s, a);
    },
    screenToFlowPosition: (i) => {
      const { transform: o, snapToGrid: s, snapGrid: a, domNode: l } = e.getState();
      if (!l)
        return i;
      const { x: u, y: c } = l.getBoundingClientRect(), d = {
        x: i.x - u,
        y: i.y - c
      };
      return tw(d, o, s, a);
    },
    flowToScreenPosition: (i) => {
      const { transform: o, domNode: s } = e.getState();
      if (!s)
        return i;
      const { x: a, y: l } = s.getBoundingClientRect(), u = HN(i, o);
      return {
        x: u.x + a,
        y: u.y + l
      };
    },
    viewportInitialized: !0
  } : Cce, [t, n]);
};
function XC() {
  const e = xce(), t = xr(), n = Kt(() => t.getState().getNodes().map((g) => ({ ...g })), []), r = Kt((g) => t.getState().nodeInternals.get(g), []), i = Kt(() => {
    const { edges: g = [] } = t.getState();
    return g.map((m) => ({ ...m }));
  }, []), o = Kt((g) => {
    const { edges: m = [] } = t.getState();
    return m.find((v) => v.id === g);
  }, []), s = Kt((g) => {
    const { getNodes: m, setNodes: v, hasDefaultNodes: b, onNodesChange: x } = t.getState(), w = m(), C = typeof g == "function" ? g(w) : g;
    if (b)
      v(C);
    else if (x) {
      const y = C.length === 0 ? w.map((S) => ({ type: "remove", id: S.id })) : C.map((S) => ({ item: S, type: "reset" }));
      x(y);
    }
  }, []), a = Kt((g) => {
    const { edges: m = [], setEdges: v, hasDefaultEdges: b, onEdgesChange: x } = t.getState(), w = typeof g == "function" ? g(m) : g;
    if (b)
      v(w);
    else if (x) {
      const C = w.length === 0 ? m.map((y) => ({ type: "remove", id: y.id })) : w.map((y) => ({ item: y, type: "reset" }));
      x(C);
    }
  }, []), l = Kt((g) => {
    const m = Array.isArray(g) ? g : [g], { getNodes: v, setNodes: b, hasDefaultNodes: x, onNodesChange: w } = t.getState();
    if (x) {
      const y = [...v(), ...m];
      b(y);
    } else if (w) {
      const C = m.map((y) => ({ item: y, type: "add" }));
      w(C);
    }
  }, []), u = Kt((g) => {
    const m = Array.isArray(g) ? g : [g], { edges: v = [], setEdges: b, hasDefaultEdges: x, onEdgesChange: w } = t.getState();
    if (x)
      b([...v, ...m]);
    else if (w) {
      const C = m.map((y) => ({ item: y, type: "add" }));
      w(C);
    }
  }, []), c = Kt(() => {
    const { getNodes: g, edges: m = [], transform: v } = t.getState(), [b, x, w] = v;
    return {
      nodes: g().map((C) => ({ ...C })),
      edges: m.map((C) => ({ ...C })),
      viewport: {
        x: b,
        y: x,
        zoom: w
      }
    };
  }, []), d = Kt(({ nodes: g, edges: m }) => {
    const { nodeInternals: v, getNodes: b, edges: x, hasDefaultNodes: w, hasDefaultEdges: C, onNodesDelete: y, onEdgesDelete: S, onNodesChange: A, onEdgesChange: $ } = t.getState(), M = (g || []).map((R) => R.id), _ = (m || []).map((R) => R.id), T = b().reduce((R, I) => {
      const k = !M.includes(I.id) && I.parentNode && R.find((L) => L.id === I.parentNode);
      return (typeof I.deletable == "boolean" ? I.deletable : !0) && (M.includes(I.id) || k) && R.push(I), R;
    }, []), D = x.filter((R) => typeof R.deletable == "boolean" ? R.deletable : !0), E = D.filter((R) => _.includes(R.id));
    if (T || E) {
      const R = WN(T, D), I = [...E, ...R], k = I.reduce((P, L) => (P.includes(L.id) || P.push(L.id), P), []);
      if ((C || w) && (C && t.setState({
        edges: x.filter((P) => !k.includes(P.id))
      }), w && (T.forEach((P) => {
        v.delete(P.id);
      }), t.setState({
        nodeInternals: new Map(v)
      }))), k.length > 0 && (S == null || S(I), $ && $(k.map((P) => ({
        id: P,
        type: "remove"
      })))), T.length > 0 && (y == null || y(T), A)) {
        const P = T.map((L) => ({ id: L.id, type: "remove" }));
        A(P);
      }
    }
  }, []), f = Kt((g) => {
    const m = Vle(g), v = m ? null : t.getState().nodeInternals.get(g.id);
    return !m && !v ? [null, null, m] : [m ? g : W2(v), v, m];
  }, []), h = Kt((g, m = !0, v) => {
    const [b, x, w] = f(g);
    return b ? (v || t.getState().getNodes()).filter((C) => {
      if (!w && (C.id === x.id || !C.positionAbsolute))
        return !1;
      const y = W2(C), S = Qy(y, b);
      return m && S > 0 || S >= b.width * b.height;
    }) : [];
  }, []), p = Kt((g, m, v = !0) => {
    const [b] = f(g);
    if (!b)
      return !1;
    const x = Qy(b, m);
    return v && x > 0 || x >= b.width * b.height;
  }, []);
  return mt(() => ({
    ...e,
    getNodes: n,
    getNode: r,
    getEdges: i,
    getEdge: o,
    setNodes: s,
    setEdges: a,
    addNodes: l,
    addEdges: u,
    toObject: c,
    deleteElements: d,
    getIntersectingNodes: h,
    isNodeIntersecting: p
  }), [
    e,
    n,
    r,
    i,
    o,
    s,
    a,
    l,
    u,
    c,
    d,
    h,
    p
  ]);
}
const Ece = { actInsideInputWithModifier: !1 };
var $ce = ({ deleteKeyCode: e, multiSelectionKeyCode: t }) => {
  const n = xr(), { deleteElements: r } = XC(), i = tf(e, Ece), o = tf(t);
  Pe(() => {
    if (i) {
      const { edges: s, getNodes: a } = n.getState(), l = a().filter((c) => c.selected), u = s.filter((c) => c.selected);
      r({ nodes: l, edges: u }), n.setState({ nodesSelectionActive: !1 });
    }
  }, [i]), Pe(() => {
    n.setState({ multiSelectionActive: o });
  }, [o]);
};
function Oce(e) {
  const t = xr();
  Pe(() => {
    let n;
    const r = () => {
      var o, s;
      if (!e.current)
        return;
      const i = LC(e.current);
      (i.height === 0 || i.width === 0) && ((s = (o = t.getState()).onError) == null || s.call(o, "004", _o.error004())), t.setState({ width: i.width || 500, height: i.height || 500 });
    };
    return r(), window.addEventListener("resize", r), e.current && (n = new ResizeObserver(() => r()), n.observe(e.current)), () => {
      window.removeEventListener("resize", r), n && e.current && n.unobserve(e.current);
    };
  }, []);
}
const YC = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
}, Ace = (e, t) => e.x !== t.x || e.y !== t.y || e.zoom !== t.k, jh = (e) => ({
  x: e.x,
  y: e.y,
  zoom: e.k
}), ql = (e, t) => e.target.closest(`.${t}`), eA = (e, t) => t === 2 && Array.isArray(e) && e.includes(2), tA = (e) => {
  const t = e.ctrlKey && mg() ? 10 : 1;
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * t;
}, Dce = (e) => ({
  d3Zoom: e.d3Zoom,
  d3Selection: e.d3Selection,
  d3ZoomHandler: e.d3ZoomHandler,
  userSelectionActive: e.userSelectionActive
}), _ce = ({ onMove: e, onMoveStart: t, onMoveEnd: n, onPaneContextMenu: r, zoomOnScroll: i = !0, zoomOnPinch: o = !0, panOnScroll: s = !1, panOnScrollSpeed: a = 0.5, panOnScrollMode: l = Va.Free, zoomOnDoubleClick: u = !0, elementsSelectable: c, panOnDrag: d = !0, defaultViewport: f, translateExtent: h, minZoom: p, maxZoom: g, zoomActivationKeyCode: m, preventScrolling: v = !0, children: b, noWheelClassName: x, noPanClassName: w }) => {
  const C = he(), y = xr(), S = he(!1), A = he(!1), $ = he(null), M = he({ x: 0, y: 0, zoom: 0 }), { d3Zoom: _, d3Selection: T, d3ZoomHandler: D, userSelectionActive: E } = jn(Dce, Pr), R = tf(m), I = he(0), k = he(!1), P = he();
  return Oce($), Pe(() => {
    if ($.current) {
      const L = $.current.getBoundingClientRect(), N = Ple().scaleExtent([p, g]).translateExtent(h), F = po($.current).call(N), B = ia.translate(f.x, f.y).scale(Kc(f.zoom, p, g)), j = [
        [0, 0],
        [L.width, L.height]
      ], z = N.constrain()(B, j, h);
      N.transform(F, z), N.wheelDelta(tA), y.setState({
        d3Zoom: N,
        d3Selection: F,
        d3ZoomHandler: F.on("wheel.zoom"),
        // we need to pass transform because zoom handler is not registered when we set the initial transform
        transform: [z.x, z.y, z.k],
        domNode: $.current.closest(".react-flow")
      });
    }
  }, []), Pe(() => {
    T && _ && (s && !R && !E ? T.on("wheel.zoom", (L) => {
      if (ql(L, x))
        return !1;
      L.preventDefault(), L.stopImmediatePropagation();
      const N = T.property("__zoom").k || 1, F = mg();
      if (L.ctrlKey && o && F) {
        const Y = jo(L), X = tA(L), Z = N * Math.pow(2, X);
        _.scaleTo(T, Z, Y, L);
        return;
      }
      const B = L.deltaMode === 1 ? 20 : 1;
      let j = l === Va.Vertical ? 0 : L.deltaX * B, z = l === Va.Horizontal ? 0 : L.deltaY * B;
      !F && L.shiftKey && l !== Va.Vertical && (j = L.deltaY * B, z = 0), _.translateBy(
        T,
        -(j / N) * a,
        -(z / N) * a,
        // @ts-ignore
        { internal: !0 }
      );
      const H = jh(T.property("__zoom")), { onViewportChangeStart: W, onViewportChange: G, onViewportChangeEnd: K } = y.getState();
      clearTimeout(P.current), k.current || (k.current = !0, t == null || t(L, H), W == null || W(H)), k.current && (e == null || e(L, H), G == null || G(H), P.current = setTimeout(() => {
        n == null || n(L, H), K == null || K(H), k.current = !1;
      }, 150));
    }, { passive: !1 }) : typeof D < "u" && T.on("wheel.zoom", function(L, N) {
      if (!v || ql(L, x))
        return null;
      L.preventDefault(), D.call(this, L, N);
    }, { passive: !1 }));
  }, [
    E,
    s,
    l,
    T,
    _,
    D,
    R,
    o,
    v,
    x,
    t,
    e,
    n
  ]), Pe(() => {
    _ && _.on("start", (L) => {
      var B, j;
      if (!L.sourceEvent || L.sourceEvent.internal)
        return null;
      I.current = (B = L.sourceEvent) == null ? void 0 : B.button;
      const { onViewportChangeStart: N } = y.getState(), F = jh(L.transform);
      S.current = !0, M.current = F, ((j = L.sourceEvent) == null ? void 0 : j.type) === "mousedown" && y.setState({ paneDragging: !0 }), N == null || N(F), t == null || t(L.sourceEvent, F);
    });
  }, [_, t]), Pe(() => {
    _ && (E && !S.current ? _.on("zoom", null) : E || _.on("zoom", (L) => {
      var F;
      const { onViewportChange: N } = y.getState();
      if (y.setState({ transform: [L.transform.x, L.transform.y, L.transform.k] }), A.current = !!(r && eA(d, I.current ?? 0)), (e || N) && !((F = L.sourceEvent) != null && F.internal)) {
        const B = jh(L.transform);
        N == null || N(B), e == null || e(L.sourceEvent, B);
      }
    }));
  }, [E, _, e, d, r]), Pe(() => {
    _ && _.on("end", (L) => {
      if (!L.sourceEvent || L.sourceEvent.internal)
        return null;
      const { onViewportChangeEnd: N } = y.getState();
      if (S.current = !1, y.setState({ paneDragging: !1 }), r && eA(d, I.current ?? 0) && !A.current && r(L.sourceEvent), A.current = !1, (n || N) && Ace(M.current, L.transform)) {
        const F = jh(L.transform);
        M.current = F, clearTimeout(C.current), C.current = setTimeout(() => {
          N == null || N(F), n == null || n(L.sourceEvent, F);
        }, s ? 150 : 0);
      }
    });
  }, [_, s, d, n, r]), Pe(() => {
    _ && _.filter((L) => {
      const N = R || i, F = o && L.ctrlKey;
      if ((d === !0 || Array.isArray(d) && d.includes(1)) && L.button === 1 && L.type === "mousedown" && (ql(L, "react-flow__node") || ql(L, "react-flow__edge")))
        return !0;
      if (!d && !N && !s && !u && !o || E || !u && L.type === "dblclick" || ql(L, x) && L.type === "wheel" || ql(L, w) && (L.type !== "wheel" || s && L.type === "wheel" && !R) || !o && L.ctrlKey && L.type === "wheel" || !N && !s && !F && L.type === "wheel" || !d && (L.type === "mousedown" || L.type === "touchstart") || Array.isArray(d) && !d.includes(L.button) && (L.type === "mousedown" || L.type === "touchstart"))
        return !1;
      const B = Array.isArray(d) && d.includes(L.button) || !L.button || L.button <= 1;
      return (!L.ctrlKey || L.type === "wheel") && B;
    });
  }, [
    E,
    _,
    i,
    o,
    s,
    u,
    d,
    c,
    R
  ]), U.createElement("div", { className: "react-flow__renderer", ref: $, style: YC }, b);
}, Tce = (e) => ({
  userSelectionActive: e.userSelectionActive,
  userSelectionRect: e.userSelectionRect
});
function Rce() {
  const { userSelectionActive: e, userSelectionRect: t } = jn(Tce, Pr);
  return e && t ? U.createElement("div", { className: "react-flow__selection react-flow__container", style: {
    width: t.width,
    height: t.height,
    transform: `translate(${t.x}px, ${t.y}px)`
  } }) : null;
}
function nA(e, t) {
  const n = e.find((r) => r.id === t.parentNode);
  if (n) {
    const r = t.position.x + t.width - n.width, i = t.position.y + t.height - n.height;
    if (r > 0 || i > 0 || t.position.x < 0 || t.position.y < 0) {
      if (n.style = { ...n.style }, n.style.width = n.style.width ?? n.width, n.style.height = n.style.height ?? n.height, r > 0 && (n.style.width += r), i > 0 && (n.style.height += i), t.position.x < 0) {
        const o = Math.abs(t.position.x);
        n.position.x = n.position.x - o, n.style.width += o, t.position.x = 0;
      }
      if (t.position.y < 0) {
        const o = Math.abs(t.position.y);
        n.position.y = n.position.y - o, n.style.height += o, t.position.y = 0;
      }
      n.width = n.style.width, n.height = n.style.height;
    }
  }
}
function aL(e, t) {
  if (e.some((r) => r.type === "reset"))
    return e.filter((r) => r.type === "reset").map((r) => r.item);
  const n = e.filter((r) => r.type === "add").map((r) => r.item);
  return t.reduce((r, i) => {
    const o = e.filter((a) => a.id === i.id);
    if (o.length === 0)
      return r.push(i), r;
    const s = { ...i };
    for (const a of o)
      if (a)
        switch (a.type) {
          case "select": {
            s.selected = a.selected;
            break;
          }
          case "position": {
            typeof a.position < "u" && (s.position = a.position), typeof a.positionAbsolute < "u" && (s.positionAbsolute = a.positionAbsolute), typeof a.dragging < "u" && (s.dragging = a.dragging), s.expandParent && nA(r, s);
            break;
          }
          case "dimensions": {
            typeof a.dimensions < "u" && (s.width = a.dimensions.width, s.height = a.dimensions.height), typeof a.updateStyle < "u" && (s.style = { ...s.style || {}, ...a.dimensions }), typeof a.resizing == "boolean" && (s.resizing = a.resizing), s.expandParent && nA(r, s);
            break;
          }
          case "remove":
            return r;
        }
    return r.push(s), r;
  }, n);
}
function lL(e, t) {
  return aL(e, t);
}
function Mce(e, t) {
  return aL(e, t);
}
const Ws = (e, t) => ({
  id: e,
  type: "select",
  selected: t
});
function lc(e, t) {
  return e.reduce((n, r) => {
    const i = t.includes(r.id);
    return !r.selected && i ? (r.selected = !0, n.push(Ws(r.id, !0))) : r.selected && !i && (r.selected = !1, n.push(Ws(r.id, !1))), n;
  }, []);
}
const y0 = (e, t) => (n) => {
  n.target === t.current && (e == null || e(n));
}, Ice = (e) => ({
  userSelectionActive: e.userSelectionActive,
  elementsSelectable: e.elementsSelectable,
  dragging: e.paneDragging
}), cL = Sn(({ isSelecting: e, selectionMode: t = Jd.Full, panOnDrag: n, onSelectionStart: r, onSelectionEnd: i, onPaneClick: o, onPaneContextMenu: s, onPaneScroll: a, onPaneMouseEnter: l, onPaneMouseMove: u, onPaneMouseLeave: c, children: d }) => {
  const f = he(null), h = xr(), p = he(0), g = he(0), m = he(), { userSelectionActive: v, elementsSelectable: b, dragging: x } = jn(Ice, Pr), w = () => {
    h.setState({ userSelectionActive: !1, userSelectionRect: null }), p.current = 0, g.current = 0;
  }, C = (D) => {
    o == null || o(D), h.getState().resetSelectedElements(), h.setState({ nodesSelectionActive: !1 });
  }, y = (D) => {
    if (Array.isArray(n) && (n != null && n.includes(2))) {
      D.preventDefault();
      return;
    }
    s == null || s(D);
  }, S = a ? (D) => a(D) : void 0, A = (D) => {
    const { resetSelectedElements: E, domNode: R } = h.getState();
    if (m.current = R == null ? void 0 : R.getBoundingClientRect(), !b || !e || D.button !== 0 || D.target !== f.current || !m.current)
      return;
    const { x: I, y: k } = oa(D, m.current);
    E(), h.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: I,
        startY: k,
        x: I,
        y: k
      }
    }), r == null || r(D);
  }, $ = (D) => {
    const { userSelectionRect: E, nodeInternals: R, edges: I, transform: k, onNodesChange: P, onEdgesChange: L, nodeOrigin: N, getNodes: F } = h.getState();
    if (!e || !m.current || !E)
      return;
    h.setState({ userSelectionActive: !0, nodesSelectionActive: !1 });
    const B = oa(D, m.current), j = E.startX ?? 0, z = E.startY ?? 0, H = {
      ...E,
      x: B.x < j ? B.x : j,
      y: B.y < z ? B.y : z,
      width: Math.abs(B.x - j),
      height: Math.abs(B.y - z)
    }, W = F(), G = VN(R, H, k, t === Jd.Partial, !0, N), K = WN(G, I).map((X) => X.id), Y = G.map((X) => X.id);
    if (p.current !== Y.length) {
      p.current = Y.length;
      const X = lc(W, Y);
      X.length && (P == null || P(X));
    }
    if (g.current !== K.length) {
      g.current = K.length;
      const X = lc(I, K);
      X.length && (L == null || L(X));
    }
    h.setState({
      userSelectionRect: H
    });
  }, M = (D) => {
    if (D.button !== 0)
      return;
    const { userSelectionRect: E } = h.getState();
    !v && E && D.target === f.current && (C == null || C(D)), h.setState({ nodesSelectionActive: p.current > 0 }), w(), i == null || i(D);
  }, _ = (D) => {
    v && (h.setState({ nodesSelectionActive: p.current > 0 }), i == null || i(D)), w();
  }, T = b && (e || v);
  return U.createElement(
    "div",
    { className: di(["react-flow__pane", { dragging: x, selection: e }]), onClick: T ? void 0 : y0(C, f), onContextMenu: y0(y, f), onWheel: y0(S, f), onMouseEnter: T ? void 0 : l, onMouseDown: T ? A : void 0, onMouseMove: T ? $ : u, onMouseUp: T ? M : void 0, onMouseLeave: T ? _ : c, ref: f, style: YC },
    d,
    U.createElement(Rce, null)
  );
});
cL.displayName = "Pane";
function uL(e, t) {
  if (!e.parentNode)
    return !1;
  const n = t.get(e.parentNode);
  return n ? n.selected ? !0 : uL(n, t) : !1;
}
function rA(e, t, n) {
  let r = e;
  do {
    if (r != null && r.matches(t))
      return !0;
    if (r === n.current)
      return !1;
    r = r.parentElement;
  } while (r);
  return !1;
}
function kce(e, t, n, r) {
  return Array.from(e.values()).filter((i) => (i.selected || i.id === r) && (!i.parentNode || !uL(i, e)) && (i.draggable || t && typeof i.draggable > "u")).map((i) => {
    var o, s;
    return {
      id: i.id,
      position: i.position || { x: 0, y: 0 },
      positionAbsolute: i.positionAbsolute || { x: 0, y: 0 },
      distance: {
        x: n.x - (((o = i.positionAbsolute) == null ? void 0 : o.x) ?? 0),
        y: n.y - (((s = i.positionAbsolute) == null ? void 0 : s.y) ?? 0)
      },
      delta: {
        x: 0,
        y: 0
      },
      extent: i.extent,
      parentNode: i.parentNode,
      width: i.width,
      height: i.height,
      expandParent: i.expandParent
    };
  });
}
function Pce(e, t) {
  return !t || t === "parent" ? t : [t[0], [t[1][0] - (e.width || 0), t[1][1] - (e.height || 0)]];
}
function dL(e, t, n, r, i = [0, 0], o) {
  const s = Pce(e, e.extent || r);
  let a = s;
  if (e.extent === "parent" && !e.expandParent)
    if (e.parentNode && e.width && e.height) {
      const c = n.get(e.parentNode), { x: d, y: f } = xc(c, i).positionAbsolute;
      a = c && Ji(d) && Ji(f) && Ji(c.width) && Ji(c.height) ? [
        [d + e.width * i[0], f + e.height * i[1]],
        [
          d + c.width - e.width + e.width * i[0],
          f + c.height - e.height + e.height * i[1]
        ]
      ] : a;
    } else
      o == null || o("005", _o.error005()), a = s;
  else if (e.extent && e.parentNode && e.extent !== "parent") {
    const c = n.get(e.parentNode), { x: d, y: f } = xc(c, i).positionAbsolute;
    a = [
      [e.extent[0][0] + d, e.extent[0][1] + f],
      [e.extent[1][0] + d, e.extent[1][1] + f]
    ];
  }
  let l = { x: 0, y: 0 };
  if (e.parentNode) {
    const c = n.get(e.parentNode);
    l = xc(c, i).positionAbsolute;
  }
  const u = a && a !== "parent" ? FC(t, a) : t;
  return {
    position: {
      x: u.x - l.x,
      y: u.y - l.y
    },
    positionAbsolute: u
  };
}
function w0({ nodeId: e, dragItems: t, nodeInternals: n }) {
  const r = t.map((i) => ({
    ...n.get(i.id),
    position: i.position,
    positionAbsolute: i.positionAbsolute
  }));
  return [e ? r.find((i) => i.id === e) : r[0], r];
}
const iA = (e, t, n, r) => {
  const i = t.querySelectorAll(e);
  if (!i || !i.length)
    return null;
  const o = Array.from(i), s = t.getBoundingClientRect(), a = {
    x: s.width * r[0],
    y: s.height * r[1]
  };
  return o.map((l) => {
    const u = l.getBoundingClientRect();
    return {
      id: l.getAttribute("data-handleid"),
      position: l.getAttribute("data-handlepos"),
      x: (u.left - s.left - a.x) / n,
      y: (u.top - s.top - a.y) / n,
      ...LC(l)
    };
  });
};
function Iu(e, t, n) {
  return n === void 0 ? n : (r) => {
    const i = t().nodeInternals.get(e);
    i && n(r, { ...i });
  };
}
function rw({ id: e, store: t, unselect: n = !1, nodeRef: r }) {
  const { addSelectedNodes: i, unselectNodesAndEdges: o, multiSelectionActive: s, nodeInternals: a, onError: l } = t.getState(), u = a.get(e);
  if (!u) {
    l == null || l("012", _o.error012(e));
    return;
  }
  t.setState({ nodesSelectionActive: !1 }), u.selected ? (n || u.selected && s) && (o({ nodes: [u], edges: [] }), requestAnimationFrame(() => {
    var c;
    return (c = r == null ? void 0 : r.current) == null ? void 0 : c.blur();
  })) : i([e]);
}
function Nce() {
  const e = xr();
  return Kt(({ sourceEvent: n }) => {
    const { transform: r, snapGrid: i, snapToGrid: o } = e.getState(), s = n.touches ? n.touches[0].clientX : n.clientX, a = n.touches ? n.touches[0].clientY : n.clientY, l = {
      x: (s - r[0]) / r[2],
      y: (a - r[1]) / r[2]
    };
    return {
      xSnapped: o ? i[0] * Math.round(l.x / i[0]) : l.x,
      ySnapped: o ? i[1] * Math.round(l.y / i[1]) : l.y,
      ...l
    };
  }, []);
}
function C0(e) {
  return (t, n, r) => e == null ? void 0 : e(t, r);
}
function fL({ nodeRef: e, disabled: t = !1, noDragClassName: n, handleSelector: r, nodeId: i, isSelectable: o, selectNodesOnDrag: s }) {
  const a = xr(), [l, u] = ht(!1), c = he([]), d = he({ x: null, y: null }), f = he(0), h = he(null), p = he({ x: 0, y: 0 }), g = he(null), m = he(!1), v = he(!1), b = Nce();
  return Pe(() => {
    if (e != null && e.current) {
      const x = po(e.current), w = ({ x: S, y: A }) => {
        const { nodeInternals: $, onNodeDrag: M, onSelectionDrag: _, updateNodePositions: T, nodeExtent: D, snapGrid: E, snapToGrid: R, nodeOrigin: I, onError: k } = a.getState();
        d.current = { x: S, y: A };
        let P = !1, L = { x: 0, y: 0, x2: 0, y2: 0 };
        if (c.current.length > 1 && D) {
          const F = UC(c.current, I);
          L = BC(F);
        }
        if (c.current = c.current.map((F) => {
          const B = { x: S - F.distance.x, y: A - F.distance.y };
          R && (B.x = E[0] * Math.round(B.x / E[0]), B.y = E[1] * Math.round(B.y / E[1]));
          const j = [
            [D[0][0], D[0][1]],
            [D[1][0], D[1][1]]
          ];
          c.current.length > 1 && D && !F.extent && (j[0][0] = F.positionAbsolute.x - L.x + D[0][0], j[1][0] = F.positionAbsolute.x + (F.width ?? 0) - L.x2 + D[1][0], j[0][1] = F.positionAbsolute.y - L.y + D[0][1], j[1][1] = F.positionAbsolute.y + (F.height ?? 0) - L.y2 + D[1][1]);
          const z = dL(F, B, $, j, I, k);
          return P = P || F.position.x !== z.position.x || F.position.y !== z.position.y, F.position = z.position, F.positionAbsolute = z.positionAbsolute, F;
        }), !P)
          return;
        T(c.current, !0, !0), u(!0);
        const N = i ? M : C0(_);
        if (N && g.current) {
          const [F, B] = w0({
            nodeId: i,
            dragItems: c.current,
            nodeInternals: $
          });
          N(g.current, F, B);
        }
      }, C = () => {
        if (!h.current)
          return;
        const [S, A] = kN(p.current, h.current);
        if (S !== 0 || A !== 0) {
          const { transform: $, panBy: M } = a.getState();
          d.current.x = (d.current.x ?? 0) - S / $[2], d.current.y = (d.current.y ?? 0) - A / $[2], M({ x: S, y: A }) && w(d.current);
        }
        f.current = requestAnimationFrame(C);
      }, y = (S) => {
        var I;
        const { nodeInternals: A, multiSelectionActive: $, nodesDraggable: M, unselectNodesAndEdges: _, onNodeDragStart: T, onSelectionDragStart: D } = a.getState();
        v.current = !0;
        const E = i ? T : C0(D);
        (!s || !o) && !$ && i && ((I = A.get(i)) != null && I.selected || _()), i && o && s && rw({
          id: i,
          store: a,
          nodeRef: e
        });
        const R = b(S);
        if (d.current = R, c.current = kce(A, M, R, i), E && c.current) {
          const [k, P] = w0({
            nodeId: i,
            dragItems: c.current,
            nodeInternals: A
          });
          E(S.sourceEvent, k, P);
        }
      };
      if (t)
        x.on(".drag", null);
      else {
        const S = Use().on("start", (A) => {
          const { domNode: $, nodeDragThreshold: M } = a.getState();
          M === 0 && y(A);
          const _ = b(A);
          d.current = _, h.current = ($ == null ? void 0 : $.getBoundingClientRect()) || null, p.current = oa(A.sourceEvent, h.current);
        }).on("drag", (A) => {
          var T, D;
          const $ = b(A), { autoPanOnNodeDrag: M, nodeDragThreshold: _ } = a.getState();
          if (!m.current && v.current && M && (m.current = !0, C()), !v.current) {
            const E = $.xSnapped - (((T = d == null ? void 0 : d.current) == null ? void 0 : T.x) ?? 0), R = $.ySnapped - (((D = d == null ? void 0 : d.current) == null ? void 0 : D.y) ?? 0);
            Math.sqrt(E * E + R * R) > _ && y(A);
          }
          (d.current.x !== $.xSnapped || d.current.y !== $.ySnapped) && c.current && v.current && (g.current = A.sourceEvent, p.current = oa(A.sourceEvent, h.current), w($));
        }).on("end", (A) => {
          if (v.current && (u(!1), m.current = !1, v.current = !1, cancelAnimationFrame(f.current), c.current)) {
            const { updateNodePositions: $, nodeInternals: M, onNodeDragStop: _, onSelectionDragStop: T } = a.getState(), D = i ? _ : C0(T);
            if ($(c.current, !1, !1), D) {
              const [E, R] = w0({
                nodeId: i,
                dragItems: c.current,
                nodeInternals: M
              });
              D(A.sourceEvent, E, R);
            }
          }
        }).filter((A) => {
          const $ = A.target;
          return !A.button && (!n || !rA($, `.${n}`, e)) && (!r || rA($, r, e));
        });
        return x.call(S), () => {
          x.on(".drag", null);
        };
      }
    }
  }, [
    e,
    t,
    n,
    r,
    o,
    a,
    i,
    s,
    b
  ]), l;
}
function hL() {
  const e = xr();
  return Kt((n) => {
    const { nodeInternals: r, nodeExtent: i, updateNodePositions: o, getNodes: s, snapToGrid: a, snapGrid: l, onError: u, nodesDraggable: c } = e.getState(), d = s().filter((b) => b.selected && (b.draggable || c && typeof b.draggable > "u")), f = a ? l[0] : 5, h = a ? l[1] : 5, p = n.isShiftPressed ? 4 : 1, g = n.x * f * p, m = n.y * h * p, v = d.map((b) => {
      if (b.positionAbsolute) {
        const x = { x: b.positionAbsolute.x + g, y: b.positionAbsolute.y + m };
        a && (x.x = l[0] * Math.round(x.x / l[0]), x.y = l[1] * Math.round(x.y / l[1]));
        const { positionAbsolute: w, position: C } = dL(b, x, r, i, void 0, u);
        b.position = C, b.positionAbsolute = w;
      }
      return b;
    });
    o(v, !0, !1);
  }, []);
}
const Ec = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
};
var ku = (e) => {
  const t = ({ id: n, type: r, data: i, xPos: o, yPos: s, xPosOrigin: a, yPosOrigin: l, selected: u, onClick: c, onMouseEnter: d, onMouseMove: f, onMouseLeave: h, onContextMenu: p, onDoubleClick: g, style: m, className: v, isDraggable: b, isSelectable: x, isConnectable: w, isFocusable: C, selectNodesOnDrag: y, sourcePosition: S, targetPosition: A, hidden: $, resizeObserver: M, dragHandle: _, zIndex: T, isParent: D, noDragClassName: E, noPanClassName: R, initialized: I, disableKeyboardA11y: k, ariaLabel: P, rfId: L }) => {
    const N = xr(), F = he(null), B = he(S), j = he(A), z = he(r), H = x || b || c || d || f || h, W = hL(), G = Iu(n, N.getState, d), K = Iu(n, N.getState, f), Y = Iu(n, N.getState, h), X = Iu(n, N.getState, p), Z = Iu(n, N.getState, g), Q = (te) => {
      const { nodeDragThreshold: fe } = N.getState();
      if (x && (!y || !b || fe > 0) && rw({
        id: n,
        store: N,
        nodeRef: F
      }), c) {
        const Se = N.getState().nodeInternals.get(n);
        Se && c(te, { ...Se });
      }
    }, ne = (te) => {
      if (!Zy(te))
        if (NN.includes(te.key) && x) {
          const fe = te.key === "Escape";
          rw({
            id: n,
            store: N,
            unselect: fe,
            nodeRef: F
          });
        } else
          !k && b && u && Object.prototype.hasOwnProperty.call(Ec, te.key) && (N.setState({
            ariaLiveMessage: `Moved selected node ${te.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~o}, y: ${~~s}`
          }), W({
            x: Ec[te.key].x,
            y: Ec[te.key].y,
            isShiftPressed: te.shiftKey
          }));
    };
    Pe(() => {
      if (F.current && !$) {
        const te = F.current;
        return M == null || M.observe(te), () => M == null ? void 0 : M.unobserve(te);
      }
    }, [$]), Pe(() => {
      const te = z.current !== r, fe = B.current !== S, Se = j.current !== A;
      F.current && (te || fe || Se) && (te && (z.current = r), fe && (B.current = S), Se && (j.current = A), N.getState().updateNodeDimensions([{ id: n, nodeElement: F.current, forceUpdate: !0 }]));
    }, [n, r, S, A]);
    const q = fL({
      nodeRef: F,
      disabled: $ || !b,
      noDragClassName: E,
      handleSelector: _,
      nodeId: n,
      isSelectable: x,
      selectNodesOnDrag: y
    });
    return $ ? null : U.createElement(
      "div",
      { className: di([
        "react-flow__node",
        `react-flow__node-${r}`,
        {
          // this is overwritable by passing `nopan` as a class name
          [R]: b
        },
        v,
        {
          selected: u,
          selectable: x,
          parent: D,
          dragging: q
        }
      ]), ref: F, style: {
        zIndex: T,
        transform: `translate(${a}px,${l}px)`,
        pointerEvents: H ? "all" : "none",
        visibility: I ? "visible" : "hidden",
        ...m
      }, "data-id": n, "data-testid": `rf__node-${n}`, onMouseEnter: G, onMouseMove: K, onMouseLeave: Y, onContextMenu: X, onClick: Q, onDoubleClick: Z, onKeyDown: C ? ne : void 0, tabIndex: C ? 0 : void 0, role: C ? "button" : void 0, "aria-describedby": k ? void 0 : `${nL}-${L}`, "aria-label": P },
      U.createElement(
        Yle,
        { value: n },
        U.createElement(e, { id: n, data: i, type: r, xPos: o, yPos: s, selected: u, isConnectable: w, sourcePosition: S, targetPosition: A, dragging: q, dragHandle: _, zIndex: T })
      )
    );
  };
  return t.displayName = "NodeWrapper", Sn(t);
};
const Lce = (e) => {
  const t = e.getNodes().filter((n) => n.selected);
  return {
    ...UC(t, e.nodeOrigin),
    transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`,
    userSelectionActive: e.userSelectionActive
  };
};
function Fce({ onSelectionContextMenu: e, noPanClassName: t, disableKeyboardA11y: n }) {
  const r = xr(), { width: i, height: o, x: s, y: a, transformString: l, userSelectionActive: u } = jn(Lce, Pr), c = hL(), d = he(null);
  if (Pe(() => {
    var p;
    n || (p = d.current) == null || p.focus({
      preventScroll: !0
    });
  }, [n]), fL({
    nodeRef: d
  }), u || !i || !o)
    return null;
  const f = e ? (p) => {
    const g = r.getState().getNodes().filter((m) => m.selected);
    e(p, g);
  } : void 0, h = (p) => {
    Object.prototype.hasOwnProperty.call(Ec, p.key) && c({
      x: Ec[p.key].x,
      y: Ec[p.key].y,
      isShiftPressed: p.shiftKey
    });
  };
  return U.createElement(
    "div",
    { className: di(["react-flow__nodesselection", "react-flow__container", t]), style: {
      transform: l
    } },
    U.createElement("div", { ref: d, className: "react-flow__nodesselection-rect", onContextMenu: f, tabIndex: n ? void 0 : -1, onKeyDown: n ? void 0 : h, style: {
      width: i,
      height: o,
      top: a,
      left: s
    } })
  );
}
var Bce = Sn(Fce);
const jce = (e) => e.nodesSelectionActive, pL = ({ children: e, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: i, onPaneContextMenu: o, onPaneScroll: s, deleteKeyCode: a, onMove: l, onMoveStart: u, onMoveEnd: c, selectionKeyCode: d, selectionOnDrag: f, selectionMode: h, onSelectionStart: p, onSelectionEnd: g, multiSelectionKeyCode: m, panActivationKeyCode: v, zoomActivationKeyCode: b, elementsSelectable: x, zoomOnScroll: w, zoomOnPinch: C, panOnScroll: y, panOnScrollSpeed: S, panOnScrollMode: A, zoomOnDoubleClick: $, panOnDrag: M, defaultViewport: _, translateExtent: T, minZoom: D, maxZoom: E, preventScrolling: R, onSelectionContextMenu: I, noWheelClassName: k, noPanClassName: P, disableKeyboardA11y: L }) => {
  const N = jn(jce), F = tf(d), B = tf(v), j = B || M, z = B || y, H = F || f && j !== !0;
  return $ce({ deleteKeyCode: a, multiSelectionKeyCode: m }), U.createElement(
    _ce,
    { onMove: l, onMoveStart: u, onMoveEnd: c, onPaneContextMenu: o, elementsSelectable: x, zoomOnScroll: w, zoomOnPinch: C, panOnScroll: z, panOnScrollSpeed: S, panOnScrollMode: A, zoomOnDoubleClick: $, panOnDrag: !F && j, defaultViewport: _, translateExtent: T, minZoom: D, maxZoom: E, zoomActivationKeyCode: b, preventScrolling: R, noWheelClassName: k, noPanClassName: P },
    U.createElement(
      cL,
      { onSelectionStart: p, onSelectionEnd: g, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: r, onPaneMouseLeave: i, onPaneContextMenu: o, onPaneScroll: s, panOnDrag: j, isSelecting: !!H, selectionMode: h },
      e,
      N && U.createElement(Bce, { onSelectionContextMenu: I, noPanClassName: P, disableKeyboardA11y: L })
    )
  );
};
pL.displayName = "FlowRenderer";
var zce = Sn(pL);
function Hce(e) {
  return jn(Kt((n) => e ? VN(n.nodeInternals, { x: 0, y: 0, width: n.width, height: n.height }, n.transform, !0) : n.getNodes(), [e]));
}
function Vce(e) {
  const t = {
    input: ku(e.input || ZN),
    default: ku(e.default || nw),
    output: ku(e.output || eL),
    group: ku(e.group || KC)
  }, n = {}, r = Object.keys(e).filter((i) => !["input", "default", "output", "group"].includes(i)).reduce((i, o) => (i[o] = ku(e[o] || nw), i), n);
  return {
    ...t,
    ...r
  };
}
const Wce = ({ x: e, y: t, width: n, height: r, origin: i }) => !n || !r ? { x: e, y: t } : i[0] < 0 || i[1] < 0 || i[0] > 1 || i[1] > 1 ? { x: e, y: t } : {
  x: e - n * i[0],
  y: t - r * i[1]
}, Uce = (e) => ({
  nodesDraggable: e.nodesDraggable,
  nodesConnectable: e.nodesConnectable,
  nodesFocusable: e.nodesFocusable,
  elementsSelectable: e.elementsSelectable,
  updateNodeDimensions: e.updateNodeDimensions,
  onError: e.onError
}), gL = (e) => {
  const { nodesDraggable: t, nodesConnectable: n, nodesFocusable: r, elementsSelectable: i, updateNodeDimensions: o, onError: s } = jn(Uce, Pr), a = Hce(e.onlyRenderVisibleElements), l = he(), u = mt(() => {
    if (typeof ResizeObserver > "u")
      return null;
    const c = new ResizeObserver((d) => {
      const f = d.map((h) => ({
        id: h.target.getAttribute("data-id"),
        nodeElement: h.target,
        forceUpdate: !0
      }));
      o(f);
    });
    return l.current = c, c;
  }, []);
  return Pe(() => () => {
    var c;
    (c = l == null ? void 0 : l.current) == null || c.disconnect();
  }, []), U.createElement("div", { className: "react-flow__nodes", style: YC }, a.map((c) => {
    var C, y;
    let d = c.type || "default";
    e.nodeTypes[d] || (s == null || s("003", _o.error003(d)), d = "default");
    const f = e.nodeTypes[d] || e.nodeTypes.default, h = !!(c.draggable || t && typeof c.draggable > "u"), p = !!(c.selectable || i && typeof c.selectable > "u"), g = !!(c.connectable || n && typeof c.connectable > "u"), m = !!(c.focusable || r && typeof c.focusable > "u"), v = e.nodeExtent ? FC(c.positionAbsolute, e.nodeExtent) : c.positionAbsolute, b = (v == null ? void 0 : v.x) ?? 0, x = (v == null ? void 0 : v.y) ?? 0, w = Wce({
      x: b,
      y: x,
      width: c.width ?? 0,
      height: c.height ?? 0,
      origin: e.nodeOrigin
    });
    return U.createElement(f, { key: c.id, id: c.id, className: c.className, style: c.style, type: d, data: c.data, sourcePosition: c.sourcePosition || bt.Bottom, targetPosition: c.targetPosition || bt.Top, hidden: c.hidden, xPos: b, yPos: x, xPosOrigin: w.x, yPosOrigin: w.y, selectNodesOnDrag: e.selectNodesOnDrag, onClick: e.onNodeClick, onMouseEnter: e.onNodeMouseEnter, onMouseMove: e.onNodeMouseMove, onMouseLeave: e.onNodeMouseLeave, onContextMenu: e.onNodeContextMenu, onDoubleClick: e.onNodeDoubleClick, selected: !!c.selected, isDraggable: h, isSelectable: p, isConnectable: g, isFocusable: m, resizeObserver: u, dragHandle: c.dragHandle, zIndex: ((C = c[fr]) == null ? void 0 : C.z) ?? 0, isParent: !!((y = c[fr]) != null && y.isParent), noDragClassName: e.noDragClassName, noPanClassName: e.noPanClassName, initialized: !!c.width && !!c.height, rfId: e.rfId, disableKeyboardA11y: e.disableKeyboardA11y, ariaLabel: c.ariaLabel });
  }));
};
gL.displayName = "NodeRenderer";
var Gce = Sn(gL);
const Kce = (e, t, n) => n === bt.Left ? e - t : n === bt.Right ? e + t : e, Xce = (e, t, n) => n === bt.Top ? e - t : n === bt.Bottom ? e + t : e, oA = "react-flow__edgeupdater", sA = ({ position: e, centerX: t, centerY: n, radius: r = 10, onMouseDown: i, onMouseEnter: o, onMouseOut: s, type: a }) => U.createElement("circle", { onMouseDown: i, onMouseEnter: o, onMouseOut: s, className: di([oA, `${oA}-${a}`]), cx: Kce(t, r, e), cy: Xce(n, r, e), r, stroke: "transparent", fill: "transparent" }), Yce = () => !0;
var Ql = (e) => {
  const t = ({ id: n, className: r, type: i, data: o, onClick: s, onEdgeDoubleClick: a, selected: l, animated: u, label: c, labelStyle: d, labelShowBg: f, labelBgStyle: h, labelBgPadding: p, labelBgBorderRadius: g, style: m, source: v, target: b, sourceX: x, sourceY: w, targetX: C, targetY: y, sourcePosition: S, targetPosition: A, elementsSelectable: $, hidden: M, sourceHandleId: _, targetHandleId: T, onContextMenu: D, onMouseEnter: E, onMouseMove: R, onMouseLeave: I, edgeUpdaterRadius: k, onEdgeUpdate: P, onEdgeUpdateStart: L, onEdgeUpdateEnd: N, markerEnd: F, markerStart: B, rfId: j, ariaLabel: z, isFocusable: H, isUpdatable: W, pathOptions: G, interactionWidth: K }) => {
    const Y = he(null), [X, Z] = ht(!1), [Q, ne] = ht(!1), q = xr(), te = mt(() => `url(#${ew(B, j)})`, [B, j]), fe = mt(() => `url(#${ew(F, j)})`, [F, j]);
    if (M)
      return null;
    const Se = (me) => {
      var Ge;
      const { edges: Fe, addSelectedEdges: Be, unselectNodesAndEdges: qe, multiSelectionActive: Ve } = q.getState(), We = Fe.find(($e) => $e.id === n);
      We && ($ && (q.setState({ nodesSelectionActive: !1 }), We.selected && Ve ? (qe({ nodes: [], edges: [We] }), (Ge = Y.current) == null || Ge.blur()) : Be([n])), s && s(me, We));
    }, de = Mu(n, q.getState, a), ce = Mu(n, q.getState, D), pe = Mu(n, q.getState, E), Oe = Mu(n, q.getState, R), Re = Mu(n, q.getState, I), De = (me, Fe) => {
      if (me.button !== 0)
        return;
      const { edges: Be, isValidConnection: qe } = q.getState(), Ve = Fe ? b : v, We = (Fe ? T : _) || null, Ge = Fe ? "target" : "source", $e = qe || Yce, ze = Fe, at = Be.find((Lt) => Lt.id === n);
      ne(!0), L == null || L(me, at, Ge);
      const xt = (Lt) => {
        ne(!1), N == null || N(Lt, at, Ge);
      };
      XN({
        event: me,
        handleId: We,
        nodeId: Ve,
        onConnect: (Lt) => P == null ? void 0 : P(at, Lt),
        isTarget: ze,
        getState: q.getState,
        setState: q.setState,
        isValidConnection: $e,
        edgeUpdaterType: Ge,
        onEdgeUpdateEnd: xt
      });
    }, Me = (me) => De(me, !0), Ue = (me) => De(me, !1), oe = () => Z(!0), Ce = () => Z(!1), ge = !$ && !s, ve = (me) => {
      var Fe;
      if (NN.includes(me.key) && $) {
        const { unselectNodesAndEdges: Be, addSelectedEdges: qe, edges: Ve } = q.getState();
        me.key === "Escape" ? ((Fe = Y.current) == null || Fe.blur(), Be({ edges: [Ve.find((Ge) => Ge.id === n)] })) : qe([n]);
      }
    };
    return U.createElement(
      "g",
      { className: di([
        "react-flow__edge",
        `react-flow__edge-${i}`,
        r,
        { selected: l, animated: u, inactive: ge, updating: X }
      ]), onClick: Se, onDoubleClick: de, onContextMenu: ce, onMouseEnter: pe, onMouseMove: Oe, onMouseLeave: Re, onKeyDown: H ? ve : void 0, tabIndex: H ? 0 : void 0, role: H ? "button" : "img", "data-testid": `rf__edge-${n}`, "aria-label": z === null ? void 0 : z || `Edge from ${v} to ${b}`, "aria-describedby": H ? `${rL}-${j}` : void 0, ref: Y },
      !Q && U.createElement(e, { id: n, source: v, target: b, selected: l, animated: u, label: c, labelStyle: d, labelShowBg: f, labelBgStyle: h, labelBgPadding: p, labelBgBorderRadius: g, data: o, style: m, sourceX: x, sourceY: w, targetX: C, targetY: y, sourcePosition: S, targetPosition: A, sourceHandleId: _, targetHandleId: T, markerStart: te, markerEnd: fe, pathOptions: G, interactionWidth: K }),
      W && U.createElement(
        U.Fragment,
        null,
        (W === "source" || W === !0) && U.createElement(sA, { position: S, centerX: x, centerY: w, radius: k, onMouseDown: Me, onMouseEnter: oe, onMouseOut: Ce, type: "source" }),
        (W === "target" || W === !0) && U.createElement(sA, { position: A, centerX: C, centerY: y, radius: k, onMouseDown: Ue, onMouseEnter: oe, onMouseOut: Ce, type: "target" })
      )
    );
  };
  return t.displayName = "EdgeWrapper", Sn(t);
};
function qce(e) {
  const t = {
    default: Ql(e.default || vg),
    straight: Ql(e.bezier || HC),
    step: Ql(e.step || zC),
    smoothstep: Ql(e.step || Mm),
    simplebezier: Ql(e.simplebezier || jC)
  }, n = {}, r = Object.keys(e).filter((i) => !["default", "bezier"].includes(i)).reduce((i, o) => (i[o] = Ql(e[o] || vg), i), n);
  return {
    ...t,
    ...r
  };
}
function aA(e, t, n = null) {
  const r = ((n == null ? void 0 : n.x) || 0) + t.x, i = ((n == null ? void 0 : n.y) || 0) + t.y, o = (n == null ? void 0 : n.width) || t.width, s = (n == null ? void 0 : n.height) || t.height;
  switch (e) {
    case bt.Top:
      return {
        x: r + o / 2,
        y: i
      };
    case bt.Right:
      return {
        x: r + o,
        y: i + s / 2
      };
    case bt.Bottom:
      return {
        x: r + o / 2,
        y: i + s
      };
    case bt.Left:
      return {
        x: r,
        y: i + s / 2
      };
  }
}
function lA(e, t) {
  return e ? e.length === 1 || !t ? e[0] : t && e.find((n) => n.id === t) || null : null;
}
const Qce = (e, t, n, r, i, o) => {
  const s = aA(n, e, t), a = aA(o, r, i);
  return {
    sourceX: s.x,
    sourceY: s.y,
    targetX: a.x,
    targetY: a.y
  };
};
function Zce({ sourcePos: e, targetPos: t, sourceWidth: n, sourceHeight: r, targetWidth: i, targetHeight: o, width: s, height: a, transform: l }) {
  const u = {
    x: Math.min(e.x, t.x),
    y: Math.min(e.y, t.y),
    x2: Math.max(e.x + n, t.x + i),
    y2: Math.max(e.y + r, t.y + o)
  };
  u.x === u.x2 && (u.x2 += 1), u.y === u.y2 && (u.y2 += 1);
  const c = BC({
    x: (0 - l[0]) / l[2],
    y: (0 - l[1]) / l[2],
    width: s / l[2],
    height: a / l[2]
  }), d = Math.max(0, Math.min(c.x2, u.x2) - Math.max(c.x, u.x)), f = Math.max(0, Math.min(c.y2, u.y2) - Math.max(c.y, u.y));
  return Math.ceil(d * f) > 0;
}
function cA(e) {
  var r, i, o, s, a;
  const t = ((r = e == null ? void 0 : e[fr]) == null ? void 0 : r.handleBounds) || null, n = t && (e == null ? void 0 : e.width) && (e == null ? void 0 : e.height) && typeof ((i = e == null ? void 0 : e.positionAbsolute) == null ? void 0 : i.x) < "u" && typeof ((o = e == null ? void 0 : e.positionAbsolute) == null ? void 0 : o.y) < "u";
  return [
    {
      x: ((s = e == null ? void 0 : e.positionAbsolute) == null ? void 0 : s.x) || 0,
      y: ((a = e == null ? void 0 : e.positionAbsolute) == null ? void 0 : a.y) || 0,
      width: (e == null ? void 0 : e.width) || 0,
      height: (e == null ? void 0 : e.height) || 0
    },
    t,
    !!n
  ];
}
const Jce = [{ level: 0, isMaxLevel: !0, edges: [] }];
function eue(e, t, n = !1) {
  let r = -1;
  const i = e.reduce((s, a) => {
    var c, d;
    const l = Ji(a.zIndex);
    let u = l ? a.zIndex : 0;
    if (n) {
      const f = t.get(a.target), h = t.get(a.source), p = a.selected || (f == null ? void 0 : f.selected) || (h == null ? void 0 : h.selected), g = Math.max(((c = h == null ? void 0 : h[fr]) == null ? void 0 : c.z) || 0, ((d = f == null ? void 0 : f[fr]) == null ? void 0 : d.z) || 0, 1e3);
      u = (l ? a.zIndex : 0) + (p ? g : 0);
    }
    return s[u] ? s[u].push(a) : s[u] = [a], r = u > r ? u : r, s;
  }, {}), o = Object.entries(i).map(([s, a]) => {
    const l = +s;
    return {
      edges: a,
      level: l,
      isMaxLevel: l === r
    };
  });
  return o.length === 0 ? Jce : o;
}
function tue(e, t, n) {
  const r = jn(Kt((i) => e ? i.edges.filter((o) => {
    const s = t.get(o.source), a = t.get(o.target);
    return (s == null ? void 0 : s.width) && (s == null ? void 0 : s.height) && (a == null ? void 0 : a.width) && (a == null ? void 0 : a.height) && Zce({
      sourcePos: s.positionAbsolute || { x: 0, y: 0 },
      targetPos: a.positionAbsolute || { x: 0, y: 0 },
      sourceWidth: s.width,
      sourceHeight: s.height,
      targetWidth: a.width,
      targetHeight: a.height,
      width: i.width,
      height: i.height,
      transform: i.transform
    });
  }) : i.edges, [e, t]));
  return eue(r, t, n);
}
const nue = ({ color: e = "none", strokeWidth: t = 1 }) => U.createElement("polyline", { style: {
  stroke: e,
  strokeWidth: t
}, strokeLinecap: "round", strokeLinejoin: "round", fill: "none", points: "-5,-4 0,0 -5,4" }), rue = ({ color: e = "none", strokeWidth: t = 1 }) => U.createElement("polyline", { style: {
  stroke: e,
  fill: e,
  strokeWidth: t
}, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" }), uA = {
  [ef.Arrow]: nue,
  [ef.ArrowClosed]: rue
};
function iue(e) {
  const t = xr();
  return mt(() => {
    var i, o;
    return Object.prototype.hasOwnProperty.call(uA, e) ? uA[e] : ((o = (i = t.getState()).onError) == null || o.call(i, "009", _o.error009(e)), null);
  }, [e]);
}
const oue = ({ id: e, type: t, color: n, width: r = 12.5, height: i = 12.5, markerUnits: o = "strokeWidth", strokeWidth: s, orient: a = "auto-start-reverse" }) => {
  const l = iue(t);
  return l ? U.createElement(
    "marker",
    { className: "react-flow__arrowhead", id: e, markerWidth: `${r}`, markerHeight: `${i}`, viewBox: "-10 -10 20 20", markerUnits: o, orient: a, refX: "0", refY: "0" },
    U.createElement(l, { color: n, strokeWidth: s })
  ) : null;
}, sue = ({ defaultColor: e, rfId: t }) => (n) => {
  const r = [];
  return n.edges.reduce((i, o) => ([o.markerStart, o.markerEnd].forEach((s) => {
    if (s && typeof s == "object") {
      const a = ew(s, t);
      r.includes(a) || (i.push({ id: a, color: s.color || e, ...s }), r.push(a));
    }
  }), i), []).sort((i, o) => i.id.localeCompare(o.id));
}, mL = ({ defaultColor: e, rfId: t }) => {
  const n = jn(
    Kt(sue({ defaultColor: e, rfId: t }), [e, t]),
    // the id includes all marker options, so we just need to look at that part of the marker
    (r, i) => !(r.length !== i.length || r.some((o, s) => o.id !== i[s].id))
  );
  return U.createElement("defs", null, n.map((r) => U.createElement(oue, { id: r.id, key: r.id, type: r.type, color: r.color, width: r.width, height: r.height, markerUnits: r.markerUnits, strokeWidth: r.strokeWidth, orient: r.orient })));
};
mL.displayName = "MarkerDefinitions";
var aue = Sn(mL);
const lue = (e) => ({
  nodesConnectable: e.nodesConnectable,
  edgesFocusable: e.edgesFocusable,
  edgesUpdatable: e.edgesUpdatable,
  elementsSelectable: e.elementsSelectable,
  width: e.width,
  height: e.height,
  connectionMode: e.connectionMode,
  nodeInternals: e.nodeInternals,
  onError: e.onError
}), vL = ({ defaultMarkerColor: e, onlyRenderVisibleElements: t, elevateEdgesOnSelect: n, rfId: r, edgeTypes: i, noPanClassName: o, onEdgeUpdate: s, onEdgeContextMenu: a, onEdgeMouseEnter: l, onEdgeMouseMove: u, onEdgeMouseLeave: c, onEdgeClick: d, edgeUpdaterRadius: f, onEdgeDoubleClick: h, onEdgeUpdateStart: p, onEdgeUpdateEnd: g, children: m }) => {
  const { edgesFocusable: v, edgesUpdatable: b, elementsSelectable: x, width: w, height: C, connectionMode: y, nodeInternals: S, onError: A } = jn(lue, Pr), $ = tue(t, S, n);
  return w ? U.createElement(
    U.Fragment,
    null,
    $.map(({ level: M, edges: _, isMaxLevel: T }) => U.createElement(
      "svg",
      { key: M, style: { zIndex: M }, width: w, height: C, className: "react-flow__edges react-flow__container" },
      T && U.createElement(aue, { defaultColor: e, rfId: r }),
      U.createElement("g", null, _.map((D) => {
        const [E, R, I] = cA(S.get(D.source)), [k, P, L] = cA(S.get(D.target));
        if (!I || !L)
          return null;
        let N = D.type || "default";
        i[N] || (A == null || A("011", _o.error011(N)), N = "default");
        const F = i[N] || i.default, B = y === cl.Strict ? P.target : (P.target ?? []).concat(P.source ?? []), j = lA(R.source, D.sourceHandle), z = lA(B, D.targetHandle), H = (j == null ? void 0 : j.position) || bt.Bottom, W = (z == null ? void 0 : z.position) || bt.Top, G = !!(D.focusable || v && typeof D.focusable > "u"), K = typeof s < "u" && (D.updatable || b && typeof D.updatable > "u");
        if (!j || !z)
          return A == null || A("008", _o.error008(j, D)), null;
        const { sourceX: Y, sourceY: X, targetX: Z, targetY: Q } = Qce(E, j, H, k, z, W);
        return U.createElement(F, { key: D.id, id: D.id, className: di([D.className, o]), type: N, data: D.data, selected: !!D.selected, animated: !!D.animated, hidden: !!D.hidden, label: D.label, labelStyle: D.labelStyle, labelShowBg: D.labelShowBg, labelBgStyle: D.labelBgStyle, labelBgPadding: D.labelBgPadding, labelBgBorderRadius: D.labelBgBorderRadius, style: D.style, source: D.source, target: D.target, sourceHandleId: D.sourceHandle, targetHandleId: D.targetHandle, markerEnd: D.markerEnd, markerStart: D.markerStart, sourceX: Y, sourceY: X, targetX: Z, targetY: Q, sourcePosition: H, targetPosition: W, elementsSelectable: x, onEdgeUpdate: s, onContextMenu: a, onMouseEnter: l, onMouseMove: u, onMouseLeave: c, onClick: d, edgeUpdaterRadius: f, onEdgeDoubleClick: h, onEdgeUpdateStart: p, onEdgeUpdateEnd: g, rfId: r, ariaLabel: D.ariaLabel, isFocusable: G, isUpdatable: K, pathOptions: "pathOptions" in D ? D.pathOptions : void 0, interactionWidth: D.interactionWidth });
      }))
    )),
    m
  ) : null;
};
vL.displayName = "EdgeRenderer";
var cue = Sn(vL);
const uue = (e) => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`;
function due({ children: e }) {
  const t = jn(uue);
  return U.createElement("div", { className: "react-flow__viewport react-flow__container", style: { transform: t } }, e);
}
function fue(e) {
  const t = XC(), n = he(!1);
  Pe(() => {
    !n.current && t.viewportInitialized && e && (setTimeout(() => e(t), 1), n.current = !0);
  }, [e, t.viewportInitialized]);
}
const hue = {
  [bt.Left]: bt.Right,
  [bt.Right]: bt.Left,
  [bt.Top]: bt.Bottom,
  [bt.Bottom]: bt.Top
}, bL = ({ nodeId: e, handleType: t, style: n, type: r = Ks.Bezier, CustomComponent: i, connectionStatus: o }) => {
  var y, S, A;
  const { fromNode: s, handleId: a, toX: l, toY: u, connectionMode: c } = jn(Kt(($) => ({
    fromNode: $.nodeInternals.get(e),
    handleId: $.connectionHandleId,
    toX: ($.connectionPosition.x - $.transform[0]) / $.transform[2],
    toY: ($.connectionPosition.y - $.transform[1]) / $.transform[2],
    connectionMode: $.connectionMode
  }), [e]), Pr), d = (y = s == null ? void 0 : s[fr]) == null ? void 0 : y.handleBounds;
  let f = d == null ? void 0 : d[t];
  if (c === cl.Loose && (f = f || (d == null ? void 0 : d[t === "source" ? "target" : "source"])), !s || !f)
    return null;
  const h = a ? f.find(($) => $.id === a) : f[0], p = h ? h.x + h.width / 2 : (s.width ?? 0) / 2, g = h ? h.y + h.height / 2 : s.height ?? 0, m = (((S = s.positionAbsolute) == null ? void 0 : S.x) ?? 0) + p, v = (((A = s.positionAbsolute) == null ? void 0 : A.y) ?? 0) + g, b = h == null ? void 0 : h.position, x = b ? hue[b] : null;
  if (!b || !x)
    return null;
  if (i)
    return U.createElement(i, { connectionLineType: r, connectionLineStyle: n, fromNode: s, fromHandle: h, fromX: m, fromY: v, toX: l, toY: u, fromPosition: b, toPosition: x, connectionStatus: o });
  let w = "";
  const C = {
    sourceX: m,
    sourceY: v,
    sourcePosition: b,
    targetX: l,
    targetY: u,
    targetPosition: x
  };
  return r === Ks.Bezier ? [w] = VC(C) : r === Ks.Step ? [w] = Jy({
    ...C,
    borderRadius: 0
  }) : r === Ks.SmoothStep ? [w] = Jy(C) : r === Ks.SimpleBezier ? [w] = zN(C) : w = `M${m},${v} ${l},${u}`, U.createElement("path", { d: w, fill: "none", className: "react-flow__connection-path", style: n });
};
bL.displayName = "ConnectionLine";
const pue = (e) => ({
  nodeId: e.connectionNodeId,
  handleType: e.connectionHandleType,
  nodesConnectable: e.nodesConnectable,
  connectionStatus: e.connectionStatus,
  width: e.width,
  height: e.height
});
function gue({ containerStyle: e, style: t, type: n, component: r }) {
  const { nodeId: i, handleType: o, nodesConnectable: s, width: a, height: l, connectionStatus: u } = jn(pue, Pr);
  return !(i && o && a && s) ? null : U.createElement(
    "svg",
    { style: e, width: a, height: l, className: "react-flow__edges react-flow__connectionline react-flow__container" },
    U.createElement(
      "g",
      { className: di(["react-flow__connection", u]) },
      U.createElement(bL, { nodeId: i, handleType: o, style: t, type: n, CustomComponent: r, connectionStatus: u })
    )
  );
}
function dA(e, t) {
  const n = he(null), r = xr();
  return mt(() => {
    var o, s;
    if (process.env.NODE_ENV === "development") {
      const a = Object.keys(e);
      Pr(n.current, a) && ((s = (o = r.getState()).onError) == null || s.call(o, "002", _o.error002())), n.current = a;
    }
    return t(e);
  }, [e]);
}
const yL = ({ nodeTypes: e, edgeTypes: t, onMove: n, onMoveStart: r, onMoveEnd: i, onInit: o, onNodeClick: s, onEdgeClick: a, onNodeDoubleClick: l, onEdgeDoubleClick: u, onNodeMouseEnter: c, onNodeMouseMove: d, onNodeMouseLeave: f, onNodeContextMenu: h, onSelectionContextMenu: p, onSelectionStart: g, onSelectionEnd: m, connectionLineType: v, connectionLineStyle: b, connectionLineComponent: x, connectionLineContainerStyle: w, selectionKeyCode: C, selectionOnDrag: y, selectionMode: S, multiSelectionKeyCode: A, panActivationKeyCode: $, zoomActivationKeyCode: M, deleteKeyCode: _, onlyRenderVisibleElements: T, elementsSelectable: D, selectNodesOnDrag: E, defaultViewport: R, translateExtent: I, minZoom: k, maxZoom: P, preventScrolling: L, defaultMarkerColor: N, zoomOnScroll: F, zoomOnPinch: B, panOnScroll: j, panOnScrollSpeed: z, panOnScrollMode: H, zoomOnDoubleClick: W, panOnDrag: G, onPaneClick: K, onPaneMouseEnter: Y, onPaneMouseMove: X, onPaneMouseLeave: Z, onPaneScroll: Q, onPaneContextMenu: ne, onEdgeUpdate: q, onEdgeContextMenu: te, onEdgeMouseEnter: fe, onEdgeMouseMove: Se, onEdgeMouseLeave: de, edgeUpdaterRadius: ce, onEdgeUpdateStart: pe, onEdgeUpdateEnd: Oe, noDragClassName: Re, noWheelClassName: De, noPanClassName: Me, elevateEdgesOnSelect: Ue, disableKeyboardA11y: oe, nodeOrigin: Ce, nodeExtent: ge, rfId: ve }) => {
  const me = dA(e, Vce), Fe = dA(t, qce);
  return fue(o), U.createElement(
    zce,
    { onPaneClick: K, onPaneMouseEnter: Y, onPaneMouseMove: X, onPaneMouseLeave: Z, onPaneContextMenu: ne, onPaneScroll: Q, deleteKeyCode: _, selectionKeyCode: C, selectionOnDrag: y, selectionMode: S, onSelectionStart: g, onSelectionEnd: m, multiSelectionKeyCode: A, panActivationKeyCode: $, zoomActivationKeyCode: M, elementsSelectable: D, onMove: n, onMoveStart: r, onMoveEnd: i, zoomOnScroll: F, zoomOnPinch: B, zoomOnDoubleClick: W, panOnScroll: j, panOnScrollSpeed: z, panOnScrollMode: H, panOnDrag: G, defaultViewport: R, translateExtent: I, minZoom: k, maxZoom: P, onSelectionContextMenu: p, preventScrolling: L, noDragClassName: Re, noWheelClassName: De, noPanClassName: Me, disableKeyboardA11y: oe },
    U.createElement(
      due,
      null,
      U.createElement(
        cue,
        { edgeTypes: Fe, onEdgeClick: a, onEdgeDoubleClick: u, onEdgeUpdate: q, onlyRenderVisibleElements: T, onEdgeContextMenu: te, onEdgeMouseEnter: fe, onEdgeMouseMove: Se, onEdgeMouseLeave: de, onEdgeUpdateStart: pe, onEdgeUpdateEnd: Oe, edgeUpdaterRadius: ce, defaultMarkerColor: N, noPanClassName: Me, elevateEdgesOnSelect: !!Ue, disableKeyboardA11y: oe, rfId: ve },
        U.createElement(gue, { style: b, type: v, component: x, containerStyle: w })
      ),
      U.createElement("div", { className: "react-flow__edgelabel-renderer" }),
      U.createElement(Gce, { nodeTypes: me, onNodeClick: s, onNodeDoubleClick: l, onNodeMouseEnter: c, onNodeMouseMove: d, onNodeMouseLeave: f, onNodeContextMenu: h, selectNodesOnDrag: E, onlyRenderVisibleElements: T, noPanClassName: Me, noDragClassName: Re, disableKeyboardA11y: oe, nodeOrigin: Ce, nodeExtent: ge, rfId: ve })
    )
  );
};
yL.displayName = "GraphView";
var mue = Sn(yL);
const iw = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
], Fs = {
  rfId: "1",
  width: 0,
  height: 0,
  transform: [0, 0, 1],
  nodeInternals: /* @__PURE__ */ new Map(),
  edges: [],
  onNodesChange: null,
  onEdgesChange: null,
  hasDefaultNodes: !1,
  hasDefaultEdges: !1,
  d3Zoom: null,
  d3Selection: null,
  d3ZoomHandler: void 0,
  minZoom: 0.5,
  maxZoom: 2,
  translateExtent: iw,
  nodeExtent: iw,
  nodesSelectionActive: !1,
  userSelectionActive: !1,
  userSelectionRect: null,
  connectionNodeId: null,
  connectionHandleId: null,
  connectionHandleType: "source",
  connectionPosition: { x: 0, y: 0 },
  connectionStatus: null,
  connectionMode: cl.Strict,
  domNode: null,
  paneDragging: !1,
  noPanClassName: "nopan",
  nodeOrigin: [0, 0],
  nodeDragThreshold: 0,
  snapGrid: [15, 15],
  snapToGrid: !1,
  nodesDraggable: !0,
  nodesConnectable: !0,
  nodesFocusable: !0,
  edgesFocusable: !0,
  edgesUpdatable: !0,
  elementsSelectable: !0,
  elevateNodesOnSelect: !0,
  fitViewOnInit: !1,
  fitViewOnInitDone: !1,
  fitViewOnInitOptions: void 0,
  onSelectionChange: [],
  multiSelectionActive: !1,
  connectionStartHandle: null,
  connectionEndHandle: null,
  connectionClickStartHandle: null,
  connectOnClick: !0,
  ariaLiveMessage: "",
  autoPanOnConnect: !0,
  autoPanOnNodeDrag: !0,
  connectionRadius: 20,
  onError: LN,
  isValidConnection: void 0
}, vue = () => roe((e, t) => ({
  ...Fs,
  setNodes: (n) => {
    const { nodeInternals: r, nodeOrigin: i, elevateNodesOnSelect: o } = t();
    e({ nodeInternals: b0(n, r, i, o) });
  },
  getNodes: () => Array.from(t().nodeInternals.values()),
  setEdges: (n) => {
    const { defaultEdgeOptions: r = {} } = t();
    e({ edges: n.map((i) => ({ ...r, ...i })) });
  },
  setDefaultNodesAndEdges: (n, r) => {
    const i = typeof n < "u", o = typeof r < "u", s = i ? b0(n, /* @__PURE__ */ new Map(), t().nodeOrigin, t().elevateNodesOnSelect) : /* @__PURE__ */ new Map();
    e({ nodeInternals: s, edges: o ? r : [], hasDefaultNodes: i, hasDefaultEdges: o });
  },
  updateNodeDimensions: (n) => {
    const { onNodesChange: r, nodeInternals: i, fitViewOnInit: o, fitViewOnInitDone: s, fitViewOnInitOptions: a, domNode: l, nodeOrigin: u } = t(), c = l == null ? void 0 : l.querySelector(".react-flow__viewport");
    if (!c)
      return;
    const d = window.getComputedStyle(c), { m22: f } = new window.DOMMatrixReadOnly(d.transform), h = n.reduce((g, m) => {
      const v = i.get(m.id);
      if (v) {
        const b = LC(m.nodeElement);
        !!(b.width && b.height && (v.width !== b.width || v.height !== b.height || m.forceUpdate)) && (i.set(v.id, {
          ...v,
          [fr]: {
            ...v[fr],
            handleBounds: {
              source: iA(".source", m.nodeElement, f, u),
              target: iA(".target", m.nodeElement, f, u)
            }
          },
          ...b
        }), g.push({
          id: v.id,
          type: "dimensions",
          dimensions: b
        }));
      }
      return g;
    }, []);
    oL(i, u);
    const p = s || o && !s && sL(t, { initial: !0, ...a });
    e({ nodeInternals: new Map(i), fitViewOnInitDone: p }), (h == null ? void 0 : h.length) > 0 && (r == null || r(h));
  },
  updateNodePositions: (n, r = !0, i = !1) => {
    const { triggerNodeChanges: o } = t(), s = n.map((a) => {
      const l = {
        id: a.id,
        type: "position",
        dragging: i
      };
      return r && (l.positionAbsolute = a.positionAbsolute, l.position = a.position), l;
    });
    o(s);
  },
  triggerNodeChanges: (n) => {
    const { onNodesChange: r, nodeInternals: i, hasDefaultNodes: o, nodeOrigin: s, getNodes: a, elevateNodesOnSelect: l } = t();
    if (n != null && n.length) {
      if (o) {
        const u = lL(n, a()), c = b0(u, i, s, l);
        e({ nodeInternals: c });
      }
      r == null || r(n);
    }
  },
  addSelectedNodes: (n) => {
    const { multiSelectionActive: r, edges: i, getNodes: o } = t();
    let s, a = null;
    r ? s = n.map((l) => Ws(l, !0)) : (s = lc(o(), n), a = lc(i, [])), Bh({
      changedNodes: s,
      changedEdges: a,
      get: t,
      set: e
    });
  },
  addSelectedEdges: (n) => {
    const { multiSelectionActive: r, edges: i, getNodes: o } = t();
    let s, a = null;
    r ? s = n.map((l) => Ws(l, !0)) : (s = lc(i, n), a = lc(o(), [])), Bh({
      changedNodes: a,
      changedEdges: s,
      get: t,
      set: e
    });
  },
  unselectNodesAndEdges: ({ nodes: n, edges: r } = {}) => {
    const { edges: i, getNodes: o } = t(), s = n || o(), a = r || i, l = s.map((c) => (c.selected = !1, Ws(c.id, !1))), u = a.map((c) => Ws(c.id, !1));
    Bh({
      changedNodes: l,
      changedEdges: u,
      get: t,
      set: e
    });
  },
  setMinZoom: (n) => {
    const { d3Zoom: r, maxZoom: i } = t();
    r == null || r.scaleExtent([n, i]), e({ minZoom: n });
  },
  setMaxZoom: (n) => {
    const { d3Zoom: r, minZoom: i } = t();
    r == null || r.scaleExtent([i, n]), e({ maxZoom: n });
  },
  setTranslateExtent: (n) => {
    var r;
    (r = t().d3Zoom) == null || r.translateExtent(n), e({ translateExtent: n });
  },
  resetSelectedElements: () => {
    const { edges: n, getNodes: r } = t(), o = r().filter((a) => a.selected).map((a) => Ws(a.id, !1)), s = n.filter((a) => a.selected).map((a) => Ws(a.id, !1));
    Bh({
      changedNodes: o,
      changedEdges: s,
      get: t,
      set: e
    });
  },
  setNodeExtent: (n) => {
    const { nodeInternals: r } = t();
    r.forEach((i) => {
      i.positionAbsolute = FC(i.position, n);
    }), e({
      nodeExtent: n,
      nodeInternals: new Map(r)
    });
  },
  panBy: (n) => {
    const { transform: r, width: i, height: o, d3Zoom: s, d3Selection: a, translateExtent: l } = t();
    if (!s || !a || !n.x && !n.y)
      return !1;
    const u = ia.translate(r[0] + n.x, r[1] + n.y).scale(r[2]), c = [
      [0, 0],
      [i, o]
    ], d = s == null ? void 0 : s.constrain()(u, c, l);
    return s.transform(a, d), r[0] !== d.x || r[1] !== d.y || r[2] !== d.k;
  },
  cancelConnection: () => e({
    connectionNodeId: Fs.connectionNodeId,
    connectionHandleId: Fs.connectionHandleId,
    connectionHandleType: Fs.connectionHandleType,
    connectionStatus: Fs.connectionStatus,
    connectionStartHandle: Fs.connectionStartHandle,
    connectionEndHandle: Fs.connectionEndHandle
  }),
  reset: () => e({ ...Fs })
}), Object.is), qC = ({ children: e }) => {
  const t = he(null);
  return t.current || (t.current = vue()), U.createElement(Nle, { value: t.current }, e);
};
qC.displayName = "ReactFlowProvider";
const wL = ({ children: e }) => Yt(Rm) ? U.createElement(U.Fragment, null, e) : U.createElement(qC, null, e);
wL.displayName = "ReactFlowWrapper";
const bue = {
  input: ZN,
  default: nw,
  output: eL,
  group: KC
}, yue = {
  default: vg,
  straight: HC,
  step: zC,
  smoothstep: Mm,
  simplebezier: jC
}, wue = [0, 0], Cue = [15, 15], Sue = { x: 0, y: 0, zoom: 1 }, xue = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
}, CL = li(({ nodes: e, edges: t, defaultNodes: n, defaultEdges: r, className: i, nodeTypes: o = bue, edgeTypes: s = yue, onNodeClick: a, onEdgeClick: l, onInit: u, onMove: c, onMoveStart: d, onMoveEnd: f, onConnect: h, onConnectStart: p, onConnectEnd: g, onClickConnectStart: m, onClickConnectEnd: v, onNodeMouseEnter: b, onNodeMouseMove: x, onNodeMouseLeave: w, onNodeContextMenu: C, onNodeDoubleClick: y, onNodeDragStart: S, onNodeDrag: A, onNodeDragStop: $, onNodesDelete: M, onEdgesDelete: _, onSelectionChange: T, onSelectionDragStart: D, onSelectionDrag: E, onSelectionDragStop: R, onSelectionContextMenu: I, onSelectionStart: k, onSelectionEnd: P, connectionMode: L = cl.Strict, connectionLineType: N = Ks.Bezier, connectionLineStyle: F, connectionLineComponent: B, connectionLineContainerStyle: j, deleteKeyCode: z = "Backspace", selectionKeyCode: H = "Shift", selectionOnDrag: W = !1, selectionMode: G = Jd.Full, panActivationKeyCode: K = "Space", multiSelectionKeyCode: Y = mg() ? "Meta" : "Control", zoomActivationKeyCode: X = mg() ? "Meta" : "Control", snapToGrid: Z = !1, snapGrid: Q = Cue, onlyRenderVisibleElements: ne = !1, selectNodesOnDrag: q = !0, nodesDraggable: te, nodesConnectable: fe, nodesFocusable: Se, nodeOrigin: de = wue, edgesFocusable: ce, edgesUpdatable: pe, elementsSelectable: Oe, defaultViewport: Re = Sue, minZoom: De = 0.5, maxZoom: Me = 2, translateExtent: Ue = iw, preventScrolling: oe = !0, nodeExtent: Ce, defaultMarkerColor: ge = "#b1b1b7", zoomOnScroll: ve = !0, zoomOnPinch: me = !0, panOnScroll: Fe = !1, panOnScrollSpeed: Be = 0.5, panOnScrollMode: qe = Va.Free, zoomOnDoubleClick: Ve = !0, panOnDrag: We = !0, onPaneClick: Ge, onPaneMouseEnter: $e, onPaneMouseMove: ze, onPaneMouseLeave: at, onPaneScroll: xt, onPaneContextMenu: jt, children: Lt, onEdgeUpdate: At, onEdgeContextMenu: Et, onEdgeDoubleClick: nt, onEdgeMouseEnter: it, onEdgeMouseMove: je, onEdgeMouseLeave: Le, onEdgeUpdateStart: ot, onEdgeUpdateEnd: yt, edgeUpdaterRadius: He = 10, onNodesChange: Je, onEdgesChange: Qe, noDragClassName: lt = "nodrag", noWheelClassName: pt = "nowheel", noPanClassName: vt = "nopan", fitView: ee = !1, fitViewOptions: be, connectOnClick: Ee = !0, attributionPosition: ye, proOptions: Ke, defaultEdgeOptions: et, elevateNodesOnSelect: Ie = !0, elevateEdgesOnSelect: Ae = !1, disableKeyboardA11y: tt = !1, autoPanOnConnect: dt = !0, autoPanOnNodeDrag: Tt = !0, connectionRadius: Ct = 20, isValidConnection: vn, onError: Hn, style: pn, id: Qn, nodeDragThreshold: Fr, ...Qr }, Br) => {
  const gr = Qn || "1";
  return U.createElement(
    "div",
    { ...Qr, style: { ...pn, ...xue }, ref: Br, className: di(["react-flow", i]), "data-testid": "rf__wrapper", id: Qn },
    U.createElement(
      wL,
      null,
      U.createElement(mue, { onInit: u, onMove: c, onMoveStart: d, onMoveEnd: f, onNodeClick: a, onEdgeClick: l, onNodeMouseEnter: b, onNodeMouseMove: x, onNodeMouseLeave: w, onNodeContextMenu: C, onNodeDoubleClick: y, nodeTypes: o, edgeTypes: s, connectionLineType: N, connectionLineStyle: F, connectionLineComponent: B, connectionLineContainerStyle: j, selectionKeyCode: H, selectionOnDrag: W, selectionMode: G, deleteKeyCode: z, multiSelectionKeyCode: Y, panActivationKeyCode: K, zoomActivationKeyCode: X, onlyRenderVisibleElements: ne, selectNodesOnDrag: q, defaultViewport: Re, translateExtent: Ue, minZoom: De, maxZoom: Me, preventScrolling: oe, zoomOnScroll: ve, zoomOnPinch: me, zoomOnDoubleClick: Ve, panOnScroll: Fe, panOnScrollSpeed: Be, panOnScrollMode: qe, panOnDrag: We, onPaneClick: Ge, onPaneMouseEnter: $e, onPaneMouseMove: ze, onPaneMouseLeave: at, onPaneScroll: xt, onPaneContextMenu: jt, onSelectionContextMenu: I, onSelectionStart: k, onSelectionEnd: P, onEdgeUpdate: At, onEdgeContextMenu: Et, onEdgeDoubleClick: nt, onEdgeMouseEnter: it, onEdgeMouseMove: je, onEdgeMouseLeave: Le, onEdgeUpdateStart: ot, onEdgeUpdateEnd: yt, edgeUpdaterRadius: He, defaultMarkerColor: ge, noDragClassName: lt, noWheelClassName: pt, noPanClassName: vt, elevateEdgesOnSelect: Ae, rfId: gr, disableKeyboardA11y: tt, nodeOrigin: de, nodeExtent: Ce }),
      U.createElement(hce, { nodes: e, edges: t, defaultNodes: n, defaultEdges: r, onConnect: h, onConnectStart: p, onConnectEnd: g, onClickConnectStart: m, onClickConnectEnd: v, nodesDraggable: te, nodesConnectable: fe, nodesFocusable: Se, edgesFocusable: ce, edgesUpdatable: pe, elementsSelectable: Oe, elevateNodesOnSelect: Ie, minZoom: De, maxZoom: Me, nodeExtent: Ce, onNodesChange: Je, onEdgesChange: Qe, snapToGrid: Z, snapGrid: Q, connectionMode: L, translateExtent: Ue, connectOnClick: Ee, defaultEdgeOptions: et, fitView: ee, fitViewOptions: be, onNodesDelete: M, onEdgesDelete: _, onNodeDragStart: S, onNodeDrag: A, onNodeDragStop: $, onSelectionDrag: E, onSelectionDragStart: D, onSelectionDragStop: R, noPanClassName: vt, nodeOrigin: de, rfId: gr, autoPanOnConnect: dt, autoPanOnNodeDrag: Tt, onError: Hn, connectionRadius: Ct, isValidConnection: vn, nodeDragThreshold: Fr }),
      U.createElement(dce, { onSelectionChange: T }),
      Lt,
      U.createElement(Fle, { proOptions: Ke, position: ye }),
      U.createElement(bce, { rfId: gr, disableKeyboardA11y: tt })
    )
  );
});
CL.displayName = "ReactFlow";
const Eue = (e) => {
  var t;
  return (t = e.domNode) == null ? void 0 : t.querySelector(".react-flow__edgelabel-renderer");
};
function $ue({ children: e }) {
  const t = jn(Eue);
  return t ? gw(e, t) : null;
}
function SL(e) {
  return (t) => {
    const [n, r] = ht(t), i = Kt((o) => r((s) => e(o, s)), []);
    return [n, r, i];
  };
}
const Oue = SL(lL), Aue = SL(Mce);
function Due() {
  return U.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32" },
    U.createElement("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" })
  );
}
function _ue() {
  return U.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5" },
    U.createElement("path", { d: "M0 0h32v4.2H0z" })
  );
}
function Tue() {
  return U.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30" },
    U.createElement("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" })
  );
}
function Rue() {
  return U.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32" },
    U.createElement("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" })
  );
}
function Mue() {
  return U.createElement(
    "svg",
    { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32" },
    U.createElement("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" })
  );
}
const Wu = ({ children: e, className: t, ...n }) => U.createElement("button", { type: "button", className: di(["react-flow__controls-button", t]), ...n }, e);
Wu.displayName = "ControlButton";
const Iue = (e) => ({
  isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable,
  minZoomReached: e.transform[2] <= e.minZoom,
  maxZoomReached: e.transform[2] >= e.maxZoom
}), xL = ({ style: e, showZoom: t = !0, showFitView: n = !0, showInteractive: r = !0, fitViewOptions: i, onZoomIn: o, onZoomOut: s, onFitView: a, onInteractiveChange: l, className: u, children: c, position: d = "bottom-left" }) => {
  const f = xr(), [h, p] = ht(!1), { isInteractive: g, minZoomReached: m, maxZoomReached: v } = jn(Iue, Pr), { zoomIn: b, zoomOut: x, fitView: w } = XC();
  if (Pe(() => {
    p(!0);
  }, []), !h)
    return null;
  const C = () => {
    b(), o == null || o();
  }, y = () => {
    x(), s == null || s();
  }, S = () => {
    w(i), a == null || a();
  }, A = () => {
    f.setState({
      nodesDraggable: !g,
      nodesConnectable: !g,
      elementsSelectable: !g
    }), l == null || l(!g);
  };
  return U.createElement(
    IN,
    { className: di(["react-flow__controls", u]), position: d, style: e, "data-testid": "rf__controls" },
    t && U.createElement(
      U.Fragment,
      null,
      U.createElement(
        Wu,
        { onClick: C, className: "react-flow__controls-zoomin", title: "zoom in", "aria-label": "zoom in", disabled: v },
        U.createElement(Due, null)
      ),
      U.createElement(
        Wu,
        { onClick: y, className: "react-flow__controls-zoomout", title: "zoom out", "aria-label": "zoom out", disabled: m },
        U.createElement(_ue, null)
      )
    ),
    n && U.createElement(
      Wu,
      { className: "react-flow__controls-fitview", onClick: S, title: "fit view", "aria-label": "fit view" },
      U.createElement(Tue, null)
    ),
    r && U.createElement(Wu, { className: "react-flow__controls-interactive", onClick: A, title: "toggle interactivity", "aria-label": "toggle interactivity" }, g ? U.createElement(Mue, null) : U.createElement(Rue, null)),
    c
  );
};
xL.displayName = "Controls";
var kue = Sn(xL), So;
(function(e) {
  e.Lines = "lines", e.Dots = "dots", e.Cross = "cross";
})(So || (So = {}));
function Pue({ color: e, dimensions: t, lineWidth: n }) {
  return U.createElement("path", { stroke: e, strokeWidth: n, d: `M${t[0] / 2} 0 V${t[1]} M0 ${t[1] / 2} H${t[0]}` });
}
function Nue({ color: e, radius: t }) {
  return U.createElement("circle", { cx: t, cy: t, r: t, fill: e });
}
const Lue = {
  [So.Dots]: "#91919a",
  [So.Lines]: "#eee",
  [So.Cross]: "#e2e2e2"
}, Fue = {
  [So.Dots]: 1,
  [So.Lines]: 1,
  [So.Cross]: 6
}, Bue = (e) => ({ transform: e.transform, patternId: `pattern-${e.rfId}` });
function EL({
  id: e,
  variant: t = So.Dots,
  // only used for dots and cross
  gap: n = 20,
  // only used for lines and cross
  size: r,
  lineWidth: i = 1,
  offset: o = 2,
  color: s,
  style: a,
  className: l
}) {
  const u = he(null), { transform: c, patternId: d } = jn(Bue, Pr), f = s || Lue[t], h = r || Fue[t], p = t === So.Dots, g = t === So.Cross, m = Array.isArray(n) ? n : [n, n], v = [m[0] * c[2] || 1, m[1] * c[2] || 1], b = h * c[2], x = g ? [b, b] : v, w = p ? [b / o, b / o] : [x[0] / o, x[1] / o];
  return U.createElement(
    "svg",
    { className: di(["react-flow__background", l]), style: {
      ...a,
      position: "absolute",
      width: "100%",
      height: "100%",
      top: 0,
      left: 0
    }, ref: u, "data-testid": "rf__background" },
    U.createElement("pattern", { id: d + e, x: c[0] % v[0], y: c[1] % v[1], width: v[0], height: v[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${w[0]},-${w[1]})` }, p ? U.createElement(Nue, { color: f, radius: b / o }) : U.createElement(Pue, { dimensions: x, color: f, lineWidth: i })),
    U.createElement("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${d + e})` })
  );
}
EL.displayName = "Background";
var jue = Sn(EL), zue = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/, Hue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/, Vue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/, S0 = {
  Space_Separator: zue,
  ID_Start: Hue,
  ID_Continue: Vue
}, nr = {
  isSpaceSeparator(e) {
    return typeof e == "string" && S0.Space_Separator.test(e);
  },
  isIdStartChar(e) {
    return typeof e == "string" && (e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e === "$" || e === "_" || S0.ID_Start.test(e));
  },
  isIdContinueChar(e) {
    return typeof e == "string" && (e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e >= "0" && e <= "9" || e === "$" || e === "_" || e === "" || e === "" || S0.ID_Continue.test(e));
  },
  isDigit(e) {
    return typeof e == "string" && /[0-9]/.test(e);
  },
  isHexDigit(e) {
    return typeof e == "string" && /[0-9A-Fa-f]/.test(e);
  }
};
let ow, ri, hs, bg, va, xo, yr, QC, ld;
var Wue = function(t, n) {
  ow = String(t), ri = "start", hs = [], bg = 0, va = 1, xo = 0, yr = void 0, QC = void 0, ld = void 0;
  do
    yr = Uue(), Xue[ri]();
  while (yr.type !== "eof");
  return typeof n == "function" ? sw({ "": ld }, "", n) : ld;
};
function sw(e, t, n) {
  const r = e[t];
  if (r != null && typeof r == "object")
    if (Array.isArray(r))
      for (let i = 0; i < r.length; i++) {
        const o = String(i), s = sw(r, o, n);
        s === void 0 ? delete r[o] : Object.defineProperty(r, o, {
          value: s,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
    else
      for (const i in r) {
        const o = sw(r, i, n);
        o === void 0 ? delete r[i] : Object.defineProperty(r, i, {
          value: o,
          writable: !0,
          enumerable: !0,
          configurable: !0
        });
      }
  return n.call(e, t, r);
}
let Wt, Nt, Uu, ls, qt;
function Uue() {
  for (Wt = "default", Nt = "", Uu = !1, ls = 1; ; ) {
    qt = Cs();
    const e = $L[Wt]();
    if (e)
      return e;
  }
}
function Cs() {
  if (ow[bg])
    return String.fromCodePoint(ow.codePointAt(bg));
}
function Te() {
  const e = Cs();
  return e === `
` ? (va++, xo = 0) : e ? xo += e.length : xo++, e && (bg += e.length), e;
}
const $L = {
  default() {
    switch (qt) {
      case "	":
      case "\v":
      case "\f":
      case " ":
      case "":
      case "\uFEFF":
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        Te();
        return;
      case "/":
        Te(), Wt = "comment";
        return;
      case void 0:
        return Te(), _n("eof");
    }
    if (nr.isSpaceSeparator(qt)) {
      Te();
      return;
    }
    return $L[ri]();
  },
  comment() {
    switch (qt) {
      case "*":
        Te(), Wt = "multiLineComment";
        return;
      case "/":
        Te(), Wt = "singleLineComment";
        return;
    }
    throw Tn(Te());
  },
  multiLineComment() {
    switch (qt) {
      case "*":
        Te(), Wt = "multiLineCommentAsterisk";
        return;
      case void 0:
        throw Tn(Te());
    }
    Te();
  },
  multiLineCommentAsterisk() {
    switch (qt) {
      case "*":
        Te();
        return;
      case "/":
        Te(), Wt = "default";
        return;
      case void 0:
        throw Tn(Te());
    }
    Te(), Wt = "multiLineComment";
  },
  singleLineComment() {
    switch (qt) {
      case `
`:
      case "\r":
      case "\u2028":
      case "\u2029":
        Te(), Wt = "default";
        return;
      case void 0:
        return Te(), _n("eof");
    }
    Te();
  },
  value() {
    switch (qt) {
      case "{":
      case "[":
        return _n("punctuator", Te());
      case "n":
        return Te(), Ea("ull"), _n("null", null);
      case "t":
        return Te(), Ea("rue"), _n("boolean", !0);
      case "f":
        return Te(), Ea("alse"), _n("boolean", !1);
      case "-":
      case "+":
        Te() === "-" && (ls = -1), Wt = "sign";
        return;
      case ".":
        Nt = Te(), Wt = "decimalPointLeading";
        return;
      case "0":
        Nt = Te(), Wt = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        Nt = Te(), Wt = "decimalInteger";
        return;
      case "I":
        return Te(), Ea("nfinity"), _n("numeric", 1 / 0);
      case "N":
        return Te(), Ea("aN"), _n("numeric", NaN);
      case '"':
      case "'":
        Uu = Te() === '"', Nt = "", Wt = "string";
        return;
    }
    throw Tn(Te());
  },
  identifierNameStartEscape() {
    if (qt !== "u")
      throw Tn(Te());
    Te();
    const e = aw();
    switch (e) {
      case "$":
      case "_":
        break;
      default:
        if (!nr.isIdStartChar(e))
          throw fA();
        break;
    }
    Nt += e, Wt = "identifierName";
  },
  identifierName() {
    switch (qt) {
      case "$":
      case "_":
      case "":
      case "":
        Nt += Te();
        return;
      case "\\":
        Te(), Wt = "identifierNameEscape";
        return;
    }
    if (nr.isIdContinueChar(qt)) {
      Nt += Te();
      return;
    }
    return _n("identifier", Nt);
  },
  identifierNameEscape() {
    if (qt !== "u")
      throw Tn(Te());
    Te();
    const e = aw();
    switch (e) {
      case "$":
      case "_":
      case "":
      case "":
        break;
      default:
        if (!nr.isIdContinueChar(e))
          throw fA();
        break;
    }
    Nt += e, Wt = "identifierName";
  },
  sign() {
    switch (qt) {
      case ".":
        Nt = Te(), Wt = "decimalPointLeading";
        return;
      case "0":
        Nt = Te(), Wt = "zero";
        return;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        Nt = Te(), Wt = "decimalInteger";
        return;
      case "I":
        return Te(), Ea("nfinity"), _n("numeric", ls * (1 / 0));
      case "N":
        return Te(), Ea("aN"), _n("numeric", NaN);
    }
    throw Tn(Te());
  },
  zero() {
    switch (qt) {
      case ".":
        Nt += Te(), Wt = "decimalPoint";
        return;
      case "e":
      case "E":
        Nt += Te(), Wt = "decimalExponent";
        return;
      case "x":
      case "X":
        Nt += Te(), Wt = "hexadecimal";
        return;
    }
    return _n("numeric", ls * 0);
  },
  decimalInteger() {
    switch (qt) {
      case ".":
        Nt += Te(), Wt = "decimalPoint";
        return;
      case "e":
      case "E":
        Nt += Te(), Wt = "decimalExponent";
        return;
    }
    if (nr.isDigit(qt)) {
      Nt += Te();
      return;
    }
    return _n("numeric", ls * Number(Nt));
  },
  decimalPointLeading() {
    if (nr.isDigit(qt)) {
      Nt += Te(), Wt = "decimalFraction";
      return;
    }
    throw Tn(Te());
  },
  decimalPoint() {
    switch (qt) {
      case "e":
      case "E":
        Nt += Te(), Wt = "decimalExponent";
        return;
    }
    if (nr.isDigit(qt)) {
      Nt += Te(), Wt = "decimalFraction";
      return;
    }
    return _n("numeric", ls * Number(Nt));
  },
  decimalFraction() {
    switch (qt) {
      case "e":
      case "E":
        Nt += Te(), Wt = "decimalExponent";
        return;
    }
    if (nr.isDigit(qt)) {
      Nt += Te();
      return;
    }
    return _n("numeric", ls * Number(Nt));
  },
  decimalExponent() {
    switch (qt) {
      case "+":
      case "-":
        Nt += Te(), Wt = "decimalExponentSign";
        return;
    }
    if (nr.isDigit(qt)) {
      Nt += Te(), Wt = "decimalExponentInteger";
      return;
    }
    throw Tn(Te());
  },
  decimalExponentSign() {
    if (nr.isDigit(qt)) {
      Nt += Te(), Wt = "decimalExponentInteger";
      return;
    }
    throw Tn(Te());
  },
  decimalExponentInteger() {
    if (nr.isDigit(qt)) {
      Nt += Te();
      return;
    }
    return _n("numeric", ls * Number(Nt));
  },
  hexadecimal() {
    if (nr.isHexDigit(qt)) {
      Nt += Te(), Wt = "hexadecimalInteger";
      return;
    }
    throw Tn(Te());
  },
  hexadecimalInteger() {
    if (nr.isHexDigit(qt)) {
      Nt += Te();
      return;
    }
    return _n("numeric", ls * Number(Nt));
  },
  string() {
    switch (qt) {
      case "\\":
        Te(), Nt += Gue();
        return;
      case '"':
        if (Uu)
          return Te(), _n("string", Nt);
        Nt += Te();
        return;
      case "'":
        if (!Uu)
          return Te(), _n("string", Nt);
        Nt += Te();
        return;
      case `
`:
      case "\r":
        throw Tn(Te());
      case "\u2028":
      case "\u2029":
        Yue(qt);
        break;
      case void 0:
        throw Tn(Te());
    }
    Nt += Te();
  },
  start() {
    switch (qt) {
      case "{":
      case "[":
        return _n("punctuator", Te());
    }
    Wt = "value";
  },
  beforePropertyName() {
    switch (qt) {
      case "$":
      case "_":
        Nt = Te(), Wt = "identifierName";
        return;
      case "\\":
        Te(), Wt = "identifierNameStartEscape";
        return;
      case "}":
        return _n("punctuator", Te());
      case '"':
      case "'":
        Uu = Te() === '"', Wt = "string";
        return;
    }
    if (nr.isIdStartChar(qt)) {
      Nt += Te(), Wt = "identifierName";
      return;
    }
    throw Tn(Te());
  },
  afterPropertyName() {
    if (qt === ":")
      return _n("punctuator", Te());
    throw Tn(Te());
  },
  beforePropertyValue() {
    Wt = "value";
  },
  afterPropertyValue() {
    switch (qt) {
      case ",":
      case "}":
        return _n("punctuator", Te());
    }
    throw Tn(Te());
  },
  beforeArrayValue() {
    if (qt === "]")
      return _n("punctuator", Te());
    Wt = "value";
  },
  afterArrayValue() {
    switch (qt) {
      case ",":
      case "]":
        return _n("punctuator", Te());
    }
    throw Tn(Te());
  },
  end() {
    throw Tn(Te());
  }
};
function _n(e, t) {
  return {
    type: e,
    value: t,
    line: va,
    column: xo
  };
}
function Ea(e) {
  for (const t of e) {
    if (Cs() !== t)
      throw Tn(Te());
    Te();
  }
}
function Gue() {
  switch (Cs()) {
    case "b":
      return Te(), "\b";
    case "f":
      return Te(), "\f";
    case "n":
      return Te(), `
`;
    case "r":
      return Te(), "\r";
    case "t":
      return Te(), "	";
    case "v":
      return Te(), "\v";
    case "0":
      if (Te(), nr.isDigit(Cs()))
        throw Tn(Te());
      return "\0";
    case "x":
      return Te(), Kue();
    case "u":
      return Te(), aw();
    case `
`:
    case "\u2028":
    case "\u2029":
      return Te(), "";
    case "\r":
      return Te(), Cs() === `
` && Te(), "";
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7":
    case "8":
    case "9":
      throw Tn(Te());
    case void 0:
      throw Tn(Te());
  }
  return Te();
}
function Kue() {
  let e = "", t = Cs();
  if (!nr.isHexDigit(t) || (e += Te(), t = Cs(), !nr.isHexDigit(t)))
    throw Tn(Te());
  return e += Te(), String.fromCodePoint(parseInt(e, 16));
}
function aw() {
  let e = "", t = 4;
  for (; t-- > 0; ) {
    const n = Cs();
    if (!nr.isHexDigit(n))
      throw Tn(Te());
    e += Te();
  }
  return String.fromCodePoint(parseInt(e, 16));
}
const Xue = {
  start() {
    if (yr.type === "eof")
      throw $a();
    x0();
  },
  beforePropertyName() {
    switch (yr.type) {
      case "identifier":
      case "string":
        QC = yr.value, ri = "afterPropertyName";
        return;
      case "punctuator":
        zh();
        return;
      case "eof":
        throw $a();
    }
  },
  afterPropertyName() {
    if (yr.type === "eof")
      throw $a();
    ri = "beforePropertyValue";
  },
  beforePropertyValue() {
    if (yr.type === "eof")
      throw $a();
    x0();
  },
  beforeArrayValue() {
    if (yr.type === "eof")
      throw $a();
    if (yr.type === "punctuator" && yr.value === "]") {
      zh();
      return;
    }
    x0();
  },
  afterPropertyValue() {
    if (yr.type === "eof")
      throw $a();
    switch (yr.value) {
      case ",":
        ri = "beforePropertyName";
        return;
      case "}":
        zh();
    }
  },
  afterArrayValue() {
    if (yr.type === "eof")
      throw $a();
    switch (yr.value) {
      case ",":
        ri = "beforeArrayValue";
        return;
      case "]":
        zh();
    }
  },
  end() {
  }
};
function x0() {
  let e;
  switch (yr.type) {
    case "punctuator":
      switch (yr.value) {
        case "{":
          e = {};
          break;
        case "[":
          e = [];
          break;
      }
      break;
    case "null":
    case "boolean":
    case "numeric":
    case "string":
      e = yr.value;
      break;
  }
  if (ld === void 0)
    ld = e;
  else {
    const t = hs[hs.length - 1];
    Array.isArray(t) ? t.push(e) : Object.defineProperty(t, QC, {
      value: e,
      writable: !0,
      enumerable: !0,
      configurable: !0
    });
  }
  if (e !== null && typeof e == "object")
    hs.push(e), Array.isArray(e) ? ri = "beforeArrayValue" : ri = "beforePropertyName";
  else {
    const t = hs[hs.length - 1];
    t == null ? ri = "end" : Array.isArray(t) ? ri = "afterArrayValue" : ri = "afterPropertyValue";
  }
}
function zh() {
  hs.pop();
  const e = hs[hs.length - 1];
  e == null ? ri = "end" : Array.isArray(e) ? ri = "afterArrayValue" : ri = "afterPropertyValue";
}
function Tn(e) {
  return yg(e === void 0 ? `JSON5: invalid end of input at ${va}:${xo}` : `JSON5: invalid character '${OL(e)}' at ${va}:${xo}`);
}
function $a() {
  return yg(`JSON5: invalid end of input at ${va}:${xo}`);
}
function fA() {
  return xo -= 5, yg(`JSON5: invalid identifier character at ${va}:${xo}`);
}
function Yue(e) {
  console.warn(`JSON5: '${OL(e)}' in strings is not valid ECMAScript; consider escaping`);
}
function OL(e) {
  const t = {
    "'": "\\'",
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t",
    "\v": "\\v",
    "\0": "\\0",
    "\u2028": "\\u2028",
    "\u2029": "\\u2029"
  };
  if (t[e])
    return t[e];
  if (e < " ") {
    const n = e.charCodeAt(0).toString(16);
    return "\\x" + ("00" + n).substring(n.length);
  }
  return e;
}
function yg(e) {
  const t = new SyntaxError(e);
  return t.lineNumber = va, t.columnNumber = xo, t;
}
var que = function(t, n, r) {
  const i = [];
  let o = "", s, a, l = "", u;
  if (n != null && typeof n == "object" && !Array.isArray(n) && (r = n.space, u = n.quote, n = n.replacer), typeof n == "function")
    a = n;
  else if (Array.isArray(n)) {
    s = [];
    for (const g of n) {
      let m;
      typeof g == "string" ? m = g : (typeof g == "number" || g instanceof String || g instanceof Number) && (m = String(g)), m !== void 0 && s.indexOf(m) < 0 && s.push(m);
    }
  }
  return r instanceof Number ? r = Number(r) : r instanceof String && (r = String(r)), typeof r == "number" ? r > 0 && (r = Math.min(10, Math.floor(r)), l = "          ".substr(0, r)) : typeof r == "string" && (l = r.substr(0, 10)), c("", { "": t });
  function c(g, m) {
    let v = m[g];
    switch (v != null && (typeof v.toJSON5 == "function" ? v = v.toJSON5(g) : typeof v.toJSON == "function" && (v = v.toJSON(g))), a && (v = a.call(m, g, v)), v instanceof Number ? v = Number(v) : v instanceof String ? v = String(v) : v instanceof Boolean && (v = v.valueOf()), v) {
      case null:
        return "null";
      case !0:
        return "true";
      case !1:
        return "false";
    }
    if (typeof v == "string")
      return d(v);
    if (typeof v == "number")
      return String(v);
    if (typeof v == "object")
      return Array.isArray(v) ? p(v) : f(v);
  }
  function d(g) {
    const m = {
      "'": 0.1,
      '"': 0.2
    }, v = {
      "'": "\\'",
      '"': '\\"',
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\v": "\\v",
      "\0": "\\0",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    let b = "";
    for (let w = 0; w < g.length; w++) {
      const C = g[w];
      switch (C) {
        case "'":
        case '"':
          m[C]++, b += C;
          continue;
        case "\0":
          if (nr.isDigit(g[w + 1])) {
            b += "\\x00";
            continue;
          }
      }
      if (v[C]) {
        b += v[C];
        continue;
      }
      if (C < " ") {
        let y = C.charCodeAt(0).toString(16);
        b += "\\x" + ("00" + y).substring(y.length);
        continue;
      }
      b += C;
    }
    const x = u || Object.keys(m).reduce((w, C) => m[w] < m[C] ? w : C);
    return b = b.replace(new RegExp(x, "g"), v[x]), x + b + x;
  }
  function f(g) {
    if (i.indexOf(g) >= 0)
      throw TypeError("Converting circular structure to JSON5");
    i.push(g);
    let m = o;
    o = o + l;
    let v = s || Object.keys(g), b = [];
    for (const w of v) {
      const C = c(w, g);
      if (C !== void 0) {
        let y = h(w) + ":";
        l !== "" && (y += " "), y += C, b.push(y);
      }
    }
    let x;
    if (b.length === 0)
      x = "{}";
    else {
      let w;
      if (l === "")
        w = b.join(","), x = "{" + w + "}";
      else {
        let C = `,
` + o;
        w = b.join(C), x = `{
` + o + w + `,
` + m + "}";
      }
    }
    return i.pop(), o = m, x;
  }
  function h(g) {
    if (g.length === 0)
      return d(g);
    const m = String.fromCodePoint(g.codePointAt(0));
    if (!nr.isIdStartChar(m))
      return d(g);
    for (let v = m.length; v < g.length; v++)
      if (!nr.isIdContinueChar(String.fromCodePoint(g.codePointAt(v))))
        return d(g);
    return g;
  }
  function p(g) {
    if (i.indexOf(g) >= 0)
      throw TypeError("Converting circular structure to JSON5");
    i.push(g);
    let m = o;
    o = o + l;
    let v = [];
    for (let x = 0; x < g.length; x++) {
      const w = c(String(x), g);
      v.push(w !== void 0 ? w : "null");
    }
    let b;
    if (v.length === 0)
      b = "[]";
    else if (l === "")
      b = "[" + v.join(",") + "]";
    else {
      let x = `,
` + o, w = v.join(x);
      b = `[
` + o + w + `,
` + m + "]";
    }
    return i.pop(), o = m, b;
  }
};
const Que = {
  parse: Wue,
  stringify: que
};
var cc = Que;
const Zue = (e) => ({
  id: e == null ? void 0 : e.id,
  sourceId: e == null ? void 0 : e.source,
  type: e == null ? void 0 : e.type,
  targetId: e == null ? void 0 : e.target,
  name: e == null ? void 0 : e.label,
  sourceHandle: e.sourceHandle ?? void 0,
  targetHandle: e.targetHandle ?? void 0
}), lw = (e) => {
  var t;
  return {
    id: e.id,
    type: e.type,
    position: e.position,
    data: {
      name: e.name,
      kind: (t = e == null ? void 0 : e.content) == null ? void 0 : t.kind
    }
  };
}, E0 = (e) => e.map(lw), cw = (e) => ({
  id: e.id,
  source: e.sourceId,
  type: (e == null ? void 0 : e.type) || "edge",
  target: e.targetId,
  label: e.name,
  sourceHandle: e.sourceHandle,
  targetHandle: e.targetHandle,
  markerEnd: { type: ef.ArrowClosed, width: 20, height: 20 }
}), hA = (e) => e.filter((t) => t.sourceId && t.targetId).map(cw), hu = U.createContext({}), Jue = (e) => {
  const { children: t } = e, n = mt(
    () => pc(() => ({
      id: void 0,
      simulate: void 0,
      decisionGraph: { nodes: [], edges: [] },
      hoveredEdgeId: null,
      openTabs: [],
      activeTab: "graph",
      disabled: !1,
      configurable: !0,
      components: [],
      customNodes: [],
      simulatorLoading: !1,
      simulatorOpen: !1
    })),
    []
  ), r = mt(
    () => pc(() => ({
      onChange: void 0,
      onSimulationRun: void 0,
      onSimulatorOpen: void 0
    })),
    []
  ), i = mt(
    () => pc(() => ({
      nodesState: Uh(),
      edgesState: Uh(),
      graphClipboard: Uh()
    })),
    []
  ), o = mt(
    () => ({
      handleNodesChange: (s = []) => {
        var u, c, d, f;
        const { decisionGraph: a } = n.getState(), { nodesState: l } = i.getState();
        if ((c = (u = l.current)[2]) == null || c.call(u, s), s.find((h) => h.type === "position")) {
          const h = Mn(a, (p) => {
            const g = (p.nodes || []).map((m) => {
              const v = s.find((b) => "id" in b && b.id === m.id);
              return (v == null ? void 0 : v.type) === "position" && (v != null && v.position) && (m.position = v.position), m;
            });
            p.nodes = g;
          });
          n.setState({ decisionGraph: h }), (f = (d = r.getState()).onChange) == null || f.call(d, h);
        }
      },
      handleEdgesChange: (s = []) => {
        var u, c, d;
        const { decisionGraph: a } = n.getState(), { edgesState: l } = i.getState();
        if ((u = l == null ? void 0 : l.current) == null || u[2](s), s.find((f) => f.type === "remove")) {
          const f = Mn(a, (h) => {
            const p = (h.edges || []).map((g) => {
              const m = s.find((v) => "id" in v && v.id === g.id);
              return (m == null ? void 0 : m.type) === "remove" ? null : g;
            }).filter((g) => !!g);
            h.edges = p;
          });
          n.setState({ decisionGraph: f }), (d = (c = r.getState()).onChange) == null || d.call(c, f);
        }
      },
      setNodes: (s = []) => {
        var c, d, f;
        const { nodesState: a } = i.getState(), { decisionGraph: l } = n.getState();
        (c = a == null ? void 0 : a.current) == null || c[1](E0(s));
        const u = Mn(l, (h) => {
          h.nodes = s;
        });
        n.setState({ decisionGraph: u }), (f = (d = r.getState()).onChange) == null || f.call(d, u);
      },
      addNodes: (s) => {
        var d, f, h, p, g;
        const { nodesState: a } = i.getState(), { decisionGraph: l } = n.getState();
        ((d = a.current[0]) == null ? void 0 : d.some((m) => m.type === Fn.Input)) && (s = s.filter((m) => m.type !== Fn.Input)), (h = (f = a.current)[1]) == null || h.call(f, (m) => m.concat(E0(s)));
        const c = Mn(l, (m) => {
          m.nodes = (m.nodes || []).concat(s);
        });
        n.setState({ decisionGraph: c }), (g = (p = r.getState()).onChange) == null || g.call(p, c);
      },
      duplicateNodes: (s) => {
        var v, b, x, w, C, y, S, A;
        const { nodesState: a, edgesState: l } = i.getState(), { decisionGraph: u } = n.getState();
        let c = ((u == null ? void 0 : u.nodes) || []).filter(($) => s.includes($.id));
        if (((v = a.current[0]) == null ? void 0 : v.some(($) => $.type === Fn.Input)) && (c = c.filter(($) => $.type !== Fn.Input)), c.length === 0)
          return;
        const f = c.reduce(
          ($, M) => ({
            ...$,
            [M.id]: crypto.randomUUID()
          }),
          {}
        ), h = c.map(($) => {
          var M, _;
          return {
            ...$,
            id: f[$.id],
            position: {
              x: ((M = $.position) == null ? void 0 : M.x) || 0,
              y: (((_ = $.position) == null ? void 0 : _.y) || 0) + 140
            }
          };
        }), p = Object.keys(f), g = [];
        h.length > 0 && (((b = l.current) == null ? void 0 : b[0]) || []).forEach(($) => {
          p.includes($.source) && p.includes($.target) && g.push({
            id: crypto.randomUUID(),
            type: $.type,
            sourceId: f[$.source],
            targetId: f[$.target],
            sourceHandle: $.sourceHandle ?? void 0,
            targetHandle: $.targetHandle ?? void 0
          });
        }), (w = (x = a.current)[1]) == null || w.call(x, ($) => $.concat(h.map(lw))), (y = (C = l.current)[1]) == null || y.call(C, ($) => $.concat(g.map(cw)));
        const m = Mn(u, ($) => {
          $.nodes.push(...h), $.edges.push(...g);
        });
        n.setState({ decisionGraph: m }), (A = (S = r.getState()).onChange) == null || A.call(S, m);
      },
      copyNodes: (s) => {
        const { graphClipboard: a, nodesState: l } = i.getState();
        if (!a.current || !l.current)
          return;
        const [u] = l.current, c = u.filter((d) => s.includes(d.id));
        a.current.copyNodes(c);
      },
      pasteNodes: () => {
        var a, l;
        const { graphClipboard: s } = i.getState();
        (l = (a = s.current) == null ? void 0 : a.pasteNodes) == null || l.call(a);
      },
      removeNodes: (s = []) => {
        var d, f, h, p, g, m;
        const { nodesState: a, edgesState: l } = i.getState(), { decisionGraph: u } = n.getState();
        (f = (d = a.current)[1]) == null || f.call(d, (v) => v.filter((b) => s.every((x) => b.id !== x))), (p = (h = l.current)[1]) == null || p.call(
          h,
          (v) => v.filter(
            (b) => s.every((x) => b.source !== x && b.target !== x && b.sourceHandle !== x && b.targetHandle !== x)
          )
        );
        const c = Mn(u, (v) => {
          const b = v.nodes || [], x = v.edges || [];
          v.nodes = b.filter((w) => s.every((C) => w.id !== C)), v.edges = x.filter(
            (w) => s.every((C) => w.sourceId !== C && w.targetId !== C && w.sourceHandle !== C && w.targetHandle !== C)
          );
        });
        n.setState({ decisionGraph: c }), (m = (g = r.getState()).onChange) == null || m.call(g, c);
      },
      addEdges: (s) => {
        var c, d, f, h;
        const { edgesState: a } = i.getState(), { decisionGraph: l } = n.getState();
        (d = (c = a.current) == null ? void 0 : c[1]) == null || d.call(c, (p) => p.concat(s.map(cw)));
        const u = Mn(l, (p) => {
          p.edges = (p.edges || []).concat(s);
        });
        n.setState({ decisionGraph: u }), (h = (f = r.getState()).onChange) == null || h.call(f, u);
      },
      setEdges: (s = []) => {
        var c, d, f, h;
        const { edgesState: a } = i.getState(), { decisionGraph: l } = n.getState();
        (d = (c = a == null ? void 0 : a.current) == null ? void 0 : c[1]) == null || d.call(c, hA(s));
        const u = Mn(l, (p) => {
          p.edges = s;
        });
        n.setState({ decisionGraph: u }), (h = (f = r.getState()).onChange) == null || h.call(f, u);
      },
      removeEdges: (s) => {
        var c, d, f, h;
        const { edgesState: a } = i.getState(), { decisionGraph: l } = n.getState();
        (d = (c = a == null ? void 0 : a.current) == null ? void 0 : c[1]) == null || d.call(c, (p) => p.filter((g) => !s.find((m) => g.id === m)));
        const u = Mn(l, (p) => {
          p.edges = p.edges.filter((g) => !s.find((m) => g.id === m));
        });
        n.setState({ decisionGraph: u }), (h = (f = r.getState()).onChange) == null || h.call(f, u);
      },
      updateNode: (s, a) => {
        var d, f, h, p;
        const { decisionGraph: l } = n.getState(), { nodesState: u } = i.getState(), c = Mn(l, (g) => {
          const m = (g.nodes ?? []).find((v) => (v == null ? void 0 : v.id) === s);
          m && a(m);
        });
        (f = (d = u.current)[1]) == null || f.call(
          d,
          (g) => g.map((m) => m.id === s ? lw((c.nodes || []).find((v) => v.id === s)) : m)
        ), n.setState({ decisionGraph: c }), (p = (h = r.getState()).onChange) == null || p.call(h, c);
      },
      setDecisionGraph: (s) => {
        var u, c, d, f;
        const { edgesState: a, nodesState: l } = i.getState();
        (u = a == null ? void 0 : a.current) == null || u[1](hA((s == null ? void 0 : s.edges) || [])), (c = l == null ? void 0 : l.current) == null || c[1](E0((s == null ? void 0 : s.nodes) || [])), n.setState({ decisionGraph: s }), (f = (d = r.getState()).onChange) == null || f.call(d, s);
      },
      setHoveredEdgeId: (s) => n.setState({ hoveredEdgeId: s }),
      openTab: (s) => {
        const { openTabs: a } = n.getState(), l = a.find((u) => u === s);
        l ? n.setState({ activeTab: l }) : n.setState({ openTabs: [...a, s], activeTab: s });
      },
      closeTab: (s) => {
        const { openTabs: a, activeTab: l } = n.getState(), u = a == null ? void 0 : a.findIndex((f) => f === s), c = a == null ? void 0 : a[u], d = {
          openTabs: a.filter((f) => f !== c)
        };
        l === s && (d.activeTab = (a == null ? void 0 : a[u - 1]) ?? "graph"), n.setState(d);
      },
      setSimulatorRequest: (s) => {
        n.setState({
          simulatorRequest: s
        });
      },
      toggleSimulator: () => {
        var a, l, u;
        const s = !((a = n.getState()) != null && a.simulatorOpen);
        n.setState({ simulatorOpen: s }), (u = (l = r.getState()).onSimulatorOpen) == null || u.call(l, s);
      },
      runSimulator: async (s) => {
        const { onSimulationRun: a } = r.getState();
        if (!a)
          return { error: { title: "Component error", message: "Simulation callback is not defined.", data: {} } };
        const { decisionGraph: l, simulatorRequest: u } = n.getState();
        try {
          const c = yn(s).with(mn.not(mn.nullish), (f) => (n.setState({ simulatorRequest: cc.stringify(f, void 0, 2), simulatorLoading: !0 }), f)).otherwise(() => {
            var f;
            return n.setState({ simulatorLoading: !0 }), yn((f = u == null ? void 0 : u.trim) == null ? void 0 : f.call(u)).with(mn.string.minLength(1), (h) => cc.parse(h)).otherwise(() => ({}));
          }), d = await a({ decisionGraph: l, context: c });
          return n.setState({ simulate: d }), d;
        } catch (c) {
          throw c;
        } finally {
          n.setState({ simulatorLoading: !1 });
        }
      }
    }),
    []
  );
  return /* @__PURE__ */ V.jsx(
    hu.Provider,
    {
      value: {
        stateStore: n,
        referenceStore: i,
        listenerStore: r,
        actions: o
      },
      children: t
    }
  );
};
function Nr(e, t = ro) {
  return U.useContext(hu).stateStore(e, t);
}
function ZC(e, t = ro) {
  return U.useContext(hu).listenerStore(e, t);
}
function ede(e, t = ro) {
  return U.useContext(hu).referenceStore(e, t);
}
function Lr() {
  return U.useContext(hu).actions;
}
function JC() {
  return U.useContext(hu);
}
const tde = ({
  id: e,
  defaultValue: t,
  value: n,
  disabled: r = !1,
  configurable: i = !0,
  onChange: o,
  onSimulationRun: s,
  components: a,
  customNodes: l,
  onSimulatorOpen: u,
  onReactFlowInit: c
}) => {
  const d = he(!1), f = Lr(), { stateStore: h, listenerStore: p } = JC(), { decisionGraph: g } = Nr(({ decisionGraph: v }) => ({
    decisionGraph: v
  })), m = Sm((v) => {
    o == null || o(v);
  }, 100);
  return Pe(() => {
    h.setState({
      id: e,
      disabled: r,
      configurable: i,
      components: Array.isArray(a) ? a : [],
      customNodes: Array.isArray(l) ? l : []
    });
  }, [e, r, i, a, l]), Pe(() => {
    p.setState({
      onSimulationRun: s,
      onSimulatorOpen: u,
      onReactFlowInit: c
    });
  }, [s, u, c]), Pe(() => {
    p.setState({ onChange: m });
  }, [m]), Pe(() => {
    d.current && n !== void 0 && !ro(n, g) && f.setDecisionGraph(n);
  }, [n]), Pe(() => {
    n !== void 0 ? f.setDecisionGraph(n) : t !== void 0 && f.setDecisionGraph(t), d.current = !0;
  }, []), null;
};
var nde = { exports: {} };
(function(e, t) {
  ace.define("ace/snippets", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event_emitter", "ace/lib/lang", "ace/range", "ace/range_list", "ace/keyboard/hash_handler", "ace/tokenizer", "ace/clipboard", "ace/editor"], function(n, r, i) {
    var o = n("./lib/dom"), s = n("./lib/oop"), a = n("./lib/event_emitter").EventEmitter, l = n("./lib/lang"), u = n("./range").Range, c = n("./range_list").RangeList, d = n("./keyboard/hash_handler").HashHandler, f = n("./tokenizer").Tokenizer, h = n("./clipboard"), p = {
      CURRENT_WORD: function(y) {
        return y.session.getTextRange(y.session.getWordRange());
      },
      SELECTION: function(y, S, A) {
        var $ = y.session.getTextRange();
        return A ? $.replace(/\n\r?([ \t]*\S)/g, `
` + A + "$1") : $;
      },
      CURRENT_LINE: function(y) {
        return y.session.getLine(y.getCursorPosition().row);
      },
      PREV_LINE: function(y) {
        return y.session.getLine(y.getCursorPosition().row - 1);
      },
      LINE_INDEX: function(y) {
        return y.getCursorPosition().row;
      },
      LINE_NUMBER: function(y) {
        return y.getCursorPosition().row + 1;
      },
      SOFT_TABS: function(y) {
        return y.session.getUseSoftTabs() ? "YES" : "NO";
      },
      TAB_SIZE: function(y) {
        return y.session.getTabSize();
      },
      CLIPBOARD: function(y) {
        return h.getText && h.getText();
      },
      FILENAME: function(y) {
        return /[^/\\]*$/.exec(this.FILEPATH(y))[0];
      },
      FILENAME_BASE: function(y) {
        return /[^/\\]*$/.exec(this.FILEPATH(y))[0].replace(/\.[^.]*$/, "");
      },
      DIRECTORY: function(y) {
        return this.FILEPATH(y).replace(/[^/\\]*$/, "");
      },
      FILEPATH: function(y) {
        return "/not implemented.txt";
      },
      WORKSPACE_NAME: function() {
        return "Unknown";
      },
      FULLNAME: function() {
        return "Unknown";
      },
      BLOCK_COMMENT_START: function(y) {
        var S = y.session.$mode || {};
        return S.blockComment && S.blockComment.start || "";
      },
      BLOCK_COMMENT_END: function(y) {
        var S = y.session.$mode || {};
        return S.blockComment && S.blockComment.end || "";
      },
      LINE_COMMENT: function(y) {
        var S = y.session.$mode || {};
        return S.lineCommentStart || "";
      },
      CURRENT_YEAR: g.bind(null, { year: "numeric" }),
      CURRENT_YEAR_SHORT: g.bind(null, { year: "2-digit" }),
      CURRENT_MONTH: g.bind(null, { month: "numeric" }),
      CURRENT_MONTH_NAME: g.bind(null, { month: "long" }),
      CURRENT_MONTH_NAME_SHORT: g.bind(null, { month: "short" }),
      CURRENT_DATE: g.bind(null, { day: "2-digit" }),
      CURRENT_DAY_NAME: g.bind(null, { weekday: "long" }),
      CURRENT_DAY_NAME_SHORT: g.bind(null, { weekday: "short" }),
      CURRENT_HOUR: g.bind(null, { hour: "2-digit", hour12: !1 }),
      CURRENT_MINUTE: g.bind(null, { minute: "2-digit" }),
      CURRENT_SECOND: g.bind(null, { second: "2-digit" })
    };
    p.SELECTED_TEXT = p.SELECTION;
    function g(y) {
      var S = (/* @__PURE__ */ new Date()).toLocaleString("en-us", y);
      return S.length == 1 ? "0" + S : S;
    }
    var m = (
      /** @class */
      function() {
        function y() {
          this.snippetMap = {}, this.snippetNameMap = {}, this.variables = p;
        }
        return y.prototype.getTokenizer = function() {
          return y.$tokenizer || this.createTokenizer();
        }, y.prototype.createTokenizer = function() {
          function S(M) {
            return M = M.substr(1), /^\d+$/.test(M) ? [{ tabstopId: parseInt(M, 10) }] : [{ text: M }];
          }
          function A(M) {
            return "(?:[^\\\\" + M + "]|\\\\.)";
          }
          var $ = {
            regex: "/(" + A("/") + "+)/",
            onMatch: function(M, _, T) {
              var D = T[0];
              return D.fmtString = !0, D.guard = M.slice(1, -1), D.flag = "", "";
            },
            next: "formatString"
          };
          return y.$tokenizer = new f({
            start: [
              { regex: /\\./, onMatch: function(M, _, T) {
                var D = M[1];
                return (D == "}" && T.length || "`$\\".indexOf(D) != -1) && (M = D), [M];
              } },
              { regex: /}/, onMatch: function(M, _, T) {
                return [T.length ? T.shift() : M];
              } },
              { regex: /\$(?:\d+|\w+)/, onMatch: S },
              { regex: /\$\{[\dA-Z_a-z]+/, onMatch: function(M, _, T) {
                var D = S(M.substr(1));
                return T.unshift(D[0]), D;
              }, next: "snippetVar" },
              { regex: /\n/, token: "newline", merge: !1 }
            ],
            snippetVar: [
              { regex: "\\|" + A("\\|") + "*\\|", onMatch: function(M, _, T) {
                var D = M.slice(1, -1).replace(/\\[,|\\]|,/g, function(E) {
                  return E.length == 2 ? E[1] : "\0";
                }).split("\0").map(function(E) {
                  return { value: E };
                });
                return T[0].choices = D, [D[0]];
              }, next: "start" },
              $,
              { regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "start" }
            ],
            formatString: [
              { regex: /:/, onMatch: function(M, _, T) {
                return T.length && T[0].expectElse ? (T[0].expectElse = !1, T[0].ifEnd = { elseEnd: T[0] }, [T[0].ifEnd]) : ":";
              } },
              { regex: /\\./, onMatch: function(M, _, T) {
                var D = M[1];
                return D == "}" && T.length || "`$\\".indexOf(D) != -1 ? M = D : D == "n" ? M = `
` : D == "t" ? M = "	" : "ulULE".indexOf(D) != -1 && (M = { changeCase: D, local: D > "a" }), [M];
              } },
              { regex: "/\\w*}", onMatch: function(M, _, T) {
                var D = T.shift();
                return D && (D.flag = M.slice(1, -1)), this.next = D && D.tabstopId ? "start" : "", [D || M];
              }, next: "start" },
              { regex: /\$(?:\d+|\w+)/, onMatch: function(M, _, T) {
                return [{ text: M.slice(1) }];
              } },
              { regex: /\${\w+/, onMatch: function(M, _, T) {
                var D = { text: M.slice(2) };
                return T.unshift(D), [D];
              }, next: "formatStringVar" },
              { regex: /\n/, token: "newline", merge: !1 },
              { regex: /}/, onMatch: function(M, _, T) {
                var D = T.shift();
                return this.next = D && D.tabstopId ? "start" : "", [D || M];
              }, next: "start" }
            ],
            formatStringVar: [
              { regex: /:\/\w+}/, onMatch: function(M, _, T) {
                var D = T[0];
                return D.formatFunction = M.slice(2, -1), [T.shift()];
              }, next: "formatString" },
              $,
              { regex: /:[\?\-+]?/, onMatch: function(M, _, T) {
                M[1] == "+" && (T[0].ifEnd = T[0]), M[1] == "?" && (T[0].expectElse = !0);
              }, next: "formatString" },
              { regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "formatString" }
            ]
          }), y.$tokenizer;
        }, y.prototype.tokenizeTmSnippet = function(S, A) {
          return this.getTokenizer().getLineTokens(S, A).tokens.map(function($) {
            return $.value || $;
          });
        }, y.prototype.getVariableValue = function(S, A, $) {
          if (/^\d+$/.test(A))
            return (this.variables.__ || {})[A] || "";
          if (/^[A-Z]\d+$/.test(A))
            return (this.variables[A[0] + "__"] || {})[A.substr(1)] || "";
          if (A = A.replace(/^TM_/, ""), !this.variables.hasOwnProperty(A))
            return "";
          var M = this.variables[A];
          return typeof M == "function" && (M = this.variables[A](S, A, $)), M ?? "";
        }, y.prototype.tmStrFormat = function(S, A, $) {
          if (!A.fmt)
            return S;
          var M = A.flag || "", _ = A.guard;
          _ = new RegExp(_, M.replace(/[^gim]/g, ""));
          var T = typeof A.fmt == "string" ? this.tokenizeTmSnippet(A.fmt, "formatString") : A.fmt, D = this, E = S.replace(_, function() {
            var R = D.variables.__;
            D.variables.__ = [].slice.call(arguments);
            for (var I = D.resolveVariables(T, $), k = "E", P = 0; P < I.length; P++) {
              var L = I[P];
              if (typeof L == "object")
                if (I[P] = "", L.changeCase && L.local) {
                  var N = I[P + 1];
                  N && typeof N == "string" && (L.changeCase == "u" ? I[P] = N[0].toUpperCase() : I[P] = N[0].toLowerCase(), I[P + 1] = N.substr(1));
                } else
                  L.changeCase && (k = L.changeCase);
              else
                k == "U" ? I[P] = L.toUpperCase() : k == "L" && (I[P] = L.toLowerCase());
            }
            return D.variables.__ = R, I.join("");
          });
          return E;
        }, y.prototype.tmFormatFunction = function(S, A, $) {
          return A.formatFunction == "upcase" ? S.toUpperCase() : A.formatFunction == "downcase" ? S.toLowerCase() : S;
        }, y.prototype.resolveVariables = function(S, A) {
          for (var $ = [], M = "", _ = !0, T = 0; T < S.length; T++) {
            var D = S[T];
            if (typeof D == "string") {
              $.push(D), D == `
` ? (_ = !0, M = "") : _ && (M = /^\t*/.exec(D)[0], _ = /\S/.test(D));
              continue;
            }
            if (D) {
              if (_ = !1, D.fmtString) {
                var E = S.indexOf(D, T + 1);
                E == -1 && (E = S.length), D.fmt = S.slice(T + 1, E), T = E;
              }
              if (D.text) {
                var R = this.getVariableValue(A, D.text, M) + "";
                D.fmtString && (R = this.tmStrFormat(R, D, A)), D.formatFunction && (R = this.tmFormatFunction(R, D, A)), R && !D.ifEnd ? ($.push(R), I(D)) : !R && D.ifEnd && I(D.ifEnd);
              } else
                D.elseEnd ? I(D.elseEnd) : (D.tabstopId != null || D.changeCase != null) && $.push(D);
            }
          }
          function I(k) {
            var P = S.indexOf(k, T + 1);
            P != -1 && (T = P);
          }
          return $;
        }, y.prototype.getDisplayTextForSnippet = function(S, A) {
          var $ = v.call(this, S, A);
          return $.text;
        }, y.prototype.insertSnippetForSelection = function(S, A, $) {
          $ === void 0 && ($ = {});
          var M = v.call(this, S, A, $), _ = S.getSelectionRange(), T = S.session.replace(_, M.text), D = new b(S), E = S.inVirtualSelectionMode && S.selection.index;
          D.addTabstops(M.tabstops, _.start, T, E);
        }, y.prototype.insertSnippet = function(S, A, $) {
          $ === void 0 && ($ = {});
          var M = this;
          if (S.inVirtualSelectionMode)
            return M.insertSnippetForSelection(S, A, $);
          S.forEachSelection(function() {
            M.insertSnippetForSelection(S, A, $);
          }, null, { keepOrder: !0 }), S.tabstopManager && S.tabstopManager.tabNext();
        }, y.prototype.$getScope = function(S) {
          var A = S.session.$mode.$id || "";
          if (A = A.split("/").pop(), A === "html" || A === "php") {
            A === "php" && !S.session.$mode.inlinePhp && (A = "html");
            var $ = S.getCursorPosition(), M = S.session.getState($.row);
            typeof M == "object" && (M = M[0]), M.substring && (M.substring(0, 3) == "js-" ? A = "javascript" : M.substring(0, 4) == "css-" ? A = "css" : M.substring(0, 4) == "php-" && (A = "php"));
          }
          return A;
        }, y.prototype.getActiveScopes = function(S) {
          var A = this.$getScope(S), $ = [A], M = this.snippetMap;
          return M[A] && M[A].includeScopes && $.push.apply($, M[A].includeScopes), $.push("_"), $;
        }, y.prototype.expandWithTab = function(S, A) {
          var $ = this, M = S.forEachSelection(function() {
            return $.expandSnippetForSelection(S, A);
          }, null, { keepOrder: !0 });
          return M && S.tabstopManager && S.tabstopManager.tabNext(), M;
        }, y.prototype.expandSnippetForSelection = function(S, A) {
          var $ = S.getCursorPosition(), M = S.session.getLine($.row), _ = M.substring(0, $.column), T = M.substr($.column), D = this.snippetMap, E;
          return this.getActiveScopes(S).some(function(R) {
            var I = D[R];
            return I && (E = this.findMatchingSnippet(I, _, T)), !!E;
          }, this), E ? (A && A.dryRun || (S.session.doc.removeInLine($.row, $.column - E.replaceBefore.length, $.column + E.replaceAfter.length), this.variables.M__ = E.matchBefore, this.variables.T__ = E.matchAfter, this.insertSnippetForSelection(S, E.content), this.variables.M__ = this.variables.T__ = null), !0) : !1;
        }, y.prototype.findMatchingSnippet = function(S, A, $) {
          for (var M = S.length; M--; ) {
            var _ = S[M];
            if (!(_.startRe && !_.startRe.test(A)) && !(_.endRe && !_.endRe.test($)) && !(!_.startRe && !_.endRe))
              return _.matchBefore = _.startRe ? _.startRe.exec(A) : [""], _.matchAfter = _.endRe ? _.endRe.exec($) : [""], _.replaceBefore = _.triggerRe ? _.triggerRe.exec(A)[0] : "", _.replaceAfter = _.endTriggerRe ? _.endTriggerRe.exec($)[0] : "", _;
          }
        }, y.prototype.register = function(S, A) {
          var $ = this.snippetMap, M = this.snippetNameMap, _ = this;
          S || (S = []);
          function T(R) {
            return R && !/^\^?\(.*\)\$?$|^\\b$/.test(R) && (R = "(?:" + R + ")"), R || "";
          }
          function D(R, I, k) {
            return R = T(R), I = T(I), R = I + R, R && R[R.length - 1] != "$" && (R = R + "$"), new RegExp(R);
          }
          function E(R) {
            R.scope || (R.scope = A || "_"), A = R.scope, $[A] || ($[A] = [], M[A] = {});
            var I = M[A];
            if (R.name) {
              var k = I[R.name];
              k && _.unregister(k), I[R.name] = R;
            }
            $[A].push(R), R.prefix && (R.tabTrigger = R.prefix), !R.content && R.body && (R.content = Array.isArray(R.body) ? R.body.join(`
`) : R.body), R.tabTrigger && !R.trigger && (!R.guard && /^\w/.test(R.tabTrigger) && (R.guard = "\\b"), R.trigger = l.escapeRegExp(R.tabTrigger)), !(!R.trigger && !R.guard && !R.endTrigger && !R.endGuard) && (R.startRe = D(R.trigger, R.guard), R.triggerRe = new RegExp(R.trigger), R.endRe = D(R.endTrigger, R.endGuard), R.endTriggerRe = new RegExp(R.endTrigger));
          }
          Array.isArray(S) ? S.forEach(E) : Object.keys(S).forEach(function(R) {
            E(S[R]);
          }), this._signal("registerSnippets", { scope: A });
        }, y.prototype.unregister = function(S, A) {
          var $ = this.snippetMap, M = this.snippetNameMap;
          function _(T) {
            var D = M[T.scope || A];
            if (D && D[T.name]) {
              delete D[T.name];
              var E = $[T.scope || A], R = E && E.indexOf(T);
              R >= 0 && E.splice(R, 1);
            }
          }
          S.content ? _(S) : Array.isArray(S) && S.forEach(_);
        }, y.prototype.parseSnippetFile = function(S) {
          S = S.replace(/\r/g, "");
          for (var A = [], $ = {}, M = /^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm, _; _ = M.exec(S); ) {
            if (_[1])
              try {
                $ = JSON.parse(_[1]), A.push($);
              } catch {
              }
            if (_[4])
              $.content = _[4].replace(/^\t/gm, ""), A.push($), $ = {};
            else {
              var T = _[2], D = _[3];
              if (T == "regex") {
                var E = /\/((?:[^\/\\]|\\.)*)|$/g;
                $.guard = E.exec(D)[1], $.trigger = E.exec(D)[1], $.endTrigger = E.exec(D)[1], $.endGuard = E.exec(D)[1];
              } else
                T == "snippet" ? ($.tabTrigger = D.match(/^\S*/)[0], $.name || ($.name = D)) : T && ($[T] = D);
            }
          }
          return A;
        }, y.prototype.getSnippetByName = function(S, A) {
          var $ = this.snippetNameMap, M;
          return this.getActiveScopes(A).some(function(_) {
            var T = $[_];
            return T && (M = T[S]), !!M;
          }, this), M;
        }, y;
      }()
    );
    s.implement(m.prototype, a);
    var v = function(y, S, A) {
      A === void 0 && (A = {});
      var $ = y.getCursorPosition(), M = y.session.getLine($.row), _ = y.session.getTabString(), T = M.match(/^\s*/)[0];
      $.column < T.length && (T = T.slice(0, $.column)), S = S.replace(/\r/g, "");
      var D = this.tokenizeTmSnippet(S);
      D = this.resolveVariables(D, y), D = D.map(function(W) {
        return W == `
` && !A.excludeExtraIndent ? W + T : typeof W == "string" ? W.replace(/\t/g, _) : W;
      });
      var E = [];
      D.forEach(function(W, G) {
        if (typeof W == "object") {
          var K = W.tabstopId, Y = E[K];
          if (Y || (Y = E[K] = [], Y.index = K, Y.value = "", Y.parents = {}), Y.indexOf(W) === -1) {
            W.choices && !Y.choices && (Y.choices = W.choices), Y.push(W);
            var X = D.indexOf(W, G + 1);
            if (X !== -1) {
              var Z = D.slice(G + 1, X), Q = Z.some(function(ne) {
                return typeof ne == "object";
              });
              Q && !Y.value ? Y.value = Z : Z.length && (!Y.value || typeof Y.value != "string") && (Y.value = Z.join(""));
            }
          }
        }
      }), E.forEach(function(W) {
        W.length = 0;
      });
      var R = {};
      function I(W) {
        for (var G = [], K = 0; K < W.length; K++) {
          var Y = W[K];
          if (typeof Y == "object") {
            if (R[Y.tabstopId])
              continue;
            var X = W.lastIndexOf(Y, K - 1);
            Y = G[X] || { tabstopId: Y.tabstopId };
          }
          G[K] = Y;
        }
        return G;
      }
      for (var k = 0; k < D.length; k++) {
        var P = D[k];
        if (typeof P == "object") {
          var L = P.tabstopId, N = E[L], F = D.indexOf(P, k + 1);
          if (R[L]) {
            R[L] === P && (delete R[L], Object.keys(R).forEach(function(W) {
              N.parents[W] = !0;
            }));
            continue;
          }
          R[L] = P;
          var B = N.value;
          typeof B != "string" ? B = I(B) : P.fmt && (B = this.tmStrFormat(B, P, y)), D.splice.apply(D, [k + 1, Math.max(0, F - k)].concat(B, P)), N.indexOf(P) === -1 && N.push(P);
        }
      }
      var j = 0, z = 0, H = "";
      return D.forEach(function(W) {
        if (typeof W == "string") {
          var G = W.split(`
`);
          G.length > 1 ? (z = G[G.length - 1].length, j += G.length - 1) : z += W.length, H += W;
        } else
          W && (W.start ? W.end = { row: j, column: z } : W.start = { row: j, column: z });
      }), {
        text: H,
        tabstops: E,
        tokens: D
      };
    }, b = (
      /** @class */
      function() {
        function y(S) {
          if (this.index = 0, this.ranges = [], this.tabstops = [], S.tabstopManager)
            return S.tabstopManager;
          S.tabstopManager = this, this.$onChange = this.onChange.bind(this), this.$onChangeSelection = l.delayedCall(this.onChangeSelection.bind(this)).schedule, this.$onChangeSession = this.onChangeSession.bind(this), this.$onAfterExec = this.onAfterExec.bind(this), this.attach(S);
        }
        return y.prototype.attach = function(S) {
          this.$openTabstops = null, this.selectedTabstop = null, this.editor = S, this.session = S.session, this.editor.on("change", this.$onChange), this.editor.on("changeSelection", this.$onChangeSelection), this.editor.on("changeSession", this.$onChangeSession), this.editor.commands.on("afterExec", this.$onAfterExec), this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
        }, y.prototype.detach = function() {
          this.tabstops.forEach(this.removeTabstopMarkers, this), this.ranges.length = 0, this.tabstops.length = 0, this.selectedTabstop = null, this.editor.off("change", this.$onChange), this.editor.off("changeSelection", this.$onChangeSelection), this.editor.off("changeSession", this.$onChangeSession), this.editor.commands.off("afterExec", this.$onAfterExec), this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler), this.editor.tabstopManager = null, this.session = null, this.editor = null;
        }, y.prototype.onChange = function(S) {
          for (var A = S.action[0] == "r", $ = this.selectedTabstop || {}, M = $.parents || {}, _ = this.tabstops.slice(), T = 0; T < _.length; T++) {
            var D = _[T], E = D == $ || M[D.index];
            if (D.rangeList.$bias = E ? 0 : 1, S.action == "remove" && D !== $) {
              var R = D.parents && D.parents[$.index], I = D.rangeList.pointIndex(S.start, R);
              I = I < 0 ? -I - 1 : I + 1;
              var k = D.rangeList.pointIndex(S.end, R);
              k = k < 0 ? -k - 1 : k - 1;
              for (var P = D.rangeList.ranges.slice(I, k), L = 0; L < P.length; L++)
                this.removeRange(P[L]);
            }
            D.rangeList.$onChange(S);
          }
          var N = this.session;
          !this.$inChange && A && N.getLength() == 1 && !N.getValue() && this.detach();
        }, y.prototype.updateLinkedFields = function() {
          var S = this.selectedTabstop;
          if (!(!S || !S.hasLinkedRanges || !S.firstNonLinked)) {
            this.$inChange = !0;
            for (var A = this.session, $ = A.getTextRange(S.firstNonLinked), M = 0; M < S.length; M++) {
              var _ = S[M];
              if (_.linked) {
                var T = _.original, D = r.snippetManager.tmStrFormat($, T, this.editor);
                A.replace(_, D);
              }
            }
            this.$inChange = !1;
          }
        }, y.prototype.onAfterExec = function(S) {
          S.command && !S.command.readOnly && this.updateLinkedFields();
        }, y.prototype.onChangeSelection = function() {
          if (this.editor) {
            for (var S = this.editor.selection.lead, A = this.editor.selection.anchor, $ = this.editor.selection.isEmpty(), M = 0; M < this.ranges.length; M++)
              if (!this.ranges[M].linked) {
                var _ = this.ranges[M].contains(S.row, S.column), T = $ || this.ranges[M].contains(A.row, A.column);
                if (_ && T)
                  return;
              }
            this.detach();
          }
        }, y.prototype.onChangeSession = function() {
          this.detach();
        }, y.prototype.tabNext = function(S) {
          var A = this.tabstops.length, $ = this.index + (S || 1);
          $ = Math.min(Math.max($, 1), A), $ == A && ($ = 0), this.selectTabstop($), this.updateTabstopMarkers(), $ === 0 && this.detach();
        }, y.prototype.selectTabstop = function(S) {
          this.$openTabstops = null;
          var A = this.tabstops[this.index];
          if (A && this.addTabstopMarkers(A), this.index = S, A = this.tabstops[this.index], !(!A || !A.length)) {
            this.selectedTabstop = A;
            var $ = A.firstNonLinked || A;
            if (A.choices && ($.cursor = $.start), this.editor.inVirtualSelectionMode)
              this.editor.selection.fromOrientedRange($);
            else {
              var M = this.editor.multiSelect;
              M.toSingleRange($);
              for (var _ = 0; _ < A.length; _++)
                A.hasLinkedRanges && A[_].linked || M.addRange(A[_].clone(), !0);
            }
            this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler), this.selectedTabstop && this.selectedTabstop.choices && this.editor.execCommand("startAutocomplete", { matches: this.selectedTabstop.choices });
          }
        }, y.prototype.addTabstops = function(S, A, $) {
          var M = this.useLink || !this.editor.getOption("enableMultiselect");
          if (this.$openTabstops || (this.$openTabstops = []), !S[0]) {
            var _ = u.fromPoints($, $);
            w(_.start, A), w(_.end, A), S[0] = [_], S[0].index = 0;
          }
          var T = this.index, D = [T + 1, 0], E = this.ranges, R = this.snippetId = (this.snippetId || 0) + 1;
          S.forEach(function(I, k) {
            var P = this.$openTabstops[k] || I;
            P.snippetId = R;
            for (var L = 0; L < I.length; L++) {
              var N = I[L], F = u.fromPoints(N.start, N.end || N.start);
              x(F.start, A), x(F.end, A), F.original = N, F.tabstop = P, E.push(F), P != I ? P.unshift(F) : P[L] = F, N.fmtString || P.firstNonLinked && M ? (F.linked = !0, P.hasLinkedRanges = !0) : P.firstNonLinked || (P.firstNonLinked = F);
            }
            P.firstNonLinked || (P.hasLinkedRanges = !1), P === I && (D.push(P), this.$openTabstops[k] = P), this.addTabstopMarkers(P), P.rangeList = P.rangeList || new c(), P.rangeList.$bias = 0, P.rangeList.addList(P);
          }, this), D.length > 2 && (this.tabstops.length && D.push(D.splice(2, 1)[0]), this.tabstops.splice.apply(this.tabstops, D));
        }, y.prototype.addTabstopMarkers = function(S) {
          var A = this.session;
          S.forEach(function($) {
            $.markerId || ($.markerId = A.addMarker($, "ace_snippet-marker", "text"));
          });
        }, y.prototype.removeTabstopMarkers = function(S) {
          var A = this.session;
          S.forEach(function($) {
            A.removeMarker($.markerId), $.markerId = null;
          });
        }, y.prototype.updateTabstopMarkers = function() {
          if (this.selectedTabstop) {
            var S = this.selectedTabstop.snippetId;
            this.selectedTabstop.index === 0 && S--, this.tabstops.forEach(function(A) {
              A.snippetId === S ? this.addTabstopMarkers(A) : this.removeTabstopMarkers(A);
            }, this);
          }
        }, y.prototype.removeRange = function(S) {
          var A = S.tabstop.indexOf(S);
          A != -1 && S.tabstop.splice(A, 1), A = this.ranges.indexOf(S), A != -1 && this.ranges.splice(A, 1), A = S.tabstop.rangeList.ranges.indexOf(S), A != -1 && S.tabstop.splice(A, 1), this.session.removeMarker(S.markerId), S.tabstop.length || (A = this.tabstops.indexOf(S.tabstop), A != -1 && this.tabstops.splice(A, 1), this.tabstops.length || this.detach());
        }, y;
      }()
    );
    b.prototype.keyboardHandler = new d(), b.prototype.keyboardHandler.bindKeys({
      Tab: function(y) {
        r.snippetManager && r.snippetManager.expandWithTab(y) || (y.tabstopManager.tabNext(1), y.renderer.scrollCursorIntoView());
      },
      "Shift-Tab": function(y) {
        y.tabstopManager.tabNext(-1), y.renderer.scrollCursorIntoView();
      },
      Esc: function(y) {
        y.tabstopManager.detach();
      }
    });
    var x = function(y, S) {
      y.row == 0 && (y.column += S.column), y.row += S.row;
    }, w = function(y, S) {
      y.row == S.row && (y.column -= S.column), y.row -= S.row;
    };
    o.importCssString(`
.ace_snippet-marker {
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    background: rgba(194, 193, 208, 0.09);
    border: 1px dotted rgba(211, 208, 235, 0.62);
    position: absolute;
}`, "snippets.css", !1), r.snippetManager = new m();
    var C = n("./editor").Editor;
    (function() {
      this.insertSnippet = function(y, S) {
        return r.snippetManager.insertSnippet(this, y, S);
      }, this.expandSnippet = function(y) {
        return r.snippetManager.expandWithTab(this, y);
      };
    }).call(C.prototype);
  }), ace.define("ace/autocomplete/popup", ["require", "exports", "module", "ace/virtual_renderer", "ace/editor", "ace/range", "ace/lib/event", "ace/lib/lang", "ace/lib/dom", "ace/config", "ace/lib/useragent"], function(n, r, i) {
    var o = n("../virtual_renderer").VirtualRenderer, s = n("../editor").Editor, a = n("../range").Range, l = n("../lib/event"), u = n("../lib/lang"), c = n("../lib/dom"), d = n("../config").nls, f = n("./../lib/useragent"), h = function(x) {
      return "suggest-aria-id:".concat(x);
    }, p = f.isSafari ? "menu" : "listbox", g = f.isSafari ? "menuitem" : "option", m = f.isSafari ? "aria-current" : "aria-selected", v = function(x) {
      var w = new o(x);
      w.$maxLines = 4;
      var C = new s(w);
      return C.setHighlightActiveLine(!1), C.setShowPrintMargin(!1), C.renderer.setShowGutter(!1), C.renderer.setHighlightGutterLine(!1), C.$mouseHandler.$focusTimeout = 0, C.$highlightTagPending = !0, C;
    }, b = (
      /** @class */
      /* @__PURE__ */ function() {
        function x(w) {
          var C = c.createElement("div"), y = v(C);
          w && w.appendChild(C), C.style.display = "none", y.renderer.content.style.cursor = "default", y.renderer.setStyle("ace_autocomplete"), y.renderer.$textLayer.element.setAttribute("role", p), y.renderer.$textLayer.element.setAttribute("aria-roledescription", d("autocomplete.popup.aria-roledescription", "Autocomplete suggestions")), y.renderer.$textLayer.element.setAttribute("aria-label", d("autocomplete.popup.aria-label", "Autocomplete suggestions")), y.renderer.textarea.setAttribute("aria-hidden", "true"), y.setOption("displayIndentGuides", !1), y.setOption("dragDelay", 150);
          var S = function() {
          };
          y.focus = S, y.$isFocused = !0, y.renderer.$cursorLayer.restartTimer = S, y.renderer.$cursorLayer.element.style.opacity = "0", y.renderer.$maxLines = 8, y.renderer.$keepTextAreaAtCursor = !1, y.setHighlightActiveLine(!1), y.session.highlight(""), y.session.$searchHighlight.clazz = "ace_highlight-marker", y.on("mousedown", function(E) {
            var R = E.getDocumentPosition();
            y.selection.moveToPosition(R), M.start.row = M.end.row = R.row, E.stop();
          });
          var A, $ = new a(-1, 0, -1, 1 / 0), M = new a(-1, 0, -1, 1 / 0);
          M.id = y.session.addMarker(M, "ace_active-line", "fullLine"), y.setSelectOnHover = function(E) {
            E ? $.id && (y.session.removeMarker($.id), $.id = null) : $.id = y.session.addMarker($, "ace_line-hover", "fullLine");
          }, y.setSelectOnHover(!1), y.on("mousemove", function(E) {
            if (!A) {
              A = E;
              return;
            }
            if (!(A.x == E.x && A.y == E.y)) {
              A = E, A.scrollTop = y.renderer.scrollTop, y.isMouseOver = !0;
              var R = A.getDocumentPosition().row;
              $.start.row != R && ($.id || y.setRow(R), T(R));
            }
          }), y.renderer.on("beforeRender", function() {
            if (A && $.start.row != -1) {
              A.$pos = null;
              var E = A.getDocumentPosition().row;
              $.id || y.setRow(E), T(E, !0);
            }
          }), y.renderer.on("afterRender", function() {
            var E = y.getRow(), R = y.renderer.$textLayer, I = (
              /** @type {HTMLElement|null} */
              R.element.childNodes[E - R.config.firstRow]
            ), k = document.activeElement;
            if (I !== y.selectedNode && y.selectedNode && (c.removeCssClass(y.selectedNode, "ace_selected"), k.removeAttribute("aria-activedescendant"), y.selectedNode.removeAttribute(m), y.selectedNode.removeAttribute("id")), y.selectedNode = I, I) {
              c.addCssClass(I, "ace_selected");
              var P = h(E);
              I.id = P, R.element.setAttribute("aria-activedescendant", P), k.setAttribute("aria-activedescendant", P), I.setAttribute("role", g), I.setAttribute("aria-roledescription", d("autocomplete.popup.item.aria-roledescription", "item")), I.setAttribute("aria-label", y.getData(E).caption || y.getData(E).value), I.setAttribute("aria-setsize", y.data.length), I.setAttribute("aria-posinset", E + 1), I.setAttribute("aria-describedby", "doc-tooltip"), I.setAttribute(m, "true");
            }
          });
          var _ = function() {
            T(-1);
          }, T = function(E, R) {
            E !== $.start.row && ($.start.row = $.end.row = E, R || y.session._emit("changeBackMarker"), y._emit("changeHoverMarker"));
          };
          y.getHoveredRow = function() {
            return $.start.row;
          }, l.addListener(y.container, "mouseout", function() {
            y.isMouseOver = !1, _();
          }), y.on("hide", _), y.on("changeSelection", _), y.session.doc.getLength = function() {
            return y.data.length;
          }, y.session.doc.getLine = function(E) {
            var R = y.data[E];
            return typeof R == "string" ? R : R && R.value || "";
          };
          var D = y.session.bgTokenizer;
          return D.$tokenizeRow = function(E) {
            var R = y.data[E], I = [];
            if (!R)
              return I;
            typeof R == "string" && (R = { value: R });
            var k = R.caption || R.value || R.name;
            function P(W, G) {
              W && I.push({
                type: (R.className || "") + (G || ""),
                value: W
              });
            }
            for (var L = k.toLowerCase(), N = (y.filterText || "").toLowerCase(), F = 0, B = 0, j = 0; j <= N.length; j++)
              if (j != B && (R.matchMask & 1 << j || j == N.length)) {
                var z = N.slice(B, j);
                B = j;
                var H = L.indexOf(z, F);
                if (H == -1)
                  continue;
                P(k.slice(F, H), ""), F = H + z.length, P(k.slice(H, F), "completion-highlight");
              }
            return P(k.slice(F, k.length), ""), I.push({ type: "completion-spacer", value: " " }), R.meta && I.push({ type: "completion-meta", value: R.meta }), R.message && I.push({ type: "completion-message", value: R.message }), I;
          }, D.$updateOnChange = S, D.start = S, y.session.$computeWidth = function() {
            return this.screenWidth = 0;
          }, y.isOpen = !1, y.isTopdown = !1, y.autoSelect = !0, y.filterText = "", y.isMouseOver = !1, y.data = [], y.setData = function(E, R) {
            y.filterText = R || "", y.setValue(u.stringRepeat(`
`, E.length), -1), y.data = E || [], y.setRow(0);
          }, y.getData = function(E) {
            return y.data[E];
          }, y.getRow = function() {
            return M.start.row;
          }, y.setRow = function(E) {
            E = Math.max(this.autoSelect ? 0 : -1, Math.min(this.data.length - 1, E)), M.start.row != E && (y.selection.clearSelection(), M.start.row = M.end.row = E || 0, y.session._emit("changeBackMarker"), y.moveCursorTo(E || 0, 0), y.isOpen && y._signal("select"));
          }, y.on("changeSelection", function() {
            y.isOpen && y.setRow(y.selection.lead.row), y.renderer.scrollCursorIntoView();
          }), y.hide = function() {
            this.container.style.display = "none", y.anchorPos = null, y.anchor = null, y.isOpen && (y.isOpen = !1, this._signal("hide"));
          }, y.tryShow = function(E, R, I, k) {
            if (!k && y.isOpen && y.anchorPos && y.anchor && y.anchorPos.top === E.top && y.anchorPos.left === E.left && y.anchor === I)
              return !0;
            var P = this.container, L = window.innerHeight, N = window.innerWidth, F = this.renderer, B = F.$maxLines * R * 1.4, j = { top: 0, bottom: 0, left: 0 }, z = L - E.top - 3 * this.$borderSize - R, H = E.top - 3 * this.$borderSize;
            I || (H <= z || z >= B ? I = "bottom" : I = "top"), I === "top" ? (j.bottom = E.top - this.$borderSize, j.top = j.bottom - B) : I === "bottom" && (j.top = E.top + R + this.$borderSize, j.bottom = j.top + B);
            var W = j.top >= 0 && j.bottom <= L;
            if (!k && !W)
              return !1;
            W ? F.$maxPixelHeight = null : I === "top" ? F.$maxPixelHeight = H : F.$maxPixelHeight = z, I === "top" ? (P.style.top = "", P.style.bottom = L - j.bottom + "px", y.isTopdown = !1) : (P.style.top = j.top + "px", P.style.bottom = "", y.isTopdown = !0), P.style.display = "";
            var G = E.left;
            return G + P.offsetWidth > N && (G = N - P.offsetWidth), P.style.left = G + "px", P.style.right = "", y.isOpen || (y.isOpen = !0, this._signal("show"), A = null), y.anchorPos = E, y.anchor = I, !0;
          }, y.show = function(E, R, I) {
            this.tryShow(E, R, I ? "bottom" : void 0, !0);
          }, y.goTo = function(E) {
            var R = this.getRow(), I = this.session.getLength() - 1;
            switch (E) {
              case "up":
                R = R <= 0 ? I : R - 1;
                break;
              case "down":
                R = R >= I ? -1 : R + 1;
                break;
              case "start":
                R = 0;
                break;
              case "end":
                R = I;
                break;
            }
            this.setRow(R);
          }, y.getTextLeftOffset = function() {
            return this.$borderSize + this.renderer.$padding + this.$imageSize;
          }, y.$imageSize = 0, y.$borderSize = 1, y;
        }
        return x;
      }()
    );
    c.importCssString(`
.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {
    background-color: #CAD6FA;
    z-index: 1;
}
.ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {
    background-color: #3a674e;
}
.ace_editor.ace_autocomplete .ace_line-hover {
    border: 1px solid #abbffe;
    margin-top: -1px;
    background: rgba(233,233,253,0.4);
    position: absolute;
    z-index: 2;
}
.ace_dark.ace_editor.ace_autocomplete .ace_line-hover {
    border: 1px solid rgba(109, 150, 13, 0.8);
    background: rgba(58, 103, 78, 0.62);
}
.ace_completion-meta {
    opacity: 0.5;
    margin-left: 0.9em;
}
.ace_completion-message {
    margin-left: 0.9em;
    color: blue;
}
.ace_editor.ace_autocomplete .ace_completion-highlight{
    color: #2d69c7;
}
.ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight{
    color: #93ca12;
}
.ace_editor.ace_autocomplete {
    width: 300px;
    z-index: 200000;
    border: 1px lightgray solid;
    position: fixed;
    box-shadow: 2px 3px 5px rgba(0,0,0,.2);
    line-height: 1.4;
    background: #fefefe;
    color: #111;
}
.ace_dark.ace_editor.ace_autocomplete {
    border: 1px #484747 solid;
    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);
    line-height: 1.4;
    background: #25282c;
    color: #c1c1c1;
}
.ace_autocomplete .ace_text-layer  {
    width: calc(100% - 8px);
}
.ace_autocomplete .ace_line {
    display: flex;
    align-items: center;
}
.ace_autocomplete .ace_line > * {
    min-width: 0;
    flex: 0 0 auto;
}
.ace_autocomplete .ace_line .ace_ {
    flex: 0 1 auto;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
}
.ace_autocomplete .ace_completion-spacer {
    flex: 1;
}
.ace_autocomplete.ace_loading:after  {
    content: "";
    position: absolute;
    top: 0px;
    height: 2px;
    width: 8%;
    background: blue;
    z-index: 100;
    animation: ace_progress 3s infinite linear;
    animation-delay: 300ms;
    transform: translateX(-100%) scaleX(1);
}
@keyframes ace_progress {
    0% { transform: translateX(-100%) scaleX(1) }
    50% { transform: translateX(625%) scaleX(2) } 
    100% { transform: translateX(1500%) scaleX(3) } 
}
@media (prefers-reduced-motion) {
    .ace_autocomplete.ace_loading:after {
        transform: translateX(625%) scaleX(2);
        animation: none;
     }
}
`, "autocompletion.css", !1), r.AcePopup = b, r.$singleLineEditor = v, r.getAriaId = h;
  }), ace.define("ace/autocomplete/inline_screenreader", ["require", "exports", "module"], function(n, r, i) {
    var o = (
      /** @class */
      function() {
        function s(a) {
          this.editor = a, this.screenReaderDiv = document.createElement("div"), this.screenReaderDiv.classList.add("ace_screenreader-only"), this.editor.container.appendChild(this.screenReaderDiv);
        }
        return s.prototype.setScreenReaderContent = function(a) {
          for (!this.popup && this.editor.completer && /**@type{import("../autocomplete").Autocomplete}*/
          this.editor.completer.popup && (this.popup = /**@type{import("../autocomplete").Autocomplete}*/
          this.editor.completer.popup, this.popup.renderer.on("afterRender", (function() {
            var u = this.popup.getRow(), c = this.popup.renderer.$textLayer, d = c.element.childNodes[u - c.config.firstRow];
            if (d) {
              for (var f = "doc-tooltip ", h = 0; h < this._lines.length; h++)
                f += "ace-inline-screenreader-line-".concat(h, " ");
              d.setAttribute("aria-describedby", f);
            }
          }).bind(this))); this.screenReaderDiv.firstChild; )
            this.screenReaderDiv.removeChild(this.screenReaderDiv.firstChild);
          this._lines = a.split(/\r\n|\r|\n/);
          var l = this.createCodeBlock();
          this.screenReaderDiv.appendChild(l);
        }, s.prototype.destroy = function() {
          this.screenReaderDiv.remove();
        }, s.prototype.createCodeBlock = function() {
          var a = document.createElement("pre");
          a.setAttribute("id", "ace-inline-screenreader");
          for (var l = 0; l < this._lines.length; l++) {
            var u = document.createElement("code");
            u.setAttribute("id", "ace-inline-screenreader-line-".concat(l));
            var c = document.createTextNode(this._lines[l]);
            u.appendChild(c), a.appendChild(u);
          }
          return a;
        }, s;
      }()
    );
    r.AceInlineScreenReader = o;
  }), ace.define("ace/autocomplete/inline", ["require", "exports", "module", "ace/snippets", "ace/autocomplete/inline_screenreader"], function(n, r, i) {
    var o = n("../snippets").snippetManager, s = n("./inline_screenreader").AceInlineScreenReader, a = (
      /** @class */
      function() {
        function l() {
          this.editor = null;
        }
        return l.prototype.show = function(u, c, d) {
          if (d = d || "", u && this.editor && this.editor !== u && (this.hide(), this.editor = null, this.inlineScreenReader = null), !u || !c)
            return !1;
          this.inlineScreenReader || (this.inlineScreenReader = new s(u));
          var f = c.snippet ? o.getDisplayTextForSnippet(u, c.snippet) : c.value;
          return c.hideInlinePreview || !f || !f.startsWith(d) ? !1 : (this.editor = u, this.inlineScreenReader.setScreenReaderContent(f), f = f.slice(d.length), f === "" ? u.removeGhostText() : u.setGhostText(f), !0);
        }, l.prototype.isOpen = function() {
          return this.editor ? !!this.editor.renderer.$ghostText : !1;
        }, l.prototype.hide = function() {
          return this.editor ? (this.editor.removeGhostText(), !0) : !1;
        }, l.prototype.destroy = function() {
          this.hide(), this.editor = null, this.inlineScreenReader && (this.inlineScreenReader.destroy(), this.inlineScreenReader = null);
        }, l;
      }()
    );
    r.AceInline = a;
  }), ace.define("ace/autocomplete/util", ["require", "exports", "module"], function(n, r, i) {
    r.parForEach = function(s, a, l) {
      var u = 0, c = s.length;
      c === 0 && l();
      for (var d = 0; d < c; d++)
        a(s[d], function(f, h) {
          u++, u === c && l(f, h);
        });
    };
    var o = /[a-zA-Z_0-9\$\-\u00A2-\u2000\u2070-\uFFFF]/;
    r.retrievePrecedingIdentifier = function(s, a, l) {
      l = l || o;
      for (var u = [], c = a - 1; c >= 0 && l.test(s[c]); c--)
        u.push(s[c]);
      return u.reverse().join("");
    }, r.retrieveFollowingIdentifier = function(s, a, l) {
      l = l || o;
      for (var u = [], c = a; c < s.length && l.test(s[c]); c++)
        u.push(s[c]);
      return u;
    }, r.getCompletionPrefix = function(s) {
      var a = s.getCursorPosition(), l = s.session.getLine(a.row), u;
      return s.completers.forEach((function(c) {
        c.identifierRegexps && c.identifierRegexps.forEach((function(d) {
          !u && d && (u = this.retrievePrecedingIdentifier(l, a.column, d));
        }).bind(this));
      }).bind(this)), u || this.retrievePrecedingIdentifier(l, a.column);
    }, r.triggerAutocomplete = function(s, l) {
      var l = l ?? s.session.getPrecedingCharacter();
      return s.completers.some(function(u) {
        if (u.triggerCharacters && Array.isArray(u.triggerCharacters))
          return u.triggerCharacters.includes(l);
      });
    };
  }), ace.define("ace/autocomplete", ["require", "exports", "module", "ace/keyboard/hash_handler", "ace/autocomplete/popup", "ace/autocomplete/inline", "ace/autocomplete/popup", "ace/autocomplete/util", "ace/lib/lang", "ace/lib/dom", "ace/snippets", "ace/config", "ace/lib/event", "ace/lib/scroll"], function(n, r, i) {
    var o = n("./keyboard/hash_handler").HashHandler, s = n("./autocomplete/popup").AcePopup, a = n("./autocomplete/inline").AceInline, l = n("./autocomplete/popup").getAriaId, u = n("./autocomplete/util"), c = n("./lib/lang"), d = n("./lib/dom"), f = n("./snippets").snippetManager, h = n("./config"), p = n("./lib/event"), g = n("./lib/scroll").preventParentScroll, m = function(w, C) {
      C.completer && C.completer.destroy();
    }, v = (
      /** @class */
      function() {
        function w() {
          this.autoInsert = !1, this.autoSelect = !0, this.autoShown = !1, this.exactMatch = !1, this.inlineEnabled = !1, this.keyboardHandler = new o(), this.keyboardHandler.bindKeys(this.commands), this.parentNode = null, this.setSelectOnHover = !1, this.hasSeen = /* @__PURE__ */ new Set(), this.showLoadingState = !1, this.stickySelectionDelay = 500, this.blurListener = this.blurListener.bind(this), this.changeListener = this.changeListener.bind(this), this.mousedownListener = this.mousedownListener.bind(this), this.mousewheelListener = this.mousewheelListener.bind(this), this.onLayoutChange = this.onLayoutChange.bind(this), this.changeTimer = c.delayedCall((function() {
            this.updateCompletions(!0);
          }).bind(this)), this.tooltipTimer = c.delayedCall(this.updateDocTooltip.bind(this), 50), this.popupTimer = c.delayedCall(this.$updatePopupPosition.bind(this), 50), this.stickySelectionTimer = c.delayedCall((function() {
            this.stickySelection = !0;
          }).bind(this), this.stickySelectionDelay), this.$firstOpenTimer = c.delayedCall(
            /**@this{Autocomplete}*/
            (function() {
              var C = this.completionProvider && this.completionProvider.initialPosition;
              this.autoShown || this.popup && this.popup.isOpen || !C || this.editor.completers.length === 0 || (this.completions = new x(w.completionsForLoading), this.openPopup(this.editor, C.prefix, !1), this.popup.renderer.setStyle("ace_loading", !0));
            }).bind(this),
            this.stickySelectionDelay
          );
        }
        return Object.defineProperty(w, "completionsForLoading", {
          get: function() {
            return [{
              caption: h.nls("autocomplete.loading", "Loading..."),
              value: ""
            }];
          },
          enumerable: !1,
          configurable: !0
        }), w.prototype.$init = function() {
          return this.popup = new s(this.parentNode || document.body || document.documentElement), this.popup.on("click", (function(C) {
            this.insertMatch(), C.stop();
          }).bind(this)), this.popup.focus = this.editor.focus.bind(this.editor), this.popup.on("show", this.$onPopupShow.bind(this)), this.popup.on("hide", this.$onHidePopup.bind(this)), this.popup.on("select", this.$onPopupChange.bind(this)), p.addListener(this.popup.container, "mouseout", this.mouseOutListener.bind(this)), this.popup.on("changeHoverMarker", this.tooltipTimer.bind(null, null)), this.popup.renderer.on("afterRender", this.$onPopupRender.bind(this)), this.popup;
        }, w.prototype.$initInline = function() {
          if (!(!this.inlineEnabled || this.inlineRenderer))
            return this.inlineRenderer = new a(), this.inlineRenderer;
        }, w.prototype.getPopup = function() {
          return this.popup || this.$init();
        }, w.prototype.$onHidePopup = function() {
          this.inlineRenderer && this.inlineRenderer.hide(), this.hideDocTooltip(), this.stickySelectionTimer.cancel(), this.popupTimer.cancel(), this.stickySelection = !1;
        }, w.prototype.$seen = function(C) {
          !this.hasSeen.has(C) && C && C.completer && C.completer.onSeen && typeof C.completer.onSeen == "function" && (C.completer.onSeen(this.editor, C), this.hasSeen.add(C));
        }, w.prototype.$onPopupChange = function(C) {
          if (this.inlineRenderer && this.inlineEnabled) {
            var y = C ? null : this.popup.getData(this.popup.getRow());
            if (this.$updateGhostText(y), this.popup.isMouseOver && this.setSelectOnHover) {
              this.tooltipTimer.call(null, null);
              return;
            }
            this.popupTimer.schedule(), this.tooltipTimer.schedule();
          } else
            this.popupTimer.call(null, null), this.tooltipTimer.call(null, null);
        }, w.prototype.$updateGhostText = function(C) {
          var y = this.base.row, S = this.base.column, A = this.editor.getCursorPosition().column, $ = this.editor.session.getLine(y).slice(S, A);
          this.inlineRenderer.show(this.editor, C, $) ? this.$seen(C) : this.inlineRenderer.hide();
        }, w.prototype.$onPopupRender = function() {
          var C = this.inlineRenderer && this.inlineEnabled;
          if (this.completions && this.completions.filtered && this.completions.filtered.length > 0)
            for (var y = this.popup.getFirstVisibleRow(); y <= this.popup.getLastVisibleRow(); y++) {
              var S = this.popup.getData(y);
              S && (!C || S.hideInlinePreview) && this.$seen(S);
            }
        }, w.prototype.$onPopupShow = function(C) {
          this.$onPopupChange(C), this.stickySelection = !1, this.stickySelectionDelay >= 0 && this.stickySelectionTimer.schedule(this.stickySelectionDelay);
        }, w.prototype.observeLayoutChanges = function() {
          if (!(this.$elements || !this.editor)) {
            window.addEventListener("resize", this.onLayoutChange, { passive: !0 }), window.addEventListener("wheel", this.mousewheelListener);
            for (var C = this.editor.container.parentNode, y = []; C; )
              y.push(C), C.addEventListener("scroll", this.onLayoutChange, { passive: !0 }), C = C.parentNode;
            this.$elements = y;
          }
        }, w.prototype.unObserveLayoutChanges = function() {
          var C = this;
          window.removeEventListener("resize", this.onLayoutChange, { passive: !0 }), window.removeEventListener("wheel", this.mousewheelListener), this.$elements && this.$elements.forEach(function(y) {
            y.removeEventListener("scroll", C.onLayoutChange, { passive: !0 });
          }), this.$elements = null;
        }, w.prototype.onLayoutChange = function() {
          if (!this.popup.isOpen)
            return this.unObserveLayoutChanges();
          this.$updatePopupPosition(), this.updateDocTooltip();
        }, w.prototype.$updatePopupPosition = function() {
          var C = this.editor, y = C.renderer, S = y.layerConfig.lineHeight, A = y.$cursorLayer.getPixelPosition(this.base, !0);
          A.left -= this.popup.getTextLeftOffset();
          var $ = C.container.getBoundingClientRect();
          A.top += $.top - y.layerConfig.offset, A.left += $.left - C.renderer.scrollLeft, A.left += y.gutterWidth;
          var M = {
            top: A.top,
            left: A.left
          };
          y.$ghostText && y.$ghostTextWidget && this.base.row === y.$ghostText.position.row && (M.top += y.$ghostTextWidget.el.offsetHeight);
          var _ = C.container.getBoundingClientRect().bottom - S, T = _ < M.top ? { top: _, left: M.left } : M;
          this.popup.tryShow(T, S, "bottom") || this.popup.tryShow(A, S, "top") || this.popup.show(A, S);
        }, w.prototype.openPopup = function(C, y, S) {
          this.$firstOpenTimer.cancel(), this.popup || this.$init(), this.inlineEnabled && !this.inlineRenderer && this.$initInline(), this.popup.autoSelect = this.autoSelect, this.popup.setSelectOnHover(this.setSelectOnHover);
          var A = this.popup.getRow(), $ = this.popup.data[A];
          this.popup.setData(this.completions.filtered, this.completions.filterText), this.editor.textInput.setAriaOptions && this.editor.textInput.setAriaOptions({
            activeDescendant: l(this.popup.getRow()),
            inline: this.inlineEnabled
          }), C.keyBinding.addKeyboardHandler(this.keyboardHandler);
          var M;
          this.stickySelection && (M = this.popup.data.indexOf($)), (!M || M === -1) && (M = 0), this.popup.setRow(this.autoSelect ? M : -1), M === A && $ !== this.completions.filtered[M] && this.$onPopupChange();
          var _ = this.inlineRenderer && this.inlineEnabled;
          if (M === A && _) {
            var T = this.popup.getData(this.popup.getRow());
            this.$updateGhostText(T);
          }
          S || (this.popup.setTheme(C.getTheme()), this.popup.setFontSize(C.getFontSize()), this.$updatePopupPosition(), this.tooltipNode && this.updateDocTooltip()), this.changeTimer.cancel(), this.observeLayoutChanges();
        }, w.prototype.detach = function() {
          this.editor && (this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler), this.editor.off("changeSelection", this.changeListener), this.editor.off("blur", this.blurListener), this.editor.off("mousedown", this.mousedownListener), this.editor.off("mousewheel", this.mousewheelListener)), this.$firstOpenTimer.cancel(), this.changeTimer.cancel(), this.hideDocTooltip(), this.completionProvider && this.completionProvider.detach(), this.popup && this.popup.isOpen && this.popup.hide(), this.popup && this.popup.renderer && this.popup.renderer.off("afterRender", this.$onPopupRender), this.base && this.base.detach(), this.activated = !1, this.completionProvider = this.completions = this.base = null, this.unObserveLayoutChanges();
        }, w.prototype.changeListener = function(C) {
          var y = this.editor.selection.lead;
          (y.row != this.base.row || y.column < this.base.column) && this.detach(), this.activated ? this.changeTimer.schedule() : this.detach();
        }, w.prototype.blurListener = function(C) {
          var y = document.activeElement, S = this.editor.textInput.getElement(), A = C.relatedTarget && this.tooltipNode && this.tooltipNode.contains(C.relatedTarget), $ = this.popup && this.popup.container;
          y != S && y.parentNode != $ && !A && y != this.tooltipNode && C.relatedTarget != S && this.detach();
        }, w.prototype.mousedownListener = function(C) {
          this.detach();
        }, w.prototype.mousewheelListener = function(C) {
          this.popup && !this.popup.isMouseOver && this.detach();
        }, w.prototype.mouseOutListener = function(C) {
          this.popup.isOpen && this.$updatePopupPosition();
        }, w.prototype.goTo = function(C) {
          this.popup.goTo(C);
        }, w.prototype.insertMatch = function(C, y) {
          if (C || (C = this.popup.getData(this.popup.getRow())), !C)
            return !1;
          if (C.value === "")
            return this.detach();
          var S = this.completions, A = this.getCompletionProvider().insertMatch(this.editor, C, S.filterText, y);
          return this.completions == S && this.detach(), A;
        }, w.prototype.showPopup = function(C, y) {
          this.editor && this.detach(), this.activated = !0, this.editor = C, C.completer != this && (C.completer && C.completer.detach(), C.completer = this), C.on("changeSelection", this.changeListener), C.on("blur", this.blurListener), C.on("mousedown", this.mousedownListener), C.on("mousewheel", this.mousewheelListener), this.updateCompletions(!1, y);
        }, w.prototype.getCompletionProvider = function(C) {
          return this.completionProvider || (this.completionProvider = new b(C)), this.completionProvider;
        }, w.prototype.gatherCompletions = function(C, y) {
          return this.getCompletionProvider().gatherCompletions(C, y);
        }, w.prototype.updateCompletions = function(C, y) {
          if (C && this.base && this.completions) {
            var A = this.editor.getCursorPosition(), $ = this.editor.session.getTextRange({ start: this.base, end: A });
            if ($ == this.completions.filterText)
              return;
            if (this.completions.setFilter($), !this.completions.filtered.length)
              return this.detach();
            if (this.completions.filtered.length == 1 && this.completions.filtered[0].value == $ && !this.completions.filtered[0].snippet)
              return this.detach();
            this.openPopup(this.editor, $, C);
            return;
          }
          if (y && y.matches) {
            var A = this.editor.getSelectionRange().start;
            return this.base = this.editor.session.doc.createAnchor(A.row, A.column), this.base.$insertRight = !0, this.completions = new x(y.matches), this.getCompletionProvider().completions = this.completions, this.openPopup(this.editor, "", C);
          }
          var S = this.editor.getSession(), A = this.editor.getCursorPosition(), $ = u.getCompletionPrefix(this.editor);
          this.base = S.doc.createAnchor(A.row, A.column - $.length), this.base.$insertRight = !0;
          var M = {
            exactMatch: this.exactMatch,
            ignoreCaption: this.ignoreCaption
          };
          this.getCompletionProvider({
            prefix: $,
            pos: A
          }).provideCompletions(
            this.editor,
            M,
            (function(_, T, D) {
              var E = T.filtered, R = u.getCompletionPrefix(this.editor);
              if (this.$firstOpenTimer.cancel(), D) {
                if (!E.length) {
                  var I = !this.autoShown && this.emptyMessage;
                  if (typeof I == "function" && (I = this.emptyMessage(R)), I) {
                    var k = [
                      {
                        caption: I,
                        value: ""
                      }
                    ];
                    this.completions = new x(k), this.openPopup(this.editor, R, C), this.popup.renderer.setStyle("ace_loading", !1), this.popup.renderer.setStyle("ace_empty-message", !0);
                    return;
                  }
                  return this.detach();
                }
                if (E.length == 1 && E[0].value == R && !E[0].snippet)
                  return this.detach();
                if (this.autoInsert && !this.autoShown && E.length == 1)
                  return this.insertMatch(E[0]);
              }
              this.completions = !D && this.showLoadingState ? new x(w.completionsForLoading.concat(E), T.filterText) : T, this.openPopup(this.editor, R, C), this.popup.renderer.setStyle("ace_empty-message", !1), this.popup.renderer.setStyle("ace_loading", !D);
            }).bind(this)
          ), this.showLoadingState && !this.autoShown && !(this.popup && this.popup.isOpen) && this.$firstOpenTimer.delay(this.stickySelectionDelay / 2);
        }, w.prototype.cancelContextMenu = function() {
          this.editor.$mouseHandler.cancelContextMenu();
        }, w.prototype.updateDocTooltip = function() {
          var C = this.popup, y = this.completions.filtered, S = y && (y[C.getHoveredRow()] || y[C.getRow()]), A = null;
          if (!S || !this.editor || !this.popup.isOpen)
            return this.hideDocTooltip();
          for (var $ = this.editor.completers.length, M = 0; M < $; M++) {
            var _ = this.editor.completers[M];
            if (_.getDocTooltip && S.completerId === _.id) {
              A = _.getDocTooltip(S);
              break;
            }
          }
          if (!A && typeof S != "string" && (A = S), typeof A == "string" && (A = { docText: A }), !A || !(A.docHTML || A.docText))
            return this.hideDocTooltip();
          this.showDocTooltip(A);
        }, w.prototype.showDocTooltip = function(C) {
          this.tooltipNode || (this.tooltipNode = d.createElement("div"), this.tooltipNode.style.margin = "0", this.tooltipNode.style.pointerEvents = "auto", this.tooltipNode.style.overscrollBehavior = "contain", this.tooltipNode.tabIndex = -1, this.tooltipNode.onblur = this.blurListener.bind(this), this.tooltipNode.onclick = this.onTooltipClick.bind(this), this.tooltipNode.id = "doc-tooltip", this.tooltipNode.setAttribute("role", "tooltip"), this.tooltipNode.addEventListener("wheel", g));
          var y = this.editor.renderer.theme;
          this.tooltipNode.className = "ace_tooltip ace_doc-tooltip " + (y.isDark ? "ace_dark " : "") + (y.cssClass || "");
          var S = this.tooltipNode;
          C.docHTML ? S.innerHTML = C.docHTML : C.docText && (S.textContent = C.docText), S.parentNode || this.popup.container.appendChild(this.tooltipNode);
          var A = this.popup, $ = A.container.getBoundingClientRect();
          S.style.top = A.container.style.top, S.style.bottom = A.container.style.bottom, S.style.display = "block", window.innerWidth - $.right < 320 ? $.left < 320 ? A.isTopdown ? (S.style.top = $.bottom + "px", S.style.left = $.left + "px", S.style.right = "", S.style.bottom = "") : (S.style.top = A.container.offsetTop - S.offsetHeight + "px", S.style.left = $.left + "px", S.style.right = "", S.style.bottom = "") : (S.style.right = window.innerWidth - $.left + "px", S.style.left = "") : (S.style.left = $.right + 1 + "px", S.style.right = "");
        }, w.prototype.hideDocTooltip = function() {
          if (this.tooltipTimer.cancel(), !!this.tooltipNode) {
            var C = this.tooltipNode;
            !this.editor.isFocused() && document.activeElement == C && this.editor.focus(), this.tooltipNode = null, C.parentNode && C.parentNode.removeChild(C);
          }
        }, w.prototype.onTooltipClick = function(C) {
          for (var y = C.target; y && y != this.tooltipNode; ) {
            if (y.nodeName == "A" && y.href) {
              y.rel = "noreferrer", y.target = "_blank";
              break;
            }
            y = y.parentNode;
          }
        }, w.prototype.destroy = function() {
          if (this.detach(), this.popup) {
            this.popup.destroy();
            var C = this.popup.container;
            C && C.parentNode && C.parentNode.removeChild(C);
          }
          this.editor && this.editor.completer == this && (this.editor.off("destroy", m), this.editor.completer = null), this.inlineRenderer = this.popup = this.editor = null;
        }, w;
      }()
    );
    v.prototype.commands = {
      Up: function(w) {
        w.completer.goTo("up");
      },
      Down: function(w) {
        w.completer.goTo("down");
      },
      "Ctrl-Up|Ctrl-Home": function(w) {
        w.completer.goTo("start");
      },
      "Ctrl-Down|Ctrl-End": function(w) {
        w.completer.goTo("end");
      },
      Esc: function(w) {
        w.completer.detach();
      },
      Return: function(w) {
        return w.completer.insertMatch();
      },
      "Shift-Return": function(w) {
        w.completer.insertMatch(null, { deleteSuffix: !0 });
      },
      Tab: function(w) {
        var C = w.completer.insertMatch();
        if (!C && !w.tabstopManager)
          w.completer.goTo("down");
        else
          return C;
      },
      Backspace: function(w) {
        w.execCommand("backspace");
        var C = u.getCompletionPrefix(w);
        !C && w.completer && w.completer.detach();
      },
      PageUp: function(w) {
        w.completer.popup.gotoPageUp();
      },
      PageDown: function(w) {
        w.completer.popup.gotoPageDown();
      }
    }, v.for = function(w) {
      return w.completer instanceof v || (w.completer && (w.completer.destroy(), w.completer = null), h.get("sharedPopups") ? (v.$sharedInstance || (v.$sharedInstance = new v()), w.completer = v.$sharedInstance) : (w.completer = new v(), w.once("destroy", m))), w.completer;
    }, v.startCommand = {
      name: "startAutocomplete",
      exec: function(w, C) {
        var y = v.for(w);
        y.autoInsert = !1, y.autoSelect = !0, y.autoShown = !1, y.showPopup(w, C), y.cancelContextMenu();
      },
      bindKey: "Ctrl-Space|Ctrl-Shift-Space|Alt-Space"
    };
    var b = (
      /** @class */
      function() {
        function w(C) {
          this.initialPosition = C, this.active = !0;
        }
        return w.prototype.insertByIndex = function(C, y, S) {
          return !this.completions || !this.completions.filtered ? !1 : this.insertMatch(C, this.completions.filtered[y], S);
        }, w.prototype.insertMatch = function(C, y, S) {
          if (!y)
            return !1;
          if (C.startOperation({ command: { name: "insertMatch" } }), y.completer && y.completer.insertMatch)
            y.completer.insertMatch(C, y);
          else {
            if (!this.completions)
              return !1;
            var A = this.completions.filterText.length, $ = 0;
            if (y.range && y.range.start.row === y.range.end.row && (A -= this.initialPosition.prefix.length, A += this.initialPosition.pos.column - y.range.start.column, $ += y.range.end.column - this.initialPosition.pos.column), A || $) {
              var M;
              C.selection.getAllRanges ? M = C.selection.getAllRanges() : M = [C.getSelectionRange()];
              for (var _ = 0, T; T = M[_]; _++)
                T.start.column -= A, T.end.column += $, C.session.remove(T);
            }
            y.snippet ? f.insertSnippet(C, y.snippet) : this.$insertString(C, y), y.completer && y.completer.onInsert && typeof y.completer.onInsert == "function" && y.completer.onInsert(C, y), y.command && y.command === "startAutocomplete" && C.execCommand(y.command);
          }
          return C.endOperation(), !0;
        }, w.prototype.$insertString = function(C, y) {
          var S = y.value || y;
          C.execCommand("insertstring", S);
        }, w.prototype.gatherCompletions = function(C, y) {
          var S = C.getSession(), A = C.getCursorPosition(), $ = u.getCompletionPrefix(C), M = [];
          this.completers = C.completers;
          var _ = C.completers.length;
          return C.completers.forEach(function(T, D) {
            T.getCompletions(C, S, A, $, function(E, R) {
              T.hideInlinePreview && (R = R.map(function(I) {
                return Object.assign(I, { hideInlinePreview: T.hideInlinePreview });
              })), !E && R && (M = M.concat(R)), y(null, {
                prefix: u.getCompletionPrefix(C),
                matches: M,
                finished: --_ === 0
              });
            });
          }), !0;
        }, w.prototype.provideCompletions = function(C, y, S) {
          var A = (function(T) {
            var D = T.prefix, E = T.matches;
            this.completions = new x(E), y.exactMatch && (this.completions.exactMatch = !0), y.ignoreCaption && (this.completions.ignoreCaption = !0), this.completions.setFilter(D), (T.finished || this.completions.filtered.length) && S(null, this.completions, T.finished);
          }).bind(this), $ = !0, M = null;
          if (this.gatherCompletions(C, (function(T, D) {
            if (this.active) {
              T && (S(T, [], !0), this.detach());
              var E = D.prefix;
              if (E.indexOf(D.prefix) === 0) {
                if ($) {
                  M = D;
                  return;
                }
                A(D);
              }
            }
          }).bind(this)), $ = !1, M) {
            var _ = M;
            M = null, A(_);
          }
        }, w.prototype.detach = function() {
          this.active = !1, this.completers && this.completers.forEach(function(C) {
            typeof C.cancel == "function" && C.cancel();
          });
        }, w;
      }()
    ), x = (
      /** @class */
      function() {
        function w(C, y) {
          this.all = C, this.filtered = C, this.filterText = y || "", this.exactMatch = !1, this.ignoreCaption = !1;
        }
        return w.prototype.setFilter = function(C) {
          if (C.length > this.filterText && C.lastIndexOf(this.filterText, 0) === 0)
            var y = this.filtered;
          else
            var y = this.all;
          this.filterText = C, y = this.filterCompletions(y, this.filterText), y = y.sort(function(A, $) {
            return $.exactMatch - A.exactMatch || $.$score - A.$score || (A.caption || A.value).localeCompare($.caption || $.value);
          });
          var S = null;
          y = y.filter(function(A) {
            var $ = A.snippet || A.caption || A.value;
            return $ === S ? !1 : (S = $, !0);
          }), this.filtered = y;
        }, w.prototype.filterCompletions = function(C, y) {
          var S = [], A = y.toUpperCase(), $ = y.toLowerCase();
          e:
            for (var M = 0, _; _ = C[M]; M++) {
              var T = !this.ignoreCaption && _.caption || _.value || _.snippet;
              if (T) {
                var D = -1, E = 0, R = 0, I, k;
                if (this.exactMatch) {
                  if (y !== T.substr(0, y.length))
                    continue e;
                } else {
                  var P = T.toLowerCase().indexOf($);
                  if (P > -1)
                    R = P;
                  else
                    for (var L = 0; L < y.length; L++) {
                      var N = T.indexOf($[L], D + 1), F = T.indexOf(A[L], D + 1);
                      if (I = N >= 0 && (F < 0 || N < F) ? N : F, I < 0)
                        continue e;
                      k = I - D - 1, k > 0 && (D === -1 && (R += 10), R += k, E = E | 1 << L), D = I;
                    }
                }
                _.matchMask = E, _.exactMatch = R ? 0 : 1, _.$score = (_.score || 0) - R, S.push(_);
              }
            }
          return S;
        }, w;
      }()
    );
    r.Autocomplete = v, r.CompletionProvider = b, r.FilteredList = x;
  }), ace.define("ace/autocomplete/text_completer", ["require", "exports", "module", "ace/range"], function(n, r, i) {
    var o = n("../range").Range, s = /[^a-zA-Z_0-9\$\-\u00C0-\u1FFF\u2C00-\uD7FF\w]+/;
    function a(u, c) {
      var d = u.getTextRange(o.fromPoints({
        row: 0,
        column: 0
      }, c));
      return d.split(s).length - 1;
    }
    function l(u, c) {
      var d = a(u, c), f = u.getValue().split(s), h = /* @__PURE__ */ Object.create(null), p = f[d];
      return f.forEach(function(g, m) {
        if (!(!g || g === p)) {
          var v = Math.abs(d - m), b = f.length - v;
          h[g] ? h[g] = Math.max(b, h[g]) : h[g] = b;
        }
      }), h;
    }
    r.getCompletions = function(u, c, d, f, h) {
      var p = l(c, d), g = Object.keys(p);
      h(null, g.map(function(m) {
        return {
          caption: m,
          value: m,
          score: p[m],
          meta: "local"
        };
      }));
    };
  }), ace.define("ace/ext/language_tools", ["require", "exports", "module", "ace/snippets", "ace/autocomplete", "ace/config", "ace/lib/lang", "ace/autocomplete/util", "ace/autocomplete/text_completer", "ace/editor", "ace/config"], function(n, r, i) {
    var o = n("../snippets").snippetManager, s = n("../autocomplete").Autocomplete, a = n("../config"), l = n("../lib/lang"), u = n("../autocomplete/util"), c = n("../autocomplete/text_completer"), d = {
      getCompletions: function(A, $, M, _, T) {
        if ($.$mode.completer)
          return $.$mode.completer.getCompletions(A, $, M, _, T);
        var D = A.session.getState(M.row), E = $.$mode.getCompletions(D, $, M, _);
        E = E.map(function(R) {
          return R.completerId = d.id, R;
        }), T(null, E);
      },
      id: "keywordCompleter"
    }, f = function(A) {
      var $ = {};
      return A.replace(/\${(\d+)(:(.*?))?}/g, function(M, _, T, D) {
        return $[_] = D || "";
      }).replace(/\$(\d+?)/g, function(M, _) {
        return $[_];
      });
    }, h = {
      getCompletions: function(A, $, M, _, T) {
        var D = [], E = $.getTokenAt(M.row, M.column);
        E && E.type.match(/(tag-name|tag-open|tag-whitespace|attribute-name|attribute-value)\.xml$/) ? D.push("html-tag") : D = o.getActiveScopes(A);
        var R = o.snippetMap, I = [];
        D.forEach(function(k) {
          for (var P = R[k] || [], L = P.length; L--; ) {
            var N = P[L], F = N.name || N.tabTrigger;
            F && I.push({
              caption: F,
              snippet: N.content,
              meta: N.tabTrigger && !N.name ? N.tabTrigger + " " : "snippet",
              completerId: h.id
            });
          }
        }, this), T(null, I);
      },
      getDocTooltip: function(A) {
        A.snippet && !A.docHTML && (A.docHTML = [
          "<b>",
          l.escapeHTML(A.caption),
          "</b>",
          "<hr></hr>",
          l.escapeHTML(f(A.snippet))
        ].join(""));
      },
      id: "snippetCompleter"
    }, p = [h, c, d];
    r.setCompleters = function(A) {
      p.length = 0, A && p.push.apply(p, A);
    }, r.addCompleter = function(A) {
      p.push(A);
    }, r.textCompleter = c, r.keyWordCompleter = d, r.snippetCompleter = h;
    var g = {
      name: "expandSnippet",
      exec: function(A) {
        return o.expandWithTab(A);
      },
      bindKey: "Tab"
    }, m = function(A, $) {
      v($.session.$mode);
    }, v = function(A) {
      typeof A == "string" && (A = a.$modes[A]), A && (o.files || (o.files = {}), b(A.$id, A.snippetFileId), A.modes && A.modes.forEach(v));
    }, b = function(A, $) {
      !$ || !A || o.files[A] || (o.files[A] = {}, a.loadModule($, function(M) {
        M && (o.files[A] = M, !M.snippets && M.snippetText && (M.snippets = o.parseSnippetFile(M.snippetText)), o.register(M.snippets || [], M.scope), M.includeScopes && (o.snippetMap[M.scope].includeScopes = M.includeScopes, M.includeScopes.forEach(function(_) {
          v("ace/mode/" + _);
        })));
      }));
    }, x = function(A) {
      var $ = A.editor, M = $.completer && $.completer.activated;
      if (A.command.name === "backspace")
        M && !u.getCompletionPrefix($) && $.completer.detach();
      else if (A.command.name === "insertstring" && !M) {
        w = A;
        var _ = A.editor.$liveAutocompletionDelay;
        _ ? C.delay(_) : y(A);
      }
    }, w, C = l.delayedCall(function() {
      y(w);
    }, 0), y = function(A) {
      var $ = A.editor, M = u.getCompletionPrefix($), _ = A.args, T = u.triggerAutocomplete($, _);
      if (M && M.length >= $.$liveAutocompletionThreshold || T) {
        var D = s.for($);
        D.autoShown = !0, D.showPopup($);
      }
    }, S = n("../editor").Editor;
    n("../config").defineOptions(S.prototype, "editor", {
      enableBasicAutocompletion: {
        set: function(A) {
          A ? (this.completers || (this.completers = Array.isArray(A) ? A : p), this.commands.addCommand(s.startCommand)) : this.commands.removeCommand(s.startCommand);
        },
        value: !1
      },
      enableLiveAutocompletion: {
        set: function(A) {
          A ? (this.completers || (this.completers = Array.isArray(A) ? A : p), this.commands.on("afterExec", x)) : this.commands.off("afterExec", x);
        },
        value: !1
      },
      liveAutocompletionDelay: {
        initialValue: 0
      },
      liveAutocompletionThreshold: {
        initialValue: 0
      },
      enableSnippets: {
        set: function(A) {
          A ? (this.commands.addCommand(g), this.on("changeMode", m), m(null, this)) : (this.commands.removeCommand(g), this.off("changeMode", m));
        },
        value: !1
      }
    });
  }), function() {
    ace.require(["ace/ext/language_tools"], function(n) {
      e && (e.exports = n);
    });
  }();
})(nde);
var rde = { exports: {} };
(function(e, t) {
  ace.define("ace/mode/json_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text_highlight_rules"], function(n, r, i) {
    var o = n("../lib/oop"), s = n("./text_highlight_rules").TextHighlightRules, a = function() {
      this.$rules = {
        start: [
          {
            token: "variable",
            // single line
            regex: '["](?:(?:\\\\.)|(?:[^"\\\\]))*?["]\\s*(?=:)'
          },
          {
            token: "string",
            // single line
            regex: '"',
            next: "string"
          },
          {
            token: "constant.numeric",
            // hex
            regex: "0[xX][0-9a-fA-F]+\\b"
          },
          {
            token: "constant.numeric",
            // float
            regex: "[+-]?\\d+(?:(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)?\\b"
          },
          {
            token: "constant.language.boolean",
            regex: "(?:true|false)\\b"
          },
          {
            token: "text",
            // single quoted strings are not allowed
            regex: "['](?:(?:\\\\.)|(?:[^'\\\\]))*?[']"
          },
          {
            token: "comment",
            // comments are not allowed, but who cares?
            regex: "\\/\\/.*$"
          },
          {
            token: "comment.start",
            // comments are not allowed, but who cares?
            regex: "\\/\\*",
            next: "comment"
          },
          {
            token: "paren.lparen",
            regex: "[[({]"
          },
          {
            token: "paren.rparen",
            regex: "[\\])}]"
          },
          {
            token: "punctuation.operator",
            regex: /[,]/
          },
          {
            token: "text",
            regex: "\\s+"
          }
        ],
        string: [
          {
            token: "constant.language.escape",
            regex: /\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|["\\\/bfnrt])/
          },
          {
            token: "string",
            regex: '"|$',
            next: "start"
          },
          {
            defaultToken: "string"
          }
        ],
        comment: [
          {
            token: "comment.end",
            // comments are not allowed, but who cares?
            regex: "\\*\\/",
            next: "start"
          },
          {
            defaultToken: "comment"
          }
        ]
      };
    };
    o.inherits(a, s), r.JsonHighlightRules = a;
  }), ace.define("ace/mode/json5_highlight_rules", ["require", "exports", "module", "ace/lib/oop", "ace/mode/json_highlight_rules"], function(n, r, i) {
    var o = n("../lib/oop"), s = n("./json_highlight_rules").JsonHighlightRules, a = function() {
      s.call(this);
      var l = [{
        token: "variable",
        regex: /[a-zA-Z$_\u00a1-\uffff][\w$\u00a1-\uffff]*\s*(?=:)/
      }, {
        token: "variable",
        regex: /['](?:(?:\\.)|(?:[^'\\]))*?[']\s*(?=:)/
      }, {
        token: "constant.language.boolean",
        regex: /(?:null)\b/
      }, {
        token: "string",
        regex: /'/,
        next: [{
          token: "constant.language.escape",
          regex: /\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|["\/bfnrt]|$)/,
          consumeLineEnd: !0
        }, {
          token: "string",
          regex: /'|$/,
          next: "start"
        }, {
          defaultToken: "string"
        }]
      }, {
        token: "string",
        regex: /"(?![^"]*":)/,
        next: [{
          token: "constant.language.escape",
          regex: /\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|["\/bfnrt]|$)/,
          consumeLineEnd: !0
        }, {
          token: "string",
          regex: /"|$/,
          next: "start"
        }, {
          defaultToken: "string"
        }]
      }, {
        token: "constant.numeric",
        regex: /[+-]?(?:Infinity|NaN)\b/
      }];
      for (var u in this.$rules)
        this.$rules[u].unshift.apply(this.$rules[u], l);
      this.normalizeRules();
    };
    o.inherits(a, s), r.Json5HighlightRules = a;
  }), ace.define("ace/mode/matching_brace_outdent", ["require", "exports", "module", "ace/range"], function(n, r, i) {
    var o = n("../range").Range, s = function() {
    };
    (function() {
      this.checkOutdent = function(a, l) {
        return /^\s+$/.test(a) ? /^\s*\}/.test(l) : !1;
      }, this.autoOutdent = function(a, l) {
        var u = a.getLine(l), c = u.match(/^(\s*\})/);
        if (!c)
          return 0;
        var d = c[1].length, f = a.findMatchingBracket({ row: l, column: d });
        if (!f || f.row == l)
          return 0;
        var h = this.$getIndent(a.getLine(f.row));
        a.replace(new o(l, 0, l, d - 1), h);
      }, this.$getIndent = function(a) {
        return a.match(/^\s*/)[0];
      };
    }).call(s.prototype), r.MatchingBraceOutdent = s;
  }), ace.define("ace/mode/folding/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/range", "ace/mode/folding/fold_mode"], function(n, r, i) {
    var o = n("../../lib/oop"), s = n("../../range").Range, a = n("./fold_mode").FoldMode, l = r.FoldMode = function(u) {
      u && (this.foldingStartMarker = new RegExp(this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + u.start)), this.foldingStopMarker = new RegExp(this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + u.end)));
    };
    o.inherits(l, a), (function() {
      this.foldingStartMarker = /([\{\[\(])[^\}\]\)]*$|^\s*(\/\*)/, this.foldingStopMarker = /^[^\[\{\(]*([\}\]\)])|^[\s\*]*(\*\/)/, this.singleLineBlockCommentRe = /^\s*(\/\*).*\*\/\s*$/, this.tripleStarBlockCommentRe = /^\s*(\/\*\*\*).*\*\/\s*$/, this.startRegionRe = /^\s*(\/\*|\/\/)#?region\b/, this._getFoldWidgetBase = this.getFoldWidget, this.getFoldWidget = function(u, c, d) {
        var f = u.getLine(d);
        if (this.singleLineBlockCommentRe.test(f) && !this.startRegionRe.test(f) && !this.tripleStarBlockCommentRe.test(f))
          return "";
        var h = this._getFoldWidgetBase(u, c, d);
        return !h && this.startRegionRe.test(f) ? "start" : h;
      }, this.getFoldWidgetRange = function(u, c, d, f) {
        var h = u.getLine(d);
        if (this.startRegionRe.test(h))
          return this.getCommentRegionBlock(u, h, d);
        var m = h.match(this.foldingStartMarker);
        if (m) {
          var p = m.index;
          if (m[1])
            return this.openingBracketBlock(u, m[1], d, p);
          var g = u.getCommentFoldRange(d, p + m[0].length, 1);
          return g && !g.isMultiLine() && (f ? g = this.getSectionRange(u, d) : c != "all" && (g = null)), g;
        }
        if (c !== "markbegin") {
          var m = h.match(this.foldingStopMarker);
          if (m) {
            var p = m.index + m[0].length;
            return m[1] ? this.closingBracketBlock(u, m[1], d, p) : u.getCommentFoldRange(d, p, -1);
          }
        }
      }, this.getSectionRange = function(u, c) {
        var d = u.getLine(c), f = d.search(/\S/), h = c, p = d.length;
        c = c + 1;
        for (var g = c, m = u.getLength(); ++c < m; ) {
          d = u.getLine(c);
          var v = d.search(/\S/);
          if (v !== -1) {
            if (f > v)
              break;
            var b = this.getFoldWidgetRange(u, "all", c);
            if (b) {
              if (b.start.row <= h)
                break;
              if (b.isMultiLine())
                c = b.end.row;
              else if (f == v)
                break;
            }
            g = c;
          }
        }
        return new s(h, p, g, u.getLine(g).length);
      }, this.getCommentRegionBlock = function(u, c, d) {
        for (var f = c.search(/\s*$/), h = u.getLength(), p = d, g = /^\s*(?:\/\*|\/\/|--)#?(end)?region\b/, m = 1; ++d < h; ) {
          c = u.getLine(d);
          var v = g.exec(c);
          if (v && (v[1] ? m-- : m++, !m))
            break;
        }
        var b = d;
        if (b > p)
          return new s(p, f, b, c.length);
      };
    }).call(l.prototype);
  }), ace.define("ace/mode/json5", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/json5_highlight_rules", "ace/mode/matching_brace_outdent", "ace/mode/folding/cstyle"], function(n, r, i) {
    var o = n("../lib/oop"), s = n("./text").Mode, a = n("./json5_highlight_rules").Json5HighlightRules, l = n("./matching_brace_outdent").MatchingBraceOutdent, u = n("./folding/cstyle").FoldMode, c = function() {
      this.HighlightRules = a, this.$outdent = new l(), this.$behaviour = this.$defaultBehaviour, this.foldingRules = new u();
    };
    o.inherits(c, s), (function() {
      this.lineCommentStart = "//", this.blockComment = { start: "/*", end: "*/" }, this.checkOutdent = function(d, f, h) {
        return this.$outdent.checkOutdent(f, h);
      }, this.autoOutdent = function(d, f, h) {
        this.$outdent.autoOutdent(f, h);
      }, this.$id = "ace/mode/json5";
    }).call(c.prototype), r.Mode = c;
  }), function() {
    ace.require(["ace/mode/json5"], function(n) {
      e && (e.exports = n);
    });
  }();
})(rde);
var ide = { exports: {} };
(function(e, t) {
  ace.define("ace/theme/chrome-css", ["require", "exports", "module"], function(n, r, i) {
    i.exports = `.ace-chrome .ace_gutter {
  background: #ebebeb;
  color: #333;
  overflow : hidden;
}

.ace-chrome .ace_print-margin {
  width: 1px;
  background: #e8e8e8;
}

.ace-chrome {
  background-color: #FFFFFF;
  color: black;
}

.ace-chrome .ace_cursor {
  color: black;
}

.ace-chrome .ace_invisible {
  color: rgb(191, 191, 191);
}

.ace-chrome .ace_constant.ace_buildin {
  color: rgb(88, 72, 246);
}

.ace-chrome .ace_constant.ace_language {
  color: rgb(88, 92, 246);
}

.ace-chrome .ace_constant.ace_library {
  color: rgb(6, 150, 14);
}

.ace-chrome .ace_invalid {
  background-color: rgb(153, 0, 0);
  color: white;
}

.ace-chrome .ace_fold {
}

.ace-chrome .ace_support.ace_function {
  color: rgb(60, 76, 114);
}

.ace-chrome .ace_support.ace_constant {
  color: rgb(6, 150, 14);
}

.ace-chrome .ace_support.ace_type,
.ace-chrome .ace_support.ace_class
.ace-chrome .ace_support.ace_other {
  color: rgb(109, 121, 222);
}

.ace-chrome .ace_variable.ace_parameter {
  font-style:italic;
  color:#FD971F;
}
.ace-chrome .ace_keyword.ace_operator {
  color: rgb(104, 118, 135);
}

.ace-chrome .ace_comment {
  color: #236e24;
}

.ace-chrome .ace_comment.ace_doc {
  color: #236e24;
}

.ace-chrome .ace_comment.ace_doc.ace_tag {
  color: #236e24;
}

.ace-chrome .ace_constant.ace_numeric {
  color: rgb(0, 0, 205);
}

.ace-chrome .ace_variable {
  color: rgb(49, 132, 149);
}

.ace-chrome .ace_xml-pe {
  color: rgb(104, 104, 91);
}

.ace-chrome .ace_entity.ace_name.ace_function {
  color: #0000A2;
}


.ace-chrome .ace_heading {
  color: rgb(12, 7, 255);
}

.ace-chrome .ace_list {
  color:rgb(185, 6, 144);
}

.ace-chrome .ace_marker-layer .ace_selection {
  background: rgb(181, 213, 255);
}

.ace-chrome .ace_marker-layer .ace_step {
  background: rgb(252, 255, 0);
}

.ace-chrome .ace_marker-layer .ace_stack {
  background: rgb(164, 229, 101);
}

.ace-chrome .ace_marker-layer .ace_bracket {
  margin: -1px 0 0 -1px;
  border: 1px solid rgb(192, 192, 192);
}

.ace-chrome .ace_marker-layer .ace_active-line {
  background: rgba(0, 0, 0, 0.07);
}

.ace-chrome .ace_gutter-active-line {
    background-color : #dcdcdc;
}

.ace-chrome .ace_marker-layer .ace_selected-word {
  background: rgb(250, 250, 255);
  border: 1px solid rgb(200, 200, 250);
}

.ace-chrome .ace_storage,
.ace-chrome .ace_keyword,
.ace-chrome .ace_meta.ace_tag {
  color: rgb(147, 15, 128);
}

.ace-chrome .ace_string.ace_regex {
  color: rgb(255, 0, 0)
}

.ace-chrome .ace_string {
  color: #1A1AA6;
}

.ace-chrome .ace_entity.ace_other.ace_attribute-name {
  color: #994409;
}

.ace-chrome .ace_indent-guide {
  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;
}
  
.ace-chrome .ace_indent-guide-active {
  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;
}
`;
  }), ace.define("ace/theme/chrome", ["require", "exports", "module", "ace/theme/chrome-css", "ace/lib/dom"], function(n, r, i) {
    r.isDark = !1, r.cssClass = "ace-chrome", r.cssText = n("./chrome-css");
    var o = n("../lib/dom");
    o.importCssString(r.cssText, r.cssClass, !1);
  }), function() {
    ace.require(["ace/theme/chrome"], function(n) {
      e && (e.exports = n);
    });
  }();
})(ide);
var ode = { exports: {} };
(function(e, t) {
  ace.define("ace/theme/github_dark-css", ["require", "exports", "module"], function(n, r, i) {
    i.exports = `.ace-github-dark .ace_gutter {
  background: #24292e;
  color: #7388b5
}

.ace-github-dark .ace_print-margin {
  width: 1px;
  background: #00204b
}

.ace-github-dark {
  background-color: #24292e;
  color: #FFFFFF
}

.ace-github-dark .ace_constant.ace_other,
.ace-github-dark .ace_cursor {
  color: #FFFFFF
}

.ace-github-dark .ace_marker-layer .ace_selection {
  background: #003F8E
}

.ace-github-dark.ace_multiselect .ace_selection.ace_start {
  box-shadow: 0 0 3px 0px #24292e;
}

.ace-github-dark .ace_marker-layer .ace_step {
  background: rgb(127, 111, 19)
}

.ace-github-dark .ace_marker-layer .ace_bracket {
  margin: -1px 0 0 -1px;
  border: 1px solid #404F7D
}

.ace-github-dark .ace_marker-layer .ace_active-line {
  background: #00346E
}

.ace-github-dark .ace_gutter-active-line {
  background-color: #24292e
}

.ace-github-dark .ace_marker-layer .ace_selected-word {
  border: 1px solid #003F8E
}

.ace-github-dark .ace_invisible {
  color: #404F7D
}

.ace-github-dark .ace_keyword,
.ace-github-dark .ace_meta,
.ace-github-dark .ace_storage,
.ace-github-dark .ace_storage.ace_type,
.ace-github-dark .ace_support.ace_type {
  color: #ff7b72
}

.ace-github-dark .ace_keyword.ace_operator {
  color: #79c0ff
}

.ace-github-dark .ace_constant.ace_character,
.ace-github-dark .ace_constant.ace_language,
.ace-github-dark .ace_constant.ace_numeric,
.ace-github-dark .ace_keyword.ace_other.ace_unit,
.ace-github-dark .ace_support.ace_constant,
.ace-github-dark .ace_variable.ace_parameter {
  color: #FFC58F
}

.ace-github-dark .ace_invalid {
  color: #FFFFFF;
  background-color: #F99DA5
}

.ace-github-dark .ace_invalid.ace_deprecated {
  color: #FFFFFF;
  background-color: #ff7b72
}

.ace-github-dark .ace_fold {
  background-color: #BBDAFF;
  border-color: #FFFFFF
}

.ace-github-dark .ace_entity.ace_name.ace_function,
.ace-github-dark .ace_support.ace_function,
.ace-github-dark .ace_variable {
  color: #BBDAFF
}

.ace-github-dark .ace_support.ace_class,
.ace-github-dark .ace_support.ace_type {
  color: #FFEEAD
}

.ace-github-dark .ace_heading,
.ace-github-dark .ace_markup.ace_heading,
.ace-github-dark .ace_string {
  color: #9fcef6
}

.ace-github-dark .ace_entity.ace_name.ace_tag,
.ace-github-dark .ace_entity.ace_other.ace_attribute-name,
.ace-github-dark .ace_meta.ace_tag,
.ace-github-dark .ace_string.ace_regexp,
.ace-github-dark .ace_variable {
  color: #FF9DA4
}

.ace-github-dark .ace_comment {
  color: #7285B7
}

.ace-github-dark .ace_indent-guide {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYJDzqfwPAANXAeNsiA+ZAAAAAElFTkSuQmCC) right repeat-y
}

.ace-github-dark .ace_indent-guide-active {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQIW2PQ1dX9zzBz5sz/ABCcBFFentLlAAAAAElFTkSuQmCC) right repeat-y;
}

.ace-github-dark .ace_constant.ace_buildin {
  color: #0086B3;
}

.ace-github-dark .ace_variable.ace_language {
  color: #ffffff;
}
  `;
  }), ace.define("ace/theme/github_dark", ["require", "exports", "module", "ace/theme/github_dark-css", "ace/lib/dom"], function(n, r, i) {
    r.isDark = !0, r.cssClass = "ace-github-dark", r.cssText = n("./github_dark-css");
    var o = n("../lib/dom");
    o.importCssString(r.cssText, r.cssClass, !1);
  }), function() {
    ace.require(["ace/theme/github_dark"], function(n) {
      e && (e.exports = n);
    });
  }();
})(ode);
const sde = () => {
  const { token: e } = no.useToken(), { stateStore: t } = JC(), n = Lr(), { onSimulationRun: r } = ZC(({ onSimulationRun: p }) => ({ onSimulationRun: p })), { simulate: i, simulatorOpen: o, simulatorRequest: s, simulatorLoading: a, nodeTypes: l } = Nr(
    ({ simulate: p, simulatorOpen: g, simulatorRequest: m, simulatorLoading: v, decisionGraph: b }) => ({
      simulate: p,
      simulatorOpen: g,
      simulatorRequest: m,
      simulatorLoading: v,
      nodeTypes: (b.nodes ?? []).reduce(
        (x, w) => ({
          ...x,
          [w.id]: w.type
        }),
        {}
      )
    })
  ), [u, c] = ht("graph"), d = yn(i).with({ result: mn._ }, ({ result: p }) => p).otherwise(() => {
  }), f = mt(() => yn(e.mode).with("dark", () => "github_dark").otherwise(() => "chrome"), [e.mode]), h = async () => {
    var p, g;
    try {
      const m = await n.runSimulator();
      m && typeof m == "object" && "error" in m && ap.error({
        message: ((p = m == null ? void 0 : m.error) == null ? void 0 : p.title) ?? "Node error",
        placement: "top",
        description: (g = m == null ? void 0 : m.error) == null ? void 0 : g.message
      });
    } catch (m) {
      const v = yn(m).with({ message: mn._ }, ({ message: b }) => b == null ? void 0 : b.toString()).otherwise(() => {
      });
      ap.error({
        message: "Simulation failed",
        placement: "top",
        description: v
      });
    }
  };
  return !o || !r ? null : /* @__PURE__ */ V.jsxs("div", { className: "grl-dg__simulator", children: [
    /* @__PURE__ */ V.jsx("div", { className: "grl-dg__simulator__sidebar" }),
    /* @__PURE__ */ V.jsxs("div", { className: "grl-dg__simulator__section grl-dg__simulator__request", children: [
      /* @__PURE__ */ V.jsxs("div", { className: "grl-dg__simulator__section__bar grl-dg__simulator__section__bar--request", children: [
        /* @__PURE__ */ V.jsx(Bt.Text, { children: "Request (json5)" }),
        /* @__PURE__ */ V.jsxs("div", { className: "grl-dg__simulator__section__bar__actions", children: [
          /* @__PURE__ */ V.jsx(lr, { title: "Format json", children: /* @__PURE__ */ V.jsx(
            Ut,
            {
              size: "small",
              type: "text",
              icon: /* @__PURE__ */ V.jsx(bC, {}),
              onClick: () => {
                if ((s || "").trim().length !== 0)
                  try {
                    t.setState({
                      simulatorRequest: cc.stringify(cc.parse(s || ""), null, 2)
                    });
                  } catch {
                    ap.error({
                      message: "Invalid format",
                      description: "Unable to format request, invalid JSON format",
                      placement: "top"
                    });
                  }
              }
            }
          ) }),
          /* @__PURE__ */ V.jsx(
            Ut,
            {
              size: "small",
              type: "primary",
              loading: a,
              icon: /* @__PURE__ */ V.jsx(yC, {}),
              onClick: h,
              children: "Run"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ V.jsx("div", { className: "grl-dg__simulator__section__content", children: /* @__PURE__ */ V.jsx(
        x2,
        {
          value: s,
          onChange: (p) => {
            n.setSimulatorRequest(p);
          },
          mode: "json5",
          theme: f,
          width: "100%",
          height: "100%",
          tabSize: 2,
          setOptions: {
            useWorker: !1
          }
        }
      ) })
    ] }),
    /* @__PURE__ */ V.jsxs("div", { className: "grl-dg__simulator__section grl-dg__simulator__nodes", children: [
      /* @__PURE__ */ V.jsxs("div", { className: "grl-dg__simulator__section__bar grl-dg__simulator__section__bar--nodes", children: [
        /* @__PURE__ */ V.jsx(Bt.Text, { children: "Nodes" }),
        /* @__PURE__ */ V.jsx("div", { className: "grl-dg__simulator__section__bar__actions", children: /* @__PURE__ */ V.jsx(lr, { title: "Clear", children: /* @__PURE__ */ V.jsx(
          Ut,
          {
            size: "small",
            type: "text",
            icon: /* @__PURE__ */ V.jsx(vP, {}),
            onClick: () => {
              t.setState({ simulate: void 0 }), c("graph");
            }
          }
        ) }) })
      ] }),
      /* @__PURE__ */ V.jsx("div", { className: "grl-dg__simulator__section__content", children: /* @__PURE__ */ V.jsx($f, { spinning: a, children: /* @__PURE__ */ V.jsxs("div", { className: "grl-dg__simulator__nodes-list", children: [
        /* @__PURE__ */ V.jsxs(
          "div",
          {
            className: wn("grl-dg__simulator__nodes-list__node", u === "graph" && "active"),
            onClick: () => c("graph"),
            children: [
              /* @__PURE__ */ V.jsx(Bt.Text, { children: "Graph" }),
              /* @__PURE__ */ V.jsx(Bt.Text, { type: "secondary", children: yn(i).with({ result: mn._ }, ({ result: p }) => p == null ? void 0 : p.performance).otherwise(() => {
              }) })
            ]
          }
        ),
        Object.entries((d == null ? void 0 : d.trace) ?? {}).filter(([, p]) => ![Fn.Input, Fn.Output].includes(l == null ? void 0 : l[p == null ? void 0 : p.id])).map(([p, g]) => /* @__PURE__ */ V.jsxs(
          "div",
          {
            className: wn("grl-dg__simulator__nodes-list__node", p === u && "active"),
            onClick: () => c(p),
            children: [
              /* @__PURE__ */ V.jsx(Bt.Text, { children: g.name }),
              /* @__PURE__ */ V.jsx(Bt.Text, { type: "secondary", children: g.performance })
            ]
          },
          p
        ))
      ] }) }) })
    ] }),
    /* @__PURE__ */ V.jsxs("div", { className: "grl-dg__simulator__section grl-dg__simulator__response", children: [
      /* @__PURE__ */ V.jsxs("div", { className: "grl-dg__simulator__section__bar grl-dg__simulator__section__bar--response", children: [
        /* @__PURE__ */ V.jsx(Bt.Text, { children: "Response" }),
        /* @__PURE__ */ V.jsx("div", { className: "grl-dg__simulator__section__bar__actions", children: /* @__PURE__ */ V.jsx(lr, { title: "Close panel", children: /* @__PURE__ */ V.jsx(
          Ut,
          {
            size: "small",
            type: "text",
            icon: /* @__PURE__ */ V.jsx(To, {}),
            onClick: () => n.toggleSimulator()
          }
        ) }) })
      ] }),
      /* @__PURE__ */ V.jsx("div", { className: "grl-dg__simulator__section__content", children: /* @__PURE__ */ V.jsx(
        x2,
        {
          value: yn(i).with(
            { result: mn._ },
            ({ result: p }) => yn(u).with("graph", () => cc.stringify((p == null ? void 0 : p.result) ?? {}, void 0, 2)).otherwise(() => {
              const { input: g, output: m, traceData: v } = (p == null ? void 0 : p.trace[u]) ?? {};
              return cc.stringify({ input: g, output: m, traceData: v }, void 0, 2);
            })
          ).otherwise(() => ""),
          readOnly: !0,
          mode: "json5",
          theme: f,
          width: "100%",
          height: "100%",
          tabSize: 2,
          setOptions: { useWorker: !1 }
        }
      ) })
    ] })
  ] });
}, ade = (e) => {
  const t = Lr(), { id: n, sourceX: r, sourceY: i, targetX: o, targetY: s, sourcePosition: a, targetPosition: l, style: u = {}, markerEnd: c } = e, { hoveredEdgeId: d, disabled: f } = Nr(({ hoveredEdgeId: m, disabled: v }) => ({
    hoveredEdgeId: m,
    disabled: v
  })), [h, p, g] = VC({
    sourceX: r,
    sourceY: i,
    sourcePosition: a,
    targetX: o,
    targetY: s,
    targetPosition: l
  });
  return /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
    /* @__PURE__ */ V.jsx(fu, { path: h, markerEnd: c, style: u }),
    /* @__PURE__ */ V.jsx($ue, { children: /* @__PURE__ */ V.jsx(
      "div",
      {
        className: "nodrag nopan edge-renderer",
        style: {
          transform: `translate(-50%, -50%) translate(${p}px,${g}px)`
        },
        children: !f && /* @__PURE__ */ V.jsx(
          Ut,
          {
            type: "primary",
            shape: "round",
            icon: /* @__PURE__ */ V.jsx(lu, {}),
            danger: !0,
            className: wn("grl-edge-delete-button"),
            "data-visible": n === d,
            onClick: () => t.removeEdges([n])
          }
        )
      }
    ) })
  ] });
}, lde = (e) => (t) => /* @__PURE__ */ V.jsx(ade, { ...t, ...e }), cde = (e) => {
  const t = document.createElement("textarea");
  t.value = e, document.body.appendChild(t), t.focus(), t.select();
  try {
    document.execCommand("copy");
  } catch (n) {
    console.error("Unable to copy to clipboard", n);
  }
  document.body.removeChild(t);
}, pA = async (e) => {
  window.isSecureContext && navigator.clipboard ? await navigator.clipboard.writeText(e) : cde(e);
}, ude = async () => {
  try {
    return navigator.clipboard.readText();
  } catch {
    return "";
  }
}, dde = (e) => typeof e != "object" ? !1 : Array.isArray(e == null ? void 0 : e.nodes), fde = (e, t) => {
  const n = JC(), r = Lr(), i = Kt(
    async (s) => {
      var a, l;
      try {
        if (!e.current)
          return;
        const u = (((l = (a = n.stateStore.getState()) == null ? void 0 : a.decisionGraph) == null ? void 0 : l.nodes) || []).filter(
          (h) => s.some((p) => p.id === h.id)
        ), c = u.map((h) => h.id), d = [];
        u.length > 0 && e.current.getEdges().forEach((p) => {
          c.includes(p.source) && c.includes(p.target) && d.push({
            id: p.id,
            type: p.type,
            sourceId: p.source,
            targetId: p.target,
            sourceHandle: p.sourceHandle ?? void 0,
            targetHandle: p.targetHandle ?? void 0
          });
        }), await pA(JSON.stringify({
          nodes: u,
          edges: d
        })), Cr.success("Copied to clipboard!");
      } catch (u) {
        Cr.error(u.message);
      }
    },
    [n]
  ), o = Kt(async () => {
    try {
      if (!(e != null && e.current))
        return;
      const s = await ude();
      if (!s)
        return;
      const a = JSON.parse(s);
      if (!dde(a))
        throw new Error("invalid clipboard");
      const l = a.nodes.reduce(
        (g, m) => ({
          ...g,
          [m.id]: crypto.randomUUID()
        }),
        {}
      ), u = Object.keys(l), c = e.current.getNodes().find((g) => u.includes(g.id)), d = a.nodes.find((g) => g.id === (c == null ? void 0 : c.id)), f = {
        x: a.nodes.reduce((g, m) => g + m.position.x, 0) / a.nodes.length,
        y: a.nodes.reduce((g, m) => g + m.position.y, 0) / a.nodes.length
      }, h = a.nodes.map((g) => {
        var v, b;
        const m = {
          x: ((v = g == null ? void 0 : g.position) == null ? void 0 : v.x) || 0,
          y: ((b = g == null ? void 0 : g.position) == null ? void 0 : b.y) || 0
        };
        if (c && d)
          g.id === c.id ? (m.x = c.position.x, m.y = c.position.y - 20) : (m.x = c.position.x - d.position.x + g.position.x, m.y = c.position.y - d.position.y + g.position.y - 20);
        else if (t.current) {
          const x = t.current.getBoundingClientRect(), w = {
            x: x.width / 2,
            y: x.height / 2
          }, C = e.current.project(w);
          m.x = g.position.x + C.x - f.x / 2, m.y = g.position.y + C.y - f.y / 2;
        }
        return {
          ...g,
          position: m,
          id: l[g.id]
        };
      }), p = (a.edges || []).map((g) => ({
        id: crypto.randomUUID(),
        type: g.type,
        sourceId: l[g.sourceId],
        targetId: l[g.targetId],
        sourceHandle: g.sourceHandle ?? void 0,
        targetHandle: g.targetHandle ?? void 0
      }));
      if (r.addNodes(h), r.addEdges(p), Cr.success("Pasted from clipboard!"), c)
        try {
          await pA(JSON.stringify({ nodes: h }));
        } catch {
        }
    } catch {
      Cr.error("Failed to paste from clipboard");
    }
  }, [e, t]);
  return mt(
    () => ({
      copyNodes: i,
      pasteNodes: o
    }),
    [i, o]
  );
}, AL = ({
  icon: e,
  name: t,
  type: n,
  children: r,
  actions: i = [],
  disabled: o = !1,
  isSelected: s = !1,
  noBodyPadding: a = !1,
  color: l = "primary",
  onNameChange: u,
  menuItems: c = [],
  status: d
}) => {
  const { token: f } = no.useToken(), [h, p] = ht(!1), g = he(null);
  Pe(() => {
    g.current && h && (g.current.value = t, g.current.focus(), g.current.select());
  }, [h]);
  const m = yn(l).with("primary", () => {
  }).with("secondary", () => "#722ed1").otherwise((v) => v);
  return /* @__PURE__ */ V.jsxs(
    "div",
    {
      className: wn("grl-dn", s && "grl-dn--selected", d && `grl-dn--${d}`),
      style: {
        "--node-color": m
      },
      onKeyDown: (v) => v.stopPropagation(),
      children: [
        d === "error" && /* @__PURE__ */ V.jsx("div", { className: wn("grl-dn__status-icon", `grl-dn__status-icon--${d}`), children: /* @__PURE__ */ V.jsx(To, {}) }),
        /* @__PURE__ */ V.jsxs("div", { className: "grl-dn__header", children: [
          /* @__PURE__ */ V.jsx("div", { className: "grl-dn__header__icon", children: e }),
          /* @__PURE__ */ V.jsxs("div", { className: "grl-dn__header__text", children: [
            !h && /* @__PURE__ */ V.jsx(
              Bt.Text,
              {
                className: wn("grl-dn__header__text__name"),
                onClick: () => {
                  !o && p(!0);
                },
                children: t
              }
            ),
            h && /* @__PURE__ */ V.jsx(
              "input",
              {
                ref: g,
                className: wn("grl-dn__header__text__name-input", "nodrag"),
                onBlur: (v) => {
                  var b, x, w, C;
                  ((w = (x = (b = v.target.value) == null ? void 0 : b.trim) == null ? void 0 : x.call(b)) == null ? void 0 : w.length) > 0 && (u == null || u((C = g == null ? void 0 : g.current) == null ? void 0 : C.value)), v.preventDefault(), p(!1);
                },
                onKeyDown: (v) => {
                  v.key === "Enter" ? (v.currentTarget.blur(), v.preventDefault()) : v.key === "Escape" && (g.current && (g.current.value = t), p(!1), v.preventDefault());
                }
              }
            ),
            /* @__PURE__ */ V.jsx(Bt.Text, { type: "secondary", style: { fontSize: f.fontSizeSM }, children: n })
          ] }),
          c.length > 0 && /* @__PURE__ */ V.jsx("div", { className: "grl-dn__header__actions", children: /* @__PURE__ */ V.jsx(da, { trigger: ["click"], overlayStyle: { minWidth: 250 }, menu: { items: c }, children: /* @__PURE__ */ V.jsx(Ut, { type: "text", icon: /* @__PURE__ */ V.jsx(Cm, {}) }) }) })
        ] }),
        r && /* @__PURE__ */ V.jsx(
          "div",
          {
            className: wn(
              "grl-dn__body",
              i.length === 0 && "grl-dn__body--no-footer",
              a && "grl-dn__body--no-padding"
            ),
            children: r
          }
        ),
        i.length > 0 && /* @__PURE__ */ V.jsx("div", { className: "grl-dn__footer", children: /* @__PURE__ */ V.jsx("div", { className: "grl-dn__footer__actions", children: i }) })
      ]
    }
  );
}, wa = ({
  id: e,
  handleLeft: t = !0,
  handleRight: n = !0,
  className: r,
  specification: i,
  name: o,
  displayError: s,
  ...a
}) => {
  const l = Lr(), { nodeError: u, nodeTrace: c, disabled: d } = Nr(({ simulate: h, disabled: p }) => ({
    disabled: p,
    nodeTrace: yn(h).with({ result: mn._ }, ({ result: g }) => {
      var m;
      return (m = g == null ? void 0 : g.trace) == null ? void 0 : m[e];
    }).otherwise(() => null),
    nodeError: yn(h).with({ error: { data: { nodeId: e } } }, ({ error: g }) => g).otherwise(() => null)
  })), f = [
    i.documentationUrl ? {
      key: "documentation",
      icon: /* @__PURE__ */ V.jsx(ag, {}),
      label: "Documentation",
      onClick: () => window.open(i.documentationUrl, "_href")
    } : null,
    i.documentationUrl ? { key: "divider-1", type: "divider" } : null,
    !s && {
      key: "copy-clipboard",
      icon: /* @__PURE__ */ V.jsx(ag, {}),
      label: /* @__PURE__ */ V.jsx(Ka, { left: "Copy to clipboard", right: Ga.shortcut("Ctrl + C") }),
      onClick: () => {
      }
    },
    !s && {
      key: "duplicate",
      icon: /* @__PURE__ */ V.jsx(F1, {}),
      disabled: d,
      label: /* @__PURE__ */ V.jsx(Ka, { left: "Duplicate", right: Ga.shortcut("Ctrl + D") }),
      onClick: () => l.duplicateNodes([e])
    },
    !s && { key: "divider-2", type: "divider" },
    {
      key: "delete",
      icon: /* @__PURE__ */ V.jsx(lu, {}),
      danger: !0,
      label: /* @__PURE__ */ V.jsx(Ka, { left: "Delete", right: Ga.shortcut("Backspace") }),
      disabled: d,
      onClick: () => pr.confirm({
        icon: null,
        title: "Delete node",
        content: /* @__PURE__ */ V.jsxs(Bt.Text, { children: [
          "Are you sure you want to delete ",
          /* @__PURE__ */ V.jsx(Bt.Text, { strong: !0, children: o }),
          " node."
        ] }),
        okButtonProps: { danger: !0 },
        onOk: () => l.removeNodes([e])
      })
    }
  ];
  return /* @__PURE__ */ V.jsxs("div", { className: wn("grl-graph-node", r), style: { minWidth: 250 }, children: [
    t && /* @__PURE__ */ V.jsx(
      ul,
      {
        className: "grl-graph-node__handle-left",
        type: "target",
        position: bt.Left,
        ...typeof t != "boolean" ? t : {}
      }
    ),
    /* @__PURE__ */ V.jsx(
      AL,
      {
        menuItems: f,
        ...a,
        disabled: d,
        icon: i.icon,
        color: i.color,
        type: i.displayName,
        name: o,
        status: yn([c, u, s]).with([mn._, mn._, !0], () => "error").with([mn.not(mn.nullish), mn._, mn._], () => "success").with([mn._, mn.not(mn.nullish), mn._], () => "error").otherwise(() => {
        }),
        onNameChange: (h) => {
          l.updateNode(e, (p) => (p.name = h, p));
        }
      }
    ),
    n && /* @__PURE__ */ V.jsx(
      ul,
      {
        className: "grl-graph-node__handle-right",
        type: "source",
        position: bt.Right,
        ...typeof n != "boolean" ? n : {}
      }
    )
  ] });
}, hde = {
  type: Fn.DecisionTable,
  icon: /* @__PURE__ */ V.jsx(_P, {}),
  displayName: "Decision table",
  documentationUrl: "https://gorules.io/docs/user-manual/decision-modeling/decisions/decision-tables",
  shortDescription: "Rules spreadsheet",
  generateNode: ({ index: e }) => ({
    name: `decisionTable${e}`,
    content: {
      hitPolicy: "first",
      inputs: [
        {
          id: crypto.randomUUID(),
          name: "Input",
          type: "expression"
        }
      ],
      outputs: [
        {
          id: crypto.randomUUID(),
          field: "output",
          name: "Output",
          type: "expression"
        }
      ],
      rules: []
    }
  }),
  renderNode: ({ id: e, data: t, selected: n, specification: r }) => {
    const i = Lr();
    return /* @__PURE__ */ V.jsx(
      wa,
      {
        id: e,
        specification: r,
        name: t.name,
        isSelected: n,
        actions: [
          /* @__PURE__ */ V.jsx(Ut, { type: "link", onClick: () => i.openTab(e), children: "Edit Table" }, "edit-table")
        ]
      }
    );
  }
}, pde = {
  type: Fn.Expression,
  icon: /* @__PURE__ */ V.jsx(AP, {}),
  displayName: "Expression",
  documentationUrl: "https://gorules.io/docs/user-manual/decision-modeling/decisions/expression",
  shortDescription: "Mapping utility",
  generateNode: ({ index: e }) => ({
    name: `expression${e}`,
    content: {
      expressions: []
    }
  }),
  renderNode: ({ id: e, data: t, selected: n, specification: r }) => {
    const i = Lr();
    return /* @__PURE__ */ V.jsx(
      wa,
      {
        id: e,
        specification: r,
        name: t.name,
        isSelected: n,
        actions: [
          /* @__PURE__ */ V.jsx(Ut, { type: "link", onClick: () => i.openTab(e), children: "Edit Expression" }, "edit-table")
        ]
      }
    );
  }
}, gde = `declare namespace Big {
    type BigSource = number | string | Big;

    /**
     * GT = 1, EQ = 0, LT = -1
     */
    type Comparison = -1 | 0 | 1;

    /**
     * RoundDown = 0, RoundHalfUp = 1, RoundHalfEven = 2, RoundUp = 3
     */
    type RoundingMode = 0 | 1 | 2 | 3;

    interface BigConstructor {
        /**
         * Returns a new instance of a Big number object
         *
         * String values may be in exponential, as well as normal (non-exponential) notation.
         * There is no limit to the number of digits of a string value (other than that of Javascript's maximum array size), but the largest recommended exponent magnitude is 1e+6.
         * Infinity, NaN and hexadecimal literal strings, e.g. '0xff', are not valid.
         * String values in octal literal form will be interpreted as decimals, e.g. '011' is 11, not 9.
         *
         * @throws \`NaN\` on an invalid value.
         */
        new(value: BigSource): Big;

        /**
         * Returns a new instance of a Big number object
         *
         * String values may be in exponential, as well as normal (non-exponential) notation.
         * There is no limit to the number of digits of a string value (other than that of Javascript's maximum array size), but the largest recommended exponent magnitude is 1e+6.
         * Infinity, NaN and hexadecimal literal strings, e.g. '0xff', are not valid.
         * String values in octal literal form will be interpreted as decimals, e.g. '011' is 11, not 9.
         *
         * @throws \`NaN\` on an invalid value.
         */
        (value: BigSource): Big;

        /**
         * Create an additional Big number constructor
         *
         * Values created with the returned constructor will have a separate set of configuration values.
         * This can be used to create Big objects with different DP and RM values.
         * Big numbers created by different constructors can be used together in operations, and it is the DP and RM setting of the Big number that an operation is called upon that will apply.
         * In the interest of memory efficiency, all Big number constructors share the same prototype object,
         * so while the DP and RM (and any other own properties) of a constructor are isolated and untouchable by another, its prototype methods are not.
         */
        (): BigConstructor;

        /**
         * The maximum number of decimal places of the results of operations involving division.
         * It is relevant only to the div and sqrt methods, and the pow method when the exponent is negative.
         *
         * 0 to 1e+6 inclusive
         * Default value: 20
         */
        DP: number;
        /**
         * The rounding mode used in the above operations and by round, toExponential, toFixed and toPrecision.
         * Default value: 1
         */
        RM: number;
        /**
         * The negative exponent value at and below which toString returns exponential notation.
         *
         * -1e+6 to 0 inclusive
         * Default value: -7
         */
        NE: number;
        /**
         * The positive exponent value at and above which toString returns exponential notation.
         *
         * 0 to 1e+6 inclusive
         * Default value: 21
         */
        PE: number;
        /**
         * When set to true, an error will be thrown if a primitive number is passed to the Big constructor,
         * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a primitive number without a loss of precision.
         *
         * true|false
         * Default value: false
         */
        strict: boolean;

        /** Readonly rounding modes */

        /**
         * Rounds towards zero.
         * I.e. truncate, no rounding.
         */
        readonly roundDown: 0;
        /**
         * Rounds towards nearest neighbour.
         * If equidistant, rounds away from zero.
         */
        readonly roundHalfUp: 1;
        /**
         * Rounds towards nearest neighbour.
         * If equidistant, rounds towards even neighbour.
         */
        readonly roundHalfEven: 2;
        /**
         * Rounds away from zero.
         */
        readonly roundUp: 3;

        readonly Big: BigConstructor;
    }

    interface Big {
        /** Returns a Big number whose value is the absolute value, i.e. the magnitude, of this Big number. */
        abs(): Big;
        /**
         * Returns a Big number whose value is the value of this Big number plus n - alias for .plus().
         *
         * @throws \`NaN\` if n is invalid.
         */
        add(n: BigSource): Big;
        /**
         * Compare the values.
         *
         * @throws \`NaN\` if n is invalid.
         */
        cmp(n: BigSource): Comparison;
        /**
         * Returns a Big number whose value is the value of this Big number divided by n.
         *
         * If the result has more fraction digits than is specified by Big.DP, it will be rounded to Big.DP decimal places using rounding mode Big.RM.
         *
         * @throws \`NaN\` if n is invalid.
         * @throws \`Infinity\` on division by zero.
         * @throws \`NaN\` on division of zero by zero.
         */
        div(n: BigSource): Big;
        /**
         * Returns true if the value of this Big equals the value of n, otherwise returns false.
         *
         * @throws \`NaN\` if n is invalid.
         */
        eq(n: BigSource): boolean;
        /**
         * Returns true if the value of this Big is greater than the value of n, otherwise returns false.
         *
         * @throws \`NaN\` if n is invalid.
         */
        gt(n: BigSource): boolean;
        /**
         * Returns true if the value of this Big is greater than or equal to the value of n, otherwise returns false.
         *
         * @throws \`NaN\` if n is invalid.
         */
        gte(n: BigSource): boolean;
        /**
         * Returns true if the value of this Big is less than the value of n, otherwise returns false.
         *
         * @throws \`NaN\` if n is invalid.
         */
        lt(n: BigSource): boolean;
        /**
         * Returns true if the value of this Big is less than or equal to the value of n, otherwise returns false.
         *
         * @throws \`NaN\` if n is invalid.
         */
        lte(n: BigSource): boolean;
        /**
         * Returns a Big number whose value is the value of this Big number minus n.
         *
         * @throws \`NaN\` if n is invalid.
         */
        minus(n: BigSource): Big;
        /**
         * Returns a Big number whose value is the value of this Big number modulo n, i.e. the integer remainder of dividing this Big number by n.
         *
         * The result will have the same sign as this Big number, and it will match that of Javascript's % operator (within the limits of its precision) and BigDecimal's remainder method.
         *
         * @throws \`NaN\` if n is negative or otherwise invalid.
         */
        mod(n: BigSource): Big;
        /**
         * Returns a Big number whose value is the value of this Big number times n - alias for .times().
         *
         * @throws \`NaN\` if n is invalid.
         */
        mul(n: BigSource): Big;
        /**
         * Return a new Big whose value is the value of this Big negated.
         */
        neg(): Big;
        /**
         * Returns a Big number whose value is the value of this Big number plus n.
         *
         * @throws \`NaN\` if n is invalid.
         */
        plus(n: BigSource): Big;
        /**
         * Returns a Big number whose value is the value of this Big number raised to the power exp.
         *
         * If exp is negative and the result has more fraction digits than is specified by Big.DP, it will be rounded to Big.DP decimal places using rounding mode Big.RM.
         *
         * @param exp The power to raise the number to, -1e+6 to 1e+6 inclusive
         * @throws \`!pow!\` if exp is invalid.
         *
         * Note: High value exponents may cause this method to be slow to return.
         */
        pow(exp: number): Big;
        /**
         * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd
         * significant digits using rounding mode rm, or Big.RM if rm is not specified.
         *
         * @param sd Significant digits: integer, 1 to MAX_DP inclusive.
         * @param rm Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
         * @throws \`!prec!\` if sd is invalid.
         * @throws \`!Big.RM!\` if rm is invalid.
         */
        prec(sd: number, rm?: RoundingMode): Big;
        /**
         * Returns a Big number whose value is the value of this Big number rounded using rounding mode rm to a maximum of dp decimal places.
         *
         * @param dp Decimal places, 0 to 1e+6 inclusive
         * @param rm Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
         * @throws \`!round!\` if dp is invalid.
         * @throws \`!Big.RM!\` if rm is invalid.
         */
        round(dp?: number, rm?: RoundingMode): Big;
        /**
         * Returns a Big number whose value is the square root of this Big number.
         *
         * If the result has more fraction digits than is specified by Big.DP, it will be rounded to Big.DP decimal places using rounding mode Big.RM.
         *
         * @throws \`NaN\` if this Big number is negative.
         */
        sqrt(): Big;
        /**
         * Returns a Big number whose value is the value of this Big number minus n - alias for .minus().
         *
         * @throws \`NaN\` if n is invalid.
         */
        sub(n: BigSource): Big;
        /**
         * Returns a Big number whose value is the value of this Big number times n.
         *
         * @throws \`NaN\` if n is invalid.
         */
        times(n: BigSource): Big;
        /**
         * Returns a string representing the value of this Big number in exponential notation to a fixed number of decimal places dp.
         *
         * If the value of this Big number in exponential notation has more digits to the right of the decimal point than is specified by dp,
         * the return value will be rounded to dp decimal places using rounding mode Big.RM.
         *
         * If the value of this Big number in exponential notation has fewer digits to the right of the decimal point than is specified by dp, the return value will be appended with zeros accordingly.
         *
         * If dp is omitted, or is null or undefined, the number of digits after the decimal point defaults to the minimum number of digits necessary to represent the value exactly.
         *
         * @param dp Decimal places, 0 to 1e+6 inclusive
         * @param rm Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
         * @throws \`!toFix!\` if dp is invalid.
         */
        toExponential(dp?: number, rm?: RoundingMode): string;
        /**
         * Returns a string representing the value of this Big number in normal notation to a fixed number of decimal places dp.
         *
         * If the value of this Big number in normal notation has more digits to the right of the decimal point than is specified by dp,
         * the return value will be rounded to dp decimal places using rounding mode Big.RM.
         *
         * If the value of this Big number in normal notation has fewer fraction digits then is specified by dp, the return value will be appended with zeros accordingly.
         *
         * Unlike Number.prototype.toFixed, which returns exponential notation if a number is greater or equal to 1021, this method will always return normal notation.
         *
         * If dp is omitted, or is null or undefined, then the return value is simply the value in normal notation.
         * This is also unlike Number.prototype.toFixed, which returns the value to zero decimal places.
         *
         * @param dp Decimal places, 0 to 1e+6 inclusive
         * @param rm Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
         * @throws \`!toFix!\` if dp is invalid.
         */
        toFixed(dp?: number, rm?: RoundingMode): string;
        /**
         * Returns a string representing the value of this Big number to the specified number of significant digits sd.
         *
         * If the value of this Big number has more digits than is specified by sd, the return value will be rounded to sd significant digits using rounding mode Big.RM.
         *
         * If the value of this Big number has fewer digits than is specified by sd, the return value will be appended with zeros accordingly.
         *
         * If sd is less than the number of digits necessary to represent the integer part of the value in normal notation, then exponential notation is used.
         *
         * If sd is omitted, or is null or undefined, then the return value is the same as .toString().
         *
         * @param sd Significant digits, 1 to 1e+6 inclusive
         * @param rm Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
         * @throws \`!toPre!\` if sd is invalid.
         */
        toPrecision(sd?: number, rm?: RoundingMode): string;
        /**
         * Returns a string representing the value of this Big number.
         *
         * If this Big number has a positive exponent that is equal to or greater than 21, or a negative exponent equal to or less than -7, then exponential notation is returned.
         *
         * The point at which toString returns exponential rather than normal notation can be adjusted by changing
         * the value of Big.E_POS and Big.E_NEG. By default, Big numbers correspond to Javascript's number type in this regard.
         */
        toString(): string;
        /**
         * Returns a primitive number representing the value of this Big number.
         *
         * If Big.strict is true an error will be thrown if toNumber is called on a Big number which cannot be converted to a primitive number without a loss of precision.
         *
         * @since 6.0
         */
        toNumber(): number;
        /**
         * Returns a string representing the value of this Big number.
         *
         * If this Big number has a positive exponent that is equal to or greater than 21, or a negative exponent equal to or less than -7, then exponential notation is returned.
         *
         * The point at which toString returns exponential rather than normal notation can be adjusted by changing
         * the value of Big.E_POS and Big.E_NEG. By default, Big numbers correspond to Javascript's number type in this regard.
         */
        valueOf(): string;
        /**
         * Returns a string representing the value of this Big number.
         *
         * If this Big number has a positive exponent that is equal to or greater than 21, or a negative exponent equal to or less than -7, then exponential notation is returned.
         *
         * The point at which toString returns exponential rather than normal notation can be adjusted by changing
         * the value of Big.E_POS and Big.E_NEG. By default, Big numbers correspond to Javascript's number type in this regard.
         */
        toJSON(): string;
        /**
         * Returns an array of single digits
         */
        c: number[];
        /**
         * Returns the exponent, Integer, -1e+6 to 1e+6 inclusive
         */
        e: number;
        /**
         * Returns the sign, -1 or 1
         */
        s: number;
    }
}

// We want the exported symbol 'Big' to represent two things:
// - The Big interface, when used in a type context.
// - The BigConstructor instance, when used in a value context.
declare const Big: Big.BigConstructor;
type Big = Big.Big;

// The export is the same as type/value combo symbol 'Big'.
export = Big;
export as namespace Big;
`, mde = `/// <reference path="./locale/index.d.ts" />

export = dayjs;

declare function dayjs (date?: dayjs.ConfigType): dayjs.Dayjs

declare function dayjs (date?: dayjs.ConfigType, format?: dayjs.OptionType, strict?: boolean): dayjs.Dayjs

declare function dayjs (date?: dayjs.ConfigType, format?: dayjs.OptionType, locale?: string, strict?: boolean): dayjs.Dayjs

declare namespace dayjs {
  interface ConfigTypeMap {
    default: string | number | Date | Dayjs | null | undefined
  }

  export type ConfigType = ConfigTypeMap[keyof ConfigTypeMap]

  export interface FormatObject { locale?: string, format?: string, utc?: boolean }

  export type OptionType = FormatObject | string | string[]

  export type UnitTypeShort = 'd' | 'D' | 'M' | 'y' | 'h' | 'm' | 's' | 'ms'

  export type UnitTypeLong = 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'month' | 'year' | 'date'

  export type UnitTypeLongPlural = 'milliseconds' | 'seconds' | 'minutes' | 'hours' | 'days' | 'months' | 'years' | 'dates'
  
  export type UnitType = UnitTypeLong | UnitTypeLongPlural | UnitTypeShort;

  export type OpUnitType = UnitType | "week" | "weeks" | 'w';
  export type QUnitType = UnitType | "quarter" | "quarters" | 'Q';
  export type ManipulateType = Exclude<OpUnitType, 'date' | 'dates'>;
  class Dayjs {
    constructor (config?: ConfigType)
    /**
     * All Day.js objects are immutable. Still, \`dayjs#clone\` can create a clone of the current object if you need one.
     * \`\`\`
     * dayjs().clone()// => Dayjs
     * dayjs(dayjs('2019-01-25')) // passing a Dayjs object to a constructor will also clone it
     * \`\`\`
     * Docs: https://day.js.org/docs/en/parse/dayjs-clone
     */
    clone(): Dayjs
    /**
     * This returns a \`boolean\` indicating whether the Day.js object contains a valid date or not.
     * \`\`\`
     * dayjs().isValid()// => boolean
     * \`\`\`
     * Docs: https://day.js.org/docs/en/parse/is-valid
     */
    isValid(): boolean
    /**
     * Get the year.
     * \`\`\`
     * dayjs().year()// => 2020
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/year
     */
    year(): number
    /**
     * Set the year.
     * \`\`\`
     * dayjs().year(2000)// => Dayjs
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/year
     */
    year(value: number): Dayjs
    /**
     * Get the month.
     *
     * Months are zero indexed, so January is month 0.
     * \`\`\`
     * dayjs().month()// => 0-11
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/month
     */
    month(): number
    /**
     * Set the month.
     *
     * Months are zero indexed, so January is month 0.
     *
     * Accepts numbers from 0 to 11. If the range is exceeded, it will bubble up to the next year.
     * \`\`\`
     * dayjs().month(0)// => Dayjs
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/month
     */
    month(value: number): Dayjs
    /**
     * Get the date of the month.
     * \`\`\`
     * dayjs().date()// => 1-31
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/date
     */
    date(): number
    /**
     * Set the date of the month.
     *
     * Accepts numbers from 1 to 31. If the range is exceeded, it will bubble up to the next months.
     * \`\`\`
     * dayjs().date(1)// => Dayjs
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/date
     */
    date(value: number): Dayjs
    /**
     * Get the day of the week.
     *
     * Returns numbers from 0 (Sunday) to 6 (Saturday).
     * \`\`\`
     * dayjs().day()// 0-6
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/day
     */
    day(): 0 | 1 | 2 | 3 | 4 | 5 | 6
    /**
     * Set the day of the week.
     *
     * Accepts numbers from 0 (Sunday) to 6 (Saturday). If the range is exceeded, it will bubble up to next weeks.
     * \`\`\`
     * dayjs().day(0)// => Dayjs
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/day
     */
    day(value: number): Dayjs
    /**
     * Get the hour.
     * \`\`\`
     * dayjs().hour()// => 0-23
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/hour
     */
    hour(): number
    /**
     * Set the hour.
     *
     * Accepts numbers from 0 to 23. If the range is exceeded, it will bubble up to the next day.
     * \`\`\`
     * dayjs().hour(12)// => Dayjs
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/hour
     */
    hour(value: number): Dayjs
    /**
     * Get the minutes.
     * \`\`\`
     * dayjs().minute()// => 0-59
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/minute
     */
    minute(): number
    /**
     * Set the minutes.
     *
     * Accepts numbers from 0 to 59. If the range is exceeded, it will bubble up to the next hour.
     * \`\`\`
     * dayjs().minute(59)// => Dayjs
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/minute
     */
    minute(value: number): Dayjs
    /**
     * Get the seconds.
     * \`\`\`
     * dayjs().second()// => 0-59
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/second
     */
    second(): number
    /**
     * Set the seconds.
     *
     * Accepts numbers from 0 to 59. If the range is exceeded, it will bubble up to the next minutes.
     * \`\`\`
     * dayjs().second(1)// Dayjs
     * \`\`\`
     */
    second(value: number): Dayjs
    /**
     * Get the milliseconds.
     * \`\`\`
     * dayjs().millisecond()// => 0-999
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/millisecond
     */
    millisecond(): number
    /**
     * Set the milliseconds.
     *
     * Accepts numbers from 0 to 999. If the range is exceeded, it will bubble up to the next seconds.
     * \`\`\`
     * dayjs().millisecond(1)// => Dayjs
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/millisecond
     */
    millisecond(value: number): Dayjs
    /**
     * Generic setter, accepting unit as first argument, and value as second, returns a new instance with the applied changes.
     *
     * In general:
     * \`\`\`
     * dayjs().set(unit, value) === dayjs()[unit](value)
     * \`\`\`
     * Units are case insensitive, and support plural and short forms.
     * \`\`\`
     * dayjs().set('date', 1)
     * dayjs().set('month', 3) // April
     * dayjs().set('second', 30)
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/set
     */
    set(unit: UnitType, value: number): Dayjs
    /**
     * String getter, returns the corresponding information getting from Day.js object.
     *
     * In general:
     * \`\`\`
     * dayjs().get(unit) === dayjs()[unit]()
     * \`\`\`
     * Units are case insensitive, and support plural and short forms.
     * \`\`\`
     * dayjs().get('year')
     * dayjs().get('month') // start 0
     * dayjs().get('date')
     * \`\`\`
     * Docs: https://day.js.org/docs/en/get-set/get
     */
    get(unit: UnitType): number
    /**
     * Returns a cloned Day.js object with a specified amount of time added.
     * \`\`\`
     * dayjs().add(7, 'day')// => Dayjs
     * \`\`\`
     * Units are case insensitive, and support plural and short forms.
     *
     * Docs: https://day.js.org/docs/en/manipulate/add
     */
    add(value: number, unit?: ManipulateType): Dayjs
    /**
     * Returns a cloned Day.js object with a specified amount of time subtracted.
     * \`\`\`
     * dayjs().subtract(7, 'year')// => Dayjs
     * \`\`\`
     * Units are case insensitive, and support plural and short forms.
     *
     * Docs: https://day.js.org/docs/en/manipulate/subtract
     */
    subtract(value: number, unit?: ManipulateType): Dayjs
    /**
     * Returns a cloned Day.js object and set it to the start of a unit of time.
     * \`\`\`
     * dayjs().startOf('year')// => Dayjs
     * \`\`\`
     * Units are case insensitive, and support plural and short forms.
     *
     * Docs: https://day.js.org/docs/en/manipulate/start-of
     */
    startOf(unit: OpUnitType): Dayjs
    /**
     * Returns a cloned Day.js object and set it to the end of a unit of time.
     * \`\`\`
     * dayjs().endOf('month')// => Dayjs
     * \`\`\`
     * Units are case insensitive, and support plural and short forms.
     *
     * Docs: https://day.js.org/docs/en/manipulate/end-of
     */
    endOf(unit: OpUnitType): Dayjs
    /**
     * Get the formatted date according to the string of tokens passed in.
     *
     * To escape characters, wrap them in square brackets (e.g. [MM]).
     * \`\`\`
     * dayjs().format()// => current date in ISO8601, without fraction seconds e.g. '2020-04-02T08:02:17-05:00'
     * dayjs('2019-01-25').format('[YYYYescape] YYYY-MM-DDTHH:mm:ssZ[Z]')// 'YYYYescape 2019-01-25T00:00:00-02:00Z'
     * dayjs('2019-01-25').format('DD/MM/YYYY') // '25/01/2019'
     * \`\`\`
     * Docs: https://day.js.org/docs/en/display/format
     */
    format(template?: string): string
    /**
     * This indicates the difference between two date-time in the specified unit.
     *
     * To get the difference in milliseconds, use \`dayjs#diff\`
     * \`\`\`
     * const date1 = dayjs('2019-01-25')
     * const date2 = dayjs('2018-06-05')
     * date1.diff(date2) // 20214000000 default milliseconds
     * date1.diff() // milliseconds to current time
     * \`\`\`
     *
     * To get the difference in another unit of measurement, pass that measurement as the second argument.
     * \`\`\`
     * const date1 = dayjs('2019-01-25')
     * date1.diff('2018-06-05', 'month') // 7
     * \`\`\`
     * Units are case insensitive, and support plural and short forms.
     *
     * Docs: https://day.js.org/docs/en/display/difference
     */
    diff(date?: ConfigType, unit?: QUnitType | OpUnitType, float?: boolean): number
    /**
     * This returns the number of **milliseconds** since the Unix Epoch of the Day.js object.
     * \`\`\`
     * dayjs('2019-01-25').valueOf() // 1548381600000
     * +dayjs(1548381600000) // 1548381600000
     * \`\`\`
     * To get a Unix timestamp (the number of seconds since the epoch) from a Day.js object, you should use Unix Timestamp \`dayjs#unix()\`.
     *
     * Docs: https://day.js.org/docs/en/display/unix-timestamp-milliseconds
     */
    valueOf(): number
    /**
     * This returns the Unix timestamp (the number of **seconds** since the Unix Epoch) of the Day.js object.
     * \`\`\`
     * dayjs('2019-01-25').unix() // 1548381600
     * \`\`\`
     * This value is floored to the nearest second, and does not include a milliseconds component.
     *
     * Docs: https://day.js.org/docs/en/display/unix-timestamp
     */
    unix(): number
    /**
     * Get the number of days in the current month.
     * \`\`\`
     * dayjs('2019-01-25').daysInMonth() // 31
     * \`\`\`
     * Docs: https://day.js.org/docs/en/display/days-in-month
     */
    daysInMonth(): number
    /**
     * To get a copy of the native \`Date\` object parsed from the Day.js object use \`dayjs#toDate\`.
     * \`\`\`
     * dayjs('2019-01-25').toDate()// => Date
     * \`\`\`
     */
    toDate(): Date
    /**
     * To serialize as an ISO 8601 string.
     * \`\`\`
     * dayjs('2019-01-25').toJSON() // '2019-01-25T02:00:00.000Z'
     * \`\`\`
     * Docs: https://day.js.org/docs/en/display/as-json
     */
    toJSON(): string
    /**
     * To format as an ISO 8601 string.
     * \`\`\`
     * dayjs('2019-01-25').toISOString() // '2019-01-25T02:00:00.000Z'
     * \`\`\`
     * Docs: https://day.js.org/docs/en/display/as-iso-string
     */
    toISOString(): string
    /**
     * Returns a string representation of the date.
     * \`\`\`
     * dayjs('2019-01-25').toString() // 'Fri, 25 Jan 2019 02:00:00 GMT'
     * \`\`\`
     * Docs: https://day.js.org/docs/en/display/as-string
     */
    toString(): string
    /**
     * Get the UTC offset in minutes.
     * \`\`\`
     * dayjs().utcOffset()
     * \`\`\`
     * Docs: https://day.js.org/docs/en/manipulate/utc-offset
     */
    utcOffset(): number
    /**
     * This indicates whether the Day.js object is before the other supplied date-time.
     * \`\`\`
     * dayjs().isBefore(dayjs('2011-01-01')) // default milliseconds
     * \`\`\`
     * If you want to limit the granularity to a unit other than milliseconds, pass it as the second parameter.
     * \`\`\`
     * dayjs().isBefore('2011-01-01', 'year')// => boolean
     * \`\`\`
     * Units are case insensitive, and support plural and short forms.
     *
     * Docs: https://day.js.org/docs/en/query/is-before
     */
    isBefore(date?: ConfigType, unit?: OpUnitType): boolean
    /**
     * This indicates whether the Day.js object is the same as the other supplied date-time.
     * \`\`\`
     * dayjs().isSame(dayjs('2011-01-01')) // default milliseconds
     * \`\`\`
     * If you want to limit the granularity to a unit other than milliseconds, pass it as the second parameter.
     * \`\`\`
     * dayjs().isSame('2011-01-01', 'year')// => boolean
     * \`\`\`
     * Docs: https://day.js.org/docs/en/query/is-same
     */
    isSame(date?: ConfigType, unit?: OpUnitType): boolean
    /**
     * This indicates whether the Day.js object is after the other supplied date-time.
     * \`\`\`
     * dayjs().isAfter(dayjs('2011-01-01')) // default milliseconds
     * \`\`\`
     * If you want to limit the granularity to a unit other than milliseconds, pass it as the second parameter.
     * \`\`\`
     * dayjs().isAfter('2011-01-01', 'year')// => boolean
     * \`\`\`
     * Units are case insensitive, and support plural and short forms.
     *
     * Docs: https://day.js.org/docs/en/query/is-after
     */
    isAfter(date?: ConfigType, unit?: OpUnitType): boolean

    locale(): string

    locale(preset: string | ILocale, object?: Partial<ILocale>): Dayjs
  }

  export type PluginFunc<T = unknown> = (option: T, c: typeof Dayjs, d: typeof dayjs) => void

  export function extend<T = unknown>(plugin: PluginFunc<T>, option?: T): Dayjs

  export function locale(preset?: string | ILocale, object?: Partial<ILocale>, isLocal?: boolean): string

  export function isDayjs(d: any): d is Dayjs

  export function unix(t: number): Dayjs

  const Ls : { [key: string] :  ILocale }
}
`, vde = `/**
 * @param input
 * @param {{
 *  dayjs: import('dayjs')
 *  Big: import('big.js').BigConstructor
 * }} helpers
 */
const handler = (input, { dayjs, Big }) => {
  return input;
};
`, gA = {
  dayjs: mde,
  "big.js": gde
}, bde = vde, yde = {
  type: Fn.Function,
  icon: /* @__PURE__ */ V.jsx(SP, {}),
  displayName: "Function",
  documentationUrl: "https://gorules.io/docs/user-manual/decision-modeling/decisions/functions",
  shortDescription: "Javascript lambda",
  generateNode: ({ index: e }) => ({
    name: `function${e}`,
    content: bde
  }),
  renderNode: ({ id: e, data: t, selected: n, specification: r }) => {
    const i = Lr();
    return /* @__PURE__ */ V.jsx(
      wa,
      {
        id: e,
        specification: r,
        name: t.name,
        isSelected: n,
        actions: [
          /* @__PURE__ */ V.jsx(Ut, { type: "link", onClick: () => i.openTab(e), children: "Edit Function" }, "edit-function")
        ]
      }
    );
  }
}, wde = {
  type: Fn.Input,
  icon: /* @__PURE__ */ V.jsx(EP, {}),
  displayName: "Request",
  color: "secondary",
  documentationUrl: "https://gorules.io/docs/user-manual/decision-modeling/decisions",
  shortDescription: "Provides input context",
  generateNode: () => ({ name: "request" }),
  renderNode: ({ id: e, data: t, selected: n, specification: r }) => {
    const i = Lr(), { disabled: o } = Nr(({ disabled: s }) => ({
      disabled: s
    }));
    return /* @__PURE__ */ V.jsx(
      wa,
      {
        id: e,
        specification: r,
        name: t.name,
        isSelected: n,
        handleLeft: !1,
        menuItems: [
          {
            key: "documentation",
            icon: /* @__PURE__ */ V.jsx(ag, {}),
            label: "Documentation",
            onClick: () => window.open(r.documentationUrl, "_href")
          },
          {
            key: "delete",
            icon: /* @__PURE__ */ V.jsx(lu, {}),
            danger: !0,
            label: /* @__PURE__ */ V.jsx(Ka, { left: "Delete", right: Ga.shortcut("Backspace") }),
            disabled: o,
            onClick: () => pr.confirm({
              icon: null,
              title: "Delete node",
              content: /* @__PURE__ */ V.jsxs(Bt.Text, { children: [
                "Are you sure you want to delete ",
                /* @__PURE__ */ V.jsx(Bt.Text, { strong: !0, children: t.name }),
                " node."
              ] }),
              okButtonProps: { danger: !0 },
              onOk: () => i.removeNodes([e])
            })
          }
        ]
      }
    );
  }
}, Cde = {
  type: Fn.Output,
  icon: /* @__PURE__ */ V.jsx($P, {}),
  color: "secondary",
  displayName: "Response",
  documentationUrl: "https://gorules.io/docs/user-manual/decision-modeling/decisions",
  shortDescription: "Outputs the context",
  generateNode: () => ({ name: "response" }),
  renderNode: ({ id: e, data: t, selected: n, specification: r }) => /* @__PURE__ */ V.jsx(wa, { id: e, specification: r, name: t.name, isSelected: n, handleRight: !1 })
}, Sde = {
  type: Fn.Switch,
  icon: /* @__PURE__ */ V.jsx(mP, {}),
  displayName: "Switch",
  documentationUrl: "https://gorules.io/docs/user-manual/decision-modeling/decisions/switch",
  shortDescription: "Conditional branching",
  generateNode: ({ index: e }) => ({
    name: `switch${e}`,
    content: {
      statements: [{ id: crypto.randomUUID(), condition: "" }]
    }
  }),
  renderNode: ({ specification: e, ...t }) => /* @__PURE__ */ V.jsx(xde, { specification: e, ...t })
}, xde = ({ id: e, data: t, selected: n, specification: r }) => {
  const i = Lr(), { content: o, disabled: s, nodeTrace: a } = Nr(({ decisionGraph: d, disabled: f, simulate: h }) => {
    var p;
    return {
      nodeTrace: yn(h).with({ result: mn._ }, ({ result: g }) => {
        var m, v;
        return (v = (m = g == null ? void 0 : g.trace) == null ? void 0 : m[e]) == null ? void 0 : v.traceData;
      }).otherwise(() => null),
      content: (p = ((d == null ? void 0 : d.nodes) || []).find((g) => (g == null ? void 0 : g.id) === e)) == null ? void 0 : p.content,
      disabled: f
    };
  }), l = (o == null ? void 0 : o.statements) || [], u = (o == null ? void 0 : o.hitPolicy) || "first", c = (d) => {
    i.updateNode(e, (f) => (f.content.hitPolicy = d, f));
  };
  return /* @__PURE__ */ V.jsx(
    wa,
    {
      id: e,
      className: wn(["switch"]),
      specification: r,
      name: t.name,
      handleRight: !1,
      noBodyPadding: !0,
      isSelected: n,
      actions: [
        /* @__PURE__ */ V.jsx(
          Ut,
          {
            type: "link",
            disabled: s,
            onClick: () => {
              i.updateNode(e, (d) => (d.content.statements.push({ id: crypto.randomUUID(), condition: "" }), d));
            },
            children: "Add row"
          },
          "add row"
        ),
        /* @__PURE__ */ V.jsx(
          da,
          {
            trigger: ["click"],
            placement: "bottomRight",
            disabled: s,
            menu: {
              items: [
                {
                  key: "first",
                  label: "First",
                  onClick: () => c("first")
                },
                {
                  key: "collect",
                  label: "Collect",
                  onClick: () => c("collect")
                }
              ]
            },
            children: /* @__PURE__ */ V.jsxs(Ut, { type: "link", style: { textTransform: "capitalize", marginLeft: "auto" }, children: [
              u,
              " ",
              /* @__PURE__ */ V.jsx(Cf, {})
            ] })
          },
          "hitPolicy"
        )
      ],
      children: /* @__PURE__ */ V.jsx("div", { className: "switchNode", children: /* @__PURE__ */ V.jsxs("div", { className: "switchNode__body edit nodrag", children: [
        !((l == null ? void 0 : l.length) > 0) && /* @__PURE__ */ V.jsx(Bt.Text, { type: "secondary", className: "no-conditions", children: "No conditions" }),
        l.map((d) => /* @__PURE__ */ V.jsx(
          Ede,
          {
            value: d.condition,
            id: d.id,
            disabled: s,
            isActive: yn(a).with(
              { statements: mn.array(mn._) },
              ({ statements: f }) => f.some((h) => typeof h == "object" && h && "id" in h && h.id === (d == null ? void 0 : d.id))
            ).otherwise(() => !1),
            onDelete: () => {
              i.updateNode(e, (f) => (f.content.statements = f.content.statements.filter(
                (h) => (h == null ? void 0 : h.id) !== (d == null ? void 0 : d.id)
              ), f));
            },
            onChange: (f) => {
              i.updateNode(e, (h) => {
                const p = h.content.statements.find((g) => g.id === d.id);
                return p.condition = f, h;
              });
            }
          },
          d.id
        ))
      ] }) })
    }
  );
}, Ede = ({ id: e, value: t, onChange: n, disabled: r, configurable: i = !0, onDelete: o, isActive: s }) => {
  const [a, l] = ht(t);
  Eg(() => {
    a !== t && l(t);
  }, [t]);
  const u = (c) => {
    l(c), n == null || n(c);
  };
  return /* @__PURE__ */ V.jsxs("div", { className: wn("switchNode__statement"), children: [
    /* @__PURE__ */ V.jsxs("div", { className: "switchNode__statement__inputArea", children: [
      /* @__PURE__ */ V.jsx(
        uu,
        {
          placeholder: "Condition (e.g. x > 10)",
          style: {
            fontSize: 12,
            lineHeight: "20px",
            width: "100%"
          },
          value: a,
          maxRows: 4,
          disabled: r,
          onChange: u
        }
      ),
      !r && i && /* @__PURE__ */ V.jsx(
        Ut,
        {
          className: "switchNode__statement__more",
          size: "small",
          type: "text",
          danger: !0,
          icon: /* @__PURE__ */ V.jsx(lu, {}),
          onClick: () => o == null ? void 0 : o()
        }
      )
    ] }),
    /* @__PURE__ */ V.jsx(
      ul,
      {
        id: e,
        type: "source",
        position: bt.Right,
        className: wn(s && "switchNode__activeHandle")
      }
    )
  ] });
};
const nf = {
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-expect-error
  [Fn.Input]: wde,
  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-expect-error
  [Fn.Output]: Cde,
  [Fn.DecisionTable]: hde,
  [Fn.Function]: yde,
  [Fn.Expression]: pde,
  [Fn.Switch]: Sde
}, $de = Object.entries(nf).reduce(
  (e, [t, n]) => ({
    ...e,
    [t]: U.memo(
      (r) => n.renderNode({ specification: n, ...r }),
      (r, i) => r.id === i.id && r.selected === i.selected && r.data === i.data
    )
  }),
  {}
), Ode = {
  edge: U.memo(lde(null))
}, Ade = li(({ reactFlowProOptions: e, className: t }, n) => {
  const r = he(null), i = he(null), o = Oue([]), s = Aue([]), a = Lr(), l = ede((w) => w), { onReactFlowInit: u } = ZC(({ onReactFlowInit: w }) => ({ onReactFlowInit: w })), { disabled: c, components: d, customNodes: f } = Nr(({ disabled: w, components: C, customNodes: y }) => ({
    disabled: w,
    components: C,
    customNodes: y
  }));
  l.nodesState.current = o, l.edgesState.current = s, l.graphClipboard.current = fde(i, r);
  const h = mt(() => U.memo(
    (w) => {
      var y, S;
      const C = f.find((A) => {
        var $;
        return A.kind === (($ = w == null ? void 0 : w.data) == null ? void 0 : $.kind);
      });
      return C ? C.renderNode({
        specification: C,
        ...w
      }) : (console.warn("node not found", w, f), /* @__PURE__ */ V.jsx(
        wa,
        {
          id: w.id,
          specification: {
            displayName: `${(y = w.data) == null ? void 0 : y.kind}`,
            color: "var(--grl-color-error)",
            icon: /* @__PURE__ */ V.jsx(TP, {})
          },
          name: (S = w == null ? void 0 : w.data) == null ? void 0 : S.name,
          isSelected: w.selected,
          displayError: !0,
          noBodyPadding: !0,
          handleLeft: !0,
          handleRight: !0
        }
      ));
    },
    (w, C) => w.id === C.id && w.selected === C.selected && w.data === C.data
  ), [f]), p = mt(() => d.reduce(
    (w, C) => ({
      ...w,
      [C.type]: U.memo(
        (y) => C.renderNode({ specification: C, ...y }),
        (y, S) => y.id === S.id && y.selected === S.selected && y.data === S.data
      )
    }),
    { ...$de, customNode: h }
  ), [d, h]), g = async (w, C, y) => {
    if (!r.current || !i.current)
      return;
    if (!C) {
      const $ = r.current.getBoundingClientRect(), M = {
        x: $.width / 2,
        y: $.height / 2
      };
      C = i.current.project(M);
    }
    const S = yn(w).with("customNode", () => f.find(($) => $.kind === y)).otherwise(() => [...Object.values(nf), ...d].find((M) => M.type === w));
    if (!S) {
      Cr.error(`Unknown node type ${w} - ${y}.`);
      return;
    }
    let A = yn(S).with({ kind: mn.string }, ($) => {
      var T;
      const M = (((T = i.current) == null ? void 0 : T.getNodes()) || []).filter((D) => {
        var E;
        return ((E = D.data) == null ? void 0 : E.kind) === $.kind;
      }).length + 1, _ = $.generateNode({ index: M });
      return {
        id: crypto.randomUUID(),
        type: "customNode",
        name: _.name,
        position: C,
        content: {
          kind: $.kind,
          config: _ == null ? void 0 : _.config
        }
      };
    }).with({ type: mn.string }, ($) => {
      var T;
      const M = (((T = i.current) == null ? void 0 : T.getNodes()) || []).filter((D) => D.type === $.type).length + 1, _ = $.generateNode({ index: M });
      return {
        id: crypto.randomUUID(),
        type: $.type,
        position: C,
        ..._
      };
    }).otherwise(() => null);
    if (!A) {
      Cr.error(`Unknown node type ${w} - ${y}.`);
      return;
    }
    if (S.onNodeAdd)
      try {
        A = await S.onNodeAdd(A);
      } catch {
        return;
      }
    a.addNodes([A]);
  }, m = (w) => {
    if (w.source === w.target || c)
      return !1;
    const [C] = s;
    return !C.some(
      (S) => S.source === w.source && S.target === w.target && (S.sourceHandle ?? null) === (w.sourceHandle ?? null) && (S.targetHandle ?? null) === (w.targetHandle ?? null)
    );
  }, v = (w) => {
    if (w.preventDefault(), !r.current || !i.current)
      return;
    const C = r.current.getBoundingClientRect(), y = w.dataTransfer.getData("application/reactflow");
    let S;
    try {
      S = JSON.parse(w.dataTransfer.getData("relativePosition"));
    } catch {
      return;
    }
    const A = i.current.project({
      x: w.clientX - C.left,
      y: w.clientY - C.top
    });
    A.x -= Math.round(S.x * 226 / 10) * 10, A.y -= Math.round(S.y * 60 / 10) * 10;
    const $ = yn(w.dataTransfer.getData("customNodeComponent")).with(mn.string, (M) => M).otherwise(() => {
    });
    g(y, A, $);
  }, b = (w) => {
    w.preventDefault(), w.dataTransfer.dropEffect = "move";
  }, x = (w) => {
    const C = {
      ...w,
      type: "edge",
      id: crypto.randomUUID()
    };
    c || a.addEdges([Zue(C)]);
  };
  return fl(n, () => a), /* @__PURE__ */ V.jsx(
    "div",
    {
      className: wn(["tab-content", t]),
      tabIndex: 0,
      onKeyDown: (w) => {
        w.key === "v" && w.metaKey && !c && a.pasteNodes();
      },
      children: /* @__PURE__ */ V.jsx("div", { className: "content-wrapper", children: /* @__PURE__ */ V.jsx("div", { className: wn(["react-flow"]), ref: r, children: /* @__PURE__ */ V.jsxs(
        CL,
        {
          elevateEdgesOnSelect: !1,
          elevateNodesOnSelect: !0,
          zoomOnDoubleClick: !1,
          nodes: o[0],
          edges: s[0],
          onInit: (w) => {
            i.current = w, u == null || u(w);
          },
          snapToGrid: !0,
          snapGrid: [5, 5],
          nodeTypes: p,
          edgeTypes: Ode,
          onDrop: v,
          onDragOver: b,
          onConnect: x,
          isValidConnection: m,
          proOptions: e,
          nodesConnectable: !c,
          nodesDraggable: !c,
          edgesUpdatable: !c,
          onNodesChange: a.handleNodesChange,
          onEdgesChange: a.handleEdgesChange,
          onNodesDelete: (w) => {
            w.forEach((C) => {
              a.closeTab(C == null ? void 0 : C.id);
            });
          },
          onKeyDown: (w) => {
            const [C] = o, [y] = s;
            if (w.key === "c" && w.metaKey) {
              const S = o[0].filter((A) => A.selected).map(({ id: A }) => A);
              if (S.length === 0)
                return;
              a.copyNodes(S), w.preventDefault();
            } else if (w.key === "d" && w.metaKey) {
              if (!c) {
                const S = C.filter((A) => A.selected).map(({ id: A }) => A);
                if (S.length === 0)
                  return;
                a.duplicateNodes(S);
              }
              w.preventDefault();
            } else if (w.key === "Backspace") {
              if (!c) {
                const S = C.filter(($) => $.selected), A = y.filter(($) => $.selected);
                if (S.length > 0) {
                  const $ = S.length, M = $ > 1 ? "nodes" : "node";
                  pr.confirm({
                    icon: null,
                    title: `Delete ${M}`,
                    content: /* @__PURE__ */ V.jsxs(Bt.Text, { children: [
                      "Are you sure you want to delete ",
                      $ > 1 ? `${$} ${M}` : M,
                      "?"
                    ] }),
                    okButtonProps: { danger: !0 },
                    onOk: () => {
                      A.length > 0 && a.removeEdges(A.map((_) => _.id)), a.removeNodes(S.map((_) => _.id));
                    }
                  });
                } else
                  A.length > 0 && a.removeEdges(A.map(($) => $.id));
              }
              w.stopPropagation(), w.preventDefault();
            }
          },
          onEdgeMouseEnter: (w, C) => a.setHoveredEdgeId(C.id),
          onEdgeMouseLeave: () => a.setHoveredEdgeId(null),
          children: [
            /* @__PURE__ */ V.jsx(kue, { showInteractive: !1 }),
            /* @__PURE__ */ V.jsx(jue, { color: "var(--grl-color-border)", gap: 20 })
          ]
        }
      ) }) })
    }
  );
}), Dde = U.memo(({ inputDisabled: e, disabled: t }) => {
  const n = Nr((u) => u.components || []), r = Nr((u) => u.customNodes || []), [i, o] = ht(""), s = Kt((u, c, d) => {
    const f = u.target;
    if (!f)
      return;
    const { offsetX: h, offsetY: p } = u.nativeEvent, { height: g, width: m } = f.getBoundingClientRect(), v = {
      x: h / m,
      y: p / g
    };
    u.dataTransfer.effectAllowed = "move", u.dataTransfer.setData("application/reactflow", c), u.dataTransfer.setData("relativePosition", JSON.stringify(v)), d && u.dataTransfer.setData("customNodeComponent", d);
  }, []), a = mt(() => {
    const u = {
      core: Object.values(nf)
    };
    return (n == null ? void 0 : n.length) > 0 && (u.extended = n), (r || []).forEach((c) => {
      var f, h;
      const d = ((h = (f = c.group) == null ? void 0 : f.trim) == null ? void 0 : h.call(f)) || "";
      d.length > 0 && (u != null && u[d] ? u[d].push({ ...c, type: "customNode" }) : u[d] = [{ ...c, type: "customNode" }]);
    }), (r || []).forEach((c) => {
      c != null && c.group || (u != null && u.custom ? u.custom.push({ ...c, type: "customNode" }) : u.custom = [{ ...c, type: "customNode" }]);
    }), u;
  }, [n, r]), l = mt(() => Object.keys(a).reduce((u, c) => ({
    ...u,
    [c]: (a[c] || []).filter(
      (d) => {
        var f;
        return !(((f = i == null ? void 0 : i.trim) == null ? void 0 : f.call(i).length) > 0) || (d.type || "").toLowerCase().indexOf(i.toLowerCase()) > -1 || (d.displayName || "").toLowerCase().indexOf(i.toLowerCase()) > -1 || (d.shortDescription || "").toLowerCase().indexOf(i.toLowerCase()) > -1 || (d.group || "").toLowerCase().indexOf(i.toLowerCase()) > -1;
      }
    )
  }), {}), [a, i]);
  return /* @__PURE__ */ V.jsxs("div", { children: [
    /* @__PURE__ */ V.jsx(
      $o,
      {
        placeholder: "Type to search",
        value: i,
        onChange: (u) => o(u.target.value || ""),
        allowClear: !0,
        className: "grl-dg__aside__menu__components__search"
      }
    ),
    /* @__PURE__ */ V.jsx("div", { className: "grl-dg__aside__menu__components", children: Object.keys(l).map((u) => yn(u).with(
      "core",
      () => {
        var c;
        return ((c = l.core) == null ? void 0 : c.length) > 0 && /* @__PURE__ */ V.jsxs(U.Fragment, { children: [
          /* @__PURE__ */ V.jsx(ip, { orientationMargin: 4, style: { margin: "4px 0 -4px 0" }, orientation: "left", plain: !0, children: /* @__PURE__ */ V.jsx(
            Bt.Text,
            {
              type: "secondary",
              strong: !0,
              style: {
                fontSize: 12,
                textTransform: "uppercase"
              },
              children: "Core"
            }
          ) }),
          (l.core || []).map((d) => /* @__PURE__ */ V.jsxs(U.Fragment, { children: [
            /* @__PURE__ */ V.jsx(
              mA,
              {
                disabled: yn(d.type).with(Fn.Input, () => t || e).otherwise(() => t),
                specification: d,
                onDragStart: (f) => nf[d.type] !== void 0 ? s(f, d.type) : s(f, "customNode", "kind" in d ? d.kind : "")
              }
            ),
            d.type === Fn.Output && /* @__PURE__ */ V.jsx(ip, { style: { margin: "4px 0" }, orientation: "left", plain: !0 })
          ] }, "kind" in d ? d.kind : d.type))
        ] }, u);
      }
    ).otherwise(
      (c) => {
        var d;
        return ((d = l[c]) == null ? void 0 : d.length) > 0 && /* @__PURE__ */ V.jsxs(U.Fragment, { children: [
          /* @__PURE__ */ V.jsx(ip, { orientationMargin: 4, style: { margin: "4px 0 -4px 0" }, orientation: "left", plain: !0, children: /* @__PURE__ */ V.jsx(
            Bt.Text,
            {
              type: "secondary",
              strong: !0,
              style: {
                fontSize: 12,
                textTransform: "uppercase"
              },
              children: c
            }
          ) }),
          ((l == null ? void 0 : l[c]) || []).map((f) => /* @__PURE__ */ V.jsx(
            mA,
            {
              disabled: t,
              specification: f,
              onDragStart: (h) => c === "extended" ? s(h, f.type) : s(h, "customNode", "kind" in f ? f.kind : "")
            },
            "kind" in f ? f.kind : f.type
          ))
        ] }, c);
      }
    )) })
  ] });
}), mA = ({ specification: e, disabled: t = !1, ...n }) => /* @__PURE__ */ V.jsx("div", { className: wn("draggable-component"), draggable: !t, ...n, children: /* @__PURE__ */ V.jsx("div", { style: { pointerEvents: "none" }, children: /* @__PURE__ */ V.jsx(
  AL,
  {
    color: e.color,
    icon: e.icon,
    name: e.displayName,
    type: e.shortDescription
  }
) }) }), vA = "application/vnd.gorules.decision", _de = ({ defaultOpenMenu: e = "components" }) => {
  const t = he(null), n = he(null), [r, i] = ht(e), { setDecisionGraph: o, toggleSimulator: s } = Lr(), { onSimulationRun: a } = ZC(({ onSimulationRun: b }) => ({ onSimulationRun: b })), { decisionGraph: l, activeNodeId: u, disabled: c, hasInputNode: d } = Nr(
    ({ decisionGraph: b, activeTab: x, disabled: w }) => {
      var C;
      return {
        decisionGraph: b,
        activeNodeId: (C = ((b == null ? void 0 : b.nodes) ?? []).find((y) => y.id === x)) == null ? void 0 : C.id,
        disabled: w,
        hasInputNode: ((b == null ? void 0 : b.nodes) || []).some((y) => y.type === Fn.Input)
      };
    }
  ), f = async (b) => {
    var C, y;
    const x = (C = b == null ? void 0 : b.target) == null ? void 0 : C.files, w = new FileReader();
    w.onload = function(S) {
      var A;
      try {
        const $ = JSON.parse((A = S == null ? void 0 : S.target) == null ? void 0 : A.result);
        if (($ == null ? void 0 : $.contentType) !== vA)
          throw new Error("Invalid content type");
        const M = Array.isArray($ == null ? void 0 : $.nodes) ? $.nodes : [], _ = M.map((D) => D.id), T = $.edges.filter(
          (D) => _.includes(D == null ? void 0 : D.targetId) && _.includes(D == null ? void 0 : D.sourceId)
        );
        o({
          nodes: M,
          edges: T
        });
      } catch ($) {
        Cr.error($.message);
      }
    }, w.readAsText((y = Array.from(x)) == null ? void 0 : y[0], "UTF-8");
  }, h = (b) => {
    var C;
    const x = (C = b == null ? void 0 : b.target) == null ? void 0 : C.files[0], w = new FileReader();
    try {
      w.readAsArrayBuffer(x), w.onload = async () => {
        const y = w.result;
        if (!y)
          return;
        const S = await MP(y), A = l.nodes.map((M) => {
          let _ = M;
          return S.forEach((T) => {
            T.id === M.id && (_ = { ...M, content: T.content });
          }), _;
        }), $ = S.filter((M) => !A.some((_) => _.id === M.id)).map((M, _) => ({ ...M, position: { x: _ * 250, y: 0 } }));
        o({
          nodes: [...A, ...$],
          edges: l.edges
        }), Cr.success("Excel file has been uploaded successfully!");
      };
    } catch {
      Cr.error("Failed to upload Excel!");
    }
  }, p = async (b = "graph") => {
    try {
      const x = `${b.replaceAll(".json", "")}.json`, w = JSON.stringify(
        {
          contentType: vA,
          nodes: l.nodes,
          edges: l.edges
        },
        null,
        2
      ), C = new Blob([w], { type: "application/json" }), y = URL.createObjectURL(C), S = window.document.createElement("a");
      S.href = y, S.download = x, window.document.body.appendChild(S), S.click(), window.document.body.removeChild(S), URL.revokeObjectURL(y);
    } catch (x) {
      Cr.error(x.message);
    }
  }, g = async (b = "decision tables") => {
    try {
      const x = l.nodes.filter((w) => w.type === Fn.DecisionTable).map((w) => ({
        ...w.content,
        id: w.id,
        name: w.name
      }));
      await RP(b, x), Cr.success("Excel file has been downloaded successfully!");
    } catch {
      Cr.error("Failed to download Excel file!");
    }
  }, m = [
    {
      key: "upload-json",
      label: "Upload JSON",
      onClick: () => {
        var b, x;
        return (x = (b = t == null ? void 0 : t.current) == null ? void 0 : b.click) == null ? void 0 : x.call(b);
      }
    },
    {
      key: "upload-excel",
      label: "Upload Excel",
      onClick: () => {
        var b, x;
        return (x = (b = n == null ? void 0 : n.current) == null ? void 0 : b.click) == null ? void 0 : x.call(b);
      }
    }
  ], v = [
    {
      key: "download-json",
      label: "Download JSON",
      onClick: () => p()
    },
    {
      key: "download-excel",
      label: "Download Excel",
      onClick: () => g()
    }
  ];
  return /* @__PURE__ */ V.jsxs("div", { className: "grl-dg__aside", children: [
    /* @__PURE__ */ V.jsx(
      "input",
      {
        hidden: !0,
        accept: "application/json",
        type: "file",
        ref: t,
        onChange: f,
        onClick: (b) => {
          b.target.value = null;
        }
      }
    ),
    /* @__PURE__ */ V.jsx(
      "input",
      {
        hidden: !0,
        accept: ".xlsx",
        type: "file",
        ref: n,
        onChange: h,
        onClick: (b) => {
          b.target.value = null;
        }
      }
    ),
    /* @__PURE__ */ V.jsxs("div", { className: "grl-dg__aside__side-bar", children: [
      /* @__PURE__ */ V.jsxs("div", { className: "grl-dg__aside__side-bar__top", children: [
        /* @__PURE__ */ V.jsx(lr, { placement: "right", title: "Components", children: /* @__PURE__ */ V.jsx(
          Ut,
          {
            type: "primary",
            icon: /* @__PURE__ */ V.jsx(DP, {}),
            onClick: () => i((b) => b !== "components" ? "components" : !1)
          }
        ) }),
        /* @__PURE__ */ V.jsx(da, { menu: { items: m }, placement: "bottomRight", trigger: ["click"], arrow: !0, children: /* @__PURE__ */ V.jsx(Ut, { type: "text", disabled: c, icon: /* @__PURE__ */ V.jsx(yP, {}) }) }),
        /* @__PURE__ */ V.jsx(da, { menu: { items: v }, placement: "bottomRight", trigger: ["click"], arrow: !0, children: /* @__PURE__ */ V.jsx(Ut, { type: "text", disabled: c, icon: /* @__PURE__ */ V.jsx(bP, {}) }) })
      ] }),
      /* @__PURE__ */ V.jsx("div", { className: "grl-dg__aside__side-bar__bottom", children: a && /* @__PURE__ */ V.jsx(lr, { placement: "right", title: "Toggle Simulator", children: /* @__PURE__ */ V.jsx(
        Ut,
        {
          type: "text",
          icon: /* @__PURE__ */ V.jsx(yC, { className: "color-primary" }),
          onClick: () => {
            s();
          }
        }
      ) }) })
    ] }),
    r && /* @__PURE__ */ V.jsx("div", { className: "grl-dg__aside__menu", children: r === "components" && /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
      /* @__PURE__ */ V.jsxs("div", { className: "grl-dg__aside__menu__heading", children: [
        /* @__PURE__ */ V.jsx("div", { className: "grl-dg__aside__menu__heading__text", children: /* @__PURE__ */ V.jsx(Bt.Text, { strong: !0, style: { marginBottom: 0 }, children: "Components" }) }),
        /* @__PURE__ */ V.jsx(Ut, { type: "text", size: "small", icon: /* @__PURE__ */ V.jsx(To, {}), onClick: () => i(!1) })
      ] }),
      /* @__PURE__ */ V.jsx("div", { className: "grl-dg__aside__menu__content", children: /* @__PURE__ */ V.jsx(Dde, { inputDisabled: d, disabled: !!u || c }) })
    ] }) })
  ] });
}, Tde = ({ disabled: e }) => {
  const t = Lr(), { openNodes: n, activeNodeId: r } = Nr(({ decisionGraph: i, activeTab: o, openTabs: s }) => {
    var a;
    return {
      activeNodeId: (a = ((i == null ? void 0 : i.nodes) ?? []).find((l) => l.id === o)) == null ? void 0 : a.id,
      openNodes: ((i == null ? void 0 : i.nodes) ?? []).filter((l) => s.includes(l.id)).map(({ id: l, name: u, type: c }) => ({
        id: l,
        name: u,
        type: c
      }))
    };
  });
  return /* @__PURE__ */ V.jsx(
    tm,
    {
      hideAdd: !0,
      type: "editable-card",
      size: "small",
      className: "tabs",
      activeKey: r || "graph",
      onEdit: (i, o) => {
        o === "remove" && t.closeTab(i);
      },
      onChange: (i) => t.openTab(i),
      items: [
        {
          closable: !1,
          key: "graph",
          label: /* @__PURE__ */ V.jsx(bA, { icon: /* @__PURE__ */ V.jsx(wP, {}), name: "Graph" })
        },
        ...n.map((i) => {
          const o = nf[i.type];
          return {
            disabled: e,
            key: i.id,
            label: /* @__PURE__ */ V.jsx(bA, { icon: o == null ? void 0 : o.icon, name: (i == null ? void 0 : i.name) ?? (i == null ? void 0 : i.type) }),
            closable: !0
          };
        })
      ]
    }
  );
}, bA = ({ icon: e, name: t }) => /* @__PURE__ */ V.jsxs("div", { style: { display: "flex", alignItems: "center", gap: 6 }, children: [
  /* @__PURE__ */ V.jsx(
    hR,
    {
      size: "small",
      shape: "square",
      style: {
        color: "var(--grl-color-primary)",
        background: "transparent",
        fontSize: 16,
        width: 20,
        height: 20,
        lineHeight: "18px"
      },
      icon: e
    }
  ),
  t
] }), Rde = ({ id: e, manager: t }) => {
  var l, u, c;
  const n = Lr(), { nodeTrace: r, disabled: i, configurable: o, content: s } = Nr(
    ({ simulate: d, disabled: f, configurable: h, decisionGraph: p }) => {
      var g;
      return {
        nodeTrace: yn(d).with({ result: mn._ }, ({ result: m }) => {
          var v;
          return (v = m == null ? void 0 : m.trace) == null ? void 0 : v[e];
        }).otherwise(() => null),
        disabled: f,
        configurable: h,
        content: (g = ((p == null ? void 0 : p.nodes) ?? []).find((m) => m.id === e)) == null ? void 0 : g.content
      };
    }
  ), a = (r == null ? void 0 : r.traceData) !== void 0 ? Array.isArray(r == null ? void 0 : r.traceData) ? (l = r == null ? void 0 : r.traceData) == null ? void 0 : l.map((d) => {
    var f;
    return (f = d == null ? void 0 : d.rule) == null ? void 0 : f._id;
  }) : [(c = (u = r == null ? void 0 : r.traceData) == null ? void 0 : u.rule) == null ? void 0 : c._id] : [];
  return /* @__PURE__ */ V.jsx(
    Dre,
    {
      tableHeight: "100%",
      value: s,
      onChange: (d) => {
        n.updateNode(e, (f) => (f.content = d, f));
      },
      manager: t,
      disabled: i,
      configurable: o,
      activeRules: (a || []).filter((d) => !!d)
    }
  );
}, eS = U.createContext({}), yA = (e = {}) => ({
  id: crypto.randomUUID(),
  key: "",
  value: "",
  ...e
}), Mde = ({
  children: e
}) => {
  const t = mt(
    () => pc((n) => ({
      configurable: !0,
      disabled: !1,
      addRowAbove: (r = 0) => {
        n(
          Mn((i) => (i.expressions.splice(r, 0, yA()), i))
        );
      },
      addRowBelow: (r) => {
        n(
          Mn((i) => (r = r ?? i.expressions.length - 1, i.expressions.splice(r + 1, 0, yA()), i))
        );
      },
      expressions: [],
      setExpressions: (r) => {
        n({ expressions: r });
      },
      swapRows: (r, i) => {
        n(
          Mn((o) => {
            const [s] = o.expressions.splice(r, 1);
            return o.expressions.splice(i, 0, s), o;
          })
        );
      },
      removeRow: (r) => {
        n(
          Mn((i) => (i.expressions.splice(r, 1), i))
        );
      },
      updateRow: (r, i) => {
        n(
          Mn((o) => (o.expressions[r] = {
            ...o.expressions[r],
            ...i
          }, o))
        );
      }
    })),
    []
  );
  return /* @__PURE__ */ V.jsx(eS.Provider, { value: t, children: e });
};
function tS(e, t = ro) {
  return U.useContext(eS)(e, t);
}
const Ide = () => U.useContext(eS), kde = ({
  value: e,
  onChange: t,
  defaultValue: n = [],
  configurable: r = !0,
  disabled: i = !1
}) => {
  const o = he(!1), s = Ide(), { setExpressions: a, expressions: l } = tS(({ setExpressions: u, expressions: c }) => ({
    setExpressions: u,
    expressions: c
  }));
  return Pe(() => {
    s.setState({
      configurable: r,
      disabled: i
    });
  }, [r, i]), Pe(() => {
    if (t)
      return s.subscribe((u, c) => {
        ro(u.expressions, c.expressions) || t == null || t(u.expressions);
      });
  }, [s, t]), Pe(() => {
    o.current && e && !ro(e, l) && a(e);
  }, [e]), Pe(() => {
    e ? a(e) : n && a(n), o.current = !0;
  }, []), null;
}, Pde = ({ expression: e, index: t }) => {
  const n = he(null), { updateRow: r, removeRow: i, swapRows: o, disabled: s, configurable: a } = tS(
    ({ updateRow: m, removeRow: v, swapRows: b, disabled: x, configurable: w }) => ({
      updateRow: m,
      removeRow: v,
      swapRows: b,
      disabled: x,
      configurable: w
    })
  ), l = (m) => {
    r(t, m);
  }, u = () => {
    i(t);
  }, [{ isDropping: c, direction: d }, f] = G1({
    accept: "row",
    collect: (m) => {
      var v;
      return {
        isDropping: m.isOver({ shallow: !0 }),
        direction: (((v = m.getDifferenceFromInitialOffset()) == null ? void 0 : v.y) || 0) > 0 ? "down" : "up"
      };
    },
    drop: (m) => {
      o(m.index, t);
    }
  }), [{ isDragging: h }, p, g] = U1({
    canDrag: a && !s,
    item: () => ({ ...e, index: t }),
    type: "row",
    collect: (m) => ({
      isDragging: m.isDragging()
    })
  });
  return g(f(n)), /* @__PURE__ */ V.jsxs(
    "div",
    {
      ref: n,
      className: wn(
        "expression-list-item",
        "expression-list__item",
        c && d === "down" && "dropping-down",
        c && d === "up" && "dropping-up"
      ),
      style: { opacity: h ? 0.5 : 1 },
      children: [
        /* @__PURE__ */ V.jsx("div", { ref: p, className: "expression-list-item__drag", "aria-disabled": !a || s, children: /* @__PURE__ */ V.jsx(OP, {}) }),
        /* @__PURE__ */ V.jsx("div", { children: /* @__PURE__ */ V.jsx(
          $o,
          {
            placeholder: "Key",
            disabled: !a || s,
            value: e == null ? void 0 : e.key,
            onChange: (m) => l({ key: m.target.value }),
            autoComplete: "off"
          }
        ) }),
        /* @__PURE__ */ V.jsx("div", { children: /* @__PURE__ */ V.jsx(
          uu,
          {
            placeholder: "Expression",
            maxRows: 6,
            disabled: s,
            value: e == null ? void 0 : e.value,
            onChange: (m) => l({ value: m })
          }
        ) }),
        /* @__PURE__ */ V.jsx("div", { children: /* @__PURE__ */ V.jsx(
          N1,
          {
            title: "Remove selected row?",
            okText: "Remove",
            onConfirm: u,
            disabled: !a || s,
            children: /* @__PURE__ */ V.jsx(Ut, { type: "text", icon: /* @__PURE__ */ V.jsx(lu, {}), danger: !0, disabled: !a || s })
          }
        ) })
      ]
    }
  );
}, Nde = ({}) => {
  const { expressions: e, addRowBelow: t, configurable: n, disabled: r } = tS(
    ({ expressions: i, addRowBelow: o, configurable: s, disabled: a }) => ({
      expressions: i,
      addRowBelow: o,
      configurable: s,
      disabled: a
    }),
    ro
  );
  return /* @__PURE__ */ V.jsxs("div", { className: "expression-list", children: [
    /* @__PURE__ */ V.jsxs("div", { className: wn("expression-list__item", "expression-list__item--heading"), children: [
      /* @__PURE__ */ V.jsx("div", {}),
      /* @__PURE__ */ V.jsx(Bt.Text, { type: "secondary", children: "Key" }),
      /* @__PURE__ */ V.jsx(Bt.Text, { type: "secondary", children: "Expression" }),
      /* @__PURE__ */ V.jsx("div", {})
    ] }),
    (e || []).map((i, o) => /* @__PURE__ */ V.jsx(Pde, { expression: i, index: o }, i.id)),
    n && !r && /* @__PURE__ */ V.jsx("div", { className: wn("expression-list__item"), children: /* @__PURE__ */ V.jsx(
      Ut,
      {
        className: "expression-list__button",
        icon: /* @__PURE__ */ V.jsx(ou, {}),
        type: "dashed",
        onClick: () => t(),
        children: "Add row"
      }
    ) })
  ] });
}, Lde = ({ manager: e, ...t }) => {
  const [n, r] = ht(!1), i = he(null);
  Pe(() => {
    r(!0);
  }, []);
  const o = mt(() => e ? {
    manager: e
  } : {
    backend: K1,
    options: {
      rootElement: i.current
    }
  }, [i.current, e]);
  return /* @__PURE__ */ V.jsx("div", { ref: i, children: i.current && /* @__PURE__ */ V.jsx(nI, { ...o, children: /* @__PURE__ */ V.jsxs(Mde, { children: [
    /* @__PURE__ */ V.jsx(kde, { ...t }),
    /* @__PURE__ */ V.jsx(Nde, {})
  ] }) }) });
}, Fde = ({ id: e, manager: t }) => {
  const n = Lr(), { disabled: r, configurable: i, content: o } = Nr(({ disabled: s, configurable: a, decisionGraph: l }) => {
    var u;
    return {
      disabled: s,
      configurable: a,
      content: (u = ((l == null ? void 0 : l.nodes) ?? []).find((c) => c.id === e)) == null ? void 0 : u.content
    };
  });
  return /* @__PURE__ */ V.jsx("div", { style: { maxWidth: 900, height: "100%", overflowY: "auto", boxSizing: "border-box", paddingBottom: "1.5rem" }, children: /* @__PURE__ */ V.jsx(
    Lde,
    {
      value: o == null ? void 0 : o.expressions,
      onChange: (s) => {
        n.updateNode(e, (a) => (a.content.expressions = s, a));
      },
      disabled: r,
      configurable: i,
      manager: t
    }
  ) });
}, Bde = U.lazy(async () => ({ default: (await import("./index-dG4TVLta.js")).Function })), jde = ({ id: e }) => {
  const t = Lr(), { nodeTrace: n, disabled: r, content: i } = Nr(
    ({ simulate: o, disabled: s, configurable: a, decisionGraph: l }) => {
      var u;
      return {
        nodeTrace: yn(o).with({ result: mn._ }, ({ result: c }) => {
          var d;
          return (d = c == null ? void 0 : c.trace) == null ? void 0 : d[e];
        }).otherwise(() => null),
        disabled: s,
        configurable: a,
        content: (u = ((l == null ? void 0 : l.nodes) ?? []).find((c) => c.id === e)) == null ? void 0 : u.content
      };
    }
  );
  return /* @__PURE__ */ V.jsx(sF, { fallback: /* @__PURE__ */ V.jsx($f, {}), children: /* @__PURE__ */ V.jsx(
    Bde,
    {
      value: typeof i == "string" ? i : "",
      onChange: (o) => {
        t.updateNode(e, (s) => (s.content = o, s));
      },
      disabled: r,
      trace: n
    }
  ) });
}, zde = U.memo(
  li(({ reactFlowProOptions: e, defaultOpenMenu: t }, n) => {
    const [r, i] = ht(!1), o = Nr(({ decisionGraph: s, activeTab: a }) => ((s == null ? void 0 : s.nodes) ?? []).some((l) => l.id === a));
    return /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
      /* @__PURE__ */ V.jsx(_de, { defaultOpenMenu: t }),
      /* @__PURE__ */ V.jsxs("div", { className: "grl-dg__graph", children: [
        /* @__PURE__ */ V.jsx(Tde, { disabled: r }),
        /* @__PURE__ */ V.jsx(
          Ade,
          {
            ref: n,
            className: wn([!o && "active"]),
            reactFlowProOptions: e,
            onDisableTabs: i
          }
        ),
        /* @__PURE__ */ V.jsx(Hde, {})
      ] }),
      /* @__PURE__ */ V.jsx(sde, {})
    ] });
  })
), Hde = U.memo(() => {
  const { openNodes: e, activeNodeId: t } = Nr(({ decisionGraph: i, openTabs: o, activeTab: s }) => {
    var u;
    const a = (u = ((i == null ? void 0 : i.nodes) ?? []).find((c) => c.id === s)) == null ? void 0 : u.id;
    return {
      openNodes: ((i == null ? void 0 : i.nodes) ?? []).filter((c) => o.includes(c.id)).map(({ id: c, type: d }) => ({ id: c, type: d })),
      activeNodeId: a
    };
  }), n = he(null), r = mt(() => tI(K1, void 0, {
    rootElement: n.current
  }), [n.current]);
  return /* @__PURE__ */ V.jsx("div", { style: { display: "contents" }, ref: n, children: e.map((i) => /* @__PURE__ */ V.jsxs("div", { className: wn(["tab-content", t === (i == null ? void 0 : i.id) && "active"]), children: [
    (i == null ? void 0 : i.type) === "decisionTableNode" && /* @__PURE__ */ V.jsx(Rde, { id: i.id, manager: r }),
    (i == null ? void 0 : i.type) === "expressionNode" && /* @__PURE__ */ V.jsx(Fde, { id: i.id, manager: r }),
    (i == null ? void 0 : i.type) === "functionNode" && /* @__PURE__ */ V.jsx(jde, { id: i.id })
  ] }, i == null ? void 0 : i.id)) });
}), eme = li(
  ({ manager: e, reactFlowProOptions: t, defaultOpenMenu: n, ...r }, i) => /* @__PURE__ */ V.jsx("div", { className: "grl-dg", children: /* @__PURE__ */ V.jsx(qC, { children: /* @__PURE__ */ V.jsxs(Jue, { children: [
    /* @__PURE__ */ V.jsx(
      zde,
      {
        ref: i,
        reactFlowProOptions: t,
        defaultOpenMenu: n
      }
    ),
    /* @__PURE__ */ V.jsx(tde, { ...r })
  ] }) }) })
), tme = (e) => ({
  kind: e.kind,
  icon: e.icon,
  color: e.color,
  displayName: e.displayName,
  group: e.group,
  shortDescription: e.shortDescription,
  generateNode: e.generateNode || (({ index: t }) => ({
    name: `${e.kind || e.displayName}${t}`
  })),
  onNodeAdd: e.onNodeAdd,
  renderNode: e.renderNode ? e.renderNode : ({ id: t, specification: n, data: r, selected: i }) => {
    var d;
    const [o, s] = ht(!1), { token: a } = no.useToken(), { updateNode: l } = Lr(), u = Nr((f) => {
      var h;
      return (((h = f.decisionGraph) == null ? void 0 : h.nodes) || []).find((p) => p.id === t);
    }), c = (d = u == null ? void 0 : u.content) == null ? void 0 : d.config;
    return /* @__PURE__ */ V.jsx(
      wa,
      {
        id: t,
        specification: n,
        name: r.name,
        isSelected: i,
        noBodyPadding: !0,
        handleLeft: e.handleLeft,
        handleRight: e.handleRight,
        actions: e != null && e.inputs ? [
          /* @__PURE__ */ V.jsx(
            Ut,
            {
              type: "link",
              style: { marginLeft: "auto", transform: o ? "rotate(180deg)" : void 0 },
              onClick: () => s((f) => !f),
              children: /* @__PURE__ */ V.jsx(Cf, {})
            },
            "edit-table"
          )
        ] : void 0,
        children: o && (e == null ? void 0 : e.inputs) && /* @__PURE__ */ V.jsx(
          Pn,
          {
            className: "grl-dn__cn__form",
            layout: "vertical",
            initialValues: c,
            onValuesChange: (f, h) => {
              l(t, (p) => (p.content.config = h, p));
            },
            children: ((e == null ? void 0 : e.inputs) || []).map(({ name: f, control: h, label: p }) => {
              const g = yn({ control: h }).with({ control: "text" }, () => /* @__PURE__ */ V.jsx(uu, { type: "template" })).with({ control: "bool" }, () => /* @__PURE__ */ V.jsx(rm, { children: /* @__PURE__ */ V.jsx(Bt.Text, { style: { fontSize: a.fontSizeSM }, children: p }) })).exhaustive(), m = yn({ control: h }).with({ control: "bool" }, () => null).otherwise(() => /* @__PURE__ */ V.jsx(Bt.Text, { style: { fontSize: a.fontSizeSM }, children: p }));
              return /* @__PURE__ */ V.jsx(
                Pn.Item,
                {
                  name: f,
                  label: m,
                  style: {
                    marginBottom: 4
                  },
                  children: g
                },
                f
              );
            })
          }
        )
      }
    );
  }
});
function Vde(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function wA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function CA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wA(Object(n), !0).forEach(function(r) {
      Vde(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Wde(e, t) {
  if (e == null)
    return {};
  var n = {}, r = Object.keys(e), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(t.indexOf(i) >= 0) && (n[i] = e[i]);
  return n;
}
function Ude(e, t) {
  if (e == null)
    return {};
  var n = Wde(e, t), r, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (i = 0; i < o.length; i++)
      r = o[i], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function Gde(e, t) {
  return Kde(e) || Xde(e, t) || Yde(e, t) || qde();
}
function Kde(e) {
  if (Array.isArray(e))
    return e;
}
function Xde(e, t) {
  if (!(typeof Symbol > "u" || !(Symbol.iterator in Object(e)))) {
    var n = [], r = !0, i = !1, o = void 0;
    try {
      for (var s = e[Symbol.iterator](), a; !(r = (a = s.next()).done) && (n.push(a.value), !(t && n.length === t)); r = !0)
        ;
    } catch (l) {
      i = !0, o = l;
    } finally {
      try {
        !r && s.return != null && s.return();
      } finally {
        if (i)
          throw o;
      }
    }
    return n;
  }
}
function Yde(e, t) {
  if (e) {
    if (typeof e == "string")
      return SA(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return SA(e, t);
  }
}
function SA(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, r = new Array(t); n < t; n++)
    r[n] = e[n];
  return r;
}
function qde() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Qde(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function xA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function EA(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xA(Object(n), !0).forEach(function(r) {
      Qde(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Zde() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return function(r) {
    return t.reduceRight(function(i, o) {
      return o(i);
    }, r);
  };
}
function Gu(e) {
  return function t() {
    for (var n = this, r = arguments.length, i = new Array(r), o = 0; o < r; o++)
      i[o] = arguments[o];
    return i.length >= e.length ? e.apply(this, i) : function() {
      for (var s = arguments.length, a = new Array(s), l = 0; l < s; l++)
        a[l] = arguments[l];
      return t.apply(n, [].concat(i, a));
    };
  };
}
function wg(e) {
  return {}.toString.call(e).includes("Object");
}
function Jde(e) {
  return !Object.keys(e).length;
}
function rf(e) {
  return typeof e == "function";
}
function efe(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function tfe(e, t) {
  return wg(t) || sa("changeType"), Object.keys(t).some(function(n) {
    return !efe(e, n);
  }) && sa("changeField"), t;
}
function nfe(e) {
  rf(e) || sa("selectorType");
}
function rfe(e) {
  rf(e) || wg(e) || sa("handlerType"), wg(e) && Object.values(e).some(function(t) {
    return !rf(t);
  }) && sa("handlersType");
}
function ife(e) {
  e || sa("initialIsRequired"), wg(e) || sa("initialType"), Jde(e) && sa("initialContent");
}
function ofe(e, t) {
  throw new Error(e[t] || e.default);
}
var sfe = {
  initialIsRequired: "initial state is required",
  initialType: "initial state should be an object",
  initialContent: "initial state shouldn't be an empty object",
  handlerType: "handler should be an object or a function",
  handlersType: "all handlers should be a functions",
  selectorType: "selector should be a function",
  changeType: "provided value of changes should be an object",
  changeField: 'it seams you want to change a field in the state which is not specified in the "initial" state',
  default: "an unknown error accured in `state-local` package"
}, sa = Gu(ofe)(sfe), Hh = {
  changes: tfe,
  selector: nfe,
  handler: rfe,
  initial: ife
};
function afe(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Hh.initial(e), Hh.handler(t);
  var n = {
    current: e
  }, r = Gu(ufe)(n, t), i = Gu(cfe)(n), o = Gu(Hh.changes)(e), s = Gu(lfe)(n);
  function a() {
    var u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function(c) {
      return c;
    };
    return Hh.selector(u), u(n.current);
  }
  function l(u) {
    Zde(r, i, o, s)(u);
  }
  return [a, l];
}
function lfe(e, t) {
  return rf(t) ? t(e.current) : t;
}
function cfe(e, t) {
  return e.current = EA(EA({}, e.current), t), t;
}
function ufe(e, t, n) {
  return rf(t) ? t(e.current) : Object.keys(n).forEach(function(r) {
    var i;
    return (i = t[r]) === null || i === void 0 ? void 0 : i.call(t, e.current[r]);
  }), n;
}
var dfe = {
  create: afe
}, ffe = {
  paths: {
    vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs"
  }
};
function hfe(e) {
  return function t() {
    for (var n = this, r = arguments.length, i = new Array(r), o = 0; o < r; o++)
      i[o] = arguments[o];
    return i.length >= e.length ? e.apply(this, i) : function() {
      for (var s = arguments.length, a = new Array(s), l = 0; l < s; l++)
        a[l] = arguments[l];
      return t.apply(n, [].concat(i, a));
    };
  };
}
function pfe(e) {
  return {}.toString.call(e).includes("Object");
}
function gfe(e) {
  return e || $A("configIsRequired"), pfe(e) || $A("configType"), e.urls ? (mfe(), {
    paths: {
      vs: e.urls.monacoBase
    }
  }) : e;
}
function mfe() {
  console.warn(DL.deprecation);
}
function vfe(e, t) {
  throw new Error(e[t] || e.default);
}
var DL = {
  configIsRequired: "the configuration object is required",
  configType: "the configuration object should be an object",
  default: "an unknown error accured in `@monaco-editor/loader` package",
  deprecation: `Deprecation warning!
    You are using deprecated way of configuration.

    Instead of using
      monaco.config({ urls: { monacoBase: '...' } })
    use
      monaco.config({ paths: { vs: '...' } })

    For more please check the link https://github.com/suren-atoyan/monaco-loader#config
  `
}, $A = hfe(vfe)(DL), bfe = {
  config: gfe
}, yfe = function() {
  for (var t = arguments.length, n = new Array(t), r = 0; r < t; r++)
    n[r] = arguments[r];
  return function(i) {
    return n.reduceRight(function(o, s) {
      return s(o);
    }, i);
  };
};
function _L(e, t) {
  return Object.keys(t).forEach(function(n) {
    t[n] instanceof Object && e[n] && Object.assign(t[n], _L(e[n], t[n]));
  }), CA(CA({}, e), t);
}
var wfe = {
  type: "cancelation",
  msg: "operation is manually canceled"
};
function $0(e) {
  var t = !1, n = new Promise(function(r, i) {
    e.then(function(o) {
      return t ? i(wfe) : r(o);
    }), e.catch(i);
  });
  return n.cancel = function() {
    return t = !0;
  }, n;
}
var Cfe = dfe.create({
  config: ffe,
  isInitialized: !1,
  resolve: null,
  reject: null,
  monaco: null
}), TL = Gde(Cfe, 2), kf = TL[0], Im = TL[1];
function Sfe(e) {
  var t = bfe.config(e), n = t.monaco, r = Ude(t, ["monaco"]);
  Im(function(i) {
    return {
      config: _L(i.config, r),
      monaco: n
    };
  });
}
function xfe() {
  var e = kf(function(t) {
    var n = t.monaco, r = t.isInitialized, i = t.resolve;
    return {
      monaco: n,
      isInitialized: r,
      resolve: i
    };
  });
  if (!e.isInitialized) {
    if (Im({
      isInitialized: !0
    }), e.monaco)
      return e.resolve(e.monaco), $0(O0);
    if (window.monaco && window.monaco.editor)
      return RL(window.monaco), e.resolve(window.monaco), $0(O0);
    yfe(Efe, Ofe)(Afe);
  }
  return $0(O0);
}
function Efe(e) {
  return document.body.appendChild(e);
}
function $fe(e) {
  var t = document.createElement("script");
  return e && (t.src = e), t;
}
function Ofe(e) {
  var t = kf(function(r) {
    var i = r.config, o = r.reject;
    return {
      config: i,
      reject: o
    };
  }), n = $fe("".concat(t.config.paths.vs, "/loader.js"));
  return n.onload = function() {
    return e();
  }, n.onerror = t.reject, n;
}
function Afe() {
  var e = kf(function(n) {
    var r = n.config, i = n.resolve, o = n.reject;
    return {
      config: r,
      resolve: i,
      reject: o
    };
  }), t = window.require;
  t.config(e.config), t(["vs/editor/editor.main"], function(n) {
    RL(n), e.resolve(n);
  }, function(n) {
    e.reject(n);
  });
}
function RL(e) {
  kf().monaco || Im({
    monaco: e
  });
}
function Dfe() {
  return kf(function(e) {
    var t = e.monaco;
    return t;
  });
}
var O0 = new Promise(function(e, t) {
  return Im({
    resolve: e,
    reject: t
  });
}), of = {
  config: Sfe,
  init: xfe,
  __getMonacoInstance: Dfe
}, _fe = { wrapper: { display: "flex", position: "relative", textAlign: "initial" }, fullWidth: { width: "100%" }, hide: { display: "none" } }, A0 = _fe, Tfe = { container: { display: "flex", height: "100%", width: "100%", justifyContent: "center", alignItems: "center" } }, Rfe = Tfe;
function Mfe({ children: e }) {
  return U.createElement("div", { style: Rfe.container }, e);
}
var Ife = Mfe, kfe = Ife;
function Pfe({ width: e, height: t, isEditorReady: n, loading: r, _ref: i, className: o, wrapperProps: s }) {
  return U.createElement("section", { style: { ...A0.wrapper, width: e, height: t }, ...s }, !n && U.createElement(kfe, null, r), U.createElement("div", { ref: i, style: { ...A0.fullWidth, ...!n && A0.hide }, className: o }));
}
var Nfe = Pfe, ML = Sn(Nfe);
function Lfe(e) {
  Pe(e, []);
}
var nS = Lfe;
function Ffe(e, t, n = !0) {
  let r = he(!0);
  Pe(r.current || !n ? () => {
    r.current = !1;
  } : e, t);
}
var Ri = Ffe;
function cd() {
}
function uc(e, t, n, r) {
  return Bfe(e, r) || jfe(e, t, n, r);
}
function Bfe(e, t) {
  return e.editor.getModel(IL(e, t));
}
function jfe(e, t, n, r) {
  return e.editor.createModel(t, n, r ? IL(e, r) : void 0);
}
function IL(e, t) {
  return e.Uri.parse(t);
}
function zfe({ original: e, modified: t, language: n, originalLanguage: r, modifiedLanguage: i, originalModelPath: o, modifiedModelPath: s, keepCurrentOriginalModel: a = !1, keepCurrentModifiedModel: l = !1, theme: u = "light", loading: c = "Loading...", options: d = {}, height: f = "100%", width: h = "100%", className: p, wrapperProps: g = {}, beforeMount: m = cd, onMount: v = cd }) {
  let [b, x] = ht(!1), [w, C] = ht(!0), y = he(null), S = he(null), A = he(null), $ = he(v), M = he(m), _ = he(!1);
  nS(() => {
    let R = of.init();
    return R.then((I) => (S.current = I) && C(!1)).catch((I) => (I == null ? void 0 : I.type) !== "cancelation" && console.error("Monaco initialization: error:", I)), () => y.current ? E() : R.cancel();
  }), Ri(() => {
    if (y.current && S.current) {
      let R = y.current.getOriginalEditor(), I = uc(S.current, e || "", r || n || "text", o || "");
      I !== R.getModel() && R.setModel(I);
    }
  }, [o], b), Ri(() => {
    if (y.current && S.current) {
      let R = y.current.getModifiedEditor(), I = uc(S.current, t || "", i || n || "text", s || "");
      I !== R.getModel() && R.setModel(I);
    }
  }, [s], b), Ri(() => {
    let R = y.current.getModifiedEditor();
    R.getOption(S.current.editor.EditorOption.readOnly) ? R.setValue(t || "") : t !== R.getValue() && (R.executeEdits("", [{ range: R.getModel().getFullModelRange(), text: t || "", forceMoveMarkers: !0 }]), R.pushUndoStop());
  }, [t], b), Ri(() => {
    var R, I;
    (I = (R = y.current) == null ? void 0 : R.getModel()) == null || I.original.setValue(e || "");
  }, [e], b), Ri(() => {
    let { original: R, modified: I } = y.current.getModel();
    S.current.editor.setModelLanguage(R, r || n || "text"), S.current.editor.setModelLanguage(I, i || n || "text");
  }, [n, r, i], b), Ri(() => {
    var R;
    (R = S.current) == null || R.editor.setTheme(u);
  }, [u], b), Ri(() => {
    var R;
    (R = y.current) == null || R.updateOptions(d);
  }, [d], b);
  let T = Kt(() => {
    var k;
    if (!S.current)
      return;
    M.current(S.current);
    let R = uc(S.current, e || "", r || n || "text", o || ""), I = uc(S.current, t || "", i || n || "text", s || "");
    (k = y.current) == null || k.setModel({ original: R, modified: I });
  }, [n, t, i, e, r, o, s]), D = Kt(() => {
    var R;
    !_.current && A.current && (y.current = S.current.editor.createDiffEditor(A.current, { automaticLayout: !0, ...d }), T(), (R = S.current) == null || R.editor.setTheme(u), x(!0), _.current = !0);
  }, [d, u, T]);
  Pe(() => {
    b && $.current(y.current, S.current);
  }, [b]), Pe(() => {
    !w && !b && D();
  }, [w, b, D]);
  function E() {
    var I, k, P, L;
    let R = (I = y.current) == null ? void 0 : I.getModel();
    a || ((k = R == null ? void 0 : R.original) == null || k.dispose()), l || ((P = R == null ? void 0 : R.modified) == null || P.dispose()), (L = y.current) == null || L.dispose();
  }
  return U.createElement(ML, { width: h, height: f, isEditorReady: b, loading: c, _ref: A, className: p, wrapperProps: g });
}
var Hfe = zfe;
Sn(Hfe);
function Vfe() {
  let [e, t] = ht(of.__getMonacoInstance());
  return nS(() => {
    let n;
    return e || (n = of.init(), n.then((r) => {
      t(r);
    })), () => n == null ? void 0 : n.cancel();
  }), e;
}
var Wfe = Vfe;
function Ufe(e) {
  let t = he();
  return Pe(() => {
    t.current = e;
  }, [e]), t.current;
}
var Gfe = Ufe, Vh = /* @__PURE__ */ new Map();
function Kfe({ defaultValue: e, defaultLanguage: t, defaultPath: n, value: r, language: i, path: o, theme: s = "light", line: a, loading: l = "Loading...", options: u = {}, overrideServices: c = {}, saveViewState: d = !0, keepCurrentModel: f = !1, width: h = "100%", height: p = "100%", className: g, wrapperProps: m = {}, beforeMount: v = cd, onMount: b = cd, onChange: x, onValidate: w = cd }) {
  let [C, y] = ht(!1), [S, A] = ht(!0), $ = he(null), M = he(null), _ = he(null), T = he(b), D = he(v), E = he(), R = he(r), I = Gfe(o), k = he(!1), P = he(!1);
  nS(() => {
    let F = of.init();
    return F.then((B) => ($.current = B) && A(!1)).catch((B) => (B == null ? void 0 : B.type) !== "cancelation" && console.error("Monaco initialization: error:", B)), () => M.current ? N() : F.cancel();
  }), Ri(() => {
    var B, j, z, H;
    let F = uc($.current, e || r || "", t || i || "", o || n || "");
    F !== ((B = M.current) == null ? void 0 : B.getModel()) && (d && Vh.set(I, (j = M.current) == null ? void 0 : j.saveViewState()), (z = M.current) == null || z.setModel(F), d && ((H = M.current) == null || H.restoreViewState(Vh.get(o))));
  }, [o], C), Ri(() => {
    var F;
    (F = M.current) == null || F.updateOptions(u);
  }, [u], C), Ri(() => {
    !M.current || r === void 0 || (M.current.getOption($.current.editor.EditorOption.readOnly) ? M.current.setValue(r) : r !== M.current.getValue() && (P.current = !0, M.current.executeEdits("", [{ range: M.current.getModel().getFullModelRange(), text: r, forceMoveMarkers: !0 }]), M.current.pushUndoStop(), P.current = !1));
  }, [r], C), Ri(() => {
    var B, j;
    let F = (B = M.current) == null ? void 0 : B.getModel();
    F && i && ((j = $.current) == null || j.editor.setModelLanguage(F, i));
  }, [i], C), Ri(() => {
    var F;
    a !== void 0 && ((F = M.current) == null || F.revealLine(a));
  }, [a], C), Ri(() => {
    var F;
    (F = $.current) == null || F.editor.setTheme(s);
  }, [s], C);
  let L = Kt(() => {
    var F;
    if (!(!_.current || !$.current) && !k.current) {
      D.current($.current);
      let B = o || n, j = uc($.current, r || e || "", t || i || "", B || "");
      M.current = (F = $.current) == null ? void 0 : F.editor.create(_.current, { model: j, automaticLayout: !0, ...u }, c), d && M.current.restoreViewState(Vh.get(B)), $.current.editor.setTheme(s), a !== void 0 && M.current.revealLine(a), y(!0), k.current = !0;
    }
  }, [e, t, n, r, i, o, u, c, d, s, a]);
  Pe(() => {
    C && T.current(M.current, $.current);
  }, [C]), Pe(() => {
    !S && !C && L();
  }, [S, C, L]), R.current = r, Pe(() => {
    var F, B;
    C && x && ((F = E.current) == null || F.dispose(), E.current = (B = M.current) == null ? void 0 : B.onDidChangeModelContent((j) => {
      P.current || x(M.current.getValue(), j);
    }));
  }, [C, x]), Pe(() => {
    if (C) {
      let F = $.current.editor.onDidChangeMarkers((B) => {
        var z;
        let j = (z = M.current.getModel()) == null ? void 0 : z.uri;
        if (j && B.find((H) => H.path === j.path)) {
          let H = $.current.editor.getModelMarkers({ resource: j });
          w == null || w(H);
        }
      });
      return () => {
        F == null || F.dispose();
      };
    }
    return () => {
    };
  }, [C, w]);
  function N() {
    var F, B;
    (F = E.current) == null || F.dispose(), f ? d && Vh.set(o, M.current.saveViewState()) : (B = M.current.getModel()) == null || B.dispose(), M.current.dispose();
  }
  return U.createElement(ML, { width: h, height: p, isEditorReady: C, loading: l, _ref: _, className: g, wrapperProps: m });
}
var Xfe = Kfe, Yfe = Sn(Xfe);
function qfe(e) {
  const t = Object.prototype.toString.call(e).slice(8, -1);
  return t === "Object" && typeof e[Symbol.iterator] == "function" ? "Iterable" : t === "Custom" && e.constructor !== Object && e instanceof Object ? "Object" : t;
}
function kL(e) {
  let {
    styling: t,
    arrowStyle: n = "single",
    expanded: r,
    nodeType: i,
    onClick: o
  } = e;
  return /* @__PURE__ */ U.createElement("div", we({}, t("arrowContainer", n), {
    onClick: o
  }), /* @__PURE__ */ U.createElement("div", t(["arrow", "arrowSign"], i, r, n), "", n === "double" && /* @__PURE__ */ U.createElement("div", t(["arrowSign", "arrowSignInner"]), "")));
}
function Qfe(e, t) {
  return e === "Object" ? Object.keys(t).length : e === "Array" ? t.length : 1 / 0;
}
function Zfe(e) {
  return typeof e.set == "function";
}
function Jfe(e, t, n) {
  let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1 / 0, o;
  if (e === "Object") {
    let s = Object.getOwnPropertyNames(t);
    n && s.sort(n === !0 ? void 0 : n), s = s.slice(r, i + 1), o = {
      entries: s.map((a) => ({
        key: a,
        value: t[a]
      }))
    };
  } else if (e === "Array")
    o = {
      entries: t.slice(r, i + 1).map((s, a) => ({
        key: a + r,
        value: s
      }))
    };
  else {
    let s = 0;
    const a = [];
    let l = !0;
    const u = Zfe(t);
    for (const c of t) {
      if (s > i) {
        l = !1;
        break;
      }
      r <= s && (u && Array.isArray(c) ? typeof c[0] == "string" || typeof c[0] == "number" ? a.push({
        key: c[0],
        value: c[1]
      }) : a.push({
        key: `[entry ${s}]`,
        value: {
          "[key]": c[0],
          "[value]": c[1]
        }
      }) : a.push({
        key: s,
        value: c
      })), s++;
    }
    o = {
      hasMore: !l,
      entries: a
    };
  }
  return o;
}
function D0(e, t, n) {
  const r = [];
  for (; t - e > n * n; )
    n = n * n;
  for (let i = e; i <= t; i += n)
    r.push({
      from: i,
      to: Math.min(t, i + n - 1)
    });
  return r;
}
function ehe(e, t, n, r) {
  let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1 / 0;
  const s = Jfe.bind(null, e, t, n);
  if (!r)
    return s().entries;
  const a = o < 1 / 0, l = Math.min(o - i, Qfe(e, t));
  if (e !== "Iterable") {
    if (l <= r || r < 7)
      return s(i, o).entries;
  } else if (l <= r && !a)
    return s(i, o).entries;
  let u;
  if (e === "Iterable") {
    const {
      hasMore: c,
      entries: d
    } = s(i, i + r - 1);
    u = c ? [...d, ...D0(i + r, i + 2 * r - 1, r)] : d;
  } else
    u = a ? D0(i, o, r) : [...s(0, r - 5).entries, ...D0(r - 4, l - 5, r), ...s(l - 4, l - 1).entries];
  return u;
}
function the(e) {
  const {
    styling: t,
    from: n,
    to: r,
    renderChildNodes: i,
    nodeType: o
  } = e, [s, a] = ht(!1), l = Kt(() => {
    a(!s);
  }, [s]);
  return s ? /* @__PURE__ */ U.createElement("div", t("itemRange", s), i(e, n, r)) : /* @__PURE__ */ U.createElement("div", we({}, t("itemRange", s), {
    onClick: l
  }), /* @__PURE__ */ U.createElement(kL, {
    nodeType: o,
    styling: t,
    expanded: !1,
    onClick: l,
    arrowStyle: "double"
  }), `${n} ... ${r}`);
}
function nhe(e) {
  return e.to !== void 0;
}
function PL(e, t, n) {
  const {
    nodeType: r,
    data: i,
    collectionLimit: o,
    circularCache: s,
    keyPath: a,
    postprocessValue: l,
    sortObjectKeys: u
  } = e, c = [];
  return ehe(r, i, u, o, t, n).forEach((d) => {
    if (nhe(d))
      c.push(/* @__PURE__ */ U.createElement(the, we({}, e, {
        key: `ItemRange--${d.from}-${d.to}`,
        from: d.from,
        to: d.to,
        renderChildNodes: PL
      })));
    else {
      const {
        key: f,
        value: h
      } = d, p = s.indexOf(h) !== -1;
      c.push(/* @__PURE__ */ U.createElement(NL, we({}, e, {
        postprocessValue: l,
        collectionLimit: o,
        key: `Node--${f}`,
        keyPath: [f, ...a],
        value: l(h),
        circularCache: [...s, h],
        isCircular: p,
        hideRoot: !1
      })));
    }
  }), c;
}
function rS(e) {
  const {
    circularCache: t = [],
    collectionLimit: n,
    createItemString: r,
    data: i,
    expandable: o,
    getItemString: s,
    hideRoot: a,
    isCircular: l,
    keyPath: u,
    labelRenderer: c,
    level: d = 0,
    nodeType: f,
    nodeTypeIndicator: h,
    shouldExpandNodeInitially: p,
    styling: g
  } = e, [m, v] = ht(
    // calculate individual node expansion if necessary
    l ? !1 : p(u, i, d)
  ), b = Kt(() => {
    o && v(!m);
  }, [o, m]), x = m || a && d === 0 ? PL({
    ...e,
    circularCache: t,
    level: d + 1
  }) : null, w = /* @__PURE__ */ U.createElement("span", g("nestedNodeItemType", m), h), C = s(f, i, w, r(i, n), u), y = [u, f, m, o];
  return a ? /* @__PURE__ */ U.createElement("li", g("rootNode", ...y), /* @__PURE__ */ U.createElement("ul", g("rootNodeChildren", ...y), x)) : /* @__PURE__ */ U.createElement("li", g("nestedNode", ...y), o && /* @__PURE__ */ U.createElement(kL, {
    styling: g,
    nodeType: f,
    expanded: m,
    onClick: b
  }), /* @__PURE__ */ U.createElement("label", we({}, g(["label", "nestedNodeLabel"], ...y), {
    onClick: b
  }), c(...y)), /* @__PURE__ */ U.createElement("span", we({}, g("nestedNodeItemString", ...y), {
    onClick: b
  }), C), /* @__PURE__ */ U.createElement("ul", g("nestedNodeChildren", ...y), x));
}
function rhe(e) {
  const t = Object.getOwnPropertyNames(e).length;
  return `${t} ${t !== 1 ? "keys" : "key"}`;
}
function ihe(e) {
  let {
    data: t,
    ...n
  } = e;
  return /* @__PURE__ */ U.createElement(rS, we({}, n, {
    data: t,
    nodeType: "Object",
    nodeTypeIndicator: n.nodeType === "Error" ? "Error()" : "{}",
    createItemString: rhe,
    expandable: Object.getOwnPropertyNames(t).length > 0
  }));
}
function ohe(e) {
  return `${e.length} ${e.length !== 1 ? "items" : "item"}`;
}
function she(e) {
  let {
    data: t,
    ...n
  } = e;
  return /* @__PURE__ */ U.createElement(rS, we({}, n, {
    data: t,
    nodeType: "Array",
    nodeTypeIndicator: "[]",
    createItemString: ohe,
    expandable: t.length > 0
  }));
}
function ahe(e, t) {
  let n = 0, r = !1;
  if (Number.isSafeInteger(e.size))
    n = e.size;
  else
    for (const i of e) {
      if (t && n + 1 > t) {
        r = !0;
        break;
      }
      n += 1;
    }
  return `${r ? ">" : ""}${n} ${n !== 1 ? "entries" : "entry"}`;
}
function lhe(e) {
  return /* @__PURE__ */ U.createElement(rS, we({}, e, {
    nodeType: "Iterable",
    nodeTypeIndicator: "()",
    createItemString: ahe,
    expandable: !0
  }));
}
function ss(e) {
  let {
    nodeType: t,
    styling: n,
    labelRenderer: r,
    keyPath: i,
    valueRenderer: o,
    value: s,
    valueGetter: a = (l) => l
  } = e;
  return /* @__PURE__ */ U.createElement("li", n("value", t, i), /* @__PURE__ */ U.createElement("label", n(["label", "valueLabel"], t, i), r(i, t, !1, !1)), /* @__PURE__ */ U.createElement("span", n("valueText", t, i), o(a(s), s, ...i)));
}
function NL(e) {
  let {
    getItemString: t,
    keyPath: n,
    labelRenderer: r,
    styling: i,
    value: o,
    valueRenderer: s,
    isCustomNode: a,
    ...l
  } = e;
  const u = a(o) ? "Custom" : qfe(o), c = {
    getItemString: t,
    key: n[0],
    keyPath: n,
    labelRenderer: r,
    nodeType: u,
    styling: i,
    value: o,
    valueRenderer: s
  }, d = {
    ...l,
    ...c,
    data: o,
    isCustomNode: a
  };
  switch (u) {
    case "Object":
    case "Error":
    case "WeakMap":
    case "WeakSet":
      return /* @__PURE__ */ U.createElement(ihe, d);
    case "Array":
      return /* @__PURE__ */ U.createElement(she, d);
    case "Iterable":
    case "Map":
    case "Set":
      return /* @__PURE__ */ U.createElement(lhe, d);
    case "String":
      return /* @__PURE__ */ U.createElement(ss, we({}, c, {
        valueGetter: (f) => `"${f}"`
      }));
    case "Number":
      return /* @__PURE__ */ U.createElement(ss, c);
    case "Boolean":
      return /* @__PURE__ */ U.createElement(ss, we({}, c, {
        valueGetter: (f) => f ? "true" : "false"
      }));
    case "Date":
      return /* @__PURE__ */ U.createElement(ss, we({}, c, {
        valueGetter: (f) => f.toISOString()
      }));
    case "Null":
      return /* @__PURE__ */ U.createElement(ss, we({}, c, {
        valueGetter: () => "null"
      }));
    case "Undefined":
      return /* @__PURE__ */ U.createElement(ss, we({}, c, {
        valueGetter: () => "undefined"
      }));
    case "Function":
    case "Symbol":
      return /* @__PURE__ */ U.createElement(ss, we({}, c, {
        valueGetter: (f) => f.toString()
      }));
    case "Custom":
      return /* @__PURE__ */ U.createElement(ss, c);
    default:
      return /* @__PURE__ */ U.createElement(ss, we({}, c, {
        valueGetter: () => `<${u}>`
      }));
  }
}
const che = {
  scheme: "threezerotwofour",
  author: "jan t. sott (http://github.com/idleberg)",
  base00: "#090300",
  base01: "#3a3432",
  base02: "#4a4543",
  base03: "#5c5855",
  base04: "#807d7c",
  base05: "#a5a2a2",
  base06: "#d6d5d4",
  base07: "#f7f7f7",
  base08: "#db2d20",
  base09: "#e8bbd0",
  base0A: "#fded02",
  base0B: "#01a252",
  base0C: "#b5e4f4",
  base0D: "#01a0e4",
  base0E: "#a16a94",
  base0F: "#cdab53"
}, uhe = {
  scheme: "apathy",
  author: "jannik siebert (https://github.com/janniks)",
  base00: "#031A16",
  base01: "#0B342D",
  base02: "#184E45",
  base03: "#2B685E",
  base04: "#5F9C92",
  base05: "#81B5AC",
  base06: "#A7CEC8",
  base07: "#D2E7E4",
  base08: "#3E9688",
  base09: "#3E7996",
  base0A: "#3E4C96",
  base0B: "#883E96",
  base0C: "#963E4C",
  base0D: "#96883E",
  base0E: "#4C963E",
  base0F: "#3E965B"
}, dhe = {
  scheme: "ashes",
  author: "jannik siebert (https://github.com/janniks)",
  base00: "#1C2023",
  base01: "#393F45",
  base02: "#565E65",
  base03: "#747C84",
  base04: "#ADB3BA",
  base05: "#C7CCD1",
  base06: "#DFE2E5",
  base07: "#F3F4F5",
  base08: "#C7AE95",
  base09: "#C7C795",
  base0A: "#AEC795",
  base0B: "#95C7AE",
  base0C: "#95AEC7",
  base0D: "#AE95C7",
  base0E: "#C795AE",
  base0F: "#C79595"
}, fhe = {
  scheme: "atelier dune",
  author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/dune)",
  base00: "#20201d",
  base01: "#292824",
  base02: "#6e6b5e",
  base03: "#7d7a68",
  base04: "#999580",
  base05: "#a6a28c",
  base06: "#e8e4cf",
  base07: "#fefbec",
  base08: "#d73737",
  base09: "#b65611",
  base0A: "#cfb017",
  base0B: "#60ac39",
  base0C: "#1fad83",
  base0D: "#6684e1",
  base0E: "#b854d4",
  base0F: "#d43552"
}, hhe = {
  scheme: "atelier forest",
  author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/forest)",
  base00: "#1b1918",
  base01: "#2c2421",
  base02: "#68615e",
  base03: "#766e6b",
  base04: "#9c9491",
  base05: "#a8a19f",
  base06: "#e6e2e0",
  base07: "#f1efee",
  base08: "#f22c40",
  base09: "#df5320",
  base0A: "#d5911a",
  base0B: "#5ab738",
  base0C: "#00ad9c",
  base0D: "#407ee7",
  base0E: "#6666ea",
  base0F: "#c33ff3"
}, phe = {
  scheme: "atelier heath",
  author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/heath)",
  base00: "#1b181b",
  base01: "#292329",
  base02: "#695d69",
  base03: "#776977",
  base04: "#9e8f9e",
  base05: "#ab9bab",
  base06: "#d8cad8",
  base07: "#f7f3f7",
  base08: "#ca402b",
  base09: "#a65926",
  base0A: "#bb8a35",
  base0B: "#379a37",
  base0C: "#159393",
  base0D: "#516aec",
  base0E: "#7b59c0",
  base0F: "#cc33cc"
}, ghe = {
  scheme: "atelier lakeside",
  author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/lakeside/)",
  base00: "#161b1d",
  base01: "#1f292e",
  base02: "#516d7b",
  base03: "#5a7b8c",
  base04: "#7195a8",
  base05: "#7ea2b4",
  base06: "#c1e4f6",
  base07: "#ebf8ff",
  base08: "#d22d72",
  base09: "#935c25",
  base0A: "#8a8a0f",
  base0B: "#568c3b",
  base0C: "#2d8f6f",
  base0D: "#257fad",
  base0E: "#5d5db1",
  base0F: "#b72dd2"
}, mhe = {
  scheme: "atelier seaside",
  author: "bram de haan (http://atelierbram.github.io/syntax-highlighting/atelier-schemes/seaside/)",
  base00: "#131513",
  base01: "#242924",
  base02: "#5e6e5e",
  base03: "#687d68",
  base04: "#809980",
  base05: "#8ca68c",
  base06: "#cfe8cf",
  base07: "#f0fff0",
  base08: "#e6193c",
  base09: "#87711d",
  base0A: "#c3c322",
  base0B: "#29a329",
  base0C: "#1999b3",
  base0D: "#3d62f5",
  base0E: "#ad2bee",
  base0F: "#e619c3"
}, vhe = {
  scheme: "bespin",
  author: "jan t. sott",
  base00: "#28211c",
  base01: "#36312e",
  base02: "#5e5d5c",
  base03: "#666666",
  base04: "#797977",
  base05: "#8a8986",
  base06: "#9d9b97",
  base07: "#baae9e",
  base08: "#cf6a4c",
  base09: "#cf7d34",
  base0A: "#f9ee98",
  base0B: "#54be0d",
  base0C: "#afc4db",
  base0D: "#5ea6ea",
  base0E: "#9b859d",
  base0F: "#937121"
}, bhe = {
  scheme: "brewer",
  author: "timothe poisot (http://github.com/tpoisot)",
  base00: "#0c0d0e",
  base01: "#2e2f30",
  base02: "#515253",
  base03: "#737475",
  base04: "#959697",
  base05: "#b7b8b9",
  base06: "#dadbdc",
  base07: "#fcfdfe",
  base08: "#e31a1c",
  base09: "#e6550d",
  base0A: "#dca060",
  base0B: "#31a354",
  base0C: "#80b1d3",
  base0D: "#3182bd",
  base0E: "#756bb1",
  base0F: "#b15928"
}, yhe = {
  scheme: "bright",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#000000",
  base01: "#303030",
  base02: "#505050",
  base03: "#b0b0b0",
  base04: "#d0d0d0",
  base05: "#e0e0e0",
  base06: "#f5f5f5",
  base07: "#ffffff",
  base08: "#fb0120",
  base09: "#fc6d24",
  base0A: "#fda331",
  base0B: "#a1c659",
  base0C: "#76c7b7",
  base0D: "#6fb3d2",
  base0E: "#d381c3",
  base0F: "#be643c"
}, whe = {
  scheme: "chalk",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#151515",
  base01: "#202020",
  base02: "#303030",
  base03: "#505050",
  base04: "#b0b0b0",
  base05: "#d0d0d0",
  base06: "#e0e0e0",
  base07: "#f5f5f5",
  base08: "#fb9fb1",
  base09: "#eda987",
  base0A: "#ddb26f",
  base0B: "#acc267",
  base0C: "#12cfc0",
  base0D: "#6fc2ef",
  base0E: "#e1a3ee",
  base0F: "#deaf8f"
}, Che = {
  scheme: "codeschool",
  author: "brettof86",
  base00: "#232c31",
  base01: "#1c3657",
  base02: "#2a343a",
  base03: "#3f4944",
  base04: "#84898c",
  base05: "#9ea7a6",
  base06: "#a7cfa3",
  base07: "#b5d8f6",
  base08: "#2a5491",
  base09: "#43820d",
  base0A: "#a03b1e",
  base0B: "#237986",
  base0C: "#b02f30",
  base0D: "#484d79",
  base0E: "#c59820",
  base0F: "#c98344"
}, She = {
  scheme: "colors",
  author: "mrmrs (http://clrs.cc)",
  base00: "#111111",
  base01: "#333333",
  base02: "#555555",
  base03: "#777777",
  base04: "#999999",
  base05: "#bbbbbb",
  base06: "#dddddd",
  base07: "#ffffff",
  base08: "#ff4136",
  base09: "#ff851b",
  base0A: "#ffdc00",
  base0B: "#2ecc40",
  base0C: "#7fdbff",
  base0D: "#0074d9",
  base0E: "#b10dc9",
  base0F: "#85144b"
}, LL = {
  scheme: "default",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#181818",
  base01: "#282828",
  base02: "#383838",
  base03: "#585858",
  base04: "#b8b8b8",
  base05: "#d8d8d8",
  base06: "#e8e8e8",
  base07: "#f8f8f8",
  base08: "#ab4642",
  base09: "#dc9656",
  base0A: "#f7ca88",
  base0B: "#a1b56c",
  base0C: "#86c1b9",
  base0D: "#7cafc2",
  base0E: "#ba8baf",
  base0F: "#a16946"
}, xhe = {
  scheme: "eighties",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#2d2d2d",
  base01: "#393939",
  base02: "#515151",
  base03: "#747369",
  base04: "#a09f93",
  base05: "#d3d0c8",
  base06: "#e8e6df",
  base07: "#f2f0ec",
  base08: "#f2777a",
  base09: "#f99157",
  base0A: "#ffcc66",
  base0B: "#99cc99",
  base0C: "#66cccc",
  base0D: "#6699cc",
  base0E: "#cc99cc",
  base0F: "#d27b53"
}, Ehe = {
  scheme: "embers",
  author: "jannik siebert (https://github.com/janniks)",
  base00: "#16130F",
  base01: "#2C2620",
  base02: "#433B32",
  base03: "#5A5047",
  base04: "#8A8075",
  base05: "#A39A90",
  base06: "#BEB6AE",
  base07: "#DBD6D1",
  base08: "#826D57",
  base09: "#828257",
  base0A: "#6D8257",
  base0B: "#57826D",
  base0C: "#576D82",
  base0D: "#6D5782",
  base0E: "#82576D",
  base0F: "#825757"
}, $he = {
  scheme: "flat",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#2C3E50",
  base01: "#34495E",
  base02: "#7F8C8D",
  base03: "#95A5A6",
  base04: "#BDC3C7",
  base05: "#e0e0e0",
  base06: "#f5f5f5",
  base07: "#ECF0F1",
  base08: "#E74C3C",
  base09: "#E67E22",
  base0A: "#F1C40F",
  base0B: "#2ECC71",
  base0C: "#1ABC9C",
  base0D: "#3498DB",
  base0E: "#9B59B6",
  base0F: "#be643c"
}, Ohe = {
  scheme: "google",
  author: "seth wright (http://sethawright.com)",
  base00: "#1d1f21",
  base01: "#282a2e",
  base02: "#373b41",
  base03: "#969896",
  base04: "#b4b7b4",
  base05: "#c5c8c6",
  base06: "#e0e0e0",
  base07: "#ffffff",
  base08: "#CC342B",
  base09: "#F96A38",
  base0A: "#FBA922",
  base0B: "#198844",
  base0C: "#3971ED",
  base0D: "#3971ED",
  base0E: "#A36AC7",
  base0F: "#3971ED"
}, Ahe = {
  scheme: "grayscale",
  author: "alexandre gavioli (https://github.com/alexx2/)",
  base00: "#101010",
  base01: "#252525",
  base02: "#464646",
  base03: "#525252",
  base04: "#ababab",
  base05: "#b9b9b9",
  base06: "#e3e3e3",
  base07: "#f7f7f7",
  base08: "#7c7c7c",
  base09: "#999999",
  base0A: "#a0a0a0",
  base0B: "#8e8e8e",
  base0C: "#868686",
  base0D: "#686868",
  base0E: "#747474",
  base0F: "#5e5e5e"
}, Dhe = {
  scheme: "green screen",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#001100",
  base01: "#003300",
  base02: "#005500",
  base03: "#007700",
  base04: "#009900",
  base05: "#00bb00",
  base06: "#00dd00",
  base07: "#00ff00",
  base08: "#007700",
  base09: "#009900",
  base0A: "#007700",
  base0B: "#00bb00",
  base0C: "#005500",
  base0D: "#009900",
  base0E: "#00bb00",
  base0F: "#005500"
}, _he = {
  scheme: "harmonic16",
  author: "jannik siebert (https://github.com/janniks)",
  base00: "#0b1c2c",
  base01: "#223b54",
  base02: "#405c79",
  base03: "#627e99",
  base04: "#aabcce",
  base05: "#cbd6e2",
  base06: "#e5ebf1",
  base07: "#f7f9fb",
  base08: "#bf8b56",
  base09: "#bfbf56",
  base0A: "#8bbf56",
  base0B: "#56bf8b",
  base0C: "#568bbf",
  base0D: "#8b56bf",
  base0E: "#bf568b",
  base0F: "#bf5656"
}, The = {
  scheme: "hopscotch",
  author: "jan t. sott",
  base00: "#322931",
  base01: "#433b42",
  base02: "#5c545b",
  base03: "#797379",
  base04: "#989498",
  base05: "#b9b5b8",
  base06: "#d5d3d5",
  base07: "#ffffff",
  base08: "#dd464c",
  base09: "#fd8b19",
  base0A: "#fdcc59",
  base0B: "#8fc13e",
  base0C: "#149b93",
  base0D: "#1290bf",
  base0E: "#c85e7c",
  base0F: "#b33508"
}, Rhe = {
  scheme: "isotope",
  author: "jan t. sott",
  base00: "#000000",
  base01: "#404040",
  base02: "#606060",
  base03: "#808080",
  base04: "#c0c0c0",
  base05: "#d0d0d0",
  base06: "#e0e0e0",
  base07: "#ffffff",
  base08: "#ff0000",
  base09: "#ff9900",
  base0A: "#ff0099",
  base0B: "#33ff00",
  base0C: "#00ffff",
  base0D: "#0066ff",
  base0E: "#cc00ff",
  base0F: "#3300ff"
}, Mhe = {
  scheme: "marrakesh",
  author: "alexandre gavioli (http://github.com/alexx2/)",
  base00: "#201602",
  base01: "#302e00",
  base02: "#5f5b17",
  base03: "#6c6823",
  base04: "#86813b",
  base05: "#948e48",
  base06: "#ccc37a",
  base07: "#faf0a5",
  base08: "#c35359",
  base09: "#b36144",
  base0A: "#a88339",
  base0B: "#18974e",
  base0C: "#75a738",
  base0D: "#477ca1",
  base0E: "#8868b3",
  base0F: "#b3588e"
}, Ihe = {
  scheme: "mocha",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#3B3228",
  base01: "#534636",
  base02: "#645240",
  base03: "#7e705a",
  base04: "#b8afad",
  base05: "#d0c8c6",
  base06: "#e9e1dd",
  base07: "#f5eeeb",
  base08: "#cb6077",
  base09: "#d28b71",
  base0A: "#f4bc87",
  base0B: "#beb55b",
  base0C: "#7bbda4",
  base0D: "#8ab3b5",
  base0E: "#a89bb9",
  base0F: "#bb9584"
}, khe = {
  scheme: "monokai",
  author: "wimer hazenberg (http://www.monokai.nl)",
  base00: "#272822",
  base01: "#383830",
  base02: "#49483e",
  base03: "#75715e",
  base04: "#a59f85",
  base05: "#f8f8f2",
  base06: "#f5f4f1",
  base07: "#f9f8f5",
  base08: "#f92672",
  base09: "#fd971f",
  base0A: "#f4bf75",
  base0B: "#a6e22e",
  base0C: "#a1efe4",
  base0D: "#66d9ef",
  base0E: "#ae81ff",
  base0F: "#cc6633"
}, Phe = {
  scheme: "ocean",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#2b303b",
  base01: "#343d46",
  base02: "#4f5b66",
  base03: "#65737e",
  base04: "#a7adba",
  base05: "#c0c5ce",
  base06: "#dfe1e8",
  base07: "#eff1f5",
  base08: "#bf616a",
  base09: "#d08770",
  base0A: "#ebcb8b",
  base0B: "#a3be8c",
  base0C: "#96b5b4",
  base0D: "#8fa1b3",
  base0E: "#b48ead",
  base0F: "#ab7967"
}, Nhe = {
  scheme: "paraiso",
  author: "jan t. sott",
  base00: "#2f1e2e",
  base01: "#41323f",
  base02: "#4f424c",
  base03: "#776e71",
  base04: "#8d8687",
  base05: "#a39e9b",
  base06: "#b9b6b0",
  base07: "#e7e9db",
  base08: "#ef6155",
  base09: "#f99b15",
  base0A: "#fec418",
  base0B: "#48b685",
  base0C: "#5bc4bf",
  base0D: "#06b6ef",
  base0E: "#815ba4",
  base0F: "#e96ba8"
}, Lhe = {
  scheme: "pop",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#000000",
  base01: "#202020",
  base02: "#303030",
  base03: "#505050",
  base04: "#b0b0b0",
  base05: "#d0d0d0",
  base06: "#e0e0e0",
  base07: "#ffffff",
  base08: "#eb008a",
  base09: "#f29333",
  base0A: "#f8ca12",
  base0B: "#37b349",
  base0C: "#00aabb",
  base0D: "#0e5a94",
  base0E: "#b31e8d",
  base0F: "#7a2d00"
}, Fhe = {
  scheme: "railscasts",
  author: "ryan bates (http://railscasts.com)",
  base00: "#2b2b2b",
  base01: "#272935",
  base02: "#3a4055",
  base03: "#5a647e",
  base04: "#d4cfc9",
  base05: "#e6e1dc",
  base06: "#f4f1ed",
  base07: "#f9f7f3",
  base08: "#da4939",
  base09: "#cc7833",
  base0A: "#ffc66d",
  base0B: "#a5c261",
  base0C: "#519f50",
  base0D: "#6d9cbe",
  base0E: "#b6b3eb",
  base0F: "#bc9458"
}, Bhe = {
  scheme: "shapeshifter",
  author: "tyler benziger (http://tybenz.com)",
  base00: "#000000",
  base01: "#040404",
  base02: "#102015",
  base03: "#343434",
  base04: "#555555",
  base05: "#ababab",
  base06: "#e0e0e0",
  base07: "#f9f9f9",
  base08: "#e92f2f",
  base09: "#e09448",
  base0A: "#dddd13",
  base0B: "#0ed839",
  base0C: "#23edda",
  base0D: "#3b48e3",
  base0E: "#f996e2",
  base0F: "#69542d"
}, jhe = {
  scheme: "solarized",
  author: "ethan schoonover (http://ethanschoonover.com/solarized)",
  base00: "#002b36",
  base01: "#073642",
  base02: "#586e75",
  base03: "#657b83",
  base04: "#839496",
  base05: "#93a1a1",
  base06: "#eee8d5",
  base07: "#fdf6e3",
  base08: "#dc322f",
  base09: "#cb4b16",
  base0A: "#b58900",
  base0B: "#859900",
  base0C: "#2aa198",
  base0D: "#268bd2",
  base0E: "#6c71c4",
  base0F: "#d33682"
}, zhe = {
  scheme: "summerfruit",
  author: "christopher corley (http://cscorley.github.io/)",
  base00: "#151515",
  base01: "#202020",
  base02: "#303030",
  base03: "#505050",
  base04: "#B0B0B0",
  base05: "#D0D0D0",
  base06: "#E0E0E0",
  base07: "#FFFFFF",
  base08: "#FF0086",
  base09: "#FD8900",
  base0A: "#ABA800",
  base0B: "#00C918",
  base0C: "#1faaaa",
  base0D: "#3777E6",
  base0E: "#AD00A1",
  base0F: "#cc6633"
}, Hhe = {
  scheme: "tomorrow",
  author: "chris kempson (http://chriskempson.com)",
  base00: "#1d1f21",
  base01: "#282a2e",
  base02: "#373b41",
  base03: "#969896",
  base04: "#b4b7b4",
  base05: "#c5c8c6",
  base06: "#e0e0e0",
  base07: "#ffffff",
  base08: "#cc6666",
  base09: "#de935f",
  base0A: "#f0c674",
  base0B: "#b5bd68",
  base0C: "#8abeb7",
  base0D: "#81a2be",
  base0E: "#b294bb",
  base0F: "#a3685a"
}, Vhe = {
  scheme: "london tube",
  author: "jan t. sott",
  base00: "#231f20",
  base01: "#1c3f95",
  base02: "#5a5758",
  base03: "#737171",
  base04: "#959ca1",
  base05: "#d9d8d8",
  base06: "#e7e7e8",
  base07: "#ffffff",
  base08: "#ee2e24",
  base09: "#f386a1",
  base0A: "#ffd204",
  base0B: "#00853e",
  base0C: "#85cebc",
  base0D: "#009ddc",
  base0E: "#98005d",
  base0F: "#b06110"
}, Whe = {
  scheme: "twilight",
  author: "david hart (http://hart-dev.com)",
  base00: "#1e1e1e",
  base01: "#323537",
  base02: "#464b50",
  base03: "#5f5a60",
  base04: "#838184",
  base05: "#a7a7a7",
  base06: "#c3c3c3",
  base07: "#ffffff",
  base08: "#cf6a4c",
  base09: "#cda869",
  base0A: "#f9ee98",
  base0B: "#8f9d6a",
  base0C: "#afc4db",
  base0D: "#7587a6",
  base0E: "#9b859d",
  base0F: "#9b703f"
}, Uhe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  apathy: uhe,
  ashes: dhe,
  atelierDune: fhe,
  atelierForest: hhe,
  atelierHeath: phe,
  atelierLakeside: ghe,
  atelierSeaside: mhe,
  bespin: vhe,
  brewer: bhe,
  bright: yhe,
  chalk: whe,
  codeschool: Che,
  colors: She,
  default: LL,
  eighties: xhe,
  embers: Ehe,
  flat: $he,
  google: Ohe,
  grayscale: Ahe,
  greenscreen: Dhe,
  harmonic: _he,
  hopscotch: The,
  isotope: Rhe,
  marrakesh: Mhe,
  mocha: Ihe,
  monokai: khe,
  ocean: Phe,
  paraiso: Nhe,
  pop: Lhe,
  railscasts: Fhe,
  shapeshifter: Bhe,
  solarized: jhe,
  summerfruit: zhe,
  threezerotwofour: che,
  tomorrow: Hhe,
  tube: Vhe,
  twilight: Whe
}, Symbol.toStringTag, { value: "Module" }));
var FL = { exports: {} }, Ghe = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, BL = { exports: {} }, Khe = function(t) {
  return !t || typeof t == "string" ? !1 : t instanceof Array || Array.isArray(t) || t.length >= 0 && (t.splice instanceof Function || Object.getOwnPropertyDescriptor(t, t.length - 1) && t.constructor.name !== "String");
}, Xhe = Khe, Yhe = Array.prototype.concat, qhe = Array.prototype.slice, OA = BL.exports = function(t) {
  for (var n = [], r = 0, i = t.length; r < i; r++) {
    var o = t[r];
    Xhe(o) ? n = Yhe.call(n, qhe.call(o)) : n.push(o);
  }
  return n;
};
OA.wrap = function(e) {
  return function() {
    return e(OA(arguments));
  };
};
var Qhe = BL.exports, ud = Ghe, Pf = Qhe, jL = Object.hasOwnProperty, zL = /* @__PURE__ */ Object.create(null);
for (var _0 in ud)
  jL.call(ud, _0) && (zL[ud[_0]] = _0);
var Ni = FL.exports = {
  to: {},
  get: {}
};
Ni.get = function(e) {
  var t = e.substring(0, 3).toLowerCase(), n, r;
  switch (t) {
    case "hsl":
      n = Ni.get.hsl(e), r = "hsl";
      break;
    case "hwb":
      n = Ni.get.hwb(e), r = "hwb";
      break;
    default:
      n = Ni.get.rgb(e), r = "rgb";
      break;
  }
  return n ? { model: r, value: n } : null;
};
Ni.get.rgb = function(e) {
  if (!e)
    return null;
  var t = /^#([a-f0-9]{3,4})$/i, n = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i, r = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/, i = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/, o = /^(\w+)$/, s = [0, 0, 0, 1], a, l, u;
  if (a = e.match(n)) {
    for (u = a[2], a = a[1], l = 0; l < 3; l++) {
      var c = l * 2;
      s[l] = parseInt(a.slice(c, c + 2), 16);
    }
    u && (s[3] = parseInt(u, 16) / 255);
  } else if (a = e.match(t)) {
    for (a = a[1], u = a[3], l = 0; l < 3; l++)
      s[l] = parseInt(a[l] + a[l], 16);
    u && (s[3] = parseInt(u + u, 16) / 255);
  } else if (a = e.match(r)) {
    for (l = 0; l < 3; l++)
      s[l] = parseInt(a[l + 1], 0);
    a[4] && (a[5] ? s[3] = parseFloat(a[4]) * 0.01 : s[3] = parseFloat(a[4]));
  } else if (a = e.match(i)) {
    for (l = 0; l < 3; l++)
      s[l] = Math.round(parseFloat(a[l + 1]) * 2.55);
    a[4] && (a[5] ? s[3] = parseFloat(a[4]) * 0.01 : s[3] = parseFloat(a[4]));
  } else
    return (a = e.match(o)) ? a[1] === "transparent" ? [0, 0, 0, 0] : jL.call(ud, a[1]) ? (s = ud[a[1]], s[3] = 1, s) : null : null;
  for (l = 0; l < 3; l++)
    s[l] = aa(s[l], 0, 255);
  return s[3] = aa(s[3], 0, 1), s;
};
Ni.get.hsl = function(e) {
  if (!e)
    return null;
  var t = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/, n = e.match(t);
  if (n) {
    var r = parseFloat(n[4]), i = (parseFloat(n[1]) % 360 + 360) % 360, o = aa(parseFloat(n[2]), 0, 100), s = aa(parseFloat(n[3]), 0, 100), a = aa(isNaN(r) ? 1 : r, 0, 1);
    return [i, o, s, a];
  }
  return null;
};
Ni.get.hwb = function(e) {
  if (!e)
    return null;
  var t = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/, n = e.match(t);
  if (n) {
    var r = parseFloat(n[4]), i = (parseFloat(n[1]) % 360 + 360) % 360, o = aa(parseFloat(n[2]), 0, 100), s = aa(parseFloat(n[3]), 0, 100), a = aa(isNaN(r) ? 1 : r, 0, 1);
    return [i, o, s, a];
  }
  return null;
};
Ni.to.hex = function() {
  var e = Pf(arguments);
  return "#" + Wh(e[0]) + Wh(e[1]) + Wh(e[2]) + (e[3] < 1 ? Wh(Math.round(e[3] * 255)) : "");
};
Ni.to.rgb = function() {
  var e = Pf(arguments);
  return e.length < 4 || e[3] === 1 ? "rgb(" + Math.round(e[0]) + ", " + Math.round(e[1]) + ", " + Math.round(e[2]) + ")" : "rgba(" + Math.round(e[0]) + ", " + Math.round(e[1]) + ", " + Math.round(e[2]) + ", " + e[3] + ")";
};
Ni.to.rgb.percent = function() {
  var e = Pf(arguments), t = Math.round(e[0] / 255 * 100), n = Math.round(e[1] / 255 * 100), r = Math.round(e[2] / 255 * 100);
  return e.length < 4 || e[3] === 1 ? "rgb(" + t + "%, " + n + "%, " + r + "%)" : "rgba(" + t + "%, " + n + "%, " + r + "%, " + e[3] + ")";
};
Ni.to.hsl = function() {
  var e = Pf(arguments);
  return e.length < 4 || e[3] === 1 ? "hsl(" + e[0] + ", " + e[1] + "%, " + e[2] + "%)" : "hsla(" + e[0] + ", " + e[1] + "%, " + e[2] + "%, " + e[3] + ")";
};
Ni.to.hwb = function() {
  var e = Pf(arguments), t = "";
  return e.length >= 4 && e[3] !== 1 && (t = ", " + e[3]), "hwb(" + e[0] + ", " + e[1] + "%, " + e[2] + "%" + t + ")";
};
Ni.to.keyword = function(e) {
  return zL[e.slice(0, 3)];
};
function aa(e, t, n) {
  return Math.min(Math.max(t, e), n);
}
function Wh(e) {
  var t = Math.round(e).toString(16).toUpperCase();
  return t.length < 2 ? "0" + t : t;
}
var Zhe = FL.exports, HL = { exports: {} }, Jhe = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
}, Ya = Jhe, VL = {};
for (var T0 in Ya)
  Ya.hasOwnProperty(T0) && (VL[Ya[T0]] = T0);
var gt = HL.exports = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] }
};
for (var pi in gt)
  if (gt.hasOwnProperty(pi)) {
    if (!("channels" in gt[pi]))
      throw new Error("missing channels property: " + pi);
    if (!("labels" in gt[pi]))
      throw new Error("missing channel labels property: " + pi);
    if (gt[pi].labels.length !== gt[pi].channels)
      throw new Error("channel and label counts mismatch: " + pi);
    var epe = gt[pi].channels, tpe = gt[pi].labels;
    delete gt[pi].channels, delete gt[pi].labels, Object.defineProperty(gt[pi], "channels", { value: epe }), Object.defineProperty(gt[pi], "labels", { value: tpe });
  }
gt.rgb.hsl = function(e) {
  var t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, i = Math.min(t, n, r), o = Math.max(t, n, r), s = o - i, a, l, u;
  return o === i ? a = 0 : t === o ? a = (n - r) / s : n === o ? a = 2 + (r - t) / s : r === o && (a = 4 + (t - n) / s), a = Math.min(a * 60, 360), a < 0 && (a += 360), u = (i + o) / 2, o === i ? l = 0 : u <= 0.5 ? l = s / (o + i) : l = s / (2 - o - i), [a, l * 100, u * 100];
};
gt.rgb.hsv = function(e) {
  var t, n, r, i, o, s = e[0] / 255, a = e[1] / 255, l = e[2] / 255, u = Math.max(s, a, l), c = u - Math.min(s, a, l), d = function(f) {
    return (u - f) / 6 / c + 1 / 2;
  };
  return c === 0 ? i = o = 0 : (o = c / u, t = d(s), n = d(a), r = d(l), s === u ? i = r - n : a === u ? i = 1 / 3 + t - r : l === u && (i = 2 / 3 + n - t), i < 0 ? i += 1 : i > 1 && (i -= 1)), [
    i * 360,
    o * 100,
    u * 100
  ];
};
gt.rgb.hwb = function(e) {
  var t = e[0], n = e[1], r = e[2], i = gt.rgb.hsl(e)[0], o = 1 / 255 * Math.min(t, Math.min(n, r));
  return r = 1 - 1 / 255 * Math.max(t, Math.max(n, r)), [i, o * 100, r * 100];
};
gt.rgb.cmyk = function(e) {
  var t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, i, o, s, a;
  return a = Math.min(1 - t, 1 - n, 1 - r), i = (1 - t - a) / (1 - a) || 0, o = (1 - n - a) / (1 - a) || 0, s = (1 - r - a) / (1 - a) || 0, [i * 100, o * 100, s * 100, a * 100];
};
function npe(e, t) {
  return Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2) + Math.pow(e[2] - t[2], 2);
}
gt.rgb.keyword = function(e) {
  var t = VL[e];
  if (t)
    return t;
  var n = 1 / 0, r;
  for (var i in Ya)
    if (Ya.hasOwnProperty(i)) {
      var o = Ya[i], s = npe(e, o);
      s < n && (n = s, r = i);
    }
  return r;
};
gt.keyword.rgb = function(e) {
  return Ya[e];
};
gt.rgb.xyz = function(e) {
  var t = e[0] / 255, n = e[1] / 255, r = e[2] / 255;
  t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92, n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92, r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
  var i = t * 0.4124 + n * 0.3576 + r * 0.1805, o = t * 0.2126 + n * 0.7152 + r * 0.0722, s = t * 0.0193 + n * 0.1192 + r * 0.9505;
  return [i * 100, o * 100, s * 100];
};
gt.rgb.lab = function(e) {
  var t = gt.rgb.xyz(e), n = t[0], r = t[1], i = t[2], o, s, a;
  return n /= 95.047, r /= 100, i /= 108.883, n = n > 8856e-6 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, r = r > 8856e-6 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, i = i > 8856e-6 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, o = 116 * r - 16, s = 500 * (n - r), a = 200 * (r - i), [o, s, a];
};
gt.hsl.rgb = function(e) {
  var t = e[0] / 360, n = e[1] / 100, r = e[2] / 100, i, o, s, a, l;
  if (n === 0)
    return l = r * 255, [l, l, l];
  r < 0.5 ? o = r * (1 + n) : o = r + n - r * n, i = 2 * r - o, a = [0, 0, 0];
  for (var u = 0; u < 3; u++)
    s = t + 1 / 3 * -(u - 1), s < 0 && s++, s > 1 && s--, 6 * s < 1 ? l = i + (o - i) * 6 * s : 2 * s < 1 ? l = o : 3 * s < 2 ? l = i + (o - i) * (2 / 3 - s) * 6 : l = i, a[u] = l * 255;
  return a;
};
gt.hsl.hsv = function(e) {
  var t = e[0], n = e[1] / 100, r = e[2] / 100, i = n, o = Math.max(r, 0.01), s, a;
  return r *= 2, n *= r <= 1 ? r : 2 - r, i *= o <= 1 ? o : 2 - o, a = (r + n) / 2, s = r === 0 ? 2 * i / (o + i) : 2 * n / (r + n), [t, s * 100, a * 100];
};
gt.hsv.rgb = function(e) {
  var t = e[0] / 60, n = e[1] / 100, r = e[2] / 100, i = Math.floor(t) % 6, o = t - Math.floor(t), s = 255 * r * (1 - n), a = 255 * r * (1 - n * o), l = 255 * r * (1 - n * (1 - o));
  switch (r *= 255, i) {
    case 0:
      return [r, l, s];
    case 1:
      return [a, r, s];
    case 2:
      return [s, r, l];
    case 3:
      return [s, a, r];
    case 4:
      return [l, s, r];
    case 5:
      return [r, s, a];
  }
};
gt.hsv.hsl = function(e) {
  var t = e[0], n = e[1] / 100, r = e[2] / 100, i = Math.max(r, 0.01), o, s, a;
  return a = (2 - n) * r, o = (2 - n) * i, s = n * i, s /= o <= 1 ? o : 2 - o, s = s || 0, a /= 2, [t, s * 100, a * 100];
};
gt.hwb.rgb = function(e) {
  var t = e[0] / 360, n = e[1] / 100, r = e[2] / 100, i = n + r, o, s, a, l;
  i > 1 && (n /= i, r /= i), o = Math.floor(6 * t), s = 1 - r, a = 6 * t - o, o & 1 && (a = 1 - a), l = n + a * (s - n);
  var u, c, d;
  switch (o) {
    default:
    case 6:
    case 0:
      u = s, c = l, d = n;
      break;
    case 1:
      u = l, c = s, d = n;
      break;
    case 2:
      u = n, c = s, d = l;
      break;
    case 3:
      u = n, c = l, d = s;
      break;
    case 4:
      u = l, c = n, d = s;
      break;
    case 5:
      u = s, c = n, d = l;
      break;
  }
  return [u * 255, c * 255, d * 255];
};
gt.cmyk.rgb = function(e) {
  var t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, i = e[3] / 100, o, s, a;
  return o = 1 - Math.min(1, t * (1 - i) + i), s = 1 - Math.min(1, n * (1 - i) + i), a = 1 - Math.min(1, r * (1 - i) + i), [o * 255, s * 255, a * 255];
};
gt.xyz.rgb = function(e) {
  var t = e[0] / 100, n = e[1] / 100, r = e[2] / 100, i, o, s;
  return i = t * 3.2406 + n * -1.5372 + r * -0.4986, o = t * -0.9689 + n * 1.8758 + r * 0.0415, s = t * 0.0557 + n * -0.204 + r * 1.057, i = i > 31308e-7 ? 1.055 * Math.pow(i, 1 / 2.4) - 0.055 : i * 12.92, o = o > 31308e-7 ? 1.055 * Math.pow(o, 1 / 2.4) - 0.055 : o * 12.92, s = s > 31308e-7 ? 1.055 * Math.pow(s, 1 / 2.4) - 0.055 : s * 12.92, i = Math.min(Math.max(0, i), 1), o = Math.min(Math.max(0, o), 1), s = Math.min(Math.max(0, s), 1), [i * 255, o * 255, s * 255];
};
gt.xyz.lab = function(e) {
  var t = e[0], n = e[1], r = e[2], i, o, s;
  return t /= 95.047, n /= 100, r /= 108.883, t = t > 8856e-6 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116, n = n > 8856e-6 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, r = r > 8856e-6 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, i = 116 * n - 16, o = 500 * (t - n), s = 200 * (n - r), [i, o, s];
};
gt.lab.xyz = function(e) {
  var t = e[0], n = e[1], r = e[2], i, o, s;
  o = (t + 16) / 116, i = n / 500 + o, s = o - r / 200;
  var a = Math.pow(o, 3), l = Math.pow(i, 3), u = Math.pow(s, 3);
  return o = a > 8856e-6 ? a : (o - 16 / 116) / 7.787, i = l > 8856e-6 ? l : (i - 16 / 116) / 7.787, s = u > 8856e-6 ? u : (s - 16 / 116) / 7.787, i *= 95.047, o *= 100, s *= 108.883, [i, o, s];
};
gt.lab.lch = function(e) {
  var t = e[0], n = e[1], r = e[2], i, o, s;
  return i = Math.atan2(r, n), o = i * 360 / 2 / Math.PI, o < 0 && (o += 360), s = Math.sqrt(n * n + r * r), [t, s, o];
};
gt.lch.lab = function(e) {
  var t = e[0], n = e[1], r = e[2], i, o, s;
  return s = r / 360 * 2 * Math.PI, i = n * Math.cos(s), o = n * Math.sin(s), [t, i, o];
};
gt.rgb.ansi16 = function(e) {
  var t = e[0], n = e[1], r = e[2], i = 1 in arguments ? arguments[1] : gt.rgb.hsv(e)[2];
  if (i = Math.round(i / 50), i === 0)
    return 30;
  var o = 30 + (Math.round(r / 255) << 2 | Math.round(n / 255) << 1 | Math.round(t / 255));
  return i === 2 && (o += 60), o;
};
gt.hsv.ansi16 = function(e) {
  return gt.rgb.ansi16(gt.hsv.rgb(e), e[2]);
};
gt.rgb.ansi256 = function(e) {
  var t = e[0], n = e[1], r = e[2];
  if (t === n && n === r)
    return t < 8 ? 16 : t > 248 ? 231 : Math.round((t - 8) / 247 * 24) + 232;
  var i = 16 + 36 * Math.round(t / 255 * 5) + 6 * Math.round(n / 255 * 5) + Math.round(r / 255 * 5);
  return i;
};
gt.ansi16.rgb = function(e) {
  var t = e % 10;
  if (t === 0 || t === 7)
    return e > 50 && (t += 3.5), t = t / 10.5 * 255, [t, t, t];
  var n = (~~(e > 50) + 1) * 0.5, r = (t & 1) * n * 255, i = (t >> 1 & 1) * n * 255, o = (t >> 2 & 1) * n * 255;
  return [r, i, o];
};
gt.ansi256.rgb = function(e) {
  if (e >= 232) {
    var t = (e - 232) * 10 + 8;
    return [t, t, t];
  }
  e -= 16;
  var n, r = Math.floor(e / 36) / 5 * 255, i = Math.floor((n = e % 36) / 6) / 5 * 255, o = n % 6 / 5 * 255;
  return [r, i, o];
};
gt.rgb.hex = function(e) {
  var t = ((Math.round(e[0]) & 255) << 16) + ((Math.round(e[1]) & 255) << 8) + (Math.round(e[2]) & 255), n = t.toString(16).toUpperCase();
  return "000000".substring(n.length) + n;
};
gt.hex.rgb = function(e) {
  var t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
  if (!t)
    return [0, 0, 0];
  var n = t[0];
  t[0].length === 3 && (n = n.split("").map(function(a) {
    return a + a;
  }).join(""));
  var r = parseInt(n, 16), i = r >> 16 & 255, o = r >> 8 & 255, s = r & 255;
  return [i, o, s];
};
gt.rgb.hcg = function(e) {
  var t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, i = Math.max(Math.max(t, n), r), o = Math.min(Math.min(t, n), r), s = i - o, a, l;
  return s < 1 ? a = o / (1 - s) : a = 0, s <= 0 ? l = 0 : i === t ? l = (n - r) / s % 6 : i === n ? l = 2 + (r - t) / s : l = 4 + (t - n) / s + 4, l /= 6, l %= 1, [l * 360, s * 100, a * 100];
};
gt.hsl.hcg = function(e) {
  var t = e[1] / 100, n = e[2] / 100, r = 1, i = 0;
  return n < 0.5 ? r = 2 * t * n : r = 2 * t * (1 - n), r < 1 && (i = (n - 0.5 * r) / (1 - r)), [e[0], r * 100, i * 100];
};
gt.hsv.hcg = function(e) {
  var t = e[1] / 100, n = e[2] / 100, r = t * n, i = 0;
  return r < 1 && (i = (n - r) / (1 - r)), [e[0], r * 100, i * 100];
};
gt.hcg.rgb = function(e) {
  var t = e[0] / 360, n = e[1] / 100, r = e[2] / 100;
  if (n === 0)
    return [r * 255, r * 255, r * 255];
  var i = [0, 0, 0], o = t % 1 * 6, s = o % 1, a = 1 - s, l = 0;
  switch (Math.floor(o)) {
    case 0:
      i[0] = 1, i[1] = s, i[2] = 0;
      break;
    case 1:
      i[0] = a, i[1] = 1, i[2] = 0;
      break;
    case 2:
      i[0] = 0, i[1] = 1, i[2] = s;
      break;
    case 3:
      i[0] = 0, i[1] = a, i[2] = 1;
      break;
    case 4:
      i[0] = s, i[1] = 0, i[2] = 1;
      break;
    default:
      i[0] = 1, i[1] = 0, i[2] = a;
  }
  return l = (1 - n) * r, [
    (n * i[0] + l) * 255,
    (n * i[1] + l) * 255,
    (n * i[2] + l) * 255
  ];
};
gt.hcg.hsv = function(e) {
  var t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t), i = 0;
  return r > 0 && (i = t / r), [e[0], i * 100, r * 100];
};
gt.hcg.hsl = function(e) {
  var t = e[1] / 100, n = e[2] / 100, r = n * (1 - t) + 0.5 * t, i = 0;
  return r > 0 && r < 0.5 ? i = t / (2 * r) : r >= 0.5 && r < 1 && (i = t / (2 * (1 - r))), [e[0], i * 100, r * 100];
};
gt.hcg.hwb = function(e) {
  var t = e[1] / 100, n = e[2] / 100, r = t + n * (1 - t);
  return [e[0], (r - t) * 100, (1 - r) * 100];
};
gt.hwb.hcg = function(e) {
  var t = e[1] / 100, n = e[2] / 100, r = 1 - n, i = r - t, o = 0;
  return i < 1 && (o = (r - i) / (1 - i)), [e[0], i * 100, o * 100];
};
gt.apple.rgb = function(e) {
  return [e[0] / 65535 * 255, e[1] / 65535 * 255, e[2] / 65535 * 255];
};
gt.rgb.apple = function(e) {
  return [e[0] / 255 * 65535, e[1] / 255 * 65535, e[2] / 255 * 65535];
};
gt.gray.rgb = function(e) {
  return [e[0] / 100 * 255, e[0] / 100 * 255, e[0] / 100 * 255];
};
gt.gray.hsl = gt.gray.hsv = function(e) {
  return [0, 0, e[0]];
};
gt.gray.hwb = function(e) {
  return [0, 100, e[0]];
};
gt.gray.cmyk = function(e) {
  return [0, 0, 0, e[0]];
};
gt.gray.lab = function(e) {
  return [e[0], 0, 0];
};
gt.gray.hex = function(e) {
  var t = Math.round(e[0] / 100 * 255) & 255, n = (t << 16) + (t << 8) + t, r = n.toString(16).toUpperCase();
  return "000000".substring(r.length) + r;
};
gt.rgb.gray = function(e) {
  var t = (e[0] + e[1] + e[2]) / 3;
  return [t / 255 * 100];
};
var WL = HL.exports, Cg = WL;
function rpe() {
  for (var e = {}, t = Object.keys(Cg), n = t.length, r = 0; r < n; r++)
    e[t[r]] = {
      // http://jsperf.com/1-vs-infinity
      // micro-opt, but this is simple.
      distance: -1,
      parent: null
    };
  return e;
}
function ipe(e) {
  var t = rpe(), n = [e];
  for (t[e].distance = 0; n.length; )
    for (var r = n.pop(), i = Object.keys(Cg[r]), o = i.length, s = 0; s < o; s++) {
      var a = i[s], l = t[a];
      l.distance === -1 && (l.distance = t[r].distance + 1, l.parent = r, n.unshift(a));
    }
  return t;
}
function ope(e, t) {
  return function(n) {
    return t(e(n));
  };
}
function spe(e, t) {
  for (var n = [t[e].parent, e], r = Cg[t[e].parent][e], i = t[e].parent; t[i].parent; )
    n.unshift(t[i].parent), r = ope(Cg[t[i].parent][i], r), i = t[i].parent;
  return r.conversion = n, r;
}
var ape = function(e) {
  for (var t = ipe(e), n = {}, r = Object.keys(t), i = r.length, o = 0; o < i; o++) {
    var s = r[o], a = t[s];
    a.parent !== null && (n[s] = spe(s, t));
  }
  return n;
}, uw = WL, lpe = ape, nc = {}, cpe = Object.keys(uw);
function upe(e) {
  var t = function(n) {
    return n == null ? n : (arguments.length > 1 && (n = Array.prototype.slice.call(arguments)), e(n));
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
function dpe(e) {
  var t = function(n) {
    if (n == null)
      return n;
    arguments.length > 1 && (n = Array.prototype.slice.call(arguments));
    var r = e(n);
    if (typeof r == "object")
      for (var i = r.length, o = 0; o < i; o++)
        r[o] = Math.round(r[o]);
    return r;
  };
  return "conversion" in e && (t.conversion = e.conversion), t;
}
cpe.forEach(function(e) {
  nc[e] = {}, Object.defineProperty(nc[e], "channels", { value: uw[e].channels }), Object.defineProperty(nc[e], "labels", { value: uw[e].labels });
  var t = lpe(e), n = Object.keys(t);
  n.forEach(function(r) {
    var i = t[r];
    nc[e][r] = dpe(i), nc[e][r].raw = upe(i);
  });
});
var fpe = nc, Ku = Zhe, ki = fpe, iS = [].slice, UL = [
  // to be honest, I don't really feel like keyword belongs in color convert, but eh.
  "keyword",
  // gray conflicts with some method names, and has its own method defined.
  "gray",
  // shouldn't really be in color-convert either...
  "hex"
], dw = {};
Object.keys(ki).forEach(function(e) {
  dw[iS.call(ki[e].labels).sort().join("")] = e;
});
var Sg = {};
function Dr(e, t) {
  if (!(this instanceof Dr))
    return new Dr(e, t);
  if (t && t in UL && (t = null), t && !(t in ki))
    throw new Error("Unknown model: " + t);
  var n, r;
  if (e == null)
    this.model = "rgb", this.color = [0, 0, 0], this.valpha = 1;
  else if (e instanceof Dr)
    this.model = e.model, this.color = e.color.slice(), this.valpha = e.valpha;
  else if (typeof e == "string") {
    var i = Ku.get(e);
    if (i === null)
      throw new Error("Unable to parse color from string: " + e);
    this.model = i.model, r = ki[this.model].channels, this.color = i.value.slice(0, r), this.valpha = typeof i.value[r] == "number" ? i.value[r] : 1;
  } else if (e.length) {
    this.model = t || "rgb", r = ki[this.model].channels;
    var o = iS.call(e, 0, r);
    this.color = fw(o, r), this.valpha = typeof e[r] == "number" ? e[r] : 1;
  } else if (typeof e == "number")
    e &= 16777215, this.model = "rgb", this.color = [
      e >> 16 & 255,
      e >> 8 & 255,
      e & 255
    ], this.valpha = 1;
  else {
    this.valpha = 1;
    var s = Object.keys(e);
    "alpha" in e && (s.splice(s.indexOf("alpha"), 1), this.valpha = typeof e.alpha == "number" ? e.alpha : 0);
    var a = s.sort().join("");
    if (!(a in dw))
      throw new Error("Unable to parse color from object: " + JSON.stringify(e));
    this.model = dw[a];
    var l = ki[this.model].labels, u = [];
    for (n = 0; n < l.length; n++)
      u.push(e[l[n]]);
    this.color = fw(u);
  }
  if (Sg[this.model])
    for (r = ki[this.model].channels, n = 0; n < r; n++) {
      var c = Sg[this.model][n];
      c && (this.color[n] = c(this.color[n]));
    }
  this.valpha = Math.max(0, Math.min(1, this.valpha)), Object.freeze && Object.freeze(this);
}
Dr.prototype = {
  toString: function() {
    return this.string();
  },
  toJSON: function() {
    return this[this.model]();
  },
  string: function(e) {
    var t = this.model in Ku.to ? this : this.rgb();
    t = t.round(typeof e == "number" ? e : 1);
    var n = t.valpha === 1 ? t.color : t.color.concat(this.valpha);
    return Ku.to[t.model](n);
  },
  percentString: function(e) {
    var t = this.rgb().round(typeof e == "number" ? e : 1), n = t.valpha === 1 ? t.color : t.color.concat(this.valpha);
    return Ku.to.rgb.percent(n);
  },
  array: function() {
    return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
  },
  object: function() {
    for (var e = {}, t = ki[this.model].channels, n = ki[this.model].labels, r = 0; r < t; r++)
      e[n[r]] = this.color[r];
    return this.valpha !== 1 && (e.alpha = this.valpha), e;
  },
  unitArray: function() {
    var e = this.rgb().color;
    return e[0] /= 255, e[1] /= 255, e[2] /= 255, this.valpha !== 1 && e.push(this.valpha), e;
  },
  unitObject: function() {
    var e = this.rgb().object();
    return e.r /= 255, e.g /= 255, e.b /= 255, this.valpha !== 1 && (e.alpha = this.valpha), e;
  },
  round: function(e) {
    return e = Math.max(e || 0, 0), new Dr(this.color.map(ppe(e)).concat(this.valpha), this.model);
  },
  alpha: function(e) {
    return arguments.length ? new Dr(this.color.concat(Math.max(0, Math.min(1, e))), this.model) : this.valpha;
  },
  // rgb
  red: qn("rgb", 0, cr(255)),
  green: qn("rgb", 1, cr(255)),
  blue: qn("rgb", 2, cr(255)),
  hue: qn(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(e) {
    return (e % 360 + 360) % 360;
  }),
  // eslint-disable-line brace-style
  saturationl: qn("hsl", 1, cr(100)),
  lightness: qn("hsl", 2, cr(100)),
  saturationv: qn("hsv", 1, cr(100)),
  value: qn("hsv", 2, cr(100)),
  chroma: qn("hcg", 1, cr(100)),
  gray: qn("hcg", 2, cr(100)),
  white: qn("hwb", 1, cr(100)),
  wblack: qn("hwb", 2, cr(100)),
  cyan: qn("cmyk", 0, cr(100)),
  magenta: qn("cmyk", 1, cr(100)),
  yellow: qn("cmyk", 2, cr(100)),
  black: qn("cmyk", 3, cr(100)),
  x: qn("xyz", 0, cr(100)),
  y: qn("xyz", 1, cr(100)),
  z: qn("xyz", 2, cr(100)),
  l: qn("lab", 0, cr(100)),
  a: qn("lab", 1),
  b: qn("lab", 2),
  keyword: function(e) {
    return arguments.length ? new Dr(e) : ki[this.model].keyword(this.color);
  },
  hex: function(e) {
    return arguments.length ? new Dr(e) : Ku.to.hex(this.rgb().round().color);
  },
  rgbNumber: function() {
    var e = this.rgb().color;
    return (e[0] & 255) << 16 | (e[1] & 255) << 8 | e[2] & 255;
  },
  luminosity: function() {
    for (var e = this.rgb().color, t = [], n = 0; n < e.length; n++) {
      var r = e[n] / 255;
      t[n] = r <= 0.03928 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
    }
    return 0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2];
  },
  contrast: function(e) {
    var t = this.luminosity(), n = e.luminosity();
    return t > n ? (t + 0.05) / (n + 0.05) : (n + 0.05) / (t + 0.05);
  },
  level: function(e) {
    var t = this.contrast(e);
    return t >= 7.1 ? "AAA" : t >= 4.5 ? "AA" : "";
  },
  isDark: function() {
    var e = this.rgb().color, t = (e[0] * 299 + e[1] * 587 + e[2] * 114) / 1e3;
    return t < 128;
  },
  isLight: function() {
    return !this.isDark();
  },
  negate: function() {
    for (var e = this.rgb(), t = 0; t < 3; t++)
      e.color[t] = 255 - e.color[t];
    return e;
  },
  lighten: function(e) {
    var t = this.hsl();
    return t.color[2] += t.color[2] * e, t;
  },
  darken: function(e) {
    var t = this.hsl();
    return t.color[2] -= t.color[2] * e, t;
  },
  saturate: function(e) {
    var t = this.hsl();
    return t.color[1] += t.color[1] * e, t;
  },
  desaturate: function(e) {
    var t = this.hsl();
    return t.color[1] -= t.color[1] * e, t;
  },
  whiten: function(e) {
    var t = this.hwb();
    return t.color[1] += t.color[1] * e, t;
  },
  blacken: function(e) {
    var t = this.hwb();
    return t.color[2] += t.color[2] * e, t;
  },
  grayscale: function() {
    var e = this.rgb().color, t = e[0] * 0.3 + e[1] * 0.59 + e[2] * 0.11;
    return Dr.rgb(t, t, t);
  },
  fade: function(e) {
    return this.alpha(this.valpha - this.valpha * e);
  },
  opaquer: function(e) {
    return this.alpha(this.valpha + this.valpha * e);
  },
  rotate: function(e) {
    var t = this.hsl(), n = t.color[0];
    return n = (n + e) % 360, n = n < 0 ? 360 + n : n, t.color[0] = n, t;
  },
  mix: function(e, t) {
    if (!e || !e.rgb)
      throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof e);
    var n = e.rgb(), r = this.rgb(), i = t === void 0 ? 0.5 : t, o = 2 * i - 1, s = n.alpha() - r.alpha(), a = ((o * s === -1 ? o : (o + s) / (1 + o * s)) + 1) / 2, l = 1 - a;
    return Dr.rgb(
      a * n.red() + l * r.red(),
      a * n.green() + l * r.green(),
      a * n.blue() + l * r.blue(),
      n.alpha() * i + r.alpha() * (1 - i)
    );
  }
};
Object.keys(ki).forEach(function(e) {
  if (UL.indexOf(e) === -1) {
    var t = ki[e].channels;
    Dr.prototype[e] = function() {
      if (this.model === e)
        return new Dr(this);
      if (arguments.length)
        return new Dr(arguments, e);
      var n = typeof arguments[t] == "number" ? t : this.valpha;
      return new Dr(gpe(ki[this.model][e].raw(this.color)).concat(n), e);
    }, Dr[e] = function(n) {
      return typeof n == "number" && (n = fw(iS.call(arguments), t)), new Dr(n, e);
    };
  }
});
function hpe(e, t) {
  return Number(e.toFixed(t));
}
function ppe(e) {
  return function(t) {
    return hpe(t, e);
  };
}
function qn(e, t, n) {
  return e = Array.isArray(e) ? e : [e], e.forEach(function(r) {
    (Sg[r] || (Sg[r] = []))[t] = n;
  }), e = e[0], function(r) {
    var i;
    return arguments.length ? (n && (r = n(r)), i = this[e](), i.color[t] = r, i) : (i = this[e]().color[t], n && (i = n(i)), i);
  };
}
function cr(e) {
  return function(t) {
    return Math.max(0, Math.min(e, t));
  };
}
function gpe(e) {
  return Array.isArray(e) ? e : [e];
}
function fw(e, t) {
  for (var n = 0; n < t; n++)
    typeof e[n] != "number" && (e[n] = 0);
  return e;
}
var mpe = Dr;
const AA = /* @__PURE__ */ hl(mpe);
var vpe = "Expected a function", DA = "__lodash_placeholder__", dl = 1, km = 2, bpe = 4, qa = 8, dd = 16, $c = 32, sf = 64, GL = 128, ype = 256, KL = 512, _A = 1 / 0, wpe = 9007199254740991, Cpe = 17976931348623157e292, TA = NaN, Spe = [
  ["ary", GL],
  ["bind", dl],
  ["bindKey", km],
  ["curry", qa],
  ["curryRight", dd],
  ["flip", KL],
  ["partial", $c],
  ["partialRight", sf],
  ["rearg", ype]
], xpe = "[object Function]", Epe = "[object GeneratorFunction]", $pe = "[object Symbol]", Ope = /[\\^$.*+?()[\]{}|]/g, Ape = /^\s+|\s+$/g, Dpe = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, _pe = /\{\n\/\* \[wrapped with (.+)\] \*/, Tpe = /,? & /, Rpe = /^[-+]0x[0-9a-f]+$/i, Mpe = /^0b[01]+$/i, Ipe = /^\[object .+?Constructor\]$/, kpe = /^0o[0-7]+$/i, Ppe = /^(?:0|[1-9]\d*)$/, Npe = parseInt, Lpe = typeof Bn == "object" && Bn && Bn.Object === Object && Bn, Fpe = typeof self == "object" && self && self.Object === Object && self, Nf = Lpe || Fpe || Function("return this")();
function XL(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
function Bpe(e, t) {
  for (var n = -1, r = e ? e.length : 0; ++n < r && t(e[n], n, e) !== !1; )
    ;
  return e;
}
function jpe(e, t) {
  var n = e ? e.length : 0;
  return !!n && Hpe(e, t, 0) > -1;
}
function zpe(e, t, n, r) {
  for (var i = e.length, o = n + -1; ++o < i; )
    if (t(e[o], o, e))
      return o;
  return -1;
}
function Hpe(e, t, n) {
  if (t !== t)
    return zpe(e, Vpe, n);
  for (var r = n - 1, i = e.length; ++r < i; )
    if (e[r] === t)
      return r;
  return -1;
}
function Vpe(e) {
  return e !== e;
}
function Wpe(e, t) {
  for (var n = e.length, r = 0; n--; )
    e[n] === t && r++;
  return r;
}
function Upe(e, t) {
  return e == null ? void 0 : e[t];
}
function Gpe(e) {
  var t = !1;
  if (e != null && typeof e.toString != "function")
    try {
      t = !!(e + "");
    } catch {
    }
  return t;
}
function YL(e, t) {
  for (var n = -1, r = e.length, i = 0, o = []; ++n < r; ) {
    var s = e[n];
    (s === t || s === DA) && (e[n] = DA, o[i++] = n);
  }
  return o;
}
var Kpe = Function.prototype, qL = Object.prototype, R0 = Nf["__core-js_shared__"], RA = function() {
  var e = /[^.]+$/.exec(R0 && R0.keys && R0.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}(), QL = Kpe.toString, Xpe = qL.hasOwnProperty, ZL = qL.toString, Ype = RegExp(
  "^" + QL.call(Xpe).replace(Ope, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
), qpe = Object.create, xg = Math.max, Qpe = Math.min, MA = function() {
  var e = IA(Object, "defineProperty"), t = IA.name;
  return t && t.length > 2 ? e : void 0;
}();
function Zpe(e) {
  return Xc(e) ? qpe(e) : {};
}
function Jpe(e) {
  if (!Xc(e) || uge(e))
    return !1;
  var t = pge(e) || Gpe(e) ? Ype : Ipe;
  return t.test(fge(e));
}
function ege(e, t, n, r) {
  for (var i = -1, o = e.length, s = n.length, a = -1, l = t.length, u = xg(o - s, 0), c = Array(l + u), d = !r; ++a < l; )
    c[a] = t[a];
  for (; ++i < s; )
    (d || i < o) && (c[n[i]] = e[i]);
  for (; u--; )
    c[a++] = e[i++];
  return c;
}
function tge(e, t, n, r) {
  for (var i = -1, o = e.length, s = -1, a = n.length, l = -1, u = t.length, c = xg(o - a, 0), d = Array(c + u), f = !r; ++i < c; )
    d[i] = e[i];
  for (var h = i; ++l < u; )
    d[h + l] = t[l];
  for (; ++s < a; )
    (f || i < o) && (d[h + n[s]] = e[i++]);
  return d;
}
function nge(e, t) {
  var n = -1, r = e.length;
  for (t || (t = Array(r)); ++n < r; )
    t[n] = e[n];
  return t;
}
function rge(e, t, n) {
  var r = t & dl, i = af(e);
  function o() {
    var s = this && this !== Nf && this instanceof o ? i : e;
    return s.apply(r ? n : this, arguments);
  }
  return o;
}
function af(e) {
  return function() {
    var t = arguments;
    switch (t.length) {
      case 0:
        return new e();
      case 1:
        return new e(t[0]);
      case 2:
        return new e(t[0], t[1]);
      case 3:
        return new e(t[0], t[1], t[2]);
      case 4:
        return new e(t[0], t[1], t[2], t[3]);
      case 5:
        return new e(t[0], t[1], t[2], t[3], t[4]);
      case 6:
        return new e(t[0], t[1], t[2], t[3], t[4], t[5]);
      case 7:
        return new e(t[0], t[1], t[2], t[3], t[4], t[5], t[6]);
    }
    var n = Zpe(e.prototype), r = e.apply(n, t);
    return Xc(r) ? r : n;
  };
}
function ige(e, t, n) {
  var r = af(e);
  function i() {
    for (var o = arguments.length, s = Array(o), a = o, l = eF(i); a--; )
      s[a] = arguments[a];
    var u = o < 3 && s[0] !== l && s[o - 1] !== l ? [] : YL(s, l);
    if (o -= u.length, o < n)
      return JL(
        e,
        t,
        oS,
        i.placeholder,
        void 0,
        s,
        u,
        void 0,
        void 0,
        n - o
      );
    var c = this && this !== Nf && this instanceof i ? r : e;
    return XL(c, this, s);
  }
  return i;
}
function oS(e, t, n, r, i, o, s, a, l, u) {
  var c = t & GL, d = t & dl, f = t & km, h = t & (qa | dd), p = t & KL, g = f ? void 0 : af(e);
  function m() {
    for (var v = arguments.length, b = Array(v), x = v; x--; )
      b[x] = arguments[x];
    if (h)
      var w = eF(m), C = Wpe(b, w);
    if (r && (b = ege(b, r, i, h)), o && (b = tge(b, o, s, h)), v -= C, h && v < u) {
      var y = YL(b, w);
      return JL(
        e,
        t,
        oS,
        m.placeholder,
        n,
        b,
        y,
        a,
        l,
        u - v
      );
    }
    var S = d ? n : this, A = f ? S[e] : e;
    return v = b.length, a ? b = dge(b, a) : p && v > 1 && b.reverse(), c && l < v && (b.length = l), this && this !== Nf && this instanceof m && (A = g || af(A)), A.apply(S, b);
  }
  return m;
}
function oge(e, t, n, r) {
  var i = t & dl, o = af(e);
  function s() {
    for (var a = -1, l = arguments.length, u = -1, c = r.length, d = Array(c + l), f = this && this !== Nf && this instanceof s ? o : e; ++u < c; )
      d[u] = r[u];
    for (; l--; )
      d[u++] = arguments[++a];
    return XL(f, i ? n : this, d);
  }
  return s;
}
function JL(e, t, n, r, i, o, s, a, l, u) {
  var c = t & qa, d = c ? s : void 0, f = c ? void 0 : s, h = c ? o : void 0, p = c ? void 0 : o;
  t |= c ? $c : sf, t &= ~(c ? sf : $c), t & bpe || (t &= ~(dl | km));
  var g = n(e, t, i, h, d, p, f, a, l, u);
  return g.placeholder = r, tF(g, e, t);
}
function sge(e, t, n, r, i, o, s, a) {
  var l = t & km;
  if (!l && typeof e != "function")
    throw new TypeError(vpe);
  var u = r ? r.length : 0;
  if (u || (t &= ~($c | sf), r = i = void 0), s = s === void 0 ? s : xg(kA(s), 0), a = a === void 0 ? a : kA(a), u -= i ? i.length : 0, t & sf) {
    var c = r, d = i;
    r = i = void 0;
  }
  var f = [
    e,
    t,
    n,
    r,
    i,
    c,
    d,
    o,
    s,
    a
  ];
  if (e = f[0], t = f[1], n = f[2], r = f[3], i = f[4], a = f[9] = f[9] == null ? l ? 0 : e.length : xg(f[9] - u, 0), !a && t & (qa | dd) && (t &= ~(qa | dd)), !t || t == dl)
    var h = rge(e, t, n);
  else
    t == qa || t == dd ? h = ige(e, t, a) : (t == $c || t == (dl | $c)) && !i.length ? h = oge(e, t, n, r) : h = oS.apply(void 0, f);
  return tF(h, e, t);
}
function eF(e) {
  var t = e;
  return t.placeholder;
}
function IA(e, t) {
  var n = Upe(e, t);
  return Jpe(n) ? n : void 0;
}
function age(e) {
  var t = e.match(_pe);
  return t ? t[1].split(Tpe) : [];
}
function lge(e, t) {
  var n = t.length, r = n - 1;
  return t[r] = (n > 1 ? "& " : "") + t[r], t = t.join(n > 2 ? ", " : " "), e.replace(Dpe, `{
/* [wrapped with ` + t + `] */
`);
}
function cge(e, t) {
  return t = t ?? wpe, !!t && (typeof e == "number" || Ppe.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function uge(e) {
  return !!RA && RA in e;
}
function dge(e, t) {
  for (var n = e.length, r = Qpe(t.length, n), i = nge(e); r--; ) {
    var o = t[r];
    e[r] = cge(o, n) ? i[o] : void 0;
  }
  return e;
}
var tF = MA ? function(e, t, n) {
  var r = t + "";
  return MA(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: yge(lge(r, hge(age(r), n)))
  });
} : wge;
function fge(e) {
  if (e != null) {
    try {
      return QL.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
function hge(e, t) {
  return Bpe(Spe, function(n) {
    var r = "_." + n[0];
    t & n[1] && !jpe(e, r) && e.push(r);
  }), e.sort();
}
function sS(e, t, n) {
  t = n ? void 0 : t;
  var r = sge(e, qa, void 0, void 0, void 0, void 0, void 0, t);
  return r.placeholder = sS.placeholder, r;
}
function pge(e) {
  var t = Xc(e) ? ZL.call(e) : "";
  return t == xpe || t == Epe;
}
function Xc(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function gge(e) {
  return !!e && typeof e == "object";
}
function mge(e) {
  return typeof e == "symbol" || gge(e) && ZL.call(e) == $pe;
}
function vge(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = bge(e), e === _A || e === -_A) {
    var t = e < 0 ? -1 : 1;
    return t * Cpe;
  }
  return e === e ? e : 0;
}
function kA(e) {
  var t = vge(e), n = t % 1;
  return t === t ? n ? t - n : t : 0;
}
function bge(e) {
  if (typeof e == "number")
    return e;
  if (mge(e))
    return TA;
  if (Xc(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Xc(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(Ape, "");
  var n = Mpe.test(e);
  return n || kpe.test(e) ? Npe(e.slice(2), n ? 2 : 8) : Rpe.test(e) ? TA : +e;
}
function yge(e) {
  return function() {
    return e;
  };
}
function wge(e) {
  return e;
}
sS.placeholder = {};
var Cge = sS;
const PA = /* @__PURE__ */ hl(Cge);
function Sge(e) {
  var t = e[0], n = e[1], r = e[2], i, o, s;
  return i = t * 1 + n * 0 + r * 1.13983, o = t * 1 + n * -0.39465 + r * -0.5806, s = t * 1 + n * 2.02311 + r * 0, i = Math.min(Math.max(0, i), 1), o = Math.min(Math.max(0, o), 1), s = Math.min(Math.max(0, s), 1), [i * 255, o * 255, s * 255];
}
function xge(e) {
  var t = e[0] / 255, n = e[1] / 255, r = e[2] / 255, i = t * 0.299 + n * 0.587 + r * 0.114, o = t * -0.14713 + n * -0.28886 + r * 0.436, s = t * 0.615 + n * -0.51499 + r * -0.10001;
  return [i, o, s];
}
function NA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NA(Object(n), !0).forEach(function(r) {
      re(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nF = LL, LA = Object.keys(nF), Ege = function(t) {
  return t < 0.25 ? 1 : t < 0.5 ? 0.9 - t : 1.1 - t;
}, $ge = function(t) {
  var n = AA(t), r = xge(n.array()), i = ae(r, 3), o = i[0], s = i[1], a = i[2], l = [Ege(o), s, a], u = Sge(l);
  return AA.rgb(u).hex();
}, Zl = function(t) {
  return function(n) {
    return {
      className: [n.className, t.className].filter(Boolean).join(" "),
      style: wi(wi({}, n.style || {}), t.style || {})
    };
  };
}, Oge = function(t, n) {
  if (t === void 0)
    return n;
  if (n === void 0)
    return t;
  var r = wt(t), i = wt(n);
  switch (r) {
    case "string":
      switch (i) {
        case "string":
          return [n, t].filter(Boolean).join(" ");
        case "object":
          return Zl({
            className: t,
            style: n
          });
        case "function":
          return function(o) {
            for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), l = 1; l < s; l++)
              a[l - 1] = arguments[l];
            return Zl({
              className: t
            })(n.apply(void 0, [o].concat(a)));
          };
      }
      break;
    case "object":
      switch (i) {
        case "string":
          return Zl({
            className: n,
            style: t
          });
        case "object":
          return wi(wi({}, n), t);
        case "function":
          return function(o) {
            for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), l = 1; l < s; l++)
              a[l - 1] = arguments[l];
            return Zl({
              style: t
            })(n.apply(void 0, [o].concat(a)));
          };
      }
      break;
    case "function":
      switch (i) {
        case "string":
          return function(o) {
            for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), l = 1; l < s; l++)
              a[l - 1] = arguments[l];
            return t.apply(void 0, [Zl(o)({
              className: n
            })].concat(a));
          };
        case "object":
          return function(o) {
            for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), l = 1; l < s; l++)
              a[l - 1] = arguments[l];
            return t.apply(void 0, [Zl(o)({
              style: n
            })].concat(a));
          };
        case "function":
          return function(o) {
            for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), l = 1; l < s; l++)
              a[l - 1] = arguments[l];
            return t.apply(void 0, [n.apply(void 0, [o].concat(a))].concat(a));
          };
      }
  }
}, Age = function(t, n) {
  var r = Object.keys(n);
  for (var i in t)
    r.indexOf(i) === -1 && r.push(i);
  return r.reduce(function(o, s) {
    return o[s] = Oge(t[s], n[s]), o;
  }, {});
}, Dge = function(t, n) {
  for (var r = arguments.length, i = new Array(r > 2 ? r - 2 : 0), o = 2; o < r; o++)
    i[o - 2] = arguments[o];
  if (n === null)
    return t;
  Array.isArray(n) || (n = [n]);
  var s = n.map(function(l) {
    return t[l];
  }).filter(Boolean), a = s.reduce(function(l, u) {
    return typeof u == "string" ? l.className = [l.className, u].filter(Boolean).join(" ") : wt(u) === "object" ? l.style = wi(wi({}, l.style), u) : typeof u == "function" && (l = wi(wi({}, l), u.apply(void 0, [l].concat(i)))), l;
  }, {
    className: "",
    style: {}
  });
  return a.className || delete a.className, Object.keys(a.style).length === 0 && delete a.style, a;
}, hw = function(t) {
  return Object.keys(t).reduce(function(n, r) {
    return n[r] = /^base/.test(r) ? $ge(t[r]) : r === "scheme" ? t[r] + ":inverted" : t[r], n;
  }, {});
}, _ge = PA(function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = t.defaultBase16, i = r === void 0 ? nF : r, o = t.base16Themes, s = o === void 0 ? null : o, a = Tge(n, s);
  a && (n = wi(wi({}, a), n));
  for (var l = LA.reduce(function(g, m) {
    return g[m] = n[m] || i[m], g;
  }, {}), u = Object.keys(n).reduce(function(g, m) {
    return LA.indexOf(m) === -1 && (g[m] = n[m]), g;
  }, {}), c = e(l), d = Age(u, c), f = arguments.length, h = new Array(f > 3 ? f - 3 : 0), p = 3; p < f; p++)
    h[p - 3] = arguments[p];
  return PA(Dge, 2).apply(void 0, [d].concat(h));
}, 3), rF = function(t) {
  return !!t.extend;
}, Tge = function(t, n) {
  if (t && rF(t) && t.extend && (t = t.extend), typeof t == "string") {
    var r = t.split(":"), i = ae(r, 2), o = i[0], s = i[1];
    n ? t = n[o] : t = Uhe[o], s === "inverted" && (t = hw(t));
  }
  return t && Object.prototype.hasOwnProperty.call(t, "base00") ? t : void 0;
}, Rge = function(t) {
  return typeof t == "string" ? "".concat(t, ":inverted") : t && rF(t) && t.extend ? typeof t.extend == "string" ? wi(wi({}, t), {}, {
    extend: "".concat(t.extend, ":inverted")
  }) : wi(wi({}, t), {}, {
    extend: hw(t.extend)
  }) : t && hw(t);
};
const Mge = {
  scheme: "solarized",
  author: "ethan schoonover (http://ethanschoonover.com/solarized)",
  base00: "#002b36",
  base01: "#073642",
  base02: "#586e75",
  base03: "#657b83",
  base04: "#839496",
  base05: "#93a1a1",
  base06: "#eee8d5",
  base07: "#fdf6e3",
  base08: "#dc322f",
  base09: "#cb4b16",
  base0A: "#b58900",
  base0B: "#859900",
  base0C: "#2aa198",
  base0D: "#268bd2",
  base0E: "#6c71c4",
  base0F: "#d33682"
}, Ige = (e) => ({
  BACKGROUND_COLOR: e.base00,
  TEXT_COLOR: e.base07,
  STRING_COLOR: e.base0B,
  DATE_COLOR: e.base0B,
  NUMBER_COLOR: e.base09,
  BOOLEAN_COLOR: e.base09,
  NULL_COLOR: e.base08,
  UNDEFINED_COLOR: e.base08,
  FUNCTION_COLOR: e.base08,
  SYMBOL_COLOR: e.base08,
  LABEL_COLOR: e.base0D,
  ARROW_COLOR: e.base0D,
  ITEM_STRING_COLOR: e.base0B,
  ITEM_STRING_EXPANDED_COLOR: e.base03
}), kge = (e) => ({
  String: e.STRING_COLOR,
  Date: e.DATE_COLOR,
  Number: e.NUMBER_COLOR,
  Boolean: e.BOOLEAN_COLOR,
  Null: e.NULL_COLOR,
  Undefined: e.UNDEFINED_COLOR,
  Function: e.FUNCTION_COLOR,
  Symbol: e.SYMBOL_COLOR
}), Pge = (e) => {
  const t = Ige(e);
  return {
    tree: {
      border: 0,
      padding: 0,
      marginTop: "0.5em",
      marginBottom: "0.5em",
      marginLeft: "0.125em",
      marginRight: 0,
      listStyle: "none",
      MozUserSelect: "none",
      WebkitUserSelect: "none",
      backgroundColor: t.BACKGROUND_COLOR
    },
    value: (n, r, i) => {
      let {
        style: o
      } = n;
      return {
        style: {
          ...o,
          paddingTop: "0.25em",
          paddingRight: 0,
          marginLeft: "0.875em",
          WebkitUserSelect: "text",
          MozUserSelect: "text",
          wordWrap: "break-word",
          paddingLeft: i.length > 1 ? "2.125em" : "1.25em",
          textIndent: "-0.5em",
          wordBreak: "break-all"
        }
      };
    },
    label: {
      display: "inline-block",
      color: t.LABEL_COLOR
    },
    valueLabel: {
      margin: "0 0.5em 0 0"
    },
    valueText: (n, r) => {
      let {
        style: i
      } = n;
      return {
        style: {
          ...i,
          color: kge(t)[r]
        }
      };
    },
    itemRange: (n, r) => ({
      style: {
        paddingTop: r ? 0 : "0.25em",
        cursor: "pointer",
        color: t.LABEL_COLOR
      }
    }),
    arrow: (n, r, i) => {
      let {
        style: o
      } = n;
      return {
        style: {
          ...o,
          marginLeft: 0,
          transition: "150ms",
          WebkitTransition: "150ms",
          MozTransition: "150ms",
          WebkitTransform: i ? "rotateZ(90deg)" : "rotateZ(0deg)",
          MozTransform: i ? "rotateZ(90deg)" : "rotateZ(0deg)",
          transform: i ? "rotateZ(90deg)" : "rotateZ(0deg)",
          transformOrigin: "45% 50%",
          WebkitTransformOrigin: "45% 50%",
          MozTransformOrigin: "45% 50%",
          position: "relative",
          lineHeight: "1.1em",
          fontSize: "0.75em"
        }
      };
    },
    arrowContainer: (n, r) => {
      let {
        style: i
      } = n;
      return {
        style: {
          ...i,
          display: "inline-block",
          paddingRight: "0.5em",
          paddingLeft: r === "double" ? "1em" : 0,
          cursor: "pointer"
        }
      };
    },
    arrowSign: {
      color: t.ARROW_COLOR
    },
    arrowSignInner: {
      position: "absolute",
      top: 0,
      left: "-0.4em"
    },
    nestedNode: (n, r, i, o, s) => {
      let {
        style: a
      } = n;
      return {
        style: {
          ...a,
          position: "relative",
          paddingTop: "0.25em",
          marginLeft: r.length > 1 ? "0.875em" : 0,
          paddingLeft: s ? 0 : "1.125em"
        }
      };
    },
    rootNode: {
      padding: 0,
      margin: 0
    },
    nestedNodeLabel: (n, r, i, o, s) => {
      let {
        style: a
      } = n;
      return {
        style: {
          ...a,
          margin: 0,
          padding: 0,
          WebkitUserSelect: s ? "inherit" : "text",
          MozUserSelect: s ? "inherit" : "text",
          cursor: s ? "pointer" : "default"
        }
      };
    },
    nestedNodeItemString: (n, r, i, o) => {
      let {
        style: s
      } = n;
      return {
        style: {
          ...s,
          paddingLeft: "0.5em",
          cursor: "default",
          color: o ? t.ITEM_STRING_EXPANDED_COLOR : t.ITEM_STRING_COLOR
        }
      };
    },
    nestedNodeItemType: {
      marginLeft: "0.3em",
      marginRight: "0.3em"
    },
    nestedNodeChildren: (n, r, i) => {
      let {
        style: o
      } = n;
      return {
        style: {
          ...o,
          padding: 0,
          margin: 0,
          listStyle: "none",
          display: i ? "block" : "none"
        }
      };
    },
    rootNodeChildren: {
      padding: 0,
      margin: 0,
      listStyle: "none"
    }
  };
}, Nge = _ge(Pge, {
  defaultBase16: Mge
}), FA = (e) => e, Lge = (e, t, n) => n === 0, Fge = (e, t, n, r) => /* @__PURE__ */ U.createElement("span", null, n, " ", r), Bge = (e) => {
  let [t] = e;
  return /* @__PURE__ */ U.createElement("span", null, t, ":");
}, jge = () => !1;
function zge(e) {
  let {
    data: t,
    theme: n,
    invertTheme: r,
    keyPath: i = ["root"],
    labelRenderer: o = Bge,
    valueRenderer: s = FA,
    shouldExpandNodeInitially: a = Lge,
    hideRoot: l = !1,
    getItemString: u = Fge,
    postprocessValue: c = FA,
    isCustomNode: d = jge,
    collectionLimit: f = 50,
    sortObjectKeys: h = !1
  } = e;
  const p = mt(() => Nge(r ? Rge(n) : n), [n, r]);
  return /* @__PURE__ */ U.createElement("ul", p("tree"), /* @__PURE__ */ U.createElement(NL, {
    keyPath: l ? [] : i,
    value: c(t),
    isCustomNode: d,
    styling: p,
    labelRenderer: o,
    valueRenderer: s,
    shouldExpandNodeInitially: a,
    hideRoot: l,
    getItemString: u,
    postprocessValue: c,
    collectionLimit: f,
    sortObjectKeys: h
  }));
}
const Hge = {
  dark: {
    string: "#CE9178",
    number: "#B5CEA8",
    constants: "#569CD6",
    type: "#3DC9B0"
  },
  light: {
    string: "#A31515",
    number: "#098658",
    constants: "#0000FF",
    type: "#008080"
  }
}, Vge = ({ lines: e, msSinceRun: t }) => {
  const { token: n } = no.useToken(), r = Hge[n.mode ?? "light"];
  return /* @__PURE__ */ V.jsxs("div", { className: "grl-function__debugger__log", children: [
    /* @__PURE__ */ V.jsx("div", { className: "grl-function__debugger__log__values", children: e.map((i, o) => {
      const s = JSON.parse(i);
      return /* @__PURE__ */ V.jsx(
        zge,
        {
          data: s,
          shouldExpandNodeInitially: () => !1,
          labelRenderer: (a, l) => {
            const u = [], c = a == null ? void 0 : a[0];
            if (c !== "root" && u.push(
              /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
                /* @__PURE__ */ V.jsx("span", { style: { color: r.constants }, children: c }),
                ": "
              ] })
            ), a.length >= 1) {
              let d = [...a];
              d.pop(), d = d.reverse(), u.push(Wge(r)(Uge(s, d), l));
            }
            return /* @__PURE__ */ V.jsx(V.Fragment, { children: u });
          },
          valueRenderer: pw(r),
          theme: {
            base00: n.colorBgElevated,
            base03: n.colorTextBase,
            base0B: n.colorTextBase,
            base0D: n.colorTextBase
          }
        },
        o
      );
    }) }),
    /* @__PURE__ */ V.jsx("div", { className: "grl-function__debugger__log__time", children: /* @__PURE__ */ V.jsxs(lr, { title: "Time since start of execution of script.", children: [
      t,
      " ms"
    ] }) })
  ] });
}, Wge = (e) => (t, n) => {
  if (n === "Object") {
    const i = Object.entries(t), o = i.reduce(
      (s, [a, l], u) => [
        ...s,
        /* @__PURE__ */ V.jsxs("span", { children: [
          a,
          ": ",
          pw(e)(BA(l), l),
          u !== i.length - 1 && /* @__PURE__ */ V.jsx(V.Fragment, { children: ", " })
        ] }, a)
      ],
      []
    );
    return /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
      " {",
      o,
      "}"
    ] });
  } else if (n === "Array") {
    const r = t, i = r.reduce(
      (o, s, a) => [
        ...o,
        /* @__PURE__ */ V.jsxs("span", { children: [
          pw(e)(BA(s), s),
          a !== r.length - 1 && /* @__PURE__ */ V.jsx(V.Fragment, { children: ", " })
        ] }, a)
      ],
      []
    );
    return /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
      r.length > 2 ? `(${r.length})` : "",
      " [",
      i,
      "]"
    ] });
  } else
    return null;
}, BA = (e) => {
  switch (!0) {
    case Array.isArray(e):
      return `Array(${e.length})`;
    case typeof e == "object":
      return "{...}";
    default:
      return JSON.stringify(e);
  }
}, pw = (e) => (t, n) => typeof n == "string" ? /* @__PURE__ */ V.jsx("span", { style: { color: e.string }, children: t }) : typeof n == "boolean" ? /* @__PURE__ */ V.jsx("span", { style: { color: e.constants }, children: t }) : typeof n == "number" ? /* @__PURE__ */ V.jsx("span", { style: { color: e.number }, children: t }) : t, Uge = (e, t) => t.reduce((n, r) => n && n[r] ? n[r] : null, e), Gge = ({ trace: e }) => {
  var o;
  const { token: t } = no.useToken(), [n, r] = ht(!1), i = ((o = e == null ? void 0 : e.traceData) == null ? void 0 : o.log) || [];
  return /* @__PURE__ */ V.jsx("div", { className: "grl-function__debugger", children: /* @__PURE__ */ V.jsxs("div", { className: "grl-function__debugger__panel", children: [
    /* @__PURE__ */ V.jsxs(
      "div",
      {
        className: "function-debugger__panel-header",
        onClick: () => r(!n),
        style: {
          display: "flex",
          alignItems: "center",
          justifyContent: "space-between",
          padding: "0.75rem 1.25rem",
          position: "sticky",
          top: 0,
          background: t.colorBgLayout,
          zIndex: 3,
          borderBottom: n ? `1px solid ${t.colorBorder}` : "none",
          cursor: "pointer"
        },
        children: [
          /* @__PURE__ */ V.jsx(
            Bt.Text,
            {
              style: {
                fontWeight: "bold"
              },
              children: "Console"
            }
          ),
          /* @__PURE__ */ V.jsx("div", { children: /* @__PURE__ */ V.jsx(Cf, { style: { transform: n ? void 0 : "rotate(-180deg)", transformOrigin: "50%" } }) })
        ]
      }
    ),
    n && /* @__PURE__ */ V.jsxs(V.Fragment, { children: [
      i.length === 0 && /* @__PURE__ */ V.jsx("div", { style: { textAlign: "center", padding: "2rem" }, children: /* @__PURE__ */ V.jsx(Bt.Text, { type: "secondary", children: "Use console.log and run simulation to debug your code." }) }),
      i.map((s, a) => /* @__PURE__ */ V.jsx(Vge, { lines: s.lines, msSinceRun: s.msSinceRun }, a))
    ] })
  ] }) });
};
self.monaco && of.config({ monaco: self.monaco });
const nme = ({
  disabled: e = !1,
  disableDebug: t,
  language: n = "javascript",
  defaultValue: r,
  value: i,
  onChange: o,
  trace: s
}) => {
  const a = Wfe(), l = he(!1), { token: u } = no.useToken(), [c, d] = ht(), f = Sm((m) => {
    o == null || o(m);
  }, 100), [h, p] = ht(), g = une(() => h == null ? void 0 : h.layout(), 100, { trailing: !0 });
  return Pe(() => (window.addEventListener("resize", g), () => window.removeEventListener("resize", g)), [g, h]), Pe(() => {
    if (!a)
      return;
    const m = Object.keys(gA).map(
      (v) => ({
        content: `declare module '${v}' { ${gA[v]} }`
      }),
      {}
    );
    a.languages.typescript.javascriptDefaults.setExtraLibs(m);
  }, [a]), Pe(() => {
    l.current && i !== void 0 && i !== c && d(i);
  }, [i]), Pe(() => {
    d(i === void 0 ? r : i), l.current = !0;
  }, []), /* @__PURE__ */ V.jsxs(
    "div",
    {
      className: "grl-function",
      style: {
        height: "100%",
        "--color-text": u.colorTextBase,
        "--color-background-elevated": u.colorBgElevated,
        "--color-border": u.colorBorder,
        "--line-height": u.lineHeight
      },
      children: [
        /* @__PURE__ */ V.jsx(
          qr,
          {
            horizontal: !0,
            horizontalAlign: "space-between",
            verticalAlign: "center",
            className: "grl-function__command-bar",
            children: /* @__PURE__ */ V.jsx(qr, { gap: 8, horizontal: !0, className: "full-width", children: /* @__PURE__ */ V.jsx(
              Ut,
              {
                type: "text",
                size: "small",
                color: "secondary",
                icon: /* @__PURE__ */ V.jsx(bC, {}),
                disabled: e,
                onClick: () => {
                  var m, v, b;
                  (b = (v = (m = h == null ? void 0 : h.getAction) == null ? void 0 : m.call(h, "editor.action.formatDocument")) == null ? void 0 : v.run) == null || b.call(v);
                },
                children: "Format"
              }
            ) })
          }
        ),
        /* @__PURE__ */ V.jsxs("div", { className: "grl-function__content", children: [
          /* @__PURE__ */ V.jsx(
            Yfe,
            {
              loading: /* @__PURE__ */ V.jsx($f, { size: "large" }),
              language: n,
              value: c,
              onMount: (m) => p(m),
              onChange: (m) => {
                d(m ?? ""), f(m ?? "");
              },
              theme: u.mode === "dark" ? "vs-dark" : "light",
              height: "100%",
              options: {
                automaticLayout: !0,
                contextmenu: !1,
                fontSize: 13,
                fontFamily: "var(--mono-font-family)",
                readOnly: e,
                tabSize: 2
              }
            }
          ),
          !t && /* @__PURE__ */ V.jsx(Gge, { trace: s })
        ] })
      ]
    }
  );
}, rme = ({
  theme: { mode: e = "light", ...t } = {},
  prefixCls: n,
  children: r
}) => {
  const i = mt(() => {
    switch (e) {
      case "dark":
        return no.darkAlgorithm;
      case "light":
      default:
        return no.defaultAlgorithm;
    }
  }, [e]);
  return /* @__PURE__ */ V.jsxs(qc, { prefixCls: n, theme: { ...t, algorithm: i, token: { mode: e } }, children: [
    /* @__PURE__ */ V.jsx(Kge, { mode: e }),
    r
  ] });
}, Kge = ({ mode: e }) => {
  const { token: t } = no.useToken(), n = mt(
    () => ({
      "--grl-color-border": t.colorBorder,
      "--grl-color-border-hover": e === "light" ? "#c3c3c3" : "#555555",
      "--grl-color-primary": t.colorPrimary,
      "--grl-color-primary-bg": t.colorPrimaryBg,
      "--grl-color-primary-bg-fade": e === "light" ? "#f7f9fc" : "#141414",
      "--grl-color-primary-bg-hover": t.colorPrimaryBgHover,
      "--grl-color-primary-border": t.colorPrimaryBorder,
      "--grl-color-primary-border-hover": t.colorPrimaryBorderHover,
      "--grl-color-primary-text-hover": t.colorPrimaryTextHover,
      "--grl-color-success": t.colorSuccess,
      "--grl-color-success-bg": t.colorSuccessBg,
      "--grl-color-success-border": t.colorSuccessBorder,
      "--grl-color-error": t.colorError,
      "--grl-color-error-bg": t.colorErrorBg,
      "--grl-color-error-border": t.colorErrorBorder,
      "--grl-color-bg-layout": t.colorBgLayout,
      "--grl-color-bg-layout-fade": "#f8f8f8",
      "--grl-color-bg-mask": t.colorBgMask,
      "--grl-color-bg-elevated": t.colorBgElevated,
      "--grl-color-bg-container": t.colorBgContainer,
      "--grl-color-bg-container-disabled": t.colorBgContainerDisabled,
      "--grl-color-bg-text-hover": t.colorBgTextHover,
      "--grl-color-primary-hover": t.colorPrimaryHover,
      "--grl-color-primary-active": t.colorPrimaryActive,
      "--grl-color-text": t.colorText,
      "--grl-color-text-placeholder": t.colorTextPlaceholder,
      "--grl-color-text-base": t.colorTextBase,
      "--grl-color-text-disabled": t.colorTextDisabled,
      "--grl-color-text-secondary": t.colorTextSecondary,
      "--grl-control-outline": t.controlOutline,
      "--grl-primary-color": t.colorPrimary,
      "--grl-primary-color-bg": t.colorPrimaryBg,
      "--grl-font-family": t.fontFamily,
      "--grl-line-height": t.lineHeight,
      "--grl-border-radius": `${t.borderRadius}px`,
      "--grl-decision-table-output": e === "light" ? "#eaeaea" : "#091422",
      "--grl-decision-table-selected-row": e === "light" ? "#f4faff" : "#121720"
    }),
    [t, e]
  ), r = Object.entries(n).map(([i, o]) => `  ${i}: ${o};`).join(`
`);
  return /* @__PURE__ */ V.jsx("style", { dangerouslySetInnerHTML: { __html: `:root {
${r}
}` } });
};
export {
  uu as C,
  Dre as D,
  Lde as E,
  nme as F,
  wa as G,
  rme as J,
  tme as a,
  Lr as b,
  Bn as c,
  ede as d,
  ZC as e,
  JC as f,
  hl as g,
  eme as h,
  Nr as u
};
